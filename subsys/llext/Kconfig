# Copyright (c) 2023 Intel Corporation
# SPDX-License-Identifier: Apache-2.0

menuconfig LLEXT
	bool "Linkable loadable extensions"
	select CACHE_MANAGEMENT if DCACHE
	select KERNEL_WHOLE_ARCHIVE
	depends on !HARVARD
	help
	  Enable the linkable loadable extension subsystem

if LLEXT

choice LLEXT_BINARY_TYPE
	prompt "Binary object type for llext"
	default LLEXT_TYPE_ELF_OBJECT if ARM || ARM64
	default LLEXT_TYPE_ELF_SHAREDLIB if XTENSA
	default LLEXT_TYPE_ELF_RELOCATABLE if RISCV
	help
	  Object type for llext

config LLEXT_TYPE_ELF_OBJECT
	bool "Single object ELF file"
	depends on !RISCV
	help
	  Build and expect object files as binary object type for the
	  llext subsystem. A single compiler invocation is used to
	  generate the object file. Currently not supported on RISC-V.

config LLEXT_TYPE_ELF_RELOCATABLE
	bool "Relocatable ELF file"
	help
	  Build and expect relocatable (partially linked) files as the
	  binary object type for the llext subsystem. These object files
	  are generated by the linker by combining multiple object files
	  into a single one.

config LLEXT_TYPE_ELF_SHAREDLIB
	bool "Shared library ELF file"
	help
	  Build and expect shared libraries as binary object type for
	  the llext subsystem. The usual linking process is used to
	  generate the shared library from multiple object files.

endchoice

config LLEXT_HEAP_SIZE
	int "llext heap memory size in kilobytes"
	default 8
	help
	  Heap size in kilobytes available to llext for dynamic allocation

config LLEXT_BUILD_PIC
	bool "Use -fPIC when building LLEXT"
	depends on XTENSA
	default y if LLEXT_TYPE_ELF_SHAREDLIB
	help
	  By default LLEXT compilation is performed with -fno-pic -fno-pie compiler
	  flags. Some platforms can benefit from using -fPIC instead, in which case
	  most internal linking is performed by the linker at build time. Select "y"
	  to make use of that advantage.

config LLEXT_SHELL
	bool "llext shell commands"
	depends on SHELL
	help
	  Manage llext with shell commands for loading, unloading, and introspection

config LLEXT_SHELL_MAX_SIZE
	int "Maximum size of llext in bytes"
	depends on LLEXT_SHELL
	default 8192
	help
	  When loading llext with shell it is stored in a temporary buffer of this size

config LLEXT_STORAGE_WRITABLE
	bool "llext storage is writable"
	default y if XTENSA
	help
	  Select if LLEXT storage is writable, i.e. if extensions are stored in
	  RAM and can be modified in place

config LLEXT_EXPORT_DEVICES
	bool "Export all DT devices to llexts"
	help
	  When enabled, all Zephyr devices defined in the device tree are
	  made available to llexts via the standard DT_ / DEVICE_* macros.

config LLEXT_EXPORT_DEV_IDS_BY_HASH
	bool "Use hash of device path in device name"
	depends on LLEXT_EXPORT_DEVICES
	help
	  When enabled, exported device names are generated from a hash of the
	  node path instead of an ordinal number. Identifiers generated this
	  way are stable across rebuilds.

config LLEXT_EXPORT_BUILTINS_BY_SLID
	bool "Export built-in symbols to llexts via SLIDs"
	help
	  When enabled, symbols exported from the Zephyr kernel
	  or application (via EXPORT_SYMBOL) are linked to LLEXTs
	  via Symbol Link Identifiers (SLIDs) instead of name.

	  Enabling this option provides a huge size reduction,
	  makes the linking process faster and provides more
	  confidentiality, as exported symbol names are dropped
	  from the binary. However, it can make LLEXT debugging
	  harder and prevents usage of 'llext_find_sym' to look
	  up symbols from the built-in table by name. It also
	  requires the LLEXTs to be post-processed after build.

config LLEXT_IMPORT_ALL_GLOBALS
	bool "Import all global symbols from extensions"
	help
	  When loading an extension, by default only symbols that are mentioned
	  in the '.exported_sym' section (possibly via EXPORT_SYMBOL) are made
	  available to the Zephyr core.

	  This option instead allows all global symbols from extensions to be
	  used by the main application. This is useful to load basic extensions
	  that have been compiled without the full Zephyr EDK.

module = LLEXT
module-str = llext
source "subsys/logging/Kconfig.template.log_config"

endif

menuconfig LLEXT_EDK
	bool "Linkable loadable Extension Development Kit (EDK)"
	default y if LLEXT
	help
	  Enable the generation of an Extension Development Kit (EDK) for the
	  Linkable Loadable Extension subsystem. The EDK is an archive that
	  contains the necessary files and build settings to build extensions
	  for Zephyr without the need to have the full Zephyr source tree.

if LLEXT_EDK

config LLEXT_EDK_NAME
	string "Name for llext EDK (Extension Development Kit)"
	default "llext-edk"
	help
	  <name> will be used when generating the EDK file; the appropriate
	  extension will be appended depending on the chosen output format.
	  It will also be used, normalized, as the prefix for the variable
	  stating EDK location, used on generated Makefile.cflags. For
	  instance, the default name, "llext-edk", becomes LLEXT_EDK_INSTALL_DIR.

choice LLEXT_EDK_FORMAT
prompt "EDK compression and output format"
default LLEXT_EDK_FORMAT_TAR_XZ

config LLEXT_EDK_FORMAT_TAR_XZ
	bool ".tar.xz"
	help
	  Use GNU tar with XZ compression for the EDK file. Highest compression
	  ratio, slower choice.

config LLEXT_EDK_FORMAT_TAR_ZSTD
	bool ".tar.Z"
	help
	  Use GNU tar with Zstd compression for the EDK file. Way faster than
	  XZ, but still with a high compression ratio.

config LLEXT_EDK_FORMAT_ZIP
	bool ".zip"
	help
	  Use Zip format and compression for the EDK file. This is the most
	  portable option, but it may not compress as well as XZ or Zstd.

endchoice

config LLEXT_EDK_USERSPACE_ONLY
	bool "Only generate the Userspace codepath on syscall stubs for the EDK"
	help
	  Syscall stubs can contain code that verifies if running code is at user
	  or kernel space and route the call accordingly. If the EDK is expected
	  to be used by userspace only extensions, this option will make EDK stubs
	  not contain the routing code, and only generate the userspace one.

endif
