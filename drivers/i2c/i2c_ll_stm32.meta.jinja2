{# Copyright (c) 2018 Nordic Semiconductor ASA #}
{# SPDX-License-Identifier: Apache-2.0         #}

{% extends 'device_declare.jinja2' %}

{% block init_params %}
        {% do params.update({'irq_flag':'CONFIG_I2C_STM32_INTERRUPT'}) %}
        {% do params.update({'config_struct':'i2c_stm32_config'}) %}
        {% do params.update({'data_struct':'i2c_stm32_data'}) %}
        {% do params.update({'api_struct':'api_funcs'}) %}
        {% do params.update({'init_function':'i2c_stm32_init'}) %}
{% endblock %}

{# Because these blocks are "scoped" all variables in the macro from the
   base template can be accessed in these blocks #}
{% block config_struct_body %}
        .i2c = (I2C_TypeDef *){{ "%x"|format(device['reg']['0']['address']) }},
        .pclken = {
                .enr = {{ device['clocks']['0']['bits'] }},
                .bus = {{ device['clocks']['0']['bus'] }},
        },
#ifdef {{ get_param(params, 'irq_flag') }}
        .irq_config_func = {{ irq_config_function_name }},
#endif
        .bitrate = {{ device['clock-frequency'] }},
{% endblock %}

{% block irq_config_function_body %}
        {# The irq_connect macro will check if there is an irq with the name
           (parameter 2) and only generate IRQ_CONNECT code for irqs that
           exist in the devicetree metadata #}
	{{ gen_irq_connect(device, 'event', 'stm32_i2c_isr_event') }}
	{{ gen_irq_connect(device, 'error', 'stm32_i2c_isr_error') }}
	{{ gen_irq_connect(device, 'combined', 'stm32_i2c_isr_combined' ) }}
{% endblock %}

