/*
 * SPDX-FileCopyrightText: Copyright The Zephyr Project Contributors
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include "rmt_private.h"

#include <zephyr/drivers/dma.h>

#include <zephyr/logging/log.h>

LOG_MODULE_REGISTER(espressif_rmt_encoder_bytes, CONFIG_ESPRESSIF_RMT_LOG_LEVEL);

#include <zephyr/drivers/misc/espressif_rmt/rmt_encoder.h>

typedef struct rmt_bytes_encoder_t {
	/* !< Encoder base class */
	rmt_encoder_t base;
	/* !< Index of the encoding bit position in the encoding byte */
	size_t last_bit_index;
	/* !< Index of the encoding byte in the primary stream */
	size_t last_byte_index;
	/* !< Bit zero representing */
	rmt_symbol_word_t bit0;
	/* !< Bit one representing */
	rmt_symbol_word_t bit1;
	struct {
		/* !< Encode MSB firstly */
		uint32_t msb_first: 1;
	} flags;
} rmt_bytes_encoder_t;

static int rmt_bytes_encoder_reset(rmt_encoder_t *encoder)
{
	rmt_bytes_encoder_t *bytes_encoder = __containerof(encoder, rmt_bytes_encoder_t, base);

	/* reset index to zero */
	bytes_encoder->last_bit_index = 0;
	bytes_encoder->last_byte_index = 0;

	return 0;
}

__attribute__((always_inline))
static inline uint8_t _bitwise_reverse(uint8_t n)
{
	n = ((n & 0xf0) >> 4) | ((n & 0x0f) << 4);
	n = ((n & 0xcc) >> 2) | ((n & 0x33) << 2);
	n = ((n & 0xaa) >> 1) | ((n & 0x55) << 1);
	return n;
}

static size_t IRAM_ATTR rmt_encode_bytes(rmt_encoder_t *encoder, rmt_channel_handle_t channel,
	const void *primary_data, size_t data_size, rmt_encode_state_t *ret_state)
{
	rmt_bytes_encoder_t *bytes_encoder = __containerof(encoder, rmt_bytes_encoder_t, base);
	rmt_tx_channel_t *tx_chan = __containerof(channel, rmt_tx_channel_t, base);
	const uint8_t *nd = (const uint8_t *)primary_data;
	rmt_encode_state_t state = RMT_ENCODING_RESET;
	size_t byte_index = bytes_encoder->last_byte_index;
	size_t bit_index = bytes_encoder->last_bit_index;
	/* how many symbols will be generated by the encoder */
	size_t mem_want = (data_size - byte_index - 1) * 8 + (8 - bit_index);
	/* how many symbols we can save for this round */
	size_t mem_have = tx_chan->mem_end - tx_chan->mem_off;
	/* where to put the encoded symbols? DMA buffer or RMT HW memory */
#if SOC_RMT_SUPPORT_DMA
	rmt_symbol_word_t *mem_to = channel->dma_dev ? channel->dma_mem_base : channel->hw_mem_base;
#else
	rmt_symbol_word_t *mem_to = channel->hw_mem_base;
#endif
	/* how many symbols will be encoded in this round */
	size_t encode_len = MIN(mem_want, mem_have);
	bool encoding_truncated = mem_have < mem_want;
	bool encoding_space_free = mem_have > mem_want;
	size_t len;
#if SOC_RMT_SUPPORT_DMA
	int rc;
#endif

	len = encode_len;
	while (len > 0) {
		/* start from last time truncated encoding */
		uint8_t cur_byte = nd[byte_index];
		/* bit-wise reverse */
		if (bytes_encoder->flags.msb_first) {
			cur_byte = _bitwise_reverse(cur_byte);
		}
		while ((len > 0) && (bit_index < 8)) {
			if (cur_byte & (1 << bit_index)) {
				mem_to[tx_chan->mem_off++] = bytes_encoder->bit1;
			} else {
				mem_to[tx_chan->mem_off++] = bytes_encoder->bit0;
			}
			len--;
			bit_index++;
		}
		if (bit_index >= 8) {
			byte_index++;
			bit_index = 0;
		}
	}

#if SOC_RMT_SUPPORT_DMA
	if (channel->dma_dev) {
		rc = dma_reload(channel->dma_dev, channel->dma_channel,
			(uint32_t)channel->dma_mem_base, 0, channel->dma_mem_size);
		if (rc) {
			LOG_ERR("Reloading DMA channel failed");
			return 0;
		}
	}
#endif

	if (encoding_truncated) {
		/* this encoding has not finished yet, save the truncated position */
		bytes_encoder->last_bit_index = bit_index;
		bytes_encoder->last_byte_index = byte_index;
	} else {
		/* reset internal index if encoding session has finished */
		bytes_encoder->last_bit_index = 0;
		bytes_encoder->last_byte_index = 0;
		state |= RMT_ENCODING_COMPLETE;
	}

	if (!encoding_space_free) {
		/* no more free memory, the caller should yield */
		state |= RMT_ENCODING_MEM_FULL;
	}

	/* reset offset pointer when exceeds maximum range */
	if (tx_chan->mem_off >= tx_chan->ping_pong_symbols * 2) {
#if SOC_RMT_SUPPORT_DMA
		if (channel->dma_dev) {
			rc = dma_reload(channel->dma_dev, channel->dma_channel,
				(uint32_t)channel->dma_mem_base, 0, channel->dma_mem_size);
			if (rc) {
				LOG_ERR("Reloading DMA channel failed");
				return 0;
			}
		}
#endif
		tx_chan->mem_off = 0;
	}

	*ret_state = state;
	return encode_len;
}

static int rmt_del_bytes_encoder(rmt_encoder_t *encoder)
{
	rmt_bytes_encoder_t *bytes_encoder;

	bytes_encoder = __containerof(encoder, rmt_bytes_encoder_t, base);
	free(bytes_encoder);

	return 0;
}

int rmt_new_bytes_encoder(const rmt_bytes_encoder_config_t *config,
	rmt_encoder_handle_t *ret_encoder)
{
	rmt_bytes_encoder_t *encoder;

	if (!(config && ret_encoder)) {
		LOG_ERR("Invalid argument");
		return -EINVAL;
	}
	encoder = rmt_alloc_encoder_mem(sizeof(rmt_bytes_encoder_t));
	if (!encoder) {
		LOG_ERR("Unable to allocate memory for encoder");
		return -ENOMEM;
	}
	encoder->base.encode = rmt_encode_bytes;
	encoder->base.del = rmt_del_bytes_encoder;
	encoder->base.reset = rmt_bytes_encoder_reset;
	encoder->bit0 = config->bit0;
	encoder->bit1 = config->bit1;
	encoder->flags.msb_first = config->flags.msb_first;

	/* return general encoder handle */
	*ret_encoder = &encoder->base;
	LOG_DBG("new bytes encoder @%p", encoder);

	return 0;
}

int rmt_bytes_encoder_update_config(rmt_encoder_handle_t bytes_encoder,
	const rmt_bytes_encoder_config_t *config)
{
	rmt_bytes_encoder_t *encoder;

	if (!(bytes_encoder && config)) {
		LOG_ERR("Invalid argument");
		return -EINVAL;
	}
	encoder = __containerof(bytes_encoder, rmt_bytes_encoder_t, base);
	encoder->bit0 = config->bit0;
	encoder->bit1 = config->bit1;
	encoder->flags.msb_first = config->flags.msb_first;

	return 0;
}
