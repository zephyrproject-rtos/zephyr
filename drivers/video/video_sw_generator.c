/*
 * Copyright (c) 2019, Linaro Limited
 * Copyright 2026 NXP
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#define DT_DRV_COMPAT zephyr_video_sw_generator

#include <zephyr/drivers/video-controls.h>
#include <zephyr/drivers/video.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>
#include <zephyr/sys/byteorder.h>
#include <zephyr/sys/util.h>

#include "video_ctrls.h"
#include "video_device.h"

LOG_MODULE_REGISTER(video_sw_generator, CONFIG_VIDEO_LOG_LEVEL);

#define VIDEO_PATTERN_COLOR_BAR 0
#define DEFAULT_FRAME_RATE      30
/*
 * The pattern generator needs about 1.5 ms to fill out a 320x160 RGB565
 * buffer and 25 ms for a 720p XRGB32 buffer (tested on i.MX RT1064). So,
 * the max frame rate actually varies between 40 and 666 fps depending on
 * the buffer format. There is no way to determine this value for each
 * format. 60 fps is therefore chosen as a common value in practice.
 */
#define MAX_FRAME_RATE          60
#define MIN_FRAME_RATE          1

/* Default frame configuration */
#define DEFAULT_FRAME_WIDTH  320
#define DEFAULT_FRAME_HEIGHT 160
#define JPEG_FRAME_SIZE      0x522 /* Fixed size for each JPEG frame */
#define PNG_FRAME_SIZE       0x164 /* Fixed size for each PNG frame */

struct sw_ctrls {
	struct video_ctrl hflip;
	struct video_ctrl test_pattern;
};

/* Static JPEG frame buffers. 2 320x160 color-bar pattern frames, h-flipped. */
static uint8_t jpeg_frame_buffers[2U][JPEG_FRAME_SIZE] = {
	{0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00,
	 0x01, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43, 0x00, 0x03, 0x02, 0x02, 0x03, 0x02,
	 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x03, 0x03, 0x04, 0x05, 0x08, 0x05, 0x05, 0x04, 0x04,
	 0x05, 0x0A, 0x07, 0x07, 0x06, 0x08, 0x0C, 0x0A, 0x0C, 0x0C, 0x0B, 0x0A, 0x0B, 0x0B, 0x0D,
	 0x0E, 0x12, 0x10, 0x0D, 0x0E, 0x11, 0x0E, 0x0B, 0x0B, 0x10, 0x16, 0x10, 0x11, 0x13, 0x14,
	 0x15, 0x15, 0x15, 0x0C, 0x0F, 0x17, 0x18, 0x16, 0x14, 0x18, 0x12, 0x14, 0x15, 0x14, 0xFF,
	 0xDB, 0x00, 0x43, 0x01, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x09, 0x05, 0x05, 0x09, 0x14,
	 0x0D, 0x0B, 0x0D, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
	 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
	 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
	 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0xFF, 0xC0, 0x00, 0x11, 0x08, 0x00, 0xA0,
	 0x01, 0x40, 0x03, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xFF, 0xC4, 0x00,
	 0x17, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x07, 0x0A, 0x09, 0xFF, 0xC4, 0x00, 0x14, 0x10, 0x01, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
	 0xC4, 0x00, 0x18, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x08, 0x09, 0x0A, 0xFF, 0xC4, 0x00, 0x1C, 0x11,
	 0x01, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x05, 0x07, 0x42, 0x45, 0x81, 0x83, 0xC1, 0xC3, 0xFF, 0xDA, 0x00, 0x0C, 0x03,
	 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3F, 0x00, 0xEA, 0x98, 0x00, 0x00, 0x02, 0x62,
	 0xA7, 0x26, 0x2C, 0xA9, 0x3D, 0x2D, 0xBB, 0x7C, 0x97, 0x21, 0x95, 0xE3, 0xA0, 0x0C, 0xAA,
	 0xB8, 0x00, 0x08, 0x10, 0x0E, 0xE4, 0x38, 0xE4, 0x00, 0x02, 0x64, 0xA6, 0xA6, 0x4C, 0xAB,
	 0x3C, 0xED, 0xBB, 0x7C, 0x97, 0x21, 0x95, 0xE3, 0xA0, 0x0C, 0xAC, 0xB8, 0x00, 0x08, 0x38,
	 0x0E, 0xE0, 0x3D, 0x1D, 0x00, 0x00, 0x98, 0xA9, 0xC9, 0x8B, 0x2B, 0x4F, 0x3B, 0x6E, 0xDF,
	 0x25, 0xB8, 0x6D, 0x78, 0xE8, 0x03, 0x2A, 0xAD, 0x80, 0x02, 0x04, 0x03, 0xB8, 0xCE, 0x3A,
	 0x00, 0x00, 0x99, 0x29, 0xA9, 0x93, 0x2A, 0xCF, 0x3B, 0x6E, 0xDF, 0x25, 0xC8, 0x65, 0x78,
	 0xE8, 0x03, 0x2B, 0x2E, 0x00, 0x03, 0x55, 0x00, 0x00, 0x00, 0x09, 0x8A, 0x9C, 0x98, 0xB2,
	 0xA4, 0xF4, 0xB6, 0xED, 0xF2, 0x5C, 0x86, 0x57, 0x8E, 0x80, 0x32, 0xAA, 0xE0, 0x00, 0x20,
	 0x40, 0x3B, 0x90, 0xE3, 0x90, 0x00, 0x09, 0x92, 0x9A, 0x99, 0x32, 0xAC, 0xF3, 0xB6, 0xED,
	 0xF2, 0x5C, 0x86, 0x57, 0x8E, 0x80, 0x32, 0xB2, 0xE0, 0x00, 0x20, 0xE0, 0x3B, 0x80, 0xF4,
	 0x74, 0x00, 0x02, 0x62, 0xA7, 0x26, 0x2C, 0xAD, 0x3C, 0xED, 0xBB, 0x7C, 0x96, 0xE1, 0xB5,
	 0xE3, 0xA0, 0x0C, 0xAA, 0xB6, 0x00, 0x08, 0x10, 0x0E, 0xE3, 0x38, 0xE8, 0x00, 0x02, 0x64,
	 0xA6, 0xA6, 0x4C, 0xAB, 0x3C, 0xED, 0xBB, 0x7C, 0x97, 0x21, 0x95, 0xE3, 0xA0, 0x0C, 0xAC,
	 0xB8, 0x00, 0x0D, 0x54, 0x00, 0x00, 0x00, 0x26, 0x2A, 0x72, 0x62, 0xCA, 0x93, 0xD2, 0xDB,
	 0xB7, 0xC9, 0x72, 0x19, 0x5E, 0x3A, 0x00, 0xCA, 0xAB, 0x80, 0x00, 0x81, 0x00, 0xEE, 0x43,
	 0x8E, 0x40, 0x00, 0x26, 0x4A, 0x6A, 0x64, 0xCA, 0xB3, 0xCE, 0xDB, 0xB7, 0xC9, 0x72, 0x19,
	 0x5E, 0x3A, 0x00, 0xCA, 0xCB, 0x80, 0x00, 0x83, 0x80, 0xEE, 0x03, 0xD1, 0xD0, 0x00, 0x09,
	 0x8A, 0x9C, 0x98, 0xB2, 0xB4, 0xF3, 0xB6, 0xED, 0xF2, 0x5B, 0x86, 0xD7, 0x8E, 0x80, 0x32,
	 0xAA, 0xD8, 0x00, 0x20, 0x40, 0x3B, 0x8C, 0xE3, 0xA0, 0x00, 0x09, 0x92, 0x9A, 0x99, 0x32,
	 0xAC, 0xF3, 0xB6, 0xED, 0xF2, 0x5C, 0x86, 0x57, 0x8E, 0x80, 0x32, 0xB2, 0xE0, 0x00, 0x35,
	 0x50, 0x00, 0x00, 0x00, 0x98, 0xA9, 0xC9, 0x8B, 0x2A, 0x4F, 0x4B, 0x6E, 0xDF, 0x25, 0xC8,
	 0x65, 0x78, 0xE8, 0x03, 0x2A, 0xAE, 0x00, 0x02, 0x04, 0x03, 0xB9, 0x0E, 0x39, 0x00, 0x00,
	 0x99, 0x29, 0xA9, 0x93, 0x2A, 0xCF, 0x3B, 0x6E, 0xDF, 0x25, 0xC8, 0x65, 0x78, 0xE8, 0x03,
	 0x2B, 0x2E, 0x00, 0x02, 0x0E, 0x03, 0xB8, 0x0F, 0x47, 0x40, 0x00, 0x26, 0x2A, 0x72, 0x62,
	 0xCA, 0xD3, 0xCE, 0xDB, 0xB7, 0xC9, 0x6E, 0x1B, 0x5E, 0x3A, 0x00, 0xCA, 0xAB, 0x60, 0x00,
	 0x81, 0x00, 0xEE, 0x33, 0x8E, 0x80, 0x00, 0x26, 0x4A, 0x6A, 0x64, 0xCA, 0xB3, 0xCE, 0xDB,
	 0xB7, 0xC9, 0x72, 0x19, 0x5E, 0x3A, 0x00, 0xCA, 0xCB, 0x80, 0x00, 0xD5, 0x40, 0x00, 0x00,
	 0x02, 0x62, 0xA7, 0x26, 0x2C, 0xA9, 0x3D, 0x2D, 0xBB, 0x7C, 0x97, 0x21, 0x95, 0xE3, 0xA0,
	 0x0C, 0xAA, 0xB8, 0x00, 0x08, 0x10, 0x0E, 0xE4, 0x38, 0xE4, 0x00, 0x02, 0x64, 0xA6, 0xA6,
	 0x4C, 0xAB, 0x3C, 0xED, 0xBB, 0x7C, 0x97, 0x21, 0x95, 0xE3, 0xA0, 0x0C, 0xAC, 0xB8, 0x00,
	 0x08, 0x38, 0x0E, 0xE0, 0x3D, 0x1D, 0x00, 0x00, 0x98, 0xA9, 0xC9, 0x8B, 0x2B, 0x4F, 0x3B,
	 0x6E, 0xDF, 0x25, 0xB8, 0x6D, 0x78, 0xE8, 0x03, 0x2A, 0xAD, 0x80, 0x02, 0x04, 0x03, 0xB8,
	 0xCE, 0x3A, 0x00, 0x00, 0x99, 0x29, 0xA9, 0x93, 0x2A, 0xCF, 0x3B, 0x6E, 0xDF, 0x25, 0xC8,
	 0x65, 0x78, 0xE8, 0x03, 0x2B, 0x2E, 0x00, 0x03, 0x55, 0x00, 0x00, 0x00, 0x09, 0x8A, 0x9C,
	 0x98, 0xB2, 0xA4, 0xF4, 0xB6, 0xED, 0xF2, 0x5C, 0x86, 0x57, 0x8E, 0x80, 0x32, 0xAA, 0xE0,
	 0x00, 0x20, 0x40, 0x3B, 0x90, 0xE3, 0x90, 0x00, 0x09, 0x92, 0x9A, 0x99, 0x32, 0xAC, 0xF3,
	 0xB6, 0xED, 0xF2, 0x5C, 0x86, 0x57, 0x8E, 0x80, 0x32, 0xB2, 0xE0, 0x00, 0x20, 0xE0, 0x3B,
	 0x80, 0xF4, 0x74, 0x00, 0x02, 0x62, 0xA7, 0x26, 0x2C, 0xAD, 0x3C, 0xED, 0xBB, 0x7C, 0x96,
	 0xE1, 0xB5, 0xE3, 0xA0, 0x0C, 0xAA, 0xB6, 0x00, 0x08, 0x10, 0x0E, 0xE3, 0x38, 0xE8, 0x00,
	 0x02, 0x64, 0xA6, 0xA6, 0x4C, 0xAB, 0x3C, 0xED, 0xBB, 0x7C, 0x97, 0x21, 0x95, 0xE3, 0xA0,
	 0x0C, 0xAC, 0xB8, 0x00, 0x0D, 0x54, 0x00, 0x00, 0x00, 0x26, 0x2A, 0x72, 0x62, 0xCA, 0x93,
	 0xD2, 0xDB, 0xB7, 0xC9, 0x72, 0x19, 0x5E, 0x3A, 0x00, 0xCA, 0xAB, 0x80, 0x00, 0x81, 0x00,
	 0xEE, 0x43, 0x8E, 0x40, 0x00, 0x26, 0x4A, 0x6A, 0x64, 0xCA, 0xB3, 0xCE, 0xDB, 0xB7, 0xC9,
	 0x72, 0x19, 0x5E, 0x3A, 0x00, 0xCA, 0xCB, 0x80, 0x00, 0x83, 0x80, 0xEE, 0x03, 0xD1, 0xD0,
	 0x00, 0x09, 0x8A, 0x9C, 0x98, 0xB2, 0xB4, 0xF3, 0xB6, 0xED, 0xF2, 0x5B, 0x86, 0xD7, 0x8E,
	 0x80, 0x32, 0xAA, 0xD8, 0x00, 0x20, 0x40, 0x3B, 0x8C, 0xE3, 0xA0, 0x00, 0x09, 0x92, 0x9A,
	 0x99, 0x32, 0xAC, 0xF3, 0xB6, 0xED, 0xF2, 0x5C, 0x86, 0x57, 0x8E, 0x80, 0x32, 0xB2, 0xE0,
	 0x00, 0x35, 0x50, 0x00, 0x00, 0x00, 0x98, 0xA9, 0xC9, 0x8B, 0x2A, 0x4F, 0x4B, 0x6E, 0xDF,
	 0x25, 0xC8, 0x65, 0x78, 0xE8, 0x03, 0x2A, 0xAE, 0x00, 0x02, 0x04, 0x03, 0xB9, 0x0E, 0x39,
	 0x00, 0x00, 0x99, 0x29, 0xA9, 0x93, 0x2A, 0xCF, 0x3B, 0x6E, 0xDF, 0x25, 0xC8, 0x65, 0x78,
	 0xE8, 0x03, 0x2B, 0x2E, 0x00, 0x02, 0x0E, 0x03, 0xB8, 0x0F, 0x47, 0x40, 0x00, 0x26, 0x2A,
	 0x72, 0x62, 0xCA, 0xD3, 0xCE, 0xDB, 0xB7, 0xC9, 0x6E, 0x1B, 0x5E, 0x3A, 0x00, 0xCA, 0xAB,
	 0x60, 0x00, 0x81, 0x00, 0xEE, 0x33, 0x8E, 0x80, 0x00, 0x26, 0x4A, 0x6A, 0x64, 0xCA, 0xB3,
	 0xCE, 0xDB, 0xB7, 0xC9, 0x72, 0x19, 0x5E, 0x3A, 0x00, 0xCA, 0xCB, 0x80, 0x00, 0xD5, 0x40,
	 0x00, 0x00, 0x02, 0x62, 0xA7, 0x26, 0x2C, 0xA9, 0x3D, 0x2D, 0xBB, 0x7C, 0x97, 0x21, 0x95,
	 0xE3, 0xA0, 0x0C, 0xAA, 0xB8, 0x00, 0x08, 0x10, 0x0E, 0xE4, 0x38, 0xE4, 0x00, 0x02, 0x64,
	 0xA6, 0xA6, 0x4C, 0xAB, 0x3C, 0xED, 0xBB, 0x7C, 0x97, 0x21, 0x95, 0xE3, 0xA0, 0x0C, 0xAC,
	 0xB8, 0x00, 0x08, 0x38, 0x0E, 0xE0, 0x3D, 0x1D, 0x00, 0x00, 0x98, 0xA9, 0xC9, 0x8B, 0x2B,
	 0x4F, 0x3B, 0x6E, 0xDF, 0x25, 0xB8, 0x6D, 0x78, 0xE8, 0x03, 0x2A, 0xAD, 0x80, 0x02, 0x04,
	 0x03, 0xB8, 0xCE, 0x3A, 0x00, 0x00, 0x99, 0x29, 0xA9, 0x93, 0x2A, 0xCF, 0x3B, 0x6E, 0xDF,
	 0x25, 0xC8, 0x65, 0x78, 0xE8, 0x03, 0x2B, 0x2E, 0x00, 0x03, 0x55, 0x00, 0x00, 0x00, 0x09,
	 0x8A, 0x9C, 0x98, 0xB2, 0xA4, 0xF4, 0xB6, 0xED, 0xF2, 0x5C, 0x86, 0x57, 0x8E, 0x80, 0x32,
	 0xAA, 0xE0, 0x00, 0x20, 0x40, 0x3B, 0x90, 0xE3, 0x90, 0x00, 0x09, 0x92, 0x9A, 0x99, 0x32,
	 0xAC, 0xF3, 0xB6, 0xED, 0xF2, 0x5C, 0x86, 0x57, 0x8E, 0x80, 0x32, 0xB2, 0xE0, 0x00, 0x20,
	 0xE0, 0x3B, 0x80, 0xF4, 0x74, 0x00, 0x02, 0x62, 0xA7, 0x26, 0x2C, 0xAD, 0x3C, 0xED, 0xBB,
	 0x7C, 0x96, 0xE1, 0xB5, 0xE3, 0xA0, 0x0C, 0xAA, 0xB6, 0x00, 0x08, 0x10, 0x0E, 0xE3, 0x38,
	 0xE8, 0x00, 0x02, 0x64, 0xA6, 0xA6, 0x4C, 0xAB, 0x3C, 0xED, 0xBB, 0x7C, 0x97, 0x21, 0x95,
	 0xE3, 0xA0, 0x0C, 0xAC, 0xB8, 0x00, 0x0F, 0xFF, 0xD9},
	{0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00,
	 0x01, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43, 0x00, 0x03, 0x02, 0x02, 0x03, 0x02,
	 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x03, 0x03, 0x04, 0x05, 0x08, 0x05, 0x05, 0x04, 0x04,
	 0x05, 0x0A, 0x07, 0x07, 0x06, 0x08, 0x0C, 0x0A, 0x0C, 0x0C, 0x0B, 0x0A, 0x0B, 0x0B, 0x0D,
	 0x0E, 0x12, 0x10, 0x0D, 0x0E, 0x11, 0x0E, 0x0B, 0x0B, 0x10, 0x16, 0x10, 0x11, 0x13, 0x14,
	 0x15, 0x15, 0x15, 0x0C, 0x0F, 0x17, 0x18, 0x16, 0x14, 0x18, 0x12, 0x14, 0x15, 0x14, 0xFF,
	 0xDB, 0x00, 0x43, 0x01, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x09, 0x05, 0x05, 0x09, 0x14,
	 0x0D, 0x0B, 0x0D, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
	 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
	 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
	 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0xFF, 0xC0, 0x00, 0x11, 0x08, 0x00, 0xA0,
	 0x01, 0x40, 0x03, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xFF, 0xC4, 0x00,
	 0x17, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x07, 0x0A, 0x09, 0xFF, 0xC4, 0x00, 0x14, 0x10, 0x01, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
	 0xC4, 0x00, 0x18, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x08, 0x09, 0x0A, 0xFF, 0xC4, 0x00, 0x1C, 0x11,
	 0x01, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x05, 0x07, 0x42, 0x45, 0x81, 0x83, 0xC1, 0xC3, 0xFF, 0xDA, 0x00, 0x0C, 0x03,
	 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3F, 0x00, 0xE5, 0x50, 0x00, 0x00, 0x02, 0x9A,
	 0x99, 0x29, 0xAD, 0x53, 0x23, 0x2E, 0x5A, 0xBD, 0x50, 0xE2, 0x74, 0x67, 0x80, 0x0D, 0x54,
	 0x86, 0x00, 0x0B, 0xE8, 0x0E, 0x1C, 0xBB, 0x16, 0x00, 0x02, 0x9C, 0x98, 0xA9, 0xCD, 0x55,
	 0x23, 0x2E, 0x5A, 0xBD, 0x51, 0x22, 0x54, 0x67, 0x80, 0x0D, 0x52, 0x88, 0x00, 0x0B, 0xC0,
	 0x0E, 0x1F, 0xBC, 0xE2, 0x80, 0x00, 0xA6, 0xA6, 0x4A, 0x6B, 0x54, 0xC8, 0xCB, 0x96, 0xAF,
	 0x54, 0x38, 0x9D, 0x19, 0xE0, 0x03, 0x55, 0x21, 0x80, 0x02, 0xFA, 0x03, 0x86, 0xEE, 0xC6,
	 0x80, 0x00, 0xA7, 0x26, 0x2A, 0x73, 0x55, 0x48, 0xBB, 0x96, 0xAF, 0x54, 0x38, 0x9D, 0x19,
	 0xE0, 0x03, 0x55, 0xA1, 0x80, 0x03, 0x2A, 0xE0, 0x00, 0x00, 0x0A, 0x6A, 0x64, 0xA6, 0xB5,
	 0x4C, 0x8C, 0xB9, 0x6A, 0xF5, 0x43, 0x89, 0xD1, 0x9E, 0x00, 0x35, 0x52, 0x18, 0x00, 0x2F,
	 0xA0, 0x38, 0x72, 0xEC, 0x58, 0x00, 0x0A, 0x72, 0x62, 0xA7, 0x35, 0x54, 0x8C, 0xB9, 0x6A,
	 0xF5, 0x44, 0x89, 0x51, 0x9E, 0x00, 0x35, 0x4A, 0x20, 0x00, 0x2F, 0x00, 0x38, 0x7E, 0xF3,
	 0x8A, 0x00, 0x02, 0x9A, 0x99, 0x29, 0xAD, 0x53, 0x23, 0x2E, 0x5A, 0xBD, 0x50, 0xE2, 0x74,
	 0x67, 0x80, 0x0D, 0x54, 0x86, 0x00, 0x0B, 0xE8, 0x0E, 0x1B, 0xBB, 0x1A, 0x00, 0x02, 0x9C,
	 0x98, 0xA9, 0xCD, 0x55, 0x22, 0xEE, 0x5A, 0xBD, 0x50, 0xE2, 0x74, 0x67, 0x80, 0x0D, 0x56,
	 0x86, 0x00, 0x0C, 0xAB, 0x80, 0x00, 0x00, 0x29, 0xA9, 0x92, 0x9A, 0xD5, 0x32, 0x32, 0xE5,
	 0xAB, 0xD5, 0x0E, 0x27, 0x46, 0x78, 0x00, 0xD5, 0x48, 0x60, 0x00, 0xBE, 0x80, 0xE1, 0xCB,
	 0xB1, 0x60, 0x00, 0x29, 0xC9, 0x8A, 0x9C, 0xD5, 0x52, 0x32, 0xE5, 0xAB, 0xD5, 0x12, 0x25,
	 0x46, 0x78, 0x00, 0xD5, 0x28, 0x80, 0x00, 0xBC, 0x00, 0xE1, 0xFB, 0xCE, 0x28, 0x00, 0x0A,
	 0x6A, 0x64, 0xA6, 0xB5, 0x4C, 0x8C, 0xB9, 0x6A, 0xF5, 0x43, 0x89, 0xD1, 0x9E, 0x00, 0x35,
	 0x52, 0x18, 0x00, 0x2F, 0xA0, 0x38, 0x6E, 0xEC, 0x68, 0x00, 0x0A, 0x72, 0x62, 0xA7, 0x35,
	 0x54, 0x8B, 0xB9, 0x6A, 0xF5, 0x43, 0x89, 0xD1, 0x9E, 0x00, 0x35, 0x5A, 0x18, 0x00, 0x32,
	 0xAE, 0x00, 0x00, 0x00, 0xA6, 0xA6, 0x4A, 0x6B, 0x54, 0xC8, 0xCB, 0x96, 0xAF, 0x54, 0x38,
	 0x9D, 0x19, 0xE0, 0x03, 0x55, 0x21, 0x80, 0x02, 0xFA, 0x03, 0x87, 0x2E, 0xC5, 0x80, 0x00,
	 0xA7, 0x26, 0x2A, 0x73, 0x55, 0x48, 0xCB, 0x96, 0xAF, 0x54, 0x48, 0x95, 0x19, 0xE0, 0x03,
	 0x54, 0xA2, 0x00, 0x02, 0xF0, 0x03, 0x87, 0xEF, 0x38, 0xA0, 0x00, 0x29, 0xA9, 0x92, 0x9A,
	 0xD5, 0x32, 0x32, 0xE5, 0xAB, 0xD5, 0x0E, 0x27, 0x46, 0x78, 0x00, 0xD5, 0x48, 0x60, 0x00,
	 0xBE, 0x80, 0xE1, 0xBB, 0xB1, 0xA0, 0x00, 0x29, 0xC9, 0x8A, 0x9C, 0xD5, 0x52, 0x2E, 0xE5,
	 0xAB, 0xD5, 0x0E, 0x27, 0x46, 0x78, 0x00, 0xD5, 0x68, 0x60, 0x00, 0xCA, 0xB8, 0x00, 0x00,
	 0x02, 0x9A, 0x99, 0x29, 0xAD, 0x53, 0x23, 0x2E, 0x5A, 0xBD, 0x50, 0xE2, 0x74, 0x67, 0x80,
	 0x0D, 0x54, 0x86, 0x00, 0x0B, 0xE8, 0x0E, 0x1C, 0xBB, 0x16, 0x00, 0x02, 0x9C, 0x98, 0xA9,
	 0xCD, 0x55, 0x23, 0x2E, 0x5A, 0xBD, 0x51, 0x22, 0x54, 0x67, 0x80, 0x0D, 0x52, 0x88, 0x00,
	 0x0B, 0xC0, 0x0E, 0x1F, 0xBC, 0xE2, 0x80, 0x00, 0xA6, 0xA6, 0x4A, 0x6B, 0x54, 0xC8, 0xCB,
	 0x96, 0xAF, 0x54, 0x38, 0x9D, 0x19, 0xE0, 0x03, 0x55, 0x21, 0x80, 0x02, 0xFA, 0x03, 0x86,
	 0xEE, 0xC6, 0x80, 0x00, 0xA7, 0x26, 0x2A, 0x73, 0x55, 0x48, 0xBB, 0x96, 0xAF, 0x54, 0x38,
	 0x9D, 0x19, 0xE0, 0x03, 0x55, 0xA1, 0x80, 0x03, 0x2A, 0xE0, 0x00, 0x00, 0x0A, 0x6A, 0x64,
	 0xA6, 0xB5, 0x4C, 0x8C, 0xB9, 0x6A, 0xF5, 0x43, 0x89, 0xD1, 0x9E, 0x00, 0x35, 0x52, 0x18,
	 0x00, 0x2F, 0xA0, 0x38, 0x72, 0xEC, 0x58, 0x00, 0x0A, 0x72, 0x62, 0xA7, 0x35, 0x54, 0x8C,
	 0xB9, 0x6A, 0xF5, 0x44, 0x89, 0x51, 0x9E, 0x00, 0x35, 0x4A, 0x20, 0x00, 0x2F, 0x00, 0x38,
	 0x7E, 0xF3, 0x8A, 0x00, 0x02, 0x9A, 0x99, 0x29, 0xAD, 0x53, 0x23, 0x2E, 0x5A, 0xBD, 0x50,
	 0xE2, 0x74, 0x67, 0x80, 0x0D, 0x54, 0x86, 0x00, 0x0B, 0xE8, 0x0E, 0x1B, 0xBB, 0x1A, 0x00,
	 0x02, 0x9C, 0x98, 0xA9, 0xCD, 0x55, 0x22, 0xEE, 0x5A, 0xBD, 0x50, 0xE2, 0x74, 0x67, 0x80,
	 0x0D, 0x56, 0x86, 0x00, 0x0C, 0xAB, 0x80, 0x00, 0x00, 0x29, 0xA9, 0x92, 0x9A, 0xD5, 0x32,
	 0x32, 0xE5, 0xAB, 0xD5, 0x0E, 0x27, 0x46, 0x78, 0x00, 0xD5, 0x48, 0x60, 0x00, 0xBE, 0x80,
	 0xE1, 0xCB, 0xB1, 0x60, 0x00, 0x29, 0xC9, 0x8A, 0x9C, 0xD5, 0x52, 0x32, 0xE5, 0xAB, 0xD5,
	 0x12, 0x25, 0x46, 0x78, 0x00, 0xD5, 0x28, 0x80, 0x00, 0xBC, 0x00, 0xE1, 0xFB, 0xCE, 0x28,
	 0x00, 0x0A, 0x6A, 0x64, 0xA6, 0xB5, 0x4C, 0x8C, 0xB9, 0x6A, 0xF5, 0x43, 0x89, 0xD1, 0x9E,
	 0x00, 0x35, 0x52, 0x18, 0x00, 0x2F, 0xA0, 0x38, 0x6E, 0xEC, 0x68, 0x00, 0x0A, 0x72, 0x62,
	 0xA7, 0x35, 0x54, 0x8B, 0xB9, 0x6A, 0xF5, 0x43, 0x89, 0xD1, 0x9E, 0x00, 0x35, 0x5A, 0x18,
	 0x00, 0x32, 0xAE, 0x00, 0x00, 0x00, 0xA6, 0xA6, 0x4A, 0x6B, 0x54, 0xC8, 0xCB, 0x96, 0xAF,
	 0x54, 0x38, 0x9D, 0x19, 0xE0, 0x03, 0x55, 0x21, 0x80, 0x02, 0xFA, 0x03, 0x87, 0x2E, 0xC5,
	 0x80, 0x00, 0xA7, 0x26, 0x2A, 0x73, 0x55, 0x48, 0xCB, 0x96, 0xAF, 0x54, 0x48, 0x95, 0x19,
	 0xE0, 0x03, 0x54, 0xA2, 0x00, 0x02, 0xF0, 0x03, 0x87, 0xEF, 0x38, 0xA0, 0x00, 0x29, 0xA9,
	 0x92, 0x9A, 0xD5, 0x32, 0x32, 0xE5, 0xAB, 0xD5, 0x0E, 0x27, 0x46, 0x78, 0x00, 0xD5, 0x48,
	 0x60, 0x00, 0xBE, 0x80, 0xE1, 0xBB, 0xB1, 0xA0, 0x00, 0x29, 0xC9, 0x8A, 0x9C, 0xD5, 0x52,
	 0x2E, 0xE5, 0xAB, 0xD5, 0x0E, 0x27, 0x46, 0x78, 0x00, 0xD5, 0x68, 0x60, 0x00, 0xCA, 0xB8,
	 0x00, 0x00, 0x02, 0x9A, 0x99, 0x29, 0xAD, 0x53, 0x23, 0x2E, 0x5A, 0xBD, 0x50, 0xE2, 0x74,
	 0x67, 0x80, 0x0D, 0x54, 0x86, 0x00, 0x0B, 0xE8, 0x0E, 0x1C, 0xBB, 0x16, 0x00, 0x02, 0x9C,
	 0x98, 0xA9, 0xCD, 0x55, 0x23, 0x2E, 0x5A, 0xBD, 0x51, 0x22, 0x54, 0x67, 0x80, 0x0D, 0x52,
	 0x88, 0x00, 0x0B, 0xC0, 0x0E, 0x1F, 0xBC, 0xE2, 0x80, 0x00, 0xA6, 0xA6, 0x4A, 0x6B, 0x54,
	 0xC8, 0xCB, 0x96, 0xAF, 0x54, 0x38, 0x9D, 0x19, 0xE0, 0x03, 0x55, 0x21, 0x80, 0x02, 0xFA,
	 0x03, 0x86, 0xEE, 0xC6, 0x80, 0x00, 0xA7, 0x26, 0x2A, 0x73, 0x55, 0x48, 0xBB, 0x96, 0xAF,
	 0x54, 0x38, 0x9D, 0x19, 0xE0, 0x03, 0x55, 0xA1, 0x80, 0x03, 0x2A, 0xE0, 0x00, 0x00, 0x0A,
	 0x6A, 0x64, 0xA6, 0xB5, 0x4C, 0x8C, 0xB9, 0x6A, 0xF5, 0x43, 0x89, 0xD1, 0x9E, 0x00, 0x35,
	 0x52, 0x18, 0x00, 0x2F, 0xA0, 0x38, 0x72, 0xEC, 0x58, 0x00, 0x0A, 0x72, 0x62, 0xA7, 0x35,
	 0x54, 0x8C, 0xB9, 0x6A, 0xF5, 0x44, 0x89, 0x51, 0x9E, 0x00, 0x35, 0x4A, 0x20, 0x00, 0x2F,
	 0x00, 0x38, 0x7E, 0xF3, 0x8A, 0x00, 0x02, 0x9A, 0x99, 0x29, 0xAD, 0x53, 0x23, 0x2E, 0x5A,
	 0xBD, 0x50, 0xE2, 0x74, 0x67, 0x80, 0x0D, 0x54, 0x86, 0x00, 0x0B, 0xE8, 0x0E, 0x1B, 0xBB,
	 0x1A, 0x00, 0x02, 0x9C, 0x98, 0xA9, 0xCD, 0x55, 0x22, 0xEE, 0x5A, 0xBD, 0x50, 0xE2, 0x74,
	 0x67, 0x80, 0x0D, 0x56, 0x86, 0x00, 0x0F, 0xFF, 0xD9},
};

/* Static PNG frame buffers. 2 320x160 color-bar pattern frames, h-flipped. */
static uint8_t png_frame_buffers[2U][PNG_FRAME_SIZE] = {
	/* Frame 0: Normal (not h-flipped) - PNG file with 8-color bar pattern (320x160) */
	{0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44,
	 0x52, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0xA0, 0x08, 0x03, 0x00, 0x00, 0x00, 0x4A,
	 0x7D, 0x45, 0xAE, 0x00, 0x00, 0x00, 0x18, 0x50, 0x4C, 0x54, 0x45, 0xFF, 0xFF, 0xFF, 0xFF,
	 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00,
	 0x00, 0xFF, 0x00, 0x00, 0x00, 0xB8, 0xF2, 0x09, 0xC3, 0x00, 0x00, 0x01, 0x07, 0x49, 0x44,
	 0x41, 0x54, 0x78, 0xDA, 0xED, 0xD0, 0x41, 0x11, 0x80, 0x30, 0x10, 0x00, 0xB1, 0x2B, 0x14,
	 0xEA, 0xDF, 0x31, 0x16, 0xF6, 0xCD, 0x24, 0x12, 0x32, 0x13, 0xAD, 0xE8, 0x8A, 0xEE, 0x68,
	 0x47, 0x4F, 0xF4, 0x46, 0x27, 0x1A, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40,
	 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28,
	 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05,
	 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40,
	 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28,
	 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05,
	 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40,
	 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28,
	 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05,
	 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40,
	 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28,
	 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05,
	 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40,
	 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28,
	 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05,
	 0x0A, 0x14, 0xF8, 0xC7, 0xC0, 0x0F, 0x82, 0x59, 0xBC, 0x1F, 0x2D, 0x38, 0xE2, 0x50, 0x00,
	 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82},
	/* Frame 1: H-flipped - PNG file with 8-color bar pattern (320x160) */
	{0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44,
	 0x52, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0xA0, 0x08, 0x03, 0x00, 0x00, 0x00, 0x4A,
	 0x7D, 0x45, 0xAE, 0x00, 0x00, 0x00, 0x18, 0x50, 0x4C, 0x54, 0x45, 0xFF, 0xFF, 0xFF, 0xFF,
	 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00,
	 0x00, 0xFF, 0x00, 0x00, 0x00, 0xB8, 0xF2, 0x09, 0xC3, 0x00, 0x00, 0x01, 0x06, 0x49, 0x44,
	 0x41, 0x54, 0x78, 0xDA, 0xED, 0xD0, 0x41, 0x15, 0x80, 0x20, 0x00, 0x40, 0x31, 0x04, 0x85,
	 0xFE, 0x8D, 0xA9, 0xF0, 0xCF, 0xBE, 0x2D, 0xC2, 0xC6, 0x89, 0x76, 0xF4, 0x45, 0x6F, 0xB4,
	 0xA2, 0x19, 0x3D, 0xD1, 0xA8, 0x04, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05,
	 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40,
	 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28,
	 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05,
	 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40,
	 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28,
	 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05,
	 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40,
	 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28,
	 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05,
	 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40,
	 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28,
	 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05,
	 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40,
	 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x40, 0x81, 0x02, 0x05, 0x0A, 0x14, 0x28,
	 0x50, 0xE0, 0x1F, 0x03, 0x2F, 0xB5, 0x91, 0xBC, 0x1F, 0xBA, 0x19, 0x46, 0xE0, 0x00, 0x00,
	 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82},
};

struct video_sw_generator_data {
	const struct device *dev;
	struct sw_ctrls ctrls;
	struct video_format fmt;
	struct k_fifo fifo_in;
	struct k_fifo fifo_out;
	struct k_work_delayable work;
	int pattern;
	struct k_poll_signal *sig;
	uint32_t frame_rate;
};

#define VIDEO_SW_GENERATOR_FORMAT_CAP(pixfmt)                                                      \
	{                                                                                          \
		.pixelformat = pixfmt,                                                             \
		.width_min = 64,                                                                   \
		.width_max = 1920,                                                                 \
		.height_min = 64,                                                                  \
		.height_max = 1080,                                                                \
		.width_step = 1,                                                                   \
		.height_step = 1,                                                                  \
	}

#define VIDEO_SW_GENERATOR_FORMAT_CAP_COMPRESSED(pixfmt)					\
	{											\
		.pixelformat = pixfmt,								\
		.width_min = DEFAULT_FRAME_WIDTH,						\
		.width_max = DEFAULT_FRAME_WIDTH,						\
		.height_min = DEFAULT_FRAME_HEIGHT,						\
		.height_max = DEFAULT_FRAME_HEIGHT,						\
		.width_step = 1,								\
		.height_step = 1,								\
	}

static const struct video_format_cap fmts[] = {
	VIDEO_SW_GENERATOR_FORMAT_CAP(VIDEO_PIX_FMT_RGB24),
	VIDEO_SW_GENERATOR_FORMAT_CAP(VIDEO_PIX_FMT_YUYV),
	VIDEO_SW_GENERATOR_FORMAT_CAP(VIDEO_PIX_FMT_RGB565),
	VIDEO_SW_GENERATOR_FORMAT_CAP(VIDEO_PIX_FMT_XRGB32),
	VIDEO_SW_GENERATOR_FORMAT_CAP(VIDEO_PIX_FMT_SRGGB8),
	VIDEO_SW_GENERATOR_FORMAT_CAP(VIDEO_PIX_FMT_SGRBG8),
	VIDEO_SW_GENERATOR_FORMAT_CAP(VIDEO_PIX_FMT_SBGGR8),
	VIDEO_SW_GENERATOR_FORMAT_CAP(VIDEO_PIX_FMT_SGBRG8),
	VIDEO_SW_GENERATOR_FORMAT_CAP_COMPRESSED(VIDEO_PIX_FMT_JPEG),
	VIDEO_SW_GENERATOR_FORMAT_CAP_COMPRESSED(VIDEO_PIX_FMT_PNG),
	{0},
};

static const char *const test_pattern_menu[] = {
	"Color bars",
	NULL,
};

static int video_sw_generator_set_fmt(const struct device *dev, struct video_format *fmt)
{
	struct video_sw_generator_data *data = dev->data;
	size_t idx;
	int ret;

	ret = video_format_caps_index(fmts, fmt, &idx);
	if (ret < 0) {
		LOG_ERR("Unsupported pixel format or resolution");
		return ret;
	}

	/* Special handling for JPEG and PNG formats */
	if (fmt->pixelformat == VIDEO_PIX_FMT_JPEG) {
		if (fmt->width != DEFAULT_FRAME_WIDTH || fmt->height != DEFAULT_FRAME_HEIGHT) {
			LOG_ERR("JPEG format only supports %dx%d resolution", DEFAULT_FRAME_WIDTH,
				DEFAULT_FRAME_HEIGHT);
			return -EINVAL;
		}
		fmt->pitch = 0; /* JPEG doesn't have a pitch */
		fmt->size = JPEG_FRAME_SIZE;
	} else if (fmt->pixelformat == VIDEO_PIX_FMT_PNG) {
		if (fmt->width != DEFAULT_FRAME_WIDTH || fmt->height != DEFAULT_FRAME_HEIGHT) {
			LOG_ERR("PNG format only supports %dx%d resolution", DEFAULT_FRAME_WIDTH,
				DEFAULT_FRAME_HEIGHT);
			return -EINVAL;
		}
		fmt->pitch = 0; /* PNG doesn't have a pitch */
		fmt->size = PNG_FRAME_SIZE;
	} else {
		ret = video_estimate_fmt_size(fmt);
		if (ret < 0) {
			return ret;
		}
	}

	data->fmt = *fmt;
	return 0;
}

static int video_sw_generator_get_fmt(const struct device *dev, struct video_format *fmt)
{
	struct video_sw_generator_data *data = dev->data;

	*fmt = data->fmt;

	return 0;
}

static int video_sw_generator_set_stream(const struct device *dev, bool enable,
					 enum video_buf_type type)
{
	struct video_sw_generator_data *data = dev->data;
	struct k_work_sync work_sync = {0};

	if (enable) {
		k_work_schedule(&data->work, K_MSEC(1000 / data->frame_rate));
	} else {
		k_work_cancel_delayable_sync(&data->work, &work_sync);
	}

	return 0;
}

static const uint8_t pattern_rggb_idx[] = {0, 1, 1, 2};
static const uint8_t pattern_bggr_idx[] = {2, 1, 1, 0};
static const uint8_t pattern_gbrg_idx[] = {1, 2, 0, 1};
static const uint8_t pattern_grbg_idx[] = {1, 0, 2, 1};

/* White, Yellow, Cyan, Green, Magenta, Red, Blue, Black */

static const uint16_t pattern_8bars_yuv_bt709[8][3] = {
	{0xFE, 0x80, 0x7F}, {0xEC, 0x00, 0x8B}, {0xC8, 0x9D, 0x00}, {0xB6, 0x1D, 0x0C},
	{0x48, 0xE2, 0xF3}, {0x36, 0x62, 0xFF}, {0x12, 0xFF, 0x74}, {0x00, 0x80, 0x80},
};

static const uint16_t pattern_8bars_rgb[8][3] = {
	{0xFF, 0xFF, 0xFF}, {0xFF, 0xFF, 0x00}, {0x00, 0xFF, 0xFF}, {0x00, 0xFF, 0x00},
	{0xFF, 0x00, 0xFF}, {0xFF, 0x00, 0x00}, {0x00, 0x00, 0xFF}, {0x00, 0x00, 0x00},
};

static inline int video_sw_generator_get_color_idx(uint16_t w, uint16_t width, bool hflip)
{
	/* If hflip is on, start from the right instead */
	w = (hflip) ? (width - w - 1) : (w);

	/* Downscale from w/width to #/8 */
	return 8 * w / width;
}

static uint16_t video_sw_generator_fill_yuyv(uint8_t *buffer, uint16_t width, bool hflip)
{
	if (width % 2 != 0) {
		LOG_ERR("YUYV pixels always go by pairs");
		return 0;
	}

	for (size_t w = 0; w < width; w += 2) {
		int color_idx = video_sw_generator_get_color_idx(w, width, hflip);

		buffer[w * 2 + 0] = pattern_8bars_yuv_bt709[color_idx][0];
		buffer[w * 2 + 1] = pattern_8bars_yuv_bt709[color_idx][1];
		buffer[w * 2 + 2] = pattern_8bars_yuv_bt709[color_idx][0];
		buffer[w * 2 + 3] = pattern_8bars_yuv_bt709[color_idx][2];
	}
	return 1;
}

static uint16_t video_sw_generator_fill_xrgb32(uint8_t *buffer, uint16_t width, bool hflip)
{
	for (size_t w = 0; w < width; w++) {
		int color_idx = video_sw_generator_get_color_idx(w, width, hflip);

		buffer[w * 4 + 0] = 0xff;
		buffer[w * 4 + 1] = pattern_8bars_rgb[color_idx][0];
		buffer[w * 4 + 2] = pattern_8bars_rgb[color_idx][1];
		buffer[w * 4 + 3] = pattern_8bars_rgb[color_idx][2];
	}
	return 1;
}

static uint16_t video_sw_generator_fill_rgb24(uint8_t *buffer, uint16_t width, bool hflip)
{
	for (size_t w = 0; w < width; w++) {
		int color_idx = video_sw_generator_get_color_idx(w, width, hflip);

		buffer[w * 3 + 0] = pattern_8bars_rgb[color_idx][0];
		buffer[w * 3 + 1] = pattern_8bars_rgb[color_idx][1];
		buffer[w * 3 + 2] = pattern_8bars_rgb[color_idx][2];
	}
	return 1;
}

static uint16_t video_sw_generator_fill_rgb565(uint8_t *buffer, uint16_t width, bool hflip)
{
	for (size_t w = 0; w < width; w++) {
		int color_idx = video_sw_generator_get_color_idx(w, width, hflip);
		uint8_t r = pattern_8bars_rgb[color_idx][0] >> (8 - 5);
		uint8_t g = pattern_8bars_rgb[color_idx][1] >> (8 - 6);
		uint8_t b = pattern_8bars_rgb[color_idx][2] >> (8 - 5);

		((uint16_t *)buffer)[w] = sys_cpu_to_le16((r << 11) | (g << 6) | (b << 0));
	}
	return 1;
}

static uint16_t video_sw_generator_fill_bayer8(uint8_t *buffer, uint16_t width, bool hflip,
					       const uint8_t *bayer_idx)
{
	uint8_t *row0 = buffer + 0;
	uint8_t *row1 = buffer + width;

	if (width % 2 != 0) {
		LOG_ERR("Bayer pixels always go by pairs (vertically and horizontally)");
		return 0;
	}

	for (size_t w = 0; w < width; w += 2) {
		int color_idx = video_sw_generator_get_color_idx(w, width, hflip);

		row0[w + 0] = pattern_8bars_rgb[color_idx][bayer_idx[0]];
		row0[w + 1] = pattern_8bars_rgb[color_idx][bayer_idx[1]];
		row1[w + 0] = pattern_8bars_rgb[color_idx][bayer_idx[2]];
		row1[w + 1] = pattern_8bars_rgb[color_idx][bayer_idx[3]];
	}
	return 2;
}

static int video_sw_generator_fill_compressed(const struct device *const dev,
					      struct video_buffer *vbuf, bool hflip,
					      uint32_t pix_format)
{
	uint8_t *frame;
	uint32_t frame_size;

	switch (pix_format) {
	case VIDEO_PIX_FMT_JPEG:
		frame = jpeg_frame_buffers[hflip ? 1U : 0U];
		frame_size = JPEG_FRAME_SIZE;
		break;
	case VIDEO_PIX_FMT_PNG:
		frame = png_frame_buffers[hflip ? 1U : 0U];
		frame_size = PNG_FRAME_SIZE;
		break;
	default:
		LOG_ERR("Unsupported compressed format: %u", pix_format);
		return -EINVAL;
	}

	/* Check if buffer is large enough */
	if (vbuf->size < frame_size) {
		LOG_ERR("Buffer too small (need %d, have %zu)", PNG_FRAME_SIZE, vbuf->size);
		return -ENOMEM;
	}

	/* Copy the JPEG frame data to the video buffer */
	memcpy(vbuf->buffer, frame, frame_size);
	vbuf->bytesused = frame_size;
	vbuf->timestamp = k_uptime_get_32();
	vbuf->line_offset = 0;

	return 0;
}

static int video_sw_generator_fill(const struct device *const dev, struct video_buffer *vbuf)
{
	struct video_sw_generator_data *data = dev->data;
	struct video_format *fmt = &data->fmt;
	size_t pitch = fmt->width * video_bits_per_pixel(fmt->pixelformat) / BITS_PER_BYTE;
	bool hflip = data->ctrls.hflip.val;
	uint16_t lines = 0;

	/* Handle JPEG and PNG formats specially */
	if ((data->fmt.pixelformat == VIDEO_PIX_FMT_JPEG) ||
	    (data->fmt.pixelformat == VIDEO_PIX_FMT_PNG)) {
		return video_sw_generator_fill_compressed(dev, vbuf, hflip, data->fmt.pixelformat);
	}

	if (vbuf->size < pitch * 2) {
		LOG_ERR("At least 2 lines needed for bayer formats support");
		return -EINVAL;
	}

	/* Fill the first row of the emulated framebuffer */
	switch (data->fmt.pixelformat) {
	case VIDEO_PIX_FMT_YUYV:
		lines = video_sw_generator_fill_yuyv(vbuf->buffer, fmt->width, hflip);
		break;
	case VIDEO_PIX_FMT_XRGB32:
		lines = video_sw_generator_fill_xrgb32(vbuf->buffer, fmt->width, hflip);
		break;
	case VIDEO_PIX_FMT_RGB24:
		lines = video_sw_generator_fill_rgb24(vbuf->buffer, fmt->width, hflip);
		break;
	case VIDEO_PIX_FMT_RGB565:
		lines = video_sw_generator_fill_rgb565(vbuf->buffer, fmt->width, hflip);
		break;
	case VIDEO_PIX_FMT_SRGGB8:
		lines = video_sw_generator_fill_bayer8(vbuf->buffer, fmt->width, hflip,
						       pattern_rggb_idx);
		break;
	case VIDEO_PIX_FMT_SGBRG8:
		lines = video_sw_generator_fill_bayer8(vbuf->buffer, fmt->width, hflip,
						       pattern_gbrg_idx);
		break;
	case VIDEO_PIX_FMT_SBGGR8:
		lines = video_sw_generator_fill_bayer8(vbuf->buffer, fmt->width, hflip,
						       pattern_bggr_idx);
		break;
	case VIDEO_PIX_FMT_SGRBG8:
		lines = video_sw_generator_fill_bayer8(vbuf->buffer, fmt->width, hflip,
						       pattern_grbg_idx);
		break;
	default:
		CODE_UNREACHABLE;
		break;
	}

	if (lines == 0) {
		return -EINVAL;
	}

	/* How much was filled in so far */
	vbuf->bytesused = data->fmt.pitch * lines;

	/* Duplicate the first line(s) all over the buffer */
	for (int h = lines; h < data->fmt.height; h += lines) {
		if (vbuf->size < vbuf->bytesused + pitch * lines) {
			LOG_WRN("Generation stopped early: buffer too small");
			break;
		}
		memcpy(vbuf->buffer + h * pitch, vbuf->buffer, pitch * lines);
		vbuf->bytesused += pitch * lines;
	}

	vbuf->timestamp = k_uptime_get_32();
	vbuf->line_offset = 0;

	return 0;
}

static void video_sw_generator_worker(struct k_work *work)
{
	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
	struct video_sw_generator_data *data;
	struct video_buffer *vbuf;

	data = CONTAINER_OF(dwork, struct video_sw_generator_data, work);

	k_work_reschedule(&data->work, K_MSEC(1000 / data->frame_rate));

	vbuf = k_fifo_get(&data->fifo_in, K_NO_WAIT);
	if (vbuf == NULL) {
		return;
	}

	switch (data->pattern) {
	case VIDEO_PATTERN_COLOR_BAR:
		video_sw_generator_fill(data->dev, vbuf);
		break;
	}

	k_fifo_put(&data->fifo_out, vbuf);

	if (IS_ENABLED(CONFIG_POLL) && data->sig) {
		k_poll_signal_raise(data->sig, VIDEO_BUF_DONE);
	}

	k_yield();
}

static int video_sw_generator_enqueue(const struct device *dev, struct video_buffer *vbuf)
{
	struct video_sw_generator_data *data = dev->data;

	k_fifo_put(&data->fifo_in, vbuf);

	return 0;
}

static int video_sw_generator_dequeue(const struct device *dev, struct video_buffer **vbuf,
				      k_timeout_t timeout)
{
	struct video_sw_generator_data *data = dev->data;

	*vbuf = k_fifo_get(&data->fifo_out, timeout);
	if (*vbuf == NULL) {
		return -EAGAIN;
	}

	return 0;
}

static int video_sw_generator_flush(const struct device *dev, bool cancel)
{
	struct video_sw_generator_data *data = dev->data;
	struct video_buffer *vbuf;

	if (!cancel) {
		/* wait for all buffer to be processed */
		do {
			k_sleep(K_MSEC(1));
		} while (!k_fifo_is_empty(&data->fifo_in));
	} else {
		while ((vbuf = k_fifo_get(&data->fifo_in, K_NO_WAIT))) {
			k_fifo_put(&data->fifo_out, vbuf);
			if (IS_ENABLED(CONFIG_POLL) && data->sig) {
				k_poll_signal_raise(data->sig, VIDEO_BUF_ABORTED);
			}
		}
	}

	return 0;
}

static int video_sw_generator_get_caps(const struct device *dev, struct video_caps *caps)
{
	caps->format_caps = fmts;
	caps->min_vbuf_count = 1;

	return 0;
}

#ifdef CONFIG_POLL
static int video_sw_generator_set_signal(const struct device *dev, struct k_poll_signal *sig)
{
	struct video_sw_generator_data *data = dev->data;

	if (data->sig && sig != NULL) {
		return -EALREADY;
	}

	data->sig = sig;

	return 0;
}
#endif

static int video_sw_generator_set_frmival(const struct device *dev, struct video_frmival *frmival)
{
	struct video_sw_generator_data *data = dev->data;

	data->frame_rate = CLAMP(DIV_ROUND_CLOSEST(frmival->denominator, frmival->numerator),
				 MIN_FRAME_RATE, MAX_FRAME_RATE);
	frmival->numerator = 1;
	frmival->denominator = data->frame_rate;

	return 0;
}

static int video_sw_generator_get_frmival(const struct device *dev, struct video_frmival *frmival)
{
	struct video_sw_generator_data *data = dev->data;

	frmival->numerator = 1;
	frmival->denominator = data->frame_rate;

	return 0;
}

static int video_sw_generator_enum_frmival(const struct device *dev, struct video_frmival_enum *fie)
{
	size_t idx;
	int ret;

	if (fie->index >= 1) {
		return -ERANGE;
	}

	ret = video_format_caps_index(fmts, fie->format, &idx);
	if (ret < 0) {
		LOG_ERR("Unsupported pixel format or resolution");
		return ret;
	}

	fie->type = VIDEO_FRMIVAL_TYPE_STEPWISE;
	fie->stepwise.min.numerator = 1;
	fie->stepwise.min.denominator = MAX_FRAME_RATE;
	fie->stepwise.max.numerator = UINT32_MAX;
	fie->stepwise.max.denominator = 1;
	/* The frame interval step size is the minimum resolution of K_MSEC(), which is 1ms */
	fie->stepwise.step.numerator = 1;
	fie->stepwise.step.denominator = 1000;

	return 0;
}

static DEVICE_API(video, video_sw_generator_driver_api) = {
	.set_format = video_sw_generator_set_fmt,
	.get_format = video_sw_generator_get_fmt,
	.set_stream = video_sw_generator_set_stream,
	.flush = video_sw_generator_flush,
	.enqueue = video_sw_generator_enqueue,
	.dequeue = video_sw_generator_dequeue,
	.get_caps = video_sw_generator_get_caps,
	.set_frmival = video_sw_generator_set_frmival,
	.get_frmival = video_sw_generator_get_frmival,
	.enum_frmival = video_sw_generator_enum_frmival,
#ifdef CONFIG_POLL
	.set_signal = video_sw_generator_set_signal,
#endif
};

static int video_sw_generator_init_controls(const struct device *dev)
{
	struct video_sw_generator_data *data = dev->data;
	int ret;

	ret = video_init_menu_ctrl(&data->ctrls.test_pattern, dev, VIDEO_CID_TEST_PATTERN,
				   0, test_pattern_menu);
	if (ret < 0) {
		return ret;
	}

	return video_init_ctrl(&data->ctrls.hflip, dev, VIDEO_CID_HFLIP,
			       (struct video_ctrl_range){.min = 0, .max = 1, .step = 1, .def = 0});
}

static int video_sw_generator_init(const struct device *dev)
{
	struct video_sw_generator_data *data = dev->data;

	data->dev = dev;
	k_fifo_init(&data->fifo_in);
	k_fifo_init(&data->fifo_out);
	k_work_init_delayable(&data->work, video_sw_generator_worker);

	return video_sw_generator_init_controls(dev);
}

#define VIDEO_SW_GENERATOR_DEFINE(n)                                                               \
	static struct video_sw_generator_data video_sw_generator_data_##n = {                      \
		.fmt.width = DEFAULT_FRAME_WIDTH,                                                  \
		.fmt.height = DEFAULT_FRAME_HEIGHT,                                                \
		.fmt.pitch = DEFAULT_FRAME_WIDTH * 2,                                              \
		.fmt.pixelformat = VIDEO_PIX_FMT_RGB565,                                           \
		.fmt.size = DEFAULT_FRAME_WIDTH * 2 * DEFAULT_FRAME_HEIGHT,                        \
		.frame_rate = DEFAULT_FRAME_RATE,                                                  \
	};                                                                                         \
                                                                                                   \
	DEVICE_DT_INST_DEFINE(n, &video_sw_generator_init, NULL, &video_sw_generator_data_##n,     \
			      NULL, POST_KERNEL, CONFIG_VIDEO_INIT_PRIORITY,                       \
			      &video_sw_generator_driver_api);                                     \
                                                                                                   \
	VIDEO_DEVICE_DEFINE(video_sw_generator_##n, DEVICE_DT_INST_GET(n), NULL);

DT_INST_FOREACH_STATUS_OKAY(VIDEO_SW_GENERATOR_DEFINE)
