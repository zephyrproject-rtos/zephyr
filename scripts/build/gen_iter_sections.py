#!/usr/bin/env python3
#
# Copyright (c) 2023 Bjarki Arge Andreasen
#
# SPDX-License-Identifier: Apache-2.0
"""
Script to generate iterable sections from JSON encoded dictionary containing a list of annotations.
"""

import argparse
import json
import sys
from dataclasses import dataclass
from enum import Enum
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parents[1]))
from zpp import Annotation, AnnotationType


class IterableSectionType(Enum):
    RAM = "RAM"
    ROM = "ROM"


@dataclass
class IterableSection:
    name: str
    mem: IterableSectionType


def get_tagged_items(filepath: str) -> list[IterableSection]:
    with open(filepath) as fp:
        annotations = [Annotation(**a) for a in json.load(fp)]

    return [
        IterableSection(
            name=a.data.get("name", ""),
            mem=IterableSectionType.RAM
            if IterableSectionType.RAM.value in a.args
            else IterableSectionType.ROM,
        )
        for a in annotations
        if a.attr == AnnotationType.STRUCT
        and len(a.data.get("name", "")) > 0
        and "iterable" in a.args
    ]


def gen_ld(filepath: str, items: list[IterableSection], args):
    with open(filepath, "w") as fp:
        fp.write(f"/* Generated by {Path(__file__).name} */\n")
        for item in items:
            fp.write(f"ITERABLE_SECTION_{item.mem.value}({item.name}, {args.align})\n")


def gen_cmake(filepath: str, items: list[IterableSection], args):
    with open(filepath, "w") as fp:
        fp.write(f"# Generated by {Path(__file__).name}\n")
        for item in items:
            if item.mem == IterableSectionType.ROM:
                fp.write(
                    f'list(APPEND sections "{{NAME\\;{item.name}_area\\;'
                    + 'GROUP\\;RODATA_REGION\\;'
                    + f'SUBALIGN\\;{args.align}\\;'
                    + 'NOINPUT\\;TRUE}")\n'
                )
            elif item.mem == IterableSectionType.RAM:
                fp.write(
                    f'list(APPEND sections "{{NAME\\;{item.name}_area\\;'
                    + 'GROUP\\;DATA_REGION\\;'
                    + f'SUBALIGN\\;{args.align}\\;'
                    + ("ALIGN_WITH_INPUT\\;TRUE\\;" if args.xip else "")
                    + 'NOINPUT\\;TRUE}")\n'
                )
            else:
                raise AssertionError("Invalid memory type")

            fp.write(
                f'list(APPEND section_settings "{{SECTION\\;{item.name}_area\\;'
                + 'SORT\\;NAME\\;'
                + 'KEEP\\;TRUE\\;'
                + f'INPUT\\;._{item.name}.static.*\\;'
                + f'SYMBOLS\\;_{item.name}_list_start\\;_{item.name}_list_end}}")\n'
            )
        fp.write(f'set({args.prefix}_SECTIONS         "${{sections}}" CACHE INTERNAL "")\n')
        fp.write(f'set({args.prefix}_SECTION_SETTINGS "${{section_settings}}" CACHE INTERNAL "")\n')


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        allow_abbrev=False,
    )

    parser.add_argument("--input", required=True, help="Path to input list of tags")
    parser.add_argument(
        "--alignment", dest="align", required=True, help="Iterable section alignment"
    )
    parser.add_argument("--xip", action="store_true", help="Add if XIP is enabled")
    parser.add_argument("--ld-rom-output", required=True, help="Path to output ROM linker file")
    parser.add_argument("--ld-ram-output", required=True, help="Path to output RAM linker file")
    parser.add_argument(
        "--cmake-output", required=True, help="Path to CMake linker script inclusion file"
    )
    parser.add_argument("--cmake-prefix", dest="prefix", required=True, help="Section name prefix")

    return parser.parse_args()


def main():
    args = parse_args()

    items = get_tagged_items(args.input)

    gen_ld(
        args.ld_ram_output, [item for item in items if item.mem == IterableSectionType.RAM], args
    )
    gen_ld(
        args.ld_rom_output, [item for item in items if item.mem == IterableSectionType.ROM], args
    )
    gen_cmake(args.cmake_output, items, args)


if __name__ == "__main__":
    main()
