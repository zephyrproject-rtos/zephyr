/*
 * Copyright (c) 2025 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <zephyr/device.h>
#include <zephyr/drivers/uart.h>
#include <zephyr/drivers/serial/uart_emul.h>
#include <zephyr/kernel.h>
#include <zephyr/ztest.h>
#include <zephyr/fff.h>
#include <zephyr/zbus/multidomain/zbus_multidomain_types.h>
#include <zephyr/zbus/multidomain/zbus_multidomain_uart.h>

#include <zephyr/sys/crc.h>

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(uart_backend_test, LOG_LEVEL_DBG);

struct test_msg {
	uint32_t id;
	uint8_t channel_name[16];
	uint8_t channel_name_len;
	uint8_t data[32];
	uint8_t data_len;
};

const struct device *uart_dev = DEVICE_DT_GET(DT_NODELABEL(euart0));
uint8_t async_rx_buf[4][sizeof(struct test_msg)];
volatile uint8_t async_rx_buf_idx;
struct test_msg received_msg;

DEFINE_FFF_GLOBALS;

FAKE_VALUE_FUNC1(int, fake_multidomain_backend_recv_cb, const struct zbus_proxy_agent_msg *);
FAKE_VALUE_FUNC2(int, fake_multidomain_backend_ack_cb, uint32_t, void *);

void test_uart_dev_uart_callback(const struct device *dev, struct uart_event *evt, void *user_data)
{
	int ret;

	switch (evt->type) {
	case UART_TX_DONE:
		LOG_INF("TX done event\n");
		break;

	case UART_RX_RDY:
		LOG_INF("RX ready event, received %zu bytes\n", evt->data.rx.len);
		LOG_HEXDUMP_INF(evt->data.rx.buf, evt->data.rx.len, "Received data:");
		memcpy(&received_msg, evt->data.rx.buf, evt->data.rx.len);
		break;

	case UART_RX_BUF_REQUEST:
		LOG_INF("RX buffer request event\n");
		ret = uart_rx_buf_rsp(dev, async_rx_buf[async_rx_buf_idx],
				      sizeof(async_rx_buf[async_rx_buf_idx]));
		if (ret < 0) {
			LOG_ERR("Failed to provide RX buffer: %d", ret);
		} else {
			async_rx_buf_idx = (async_rx_buf_idx + 1) % 4;
			LOG_INF("Provided RX buffer %d", async_rx_buf_idx);
		}
		break;
	default:
		break;
	}
}

void test_uart_dev_tx_callback(const struct device *dev, size_t size, void *user_data)
{
	LOG_INF("Tx buffer got appended %zu bytes\n", size);
}

ZTEST(uart_backend, test_uart_dev)
{
	int ret;

	struct test_msg message = {
		.id = 1,
		.channel_name = "test_channel",
		.channel_name_len = sizeof("test_channel"),
		.data = "test_data",
		.data_len = sizeof("test_data"),
	};

	zassert_not_null(uart_dev, "UART device is NULL");
	zassert_true(device_is_ready(uart_dev), "UART device is not ready");

	ret = uart_rx_enable(uart_dev, async_rx_buf[async_rx_buf_idx],
			     sizeof(async_rx_buf[async_rx_buf_idx]), SYS_FOREVER_US);
	zassert_equal(ret, 0, "Failed to enable UART RX: %d", ret);

	ret = uart_callback_set(uart_dev, test_uart_dev_uart_callback, NULL);
	zassert_equal(ret, 0, "Failed to set UART callback: %d", ret);

	/* Set up emulator TX callback */
	uart_emul_callback_tx_data_ready_set(uart_dev, test_uart_dev_tx_callback, NULL);

	ret = uart_tx(uart_dev, (uint8_t *)&message, sizeof(message), SYS_FOREVER_US);
	zassert_equal(ret, 0, "Failed to send message via UART: %d", ret);

	/* Wait for TX to complete */
	k_sleep(K_MSEC(1));

	ret = uart_emul_get_tx_data(uart_dev, (uint8_t *)&received_msg, sizeof(received_msg));
	LOG_INF("Got %d bytes from emulator TX buffer", ret);
	zassert_equal(ret, sizeof(message), "Received message size mismatch: %d", ret);
	zassert_mem_equal(&received_msg, &message, sizeof(message),
			  "Received message content mismatch");

	ret = uart_emul_put_rx_data(uart_dev, (uint8_t *)&message, sizeof(message));
	zassert_equal(ret, sizeof(message), "Failed to put RX data: %d", ret);

	/* Wait for RX callback to process the data */
	k_sleep(K_MSEC(1));
	zassert_mem_equal(&received_msg, &message, sizeof(message),
			  "Received message content mismatch");

	message.id = 2;
	ret = uart_emul_put_rx_data(uart_dev, (uint8_t *)&message, sizeof(message) - 10);
	zassert_equal(ret, sizeof(message) - 10, "Failed to put RX data: %d", ret);
	zassert_not_equal(received_msg.id, message.id,
			  "Received message should not be updated on partial data");

	ret = uart_rx_disable(uart_dev);
	zassert_equal(ret, 0, "Failed to disable UART RX: %d", ret);
}

/*
 * Generate a backend config for the test agent using euart1
 * Generates struct zbus_multidomain_uart_config _name##_uart_config (test_agent_uart_config)
 */
#define EUART1_NODE DT_NODELABEL(euart1)
_ZBUS_GENERATE_BACKEND_CONFIG_ZBUS_MULTIDOMAIN_TYPE_UART(test_agent, EUART1_NODE);

ZTEST(uart_backend, test_backend_macros)
{
	/* Verify the condfig generated by _ZBUS_GENERATE_BACKEND_CONFIG_ZBUS_MULTIDOMAIN_TYPE_UART
	 */
	zassert_not_null(test_agent_uart_config.dev, "UART device in config is NULL");
	zassert_equal_ptr(test_agent_uart_config.dev, DEVICE_DT_GET(DT_NODELABEL(euart1)),
			  "UART device in config does not match expected device");
	zassert_equal(test_agent_uart_config.async_rx_buf_idx, 0,
		      "Initial async_rx_buf_idx is not 0");
	zassert_equal(sizeof(test_agent_uart_config.async_rx_buf),
		      CONFIG_ZBUS_MULTIDOMAIN_UART_BUF_COUNT * sizeof(struct zbus_proxy_agent_msg),
		      "async_rx_buf size is incorrect");
	zassert_equal(sizeof(test_agent_uart_config.async_rx_buf[0]),
		      sizeof(struct zbus_proxy_agent_msg), "async_rx_buf[0] size is incorrect");

	/* Test the macros for getting API and config */
	struct zbus_multidomain_uart_config *config;
	const struct zbus_proxy_agent_api *api;

	/* Api from zbus_multidomain_uart.c */
	extern const struct zbus_proxy_agent_api zbus_multidomain_uart_api;

	api = _ZBUS_GET_API_ZBUS_MULTIDOMAIN_TYPE_UART();
	zassert_not_null(api, "API macro returned NULL");
	zassert_equal_ptr(api, &zbus_multidomain_uart_api, "API macro returned incorrect API");

	config = _ZBUS_GET_CONFIG_ZBUS_MULTIDOMAIN_TYPE_UART(test_agent);
	zassert_not_null(config, "Config macro returned NULL");
	zassert_equal_ptr(config, &test_agent_uart_config,
			  "Config macro returned incorrect config");
}

ZTEST(uart_backend, test_backend_init)
{
	int ret;
	struct zbus_multidomain_uart_config *config =
		_ZBUS_GET_CONFIG_ZBUS_MULTIDOMAIN_TYPE_UART(test_agent);
	const struct zbus_proxy_agent_api *api = _ZBUS_GET_API_ZBUS_MULTIDOMAIN_TYPE_UART();

	ret = api->backend_init((void *)config);
	zassert_equal(ret, 0, "Failed to initialize UART backend: %d", ret);

	ret = k_sem_take(&config->tx_busy_sem, K_NO_WAIT);
	zassert_equal(ret, 0, "TX busy semaphore should be available after init");
	k_sem_give(&config->tx_busy_sem);

	ret = api->backend_init(NULL);
	zassert_not_equal(ret, 0,
			  "Expected failure when initializing UART backend with NULL config");

	ret = api->backend_init(NULL);
	zassert_equal(ret, -EINVAL, "Expected error on NULL config");
}

ZTEST(uart_backend, test_backend_send)
{
	int ret;
	struct zbus_multidomain_uart_config *config =
		_ZBUS_GET_CONFIG_ZBUS_MULTIDOMAIN_TYPE_UART(test_agent);
	const struct zbus_proxy_agent_api *api = _ZBUS_GET_API_ZBUS_MULTIDOMAIN_TYPE_UART();

	uint8_t data_buf[sizeof(struct zbus_proxy_agent_msg) + 32];

	struct zbus_proxy_agent_msg test_msg;

	ret = zbus_create_proxy_agent_msg(&test_msg, "test", 4, "chan", 4);
	zassert_equal(ret, 0, "Failed to create proxy agent message: %d", ret);

	ret = uart_emul_get_tx_data(config->dev, data_buf, sizeof(data_buf));
	zassert_equal(ret, 0, "Emulator TX buffer should be empty before send");

	ret = api->backend_send((void *)config, &test_msg);
	zassert_equal(ret, 0, "Failed to send message via UART backend: %d", ret);
	/* Wait for TX to complete */
	k_sleep(K_MSEC(1));

	ret = uart_emul_get_tx_data(config->dev, data_buf, sizeof(data_buf));
	zassert_equal(ret, sizeof(test_msg), "Emulator TX buffer size mismatch: %d", ret);
	zassert_mem_equal(data_buf, &test_msg, sizeof(test_msg),
			  "Emulator TX buffer content mismatch");
	zassert_equal(k_sem_count_get(&config->tx_busy_sem), 1,
		      "TX busy semaphore should be available after send");
	/* Test sending with NULL config */
	ret = api->backend_send(NULL, &test_msg);
	zassert_equal(ret, -EINVAL, "Expected error on NULL config");

	/* Test sending with NULL message */
	ret = api->backend_send((void *)config, NULL);
	zassert_equal(ret, -EINVAL, "Expected error on NULL message");

	/* Test sending with zero-length message */
	struct zbus_proxy_agent_msg empty_msg = {0};

	ret = api->backend_send((void *)config, &empty_msg);
	zassert_equal(ret, -EINVAL, "Expected error on zero-length message");

	/* Test sending with too large message */
	struct zbus_proxy_agent_msg large_msg;

	ret = zbus_create_proxy_agent_msg(&large_msg, "too_large",
					  CONFIG_ZBUS_MULTIDOMAIN_MESSAGE_SIZE + 1, "chan", 4);
	zassert_equal(ret, -EINVAL, "Expected error on too large message");

	/* Manually create a too large message to bypass the size check in
	 * zbus_create_proxy_agent_msg
	 */
	large_msg.type = ZBUS_PROXY_AGENT_MSG_TYPE_MSG;
	large_msg.id = 43;
	large_msg.message_size = CONFIG_ZBUS_MULTIDOMAIN_MESSAGE_SIZE + 1;
	large_msg.channel_name_len = 4;
	strncpy(large_msg.channel_name, "chan", sizeof(large_msg.channel_name) - 1);
	large_msg.channel_name[sizeof(large_msg.channel_name) - 1] = '\0';
	large_msg.crc32 = crc32_ieee((const uint8_t *)&large_msg,
				     sizeof(large_msg) - sizeof(large_msg.crc32));
	ret = api->backend_send((void *)config, &large_msg);
	zassert_equal(ret, -EINVAL, "Expected error on too large message");
}

ZTEST(uart_backend, test_backend_set_recv_cb)
{
	int ret;
	struct zbus_multidomain_uart_config *config =
		_ZBUS_GET_CONFIG_ZBUS_MULTIDOMAIN_TYPE_UART(test_agent);
	const struct zbus_proxy_agent_api *api = _ZBUS_GET_API_ZBUS_MULTIDOMAIN_TYPE_UART();

	ret = api->backend_set_recv_cb((void *)config, fake_multidomain_backend_recv_cb);
	zassert_equal(ret, 0, "Failed to set recv callback: %d", ret);
	zassert_equal_ptr(config->recv_cb, fake_multidomain_backend_recv_cb,
			  "Recv callback not set correctly");

	ret = api->backend_set_recv_cb(NULL, fake_multidomain_backend_recv_cb);
	zassert_equal(ret, -EINVAL, "Expected error on NULL config");
	zassert_equal_ptr(config->recv_cb, fake_multidomain_backend_recv_cb,
			  "Recv callback should remain unchanged after NULL config");

	ret = api->backend_set_recv_cb((void *)config, NULL);
	zassert_equal(ret, -EINVAL, "Expected error on NULL callback");
	zassert_equal_ptr(config->recv_cb, fake_multidomain_backend_recv_cb,
			  "Recv callback should remain unchanged after NULL callback");
}

ZTEST(uart_backend, test_backend_set_ack_cb)
{
	int ret;
	struct zbus_multidomain_uart_config *config =
		_ZBUS_GET_CONFIG_ZBUS_MULTIDOMAIN_TYPE_UART(test_agent);
	const struct zbus_proxy_agent_api *api = _ZBUS_GET_API_ZBUS_MULTIDOMAIN_TYPE_UART();

	void *user_data = (void *)0x12345678;

	ret = api->backend_set_ack_cb((void *)config, fake_multidomain_backend_ack_cb, user_data);
	zassert_equal(ret, 0, "Failed to set ACK callback: %d", ret);
	zassert_equal_ptr(config->ack_cb, fake_multidomain_backend_ack_cb,
			  "ACK callback not set correctly");
	zassert_equal_ptr(config->ack_cb_user_data, user_data, "ACK user data not set correctly");

	ret = api->backend_set_ack_cb(NULL, fake_multidomain_backend_ack_cb, user_data);
	zassert_equal(ret, -EINVAL, "Expected error on NULL config");
	zassert_equal_ptr(config->ack_cb, fake_multidomain_backend_ack_cb,
			  "ACK callback should remain unchanged after NULL config");
	zassert_equal_ptr(config->ack_cb_user_data, user_data,
			  "ACK user data should remain unchanged after NULL config");

	ret = api->backend_set_ack_cb((void *)config, NULL, user_data);
	zassert_equal(ret, -EINVAL, "Expected error on NULL callback");
	zassert_equal_ptr(config->ack_cb, fake_multidomain_backend_ack_cb,
			  "ACK callback should remain unchanged after NULL callback");
	zassert_equal_ptr(config->ack_cb_user_data, user_data,
			  "ACK user data should remain unchanged after NULL callback");
}

ZTEST(uart_backend, test_backend_recv)
{
	int ret;
	struct zbus_multidomain_uart_config *config =
		_ZBUS_GET_CONFIG_ZBUS_MULTIDOMAIN_TYPE_UART(test_agent);
	const struct zbus_proxy_agent_api *api = _ZBUS_GET_API_ZBUS_MULTIDOMAIN_TYPE_UART();
	uint8_t data_buf[sizeof(struct zbus_proxy_agent_msg) + 32] = {0};

	struct zbus_proxy_agent_msg test_msg;

	ret = zbus_create_proxy_agent_msg(&test_msg, "test", 4, "chan", 4);
	zassert_equal(ret, 0, "Failed to create proxy agent message: %d", ret);

	ret = uart_emul_put_rx_data(config->dev, (uint8_t *)&test_msg, sizeof(test_msg));
	zassert_equal(ret, sizeof(test_msg), "Failed to put RX data: %d", ret);
	/* Wait for RX to be processed */
	k_sleep(K_MSEC(1));
	zassert_equal(fake_multidomain_backend_recv_cb_fake.call_count, 0,
		      "Recv callback should not be called when not set");

	ret = api->backend_set_recv_cb((void *)config, fake_multidomain_backend_recv_cb);
	zassert_equal(ret, 0, "Failed to set recv callback: %d", ret);

	test_msg.id = 93;
	test_msg.crc32 =
		crc32_ieee((const uint8_t *)&test_msg, sizeof(test_msg) - sizeof(test_msg.crc32));
	uart_emul_put_rx_data(config->dev, (uint8_t *)&test_msg, sizeof(test_msg));
	k_sleep(K_MSEC(1));
	zassert_equal(fake_multidomain_backend_recv_cb_fake.call_count, 1,
		      "Recv callback should be called once");

	zassert_mem_equal(fake_multidomain_backend_recv_cb_fake.arg0_val, &test_msg,
			  sizeof(test_msg), "Recv callback received incorrect message");
	/* Should be an ACK message in TX buffer */
	ret = uart_emul_get_tx_data(config->dev, data_buf, sizeof(struct zbus_proxy_agent_msg));
	zassert_equal(ret, sizeof(struct zbus_proxy_agent_msg),
		      "Emulator TX buffer size mismatch for ACK: %d", ret);

	struct zbus_proxy_agent_msg *ack_msg = (struct zbus_proxy_agent_msg *)data_buf;

	zassert_equal(ack_msg->type, ZBUS_PROXY_AGENT_MSG_TYPE_ACK, "ACK message type incorrect");
	zassert_equal(ack_msg->id, 93, "ACK message ID incorrect");
	zassert_equal(ack_msg->message_size, 0, "ACK message size should be 0");

	/* Invalid messages */
	struct zbus_proxy_agent_msg invalid_msg = {0};

	uart_emul_put_rx_data(config->dev, (uint8_t *)&invalid_msg, sizeof(invalid_msg));
	k_sleep(K_MSEC(1));
	zassert_equal(fake_multidomain_backend_recv_cb_fake.call_count, 1,
		      "Recv callback should not be called on NULL message");

	/* Update message to verify new message received*/
	test_msg.id = 95;
	test_msg.crc32 =
		crc32_ieee((const uint8_t *)&test_msg, sizeof(test_msg) - sizeof(test_msg.crc32));
	/*
	 * Partial reception is expected to:
	 *  - not trigger the callback
	 *  - Corrupt the internal state so that the next valid message is also not processed.
	 *  - Recover when next valid message is received
	 *
	 * Partial -> not processed
	 * Valid   -> not processed, curupted by previous failure
	 * Valid   -> processed
	 */
	uart_emul_put_rx_data(config->dev, (uint8_t *)&test_msg, 30);
	k_sleep(K_MSEC(1));
	zassert_equal(fake_multidomain_backend_recv_cb_fake.call_count, 1,
		      "Recv callback should not be called on partial message");
	/* Should not be an ACK message in TX buffer */
	ret = uart_emul_get_tx_data(config->dev, data_buf, sizeof(struct zbus_proxy_agent_msg));
	zassert_equal(ret, 0, "Emulator TX buffer should be empty after partial RX: %d", ret);

	/* First valid message after partial will be cprupted by previous partial and dropped */
	uart_emul_put_rx_data(config->dev, (uint8_t *)&test_msg,
			      sizeof(struct zbus_proxy_agent_msg));
	k_sleep(K_MSEC(1));
	zassert_equal(fake_multidomain_backend_recv_cb_fake.call_count, 1,
		      "Recv callback should not be called on partial message");
	/* Should not be an ACK message in TX buffer */
	ret = uart_emul_get_tx_data(config->dev, data_buf, sizeof(struct zbus_proxy_agent_msg));
	zassert_equal(ret, 0, "Emulator TX buffer should be empty after partial RX: %d", ret);

	uart_emul_put_rx_data(config->dev, (uint8_t *)&test_msg,
			      sizeof(struct zbus_proxy_agent_msg));
	k_sleep(K_MSEC(1));
	zassert_equal(fake_multidomain_backend_recv_cb_fake.call_count, 2,
		      "Recv callback should be called again");
	/* Should be an ACK message in TX buffer */
	ret = uart_emul_get_tx_data(config->dev, data_buf, sizeof(struct zbus_proxy_agent_msg));
	zassert_equal(ret, sizeof(struct zbus_proxy_agent_msg),
		      "Emulator TX buffer size mismatch for ACK: %d", ret);
	ack_msg = (struct zbus_proxy_agent_msg *)data_buf;
	zassert_equal(ack_msg->type, ZBUS_PROXY_AGENT_MSG_TYPE_ACK, "ACK message type incorrect");
	zassert_equal(ack_msg->id, 95, "ACK message ID incorrect");
	zassert_equal(ack_msg->message_size, 0, "ACK message size should be 0");

	struct zbus_proxy_agent_msg too_large_msg = {
		.type = ZBUS_PROXY_AGENT_MSG_TYPE_MSG,
		.id = 52,
		.message_size = CONFIG_ZBUS_MULTIDOMAIN_MESSAGE_SIZE + 1,
		.message_data = {'f', 'a', 'k', 'e', ' ', 'd', 'a', 't', 'a'},
		.channel_name_len = 4,
		.channel_name = "test"};
	too_large_msg.crc32 = crc32_ieee((const uint8_t *)&too_large_msg,
					 sizeof(too_large_msg) - sizeof(too_large_msg.crc32));

	uart_emul_put_rx_data(config->dev, (uint8_t *)&too_large_msg, sizeof(too_large_msg));
	k_sleep(K_MSEC(1));
	zassert_equal(fake_multidomain_backend_recv_cb_fake.call_count, 2,
		      "Recv callback should be called again");

	/* Should work after multiple failed messages */
	/* Update message to verify new message received*/
	test_msg.id = 95;
	test_msg.crc32 =
		crc32_ieee((const uint8_t *)&test_msg, sizeof(test_msg) - sizeof(test_msg.crc32));
	uart_emul_put_rx_data(config->dev, (uint8_t *)&test_msg, sizeof(test_msg));
	k_sleep(K_MSEC(1));
	zassert_equal(fake_multidomain_backend_recv_cb_fake.call_count, 3,
		      "Recv callback should be called again");
	/* Should be an ACK message in TX buffer */
	ret = uart_emul_get_tx_data(config->dev, data_buf, sizeof(struct zbus_proxy_agent_msg));
	zassert_equal(ret, sizeof(struct zbus_proxy_agent_msg),
		      "Emulator TX buffer size mismatch for ACK: %d", ret);
	ack_msg = (struct zbus_proxy_agent_msg *)data_buf;
	zassert_equal(ack_msg->type, ZBUS_PROXY_AGENT_MSG_TYPE_ACK, "ACK message type incorrect");
	zassert_equal(ack_msg->id, 95, "ACK message ID incorrect");
	zassert_equal(ack_msg->message_size, 0, "ACK message size should be 0");

	/* Unknown message type */
	/* Update message to verify new message received*/
	test_msg.id = 96;
	test_msg.type = 99;
	test_msg.crc32 =
		crc32_ieee((const uint8_t *)&test_msg, sizeof(test_msg) - sizeof(test_msg.crc32));
	uart_emul_put_rx_data(config->dev, (uint8_t *)&test_msg, sizeof(test_msg));
	k_sleep(K_MSEC(1));
	zassert_equal(fake_multidomain_backend_recv_cb_fake.call_count, 3,
		      "Recv callback should not be called");
	zassert_equal(fake_multidomain_backend_ack_cb_fake.call_count, 0,
		      "ack callback should not be called");
}

ZTEST(uart_backend, test_backend_ack)
{
	int ret;
	struct zbus_multidomain_uart_config *config =
		_ZBUS_GET_CONFIG_ZBUS_MULTIDOMAIN_TYPE_UART(test_agent);
	const struct zbus_proxy_agent_api *api = _ZBUS_GET_API_ZBUS_MULTIDOMAIN_TYPE_UART();
	struct zbus_proxy_agent_msg ack_msg;

	ret = zbus_create_proxy_agent_ack_msg(&ack_msg, 142);

	ret = api->backend_init((void *)config);

	uart_emul_put_rx_data(config->dev, (uint8_t *)&ack_msg, sizeof(ack_msg));
	k_sleep(K_MSEC(1));
	zassert_equal(fake_multidomain_backend_ack_cb_fake.call_count, 0,
		      "ACK callback should not be called when not set");

	ret = api->backend_set_ack_cb((void *)config, fake_multidomain_backend_ack_cb,
				      (void *)0x12345678);
	zassert_equal(ret, 0, "Failed to set ACK callback: %d", ret);

	uart_emul_put_rx_data(config->dev, (uint8_t *)&ack_msg, sizeof(ack_msg));
	k_sleep(K_MSEC(1));
	zassert_equal(fake_multidomain_backend_ack_cb_fake.call_count, 1,
		      "ACK callback should be called once");
	zassert_equal(fake_multidomain_backend_ack_cb_fake.arg0_val, 142,
		      "ACK callback received incorrect message ID");
	zassert_equal_ptr(fake_multidomain_backend_ack_cb_fake.arg1_val, (void *)0x12345678,
			  "ACK callback received incorrect user data");

	fake_multidomain_backend_ack_cb_fake.return_val = -1;
	uart_emul_put_rx_data(config->dev, (uint8_t *)&ack_msg, sizeof(ack_msg));
	k_sleep(K_MSEC(1));
	zassert_equal(fake_multidomain_backend_ack_cb_fake.call_count, 2,
		      "ACK callback should be called again");
	fake_multidomain_backend_ack_cb_fake.return_val = 0;
}

static void test_teardown(void *fixture)
{
	uart_emul_flush_rx_data(uart_dev);
	uart_emul_flush_tx_data(uart_dev);

	struct zbus_multidomain_uart_config *config =
		_ZBUS_GET_CONFIG_ZBUS_MULTIDOMAIN_TYPE_UART(test_agent);
	uart_emul_flush_rx_data(config->dev);
	uart_emul_flush_tx_data(config->dev);

	memset(config->async_rx_buf, 0, sizeof(config->async_rx_buf));
	config->async_rx_buf_idx = 0;
	k_sem_reset(&config->tx_busy_sem);
	k_sem_give(&config->tx_busy_sem);

	RESET_FAKE(fake_multidomain_backend_recv_cb);
	RESET_FAKE(fake_multidomain_backend_ack_cb);
}

ZTEST_SUITE(uart_backend, NULL, NULL, NULL, test_teardown, NULL);
