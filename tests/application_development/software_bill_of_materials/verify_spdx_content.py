#!/usr/bin/env python3
# SPDX-FileCopyrightText: Copyright The Zephyr Project Contributors
# SPDX-License-Identifier: Apache-2.0

"""
Content validation for SPDX documents generated by 'west spdx'.

Usage: pytest verify_spdx_content.py --build-dir <build_dir>
                                     --spdx-version <spdx_version>
                                     --source-dir <source_dir>

Validates that generated SPDX documents contain expected packages, files, relationships, checksums,
and license information for a minimal Zephyr application.
"""

import hashlib
import os

import pytest
from spdx_tools.spdx.model.checksum import ChecksumAlgorithm
from spdx_tools.spdx.model.package import PackagePurpose
from spdx_tools.spdx.model.relationship import RelationshipType

# File name constants (as they appear in SPDX documents)
FILE_MAIN_C = "./src/main.c"
FILE_LIBAPP_A = "./app/libapp.a"
FILE_LIBKERNEL_A = "./zephyr/kernel/libkernel.a"
FILE_LIBZEPHYR_A = "./zephyr/libzephyr.a"
FILE_ZEPHYR_ELF = "./zephyr/zephyr.elf"
FILE_LIBARCH_CORTEX_M_A = "./zephyr/arch/arch/arm/core/cortex_m/libarch__arm__core__cortex_m.a"


def find_file_by_name(doc, name):
    """Find a file in a document by exact name."""
    for f in doc.files:
        if f.name == name:
            return f
    return None


def find_package_by_name(doc, name):
    """Find a package in a document by exact name."""
    for pkg in doc.packages:
        if pkg.name == name:
            return pkg
    return None


def get_relationships_for_element(doc, spdx_id, rel_type):
    """Get all relationships of a given type for a specific element."""
    return [
        r
        for r in doc.relationships
        if r.spdx_element_id == spdx_id and r.relationship_type == rel_type
    ]


def find_doc_ref_id(doc, namespace):
    """Find the DocumentRef ID in doc that points to the given namespace."""
    return next(
        (
            ref.document_ref_id
            for ref in doc.creation_info.external_document_refs
            if ref.document_uri == namespace
        ),
        None,
    )


class TestCommonValidation:
    """Tests for common SPDX document validation."""

    @pytest.fixture(params=["app_doc", "zephyr_doc", "build_doc", "modules_doc"])
    def doc_with_name(self, request):
        """Parametrized fixture providing each document with its name."""
        doc = request.getfixturevalue(request.param)
        name_map = {
            "app_doc": "app.spdx",
            "zephyr_doc": "zephyr.spdx",
            "build_doc": "build.spdx",
            "modules_doc": "modules-deps.spdx",
        }
        return doc, name_map[request.param]

    def test_spdx_version(self, doc_with_name, spdx_version):
        """Test that SPDX version matches expected value."""
        doc, doc_name = doc_with_name
        expected_ver = f"SPDX-{spdx_version}"
        assert doc.creation_info.spdx_version == expected_ver, (
            f"{doc_name}: spdx_version is '{doc.creation_info.spdx_version}', "
            f"expected '{expected_ver}'"
        )

    def test_data_license(self, doc_with_name):
        """Test that data license is CC0-1.0."""
        doc, doc_name = doc_with_name
        assert doc.creation_info.data_license == "CC0-1.0", (
            f"{doc_name}: data_license is '{doc.creation_info.data_license}', expected 'CC0-1.0'"
        )

    def test_document_namespace(self, doc_with_name):
        """Test that document namespace is not empty."""
        doc, doc_name = doc_with_name
        assert doc.creation_info.document_namespace, f"{doc_name}: document_namespace is empty"

    def test_creators(self, doc_with_name):
        """Test that creators list is not empty."""
        doc, doc_name = doc_with_name
        assert len(doc.creation_info.creators) > 0, f"{doc_name}: no creators found"

    def test_document_name(self, doc_with_name):
        """Test that document name is not empty."""
        doc, doc_name = doc_with_name
        assert doc.creation_info.name, f"{doc_name}: document name is empty"

    def test_describes_relationship(self, doc_with_name):
        """Test that DESCRIBES relationship exists."""
        doc, doc_name = doc_with_name
        describes_rels = [
            r for r in doc.relationships if r.relationship_type == RelationshipType.DESCRIBES
        ]
        assert len(describes_rels) > 0, f"{doc_name}: no DESCRIBES relationship found"


class TestAppDocument:
    """Tests for app.spdx document validation."""

    def test_app_sources_package_exists(self, app_doc):
        """Test there is only one package named app-sources."""
        pkg_names = [p.name for p in app_doc.packages]
        has_only_app_sources = len(pkg_names) == 1 and pkg_names[0] == "app-sources"
        assert has_only_app_sources, (
            f"app.spdx: expected only 'app-sources' package, got {pkg_names}"
        )

    def test_app_sources_spdx_id(self, app_doc):
        """Test that app-sources package has correct SPDX ID."""
        app_pkg = find_package_by_name(app_doc, "app-sources")
        assert app_pkg is not None, "app.spdx: app-sources package not found"
        assert app_pkg.spdx_id == "SPDXRef-app-sources", (
            f"app.spdx: app-sources spdx_id is '{app_pkg.spdx_id}'"
        )

    @pytest.mark.min_spdx_version("2.3")
    def test_primary_package_purpose_spdx_23(self, app_doc):
        """Test that primary_package_purpose is SOURCE for SPDX 2.3."""
        app_pkg = find_package_by_name(app_doc, "app-sources")
        assert app_pkg is not None, "app.spdx: app-sources package not found"
        assert app_pkg.primary_package_purpose == PackagePurpose.SOURCE, (
            f"app.spdx: primary_package_purpose is {app_pkg.primary_package_purpose}, "
            "expected PackagePurpose.SOURCE"
        )

    def test_only_file_is_main_c(self, app_doc):
        """Test that the only file in the package is main.c."""
        main_c_spdx = find_file_by_name(app_doc, FILE_MAIN_C)
        assert len(app_doc.files) == 1 and main_c_spdx is not None, (
            f"app.spdx: expected only 'main.c' file, got {len(app_doc.files)} files"
        )

    def test_file_has_sha1_checksum(self, app_doc):
        """Test that main.c has SHA1 checksum with correct length."""
        main_c_spdx = find_file_by_name(app_doc, FILE_MAIN_C)
        assert main_c_spdx is not None, f"app.spdx: {FILE_MAIN_C} not found"
        sha1s = [c for c in main_c_spdx.checksums if c.algorithm == ChecksumAlgorithm.SHA1]
        assert len(sha1s) > 0, f"app.spdx: file '{main_c_spdx.name}' has no SHA1 checksum"
        assert len(sha1s[0].value) == 40, (
            f"app.spdx: file '{main_c_spdx.name}' SHA1 has wrong length ({len(sha1s[0].value)})"
        )

    def test_verification_code(self, app_doc):
        """Test that verification code is present when files are analyzed."""
        app_pkg = find_package_by_name(app_doc, "app-sources")
        assert app_pkg is not None, "app.spdx: app-sources package not found"
        if not app_pkg.files_analyzed:
            pytest.skip("files_analyzed is False")
        assert app_pkg.verification_code is not None, (
            "app.spdx: app-sources has files_analyzed=True but no verification_code"
        )

    def test_contains_relationships(self, app_doc):
        """Test that CONTAINS relationships exist from app-sources package."""
        app_pkg = find_package_by_name(app_doc, "app-sources")
        assert app_pkg is not None, "app.spdx: app-sources package not found"
        contains_rels = [
            r
            for r in app_doc.relationships
            if r.relationship_type == RelationshipType.CONTAINS
            and r.spdx_element_id == app_pkg.spdx_id
        ]
        assert len(contains_rels) == 1, (
            f"app.spdx: expected exactly 1 CONTAINS relationship, got {len(contains_rels)}"
        )

    def test_main_c_hash_correct(self, app_doc, source_dir):
        """Test that main.c has the correct SHA1 and SHA256 hashes."""
        main_c_spdx = find_file_by_name(app_doc, FILE_MAIN_C)
        assert main_c_spdx is not None, f"app.spdx: {FILE_MAIN_C} not found"

        # Read file once for computing both hashes
        main_c_path = os.path.join(source_dir, "src", "main.c")
        assert os.path.exists(main_c_path), f"Source file not found: {main_c_path}"

        with open(main_c_path, "rb") as f:
            file_content = f.read()
            expected_sha1 = hashlib.sha1(file_content, usedforsecurity=False).hexdigest()
            expected_sha256 = hashlib.sha256(file_content, usedforsecurity=False).hexdigest()

        # Validate SHA1 checksum
        sha1_checksums = [c for c in main_c_spdx.checksums if c.algorithm == ChecksumAlgorithm.SHA1]
        assert len(sha1_checksums) > 0, "app.spdx: main.c has no SHA1 checksum"

        actual_sha1 = sha1_checksums[0].value
        assert actual_sha1 == expected_sha1, (
            f"app.spdx: main.c SHA1 mismatch. Expected '{expected_sha1}', got '{actual_sha1}'"
        )

        # Validate SHA256 checksum
        sha256_checksums = [
            c for c in main_c_spdx.checksums if c.algorithm == ChecksumAlgorithm.SHA256
        ]
        assert len(sha256_checksums) > 0, "app.spdx: main.c has no SHA256 checksum"

        actual_sha256 = sha256_checksums[0].value
        assert actual_sha256 == expected_sha256, (
            f"app.spdx: main.c SHA256 mismatch. Expected '{expected_sha256}', got '{actual_sha256}'"
        )

    def test_main_c_license_correct(self, app_doc):
        """Test that main.c has Apache-2.0 license info."""
        main_c_spdx = find_file_by_name(app_doc, FILE_MAIN_C)
        assert main_c_spdx is not None, f"app.spdx: {FILE_MAIN_C} not found"

        assert main_c_spdx.license_info_in_file, "app.spdx: main.c has no license_info_in_file"

        license_strs = [str(lic) for lic in main_c_spdx.license_info_in_file]
        has_apache = any("Apache-2.0" in lic for lic in license_strs)
        assert has_apache, f"app.spdx: main.c license should be Apache-2.0, got {license_strs}"

    def test_main_c_copyright_correct(self, app_doc):
        """Test that main.c has correct copyright text."""
        main_c_spdx = find_file_by_name(app_doc, FILE_MAIN_C)
        assert main_c_spdx is not None, f"app.spdx: {FILE_MAIN_C} not found"

        assert main_c_spdx.copyright_text, "app.spdx: main.c has no copyright_text"

        copyright_text = str(main_c_spdx.copyright_text)
        expected = [
            "Copyright The Zephyr Project Contributors",
            "Copyright (c) 2026 The Linux Foundation",
        ]
        for s in expected:
            assert s in copyright_text, f"main.c copyright missing '{s}', got '{copyright_text}'"


class TestZephyrDocument:
    """Tests for zephyr.spdx document validation."""

    def test_has_packages(self, zephyr_doc):
        """Test that zephyr.spdx has at least one package."""
        assert len(zephyr_doc.packages) >= 1, "zephyr.spdx: no packages found"

    def test_zephyr_sources_package_exists(self, zephyr_doc):
        """Test that zephyr-sources package exists."""
        pkg_names = [p.name for p in zephyr_doc.packages]
        assert "zephyr-sources" in pkg_names, (
            f"zephyr.spdx: expected 'zephyr-sources' package, got {pkg_names}"
        )

    def test_zephyr_sources_spdx_id(self, zephyr_doc):
        """Test that zephyr-sources package has correct SPDX ID."""
        zephyr_pkgs = [p for p in zephyr_doc.packages if p.name == "zephyr-sources"]
        if not zephyr_pkgs:
            pytest.skip("zephyr-sources package not found")
        assert zephyr_pkgs[0].spdx_id == "SPDXRef-zephyr-sources", (
            f"zephyr.spdx: zephyr-sources spdx_id is '{zephyr_pkgs[0].spdx_id}'"
        )

    def test_has_many_files(self, zephyr_doc):
        """Test that zephyr.spdx has more than 10 files."""
        assert len(zephyr_doc.files) > 10, (
            f"zephyr.spdx: expected >10 files, got {len(zephyr_doc.files)}"
        )

    def test_has_kernel_files(self, zephyr_doc):
        """Test that zephyr.spdx contains kernel files."""
        file_names = [f.name for f in zephyr_doc.files]
        has_kernel_file = any("kernel" in name.lower() for name in file_names)
        assert has_kernel_file, "zephyr.spdx: no files with 'kernel' in path found"

    def test_files_have_sha1_checksum(self, zephyr_doc):
        """Test that all files have SHA1 checksums."""
        for f in zephyr_doc.files:
            sha1s = [c for c in f.checksums if c.algorithm == ChecksumAlgorithm.SHA1]
            assert len(sha1s) > 0, f"zephyr.spdx: file '{f.name}' has no SHA1 checksum"

    def test_files_have_apache_license(self, zephyr_doc):
        """Test that some files have Apache-2.0 license info."""
        files_with_apache = [
            f
            for f in zephyr_doc.files
            if f.license_info_in_file
            and any("Apache-2.0" in str(lic) for lic in f.license_info_in_file)
        ]
        assert len(files_with_apache) > 0, "zephyr.spdx: no files have Apache-2.0 license info"

    def test_verification_code(self, zephyr_doc):
        """Test that verification code is present when files are analyzed."""
        zephyr_pkgs = [p for p in zephyr_doc.packages if p.name == "zephyr-sources"]
        if not zephyr_pkgs:
            pytest.skip("zephyr-sources package not found")
        zephyr_pkg = zephyr_pkgs[0]
        if not zephyr_pkg.files_analyzed:
            pytest.skip("files_analyzed is False")
        assert zephyr_pkg.verification_code is not None, (
            "zephyr.spdx: zephyr-sources has files_analyzed=True but no verification_code"
        )


class TestBuildDocument:
    """Tests for build.spdx document validation."""

    def test_has_packages(self, build_doc):
        """Test that build.spdx has at least one package."""
        assert len(build_doc.packages) >= 1, "build.spdx: no packages found"

    def test_packages_have_valid_spdx_ids(self, build_doc):
        """Test that all packages have valid SPDX IDs."""
        for pkg in build_doc.packages:
            assert pkg.spdx_id.startswith("SPDXRef-"), (
                f"build.spdx: package '{pkg.name}' has invalid spdx_id '{pkg.spdx_id}'"
            )

    def test_has_multiple_relationship_types(self, build_doc):
        """Test that build.spdx has more than one relationship type."""
        rel_types = set(r.relationship_type for r in build_doc.relationships)
        assert len(rel_types) > 1, (
            f"build.spdx: only {len(rel_types)} relationship type(s) found, expected more than 1"
        )

    def test_has_external_document_refs(self, build_doc):
        """Test that build.spdx has external document references."""
        ext_refs = build_doc.creation_info.external_document_refs
        assert len(ext_refs) > 0, "build.spdx: no external document references found"


class TestModulesDocument:
    """Tests for modules-deps.spdx document validation."""

    def test_describes_relationship_if_packages(self, modules_doc):
        """Test that DESCRIBES relationship exists if packages are present."""
        if len(modules_doc.packages) == 0:
            pytest.skip("No packages in modules-deps.spdx")
        describes = [
            r
            for r in modules_doc.relationships
            if r.relationship_type == RelationshipType.DESCRIBES
        ]
        assert len(describes) > 0, "modules-deps.spdx: has packages but no DESCRIBES relationship"

    def test_packages_have_valid_spdx_ids(self, modules_doc):
        """Test that all packages have valid SPDX IDs."""
        for pkg in modules_doc.packages:
            assert pkg.spdx_id.startswith("SPDXRef-"), (
                f"modules-deps.spdx: package '{pkg.name}' has invalid spdx_id '{pkg.spdx_id}'"
            )


class TestCrossReferences:
    """Tests for cross-document reference validation."""

    def test_external_ref_to_zephyr(self, build_doc):
        """Test that build.spdx has external reference to zephyr document."""
        ext_refs = build_doc.creation_info.external_document_refs
        ext_ref_ids = [ref.document_ref_id for ref in ext_refs]
        assert any("zephyr" in ref_id.lower() for ref_id in ext_ref_ids), (
            f"build.spdx: no external ref to zephyr document, got {ext_ref_ids}"
        )

    def test_external_ref_to_app(self, app_doc, build_doc):
        """Test that build.spdx has external reference to app document."""
        if len(app_doc.files) == 0:
            pytest.skip("App document has no files")
        ext_refs = build_doc.creation_info.external_document_refs
        ext_ref_ids = [ref.document_ref_id for ref in ext_refs]
        assert any("app" in ref_id.lower() for ref_id in ext_ref_ids), (
            f"build.spdx: no external ref to app document, got {ext_ref_ids}"
        )

    def test_external_refs_have_checksums(self, build_doc):
        """Test that all external references have checksums."""
        for ref in build_doc.creation_info.external_document_refs:
            assert ref.checksum is not None, (
                f"build.spdx: external ref '{ref.document_ref_id}' has no checksum"
            )

    def test_external_refs_use_sha1(self, build_doc):
        """Test that all external reference checksums use SHA1."""
        for ref in build_doc.creation_info.external_document_refs:
            if ref.checksum:
                assert ref.checksum.algorithm == ChecksumAlgorithm.SHA1, (
                    f"build.spdx: external ref '{ref.document_ref_id}' checksum is not SHA1"
                )

    def test_cross_doc_ref_targets_exist(self, app_doc, zephyr_doc, build_doc):
        """Test that cross-document reference targets actually exist in referenced docs.

        Validates that relationships like:
            DocumentRef-app:SPDXRef-File-main.c
            DocumentRef-zephyr:SPDXRef-File-timer.c
        reference SPDX IDs that actually exist in the target documents.
        """
        doc_map = {}

        for doc in [app_doc, zephyr_doc]:
            ref_id = find_doc_ref_id(build_doc, doc.creation_info.document_namespace)
            if ref_id:
                doc_map[ref_id] = doc

        # Collect all cross-document references from relationships
        cross_doc_refs = []
        for rel in build_doc.relationships:
            ref_id = str(rel.related_spdx_element_id)
            if ":" in ref_id and ref_id.startswith("DocumentRef-"):
                cross_doc_refs.append(ref_id)

        assert len(cross_doc_refs) > 0, "build.spdx: no cross-document references found"

        # Validate each cross-document reference
        errors = []
        for ref in cross_doc_refs:
            # Parse DocumentRef-xxx:SPDXRef-yyy format
            doc_ref, spdx_id = ref.split(":", 1)

            if doc_ref not in doc_map:
                errors.append(f"Unknown document ref: {doc_ref}")
                continue

            target_doc = doc_map[doc_ref]

            # Collect all SPDX IDs from the target document
            target_ids = set()
            target_ids.add(target_doc.creation_info.spdx_id)
            for pkg in target_doc.packages:
                target_ids.add(pkg.spdx_id)
            for f in target_doc.files:
                target_ids.add(f.spdx_id)

            if spdx_id not in target_ids:
                errors.append(f"{ref}: target '{spdx_id}' not found in {doc_ref}")

        assert not errors, (
            f"build.spdx: {len(errors)} broken cross-document reference(s):\n"
            + "\n".join(errors[:10])  # Limit output to first 10 errors
        )


class TestBuildTraceability:
    """Tests for source-to-binary traceability in SPDX documents.

    These tests verify the SBOM correctly captures the build chain:
    main.c (source) -> libapp.a (library) -> zephyr.elf (executable)
    And also kernel/arch source traceability.
    """

    # --- libapp.a is GENERATED_FROM main.c ---

    def test_libapp_exists_in_build(self, build_doc):
        """Test that libapp.a exists as a file in build.spdx."""
        libapp = find_file_by_name(build_doc, FILE_LIBAPP_A)
        assert libapp is not None, f"build.spdx: {FILE_LIBAPP_A} not found in files"

    def test_libapp_generated_from_main_c(self, build_doc, app_doc):
        """Test that libapp.a has GENERATED_FROM relationship to main.c.

        This verifies the cross-document reference:
        SPDXRef-File-libapp.a GENERATED_FROM DocumentRef-app:SPDXRef-File-main.c
        """
        libapp = find_file_by_name(build_doc, FILE_LIBAPP_A)
        assert libapp is not None, f"build.spdx: {FILE_LIBAPP_A} not found"

        generated_from_rels = get_relationships_for_element(
            build_doc, libapp.spdx_id, RelationshipType.GENERATED_FROM
        )
        assert len(generated_from_rels) > 0, (
            f"build.spdx: {FILE_LIBAPP_A} ({libapp.spdx_id}) has no GENERATED_FROM relationships"
        )

        # Check that at least one relationship points to main.c via cross-doc ref
        main_c_refs = [r for r in generated_from_rels if "main.c" in str(r.related_spdx_element_id)]
        assert len(main_c_refs) == 1, (
            f"build.spdx: expected {FILE_LIBAPP_A} GENERATED_FROM main.c, "
            f"got relationships to: {[r.related_spdx_element_id for r in generated_from_rels]}"
        )

        # hould reference zephyr document for kernel sou uses the app document cross-reference
        app_ref_id = find_doc_ref_id(build_doc, app_doc.creation_info.document_namespace)
        assert app_ref_id is not None, "build.spdx: no external reference to app document"

        app_doc_refs = [r for r in main_c_refs if app_ref_id in str(r.related_spdx_element_id)]
        assert len(app_doc_refs) > 0, (
            f"build.spdx: {FILE_LIBAPP_A} GENERATED_FROM should use {app_ref_id} cross-reference"
        )

    # --- zephyr.elf links libraries ---

    def test_zephyr_elf_exists_in_build(self, build_doc):
        """Test that zephyr.elf exists as a file in build.spdx."""
        zephyr_elf = find_file_by_name(build_doc, FILE_ZEPHYR_ELF)
        assert zephyr_elf is not None, f"build.spdx: {FILE_ZEPHYR_ELF} not found in files"

    @pytest.mark.parametrize(
        "lib_file",
        [FILE_LIBAPP_A, FILE_LIBKERNEL_A, FILE_LIBZEPHYR_A],
        ids=["libapp.a", "libkernel.a", "libzephyr.a"],
    )
    def test_zephyr_elf_static_links(self, build_doc, lib_file):
        """Test that zephyr.elf has STATIC_LINK relationship to expected libraries."""
        zephyr_elf = find_file_by_name(build_doc, FILE_ZEPHYR_ELF)
        assert zephyr_elf is not None, f"build.spdx: {FILE_ZEPHYR_ELF} not found"

        lib = find_file_by_name(build_doc, lib_file)
        assert lib is not None, f"build.spdx: {lib_file} not found"

        static_link_rels = get_relationships_for_element(
            build_doc, zephyr_elf.spdx_id, RelationshipType.STATIC_LINK
        )
        assert len(static_link_rels) > 0, (
            f"build.spdx: {FILE_ZEPHYR_ELF} has no STATIC_LINK relationships"
        )

        lib_links = [r for r in static_link_rels if r.related_spdx_element_id == lib.spdx_id]
        assert len(lib_links) == 1, f"build.spdx: expected {FILE_ZEPHYR_ELF} STATIC_LINK {lib_file}"

    # --- Full traceability chain ---

    def test_main_c_to_zephyr_elf_traceability(self, app_doc, build_doc):
        """Test complete traceability: main.c -> libapp.a -> zephyr.elf.

        Verifies the SBOM correctly captures:
        1. main.c exists in app.spdx as a source file
        2. libapp.a in build.spdx is GENERATED_FROM main.c
        3. zephyr.elf in build.spdx STATIC_LINK libapp.a
        """
        # Step 1: main.c exists in app.spdx
        main_c = find_file_by_name(app_doc, FILE_MAIN_C)
        assert main_c is not None, f"app.spdx: {FILE_MAIN_C} not found"

        # Step 2: libapp.a GENERATED_FROM main.c
        libapp = find_file_by_name(build_doc, FILE_LIBAPP_A)
        assert libapp is not None, f"build.spdx: {FILE_LIBAPP_A} not found"

        generated_from_rels = get_relationships_for_element(
            build_doc, libapp.spdx_id, RelationshipType.GENERATED_FROM
        )
        main_c_in_chain = any(
            "main.c" in str(r.related_spdx_element_id) for r in generated_from_rels
        )
        assert main_c_in_chain, f"build.spdx: {FILE_LIBAPP_A} not linked to main.c"

        # Step 3: zephyr.elf STATIC_LINK libapp.a
        zephyr_elf = find_file_by_name(build_doc, FILE_ZEPHYR_ELF)
        assert zephyr_elf is not None, f"build.spdx: {FILE_ZEPHYR_ELF} not found"

        static_link_rels = get_relationships_for_element(
            build_doc, zephyr_elf.spdx_id, RelationshipType.STATIC_LINK
        )
        libapp_in_chain = any(r.related_spdx_element_id == libapp.spdx_id for r in static_link_rels)
        assert libapp_in_chain, f"build.spdx: {FILE_ZEPHYR_ELF} not linked to {FILE_LIBAPP_A}"

    # --- Kernel and arch source traceability ---

    def test_libkernel_generated_from_kernel_sources(self, build_doc, zephyr_doc):
        """Test that libkernel.a is GENERATED_FROM kernel source files."""
        libkernel = find_file_by_name(build_doc, FILE_LIBKERNEL_A)
        assert libkernel is not None, f"build.spdx: {FILE_LIBKERNEL_A} not found"

        generated_from_rels = get_relationships_for_element(
            build_doc, libkernel.spdx_id, RelationshipType.GENERATED_FROM
        )
        assert len(generated_from_rels) > 0, (
            f"build.spdx: {FILE_LIBKERNEL_A} has no GENERATED_FROM relationships"
        )

        # Should reference zephyr document for kernel sources
        zephyr_ref_id = find_doc_ref_id(build_doc, zephyr_doc.creation_info.document_namespace)
        assert zephyr_ref_id is not None, "build.spdx: no external reference to zephyr document"

        zephyr_refs = [
            r for r in generated_from_rels if zephyr_ref_id in str(r.related_spdx_element_id)
        ]
        assert len(zephyr_refs) > 0, (
            f"build.spdx: {FILE_LIBKERNEL_A} should be GENERATED_FROM zephyr sources"
        )

    @pytest.mark.parametrize(
        "expected_source",
        ["timer.c", "banner.c", "sched.c", "thread.c", "sem.c", "mutex.c"],
    )
    def test_libkernel_generated_from_specific_sources(self, build_doc, expected_source):
        """Test that libkernel.a is generated from expected kernel source files."""
        libkernel = find_file_by_name(build_doc, FILE_LIBKERNEL_A)
        assert libkernel is not None, f"build.spdx: {FILE_LIBKERNEL_A} not found"

        generated_from_rels = get_relationships_for_element(
            build_doc, libkernel.spdx_id, RelationshipType.GENERATED_FROM
        )

        source_names = [str(r.related_spdx_element_id) for r in generated_from_rels]
        found = any(expected_source in name for name in source_names)
        assert found, f"build.spdx: {FILE_LIBKERNEL_A} should be GENERATED_FROM {expected_source}"

    def test_arch_library_generated_from_arch_sources(self, build_doc):
        """Test that arch library is GENERATED_FROM architecture source files."""
        arch_lib = find_file_by_name(build_doc, FILE_LIBARCH_CORTEX_M_A)
        if arch_lib is None:
            pytest.skip(f"{FILE_LIBARCH_CORTEX_M_A} not found (platform-specific)")

        generated_from_rels = get_relationships_for_element(
            build_doc, arch_lib.spdx_id, RelationshipType.GENERATED_FROM
        )
        assert len(generated_from_rels) > 0, (
            f"build.spdx: {FILE_LIBARCH_CORTEX_M_A} has no GENERATED_FROM relationships"
        )

        # Check for expected arch source files
        source_names = [str(r.related_spdx_element_id) for r in generated_from_rels]
        has_fault_c = any("fault.c" in name for name in source_names)
        has_reset_s = any("reset.S" in name for name in source_names)

        assert has_fault_c or has_reset_s, (
            f"build.spdx: {FILE_LIBARCH_CORTEX_M_A} should be generated from fault.c or reset.S, "
            f"got: {source_names[:5]}..."
        )
