/*
 * NOTE: File generated by gen_board_pinctrl.py
 * from MIMXRT685-EVK.mex
 *
 * Copyright 2022, 2024 NXP
 * SPDX-License-Identifier: Apache-2.0
 */

#include <nxp/nxp_imx/rt/MIMXRT685SFVKB-pinctrl.h>

&pinctrl {
	pinmux_flexcomm0_usart: pinmux_flexcomm0_usart {
		group0 {
			pinmux = <FC0_RXD_SDA_MOSI_DATA_PIO0_2>;
			input-enable;
			slew-rate = "normal";
			drive-strength = "normal";
		};

		group1 {
			pinmux = <FC0_TXD_SCL_MISO_WS_PIO0_1>;
			slew-rate = "normal";
			drive-strength = "normal";
		};
	};

	pinmux_flexcomm1_i2s: pinmux_flexcomm1_i2s {
		group0 {
			pinmux = <FC1_RXD_SDA_MOSI_DATA_PIO0_9>;
			input-enable;
			slew-rate = "normal";
			drive-strength = "high";
		};
	};

	pinmux_flexcomm2_i2c: pinmux_flexcomm2_i2c {
		group0 {
			pinmux = <FC2_CTS_SDA_SSEL0_PIO0_17>,
				 <FC2_RTS_SCL_SSEL1_PIO0_18>;
			bias-pull-up;
			input-enable;
			slew-rate = "normal";
			drive-strength = "high";
			drive-open-drain;
		};
	};

	pinmux_flexcomm3_i2s: pinmux_flexcomm3_i2s {
		group0 {
			pinmux = <FC3_RXD_SDA_MOSI_DATA_PIO0_23>,
				 <FC3_TXD_SCL_MISO_WS_PIO0_22>,
				 <FC3_SCK_PIO0_21>,
				 <MCLK_PIO1_10>;
			input-enable;
			slew-rate = "normal";
			drive-strength = "high";
		};
	};

	pinmux_flexcomm4_usart: pinmux_flexcomm4_usart {
		group0 {
			pinmux = <FC4_RXD_SDA_MOSI_DATA_PIO0_30>;
			input-enable;
			slew-rate = "normal";
			drive-strength = "normal";
		};

		group1 {
			pinmux = <FC4_TXD_SCL_MISO_WS_PIO0_29>;
			slew-rate = "normal";
			drive-strength = "normal";
		};
	};

	pinmux_flexcomm5_spi: pinmux_flexcomm5_spi {
		group0 {
			pinmux = <FC5_SCK_PIO1_3>,
				 <FC5_TXD_SCL_MISO_WS_PIO1_4>,
				 <FC5_RXD_SDA_MOSI_DATA_PIO1_5>,
				 <FC5_CTS_SDA_SSEL0_PIO1_6>;
			input-enable;
			slew-rate = "normal";
			drive-strength = "normal";
		};
	};

	pinmux_dmic0: pinmux_dmic0 {
		group0 {
			pinmux = <DMIC0_DATA2_3_PIO2_21>, <DMIC0_DATA0_1_PIO2_20>,
				 <DMIC0_CLK0_1_PIO2_16>;
			slew-rate = "normal";
			drive-strength = "normal";
			input-enable;
		};
	};

	pinmux_flexspi: pinmux_flexspi {
		group0 {
			pinmux = <FLEXSPI0B_DATA0_PIO1_11>,
				 <FLEXSPI0B_DATA1_PIO1_12>,
				 <FLEXSPI0B_DATA2_PIO1_13>,
				 <FLEXSPI0B_DATA3_PIO1_14>,
				 <FLEXSPI0B_SCLK_PIO1_29>,
				 <FLEXSPI0B_DATA4_PIO2_17>,
				 <FLEXSPI0B_DATA5_PIO2_18>,
				 <FLEXSPI0B_SS0_N_PIO2_19>,
				 <FLEXSPI0B_DATA6_PIO2_22>,
				 <FLEXSPI0B_DATA7_PIO2_23>;
			input-enable;
			slew-rate = "normal";
			drive-strength = "high";
		};

		group1 {
			pinmux = <GPIO_PIO212_PIO2_12>;
			slew-rate = "normal";
			drive-strength = "normal";
		};
	};

	/*
	 * The current test and sample applications uses a single channel for
	 * testing so we only need to enable the pin for that single use.
	 *
	 * If your application requires more then the mappings are as follows
	 * for the rt685_evk:
	 *
	 * +---------+------+---------+-------+
	 * |  Port#  | ADC  |Schematic|Arduino|
	 * |   pin   | Chn# |         |header |
	 * +---------+------+---------+-------+
	 * | PIO0_5  | CH0A | ADC0_0  | J30.1 |
	 * +---------+------+---------+-------+
	 * | PIO0_6  | CH0B | ADC0_8  | J30.2 |
	 * +---------+------+---------+-------+
	 * | PIO0_12 | CH1A | ADC0_1  |       |
	 * +---------+------+---------+-------+
	 * | PIO0_13 | CH1B | ADC0_9  |       |
	 * +---------+------+---------+-------+
	 * | PIO0_19 | CH2A | ADC0_2  | J30.3 |
	 * +---------+------+---------+-------+
	 * | PIO0_20 | CH2B | ADC0_10 | J30.4 |
	 * +---------+------+---------+-------+
	 * | PIO0_26 | CH3A | ADC0_3  |       |
	 * +---------+------+---------+-------+
	 * | PIO0_27 | CH3B | ADC0_11 |       |
	 * +---------+------+---------+-------+
	 * | PIO1_8  | CH4A | ADC0_4  |       |
	 * +---------+------+---------+-------+
	 * | PIO1_9  | CH4B | ADC0_12 |       |
	 * +---------+------+---------+-------+
	 * | PIO3_23 | CH5A | ADC0_5  |       |
	 * +---------+------+---------+-------+
	 * | PIO3_24 | CH5B | ADC0_13 |       |
	 * +---------+------+---------+-------+
	 *
	 * Per the mimxrt6xx reference manual, The channels 0-5 are analong input.
	 * Optionally, channels 0A through 5A can be paired with channels 0B
	 * through 5B for differential input on their respective ADC channel.
	 *
	 */
	pinmux_lpadc0: pinmux_lpadc0 {
		group0 {
			pinmux = <ADC0_CH0_PIO0_5>,
				 <ADC0_CH8_PIO0_6>;
			slew-rate = "normal";
			drive-strength = "normal";
			nxp,analog-mode;
		};
	};

	pinmux_pmic_i2c: pinmux_pmic_i2c {
		group0 {
			pinmux = <PMIC_I2C_SCL>,
				 <PMIC_I2C_SDA>;
			bias-pull-up;
			input-enable;
			slew-rate = "normal";
			drive-strength = "normal";
			drive-open-drain;
		};
	};

	pinmux_sctimer: pinmux_sctimer {
		group0 {
			pinmux = <SCT0_OUT7_PIO0_27>,
				 <SCT0_OUT0_PIO0_14>,
				 <SCT0_OUT6_PIO0_26>,
				 <SCT0_OUT6_PIO0_31>;
			slew-rate = "normal";
			drive-strength = "normal";
		};
	};

	pinmux_usdhc: pinmux_usdhc {
		group0 {
			pinmux = <SD0_CMD_PIO1_31>,
				 <USDHC0_USDHC_DATA0_PIO2_0>,
				 <USDHC0_USDHC_DATA1_PIO2_1>,
				 <USDHC0_USDHC_DATA2_PIO2_2>,
				 <USDHC0_USDHC_DATA3_PIO2_3>,
				 <GPIO_PIO29_PIO2_9>;
			bias-pull-up;
			input-enable;
			slew-rate = "normal";
			drive-strength = "normal";
		};

		group1 {
			pinmux = <SD0_CLK_PIO1_30>;
			input-enable;
			slew-rate = "normal";
			drive-strength = "normal";
		};

		group2 {
			pinmux = <GPIO_PIO210_PIO2_10>,
				 <GPIO_PIO24_PIO2_4>;
			slew-rate = "normal";
			drive-strength = "normal";
		};
	};

	pinmux_i3c: pinmux_i3c {
		group0 {
			pinmux = <I3C0_SCL_PIO2_29>,
				 <I3C0_SDA_PIO2_30>;
			input-enable;
			slew-rate = "slow";
			drive-strength = "high";
		};

		group1 {
			pinmux = <I3C0_PUR_PIO2_31>;
			slew-rate = "normal";
			drive-strength = "normal";
		};
	};

	pinmux_ctimer2_pwm: pinmux_ctimer2_pwm {
		group0 {
			pinmux = <CTIMER2_MATCH0_PIO0_14>;
			slew-rate = "normal";
			drive-strength = "normal";
		};
	};
};
