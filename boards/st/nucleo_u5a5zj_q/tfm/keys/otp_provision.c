/**
 ******************************************************************************
 *
 * @file    otp_provision.c
 * @author  MCD Application Team
 * @brief   File provisionning otp value
 *
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020-2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 * <h2><center>&copy; Copyright (c) 2022 Cypress Semiconductor Corporation
 * (an Infineon company) or an affiliate of Cypress Semiconductor Corporation.
 * All rights reserved.</center></h2>
 * <h2><center>&copy; Copyright (c) 2025 Leica Geosystem AG.
 * All rights reserved.</center></h2>
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
#include "template/flash_otp_nv_counters_backend.h"
#include "tfm_plat_otp.h"
#include "tfm_attest_hal.h"
#include "psa/crypto.h"

/* This file is generated by create_provisioning_data.py */

#define INT2LE(A) (uint8_t)(A & 0xFF),         \
		  (uint8_t)((A >> 8) & 0xFF),  \
		  (uint8_t)((A >> 16) & 0xFF), \
		  (uint8_t)((A >> 24) & 0xFF)

#define INT64NULL 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  \
		  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  \
		  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  \
		  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  \
		  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  \
		  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  \
		  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  \
		  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0

#if defined(__ICCARM__)
	__root
#endif

#if defined(__ICCARM__)
	#pragma default_function_attributes = @ ".BL2_OTP_Const"
#else
	__attribute__((section(".BL2_OTP_Const")))
#endif /* __ICCARM__ */

const struct flash_otp_nv_counters_region_t otp_stm_provision = {
	.init_value = OTP_NV_COUNTERS_INITIALIZED,

	/* HUK */
	.huk = {
		0xc4, 0xc2, 0xc0, 0xc9, 0xdd, 0x04, 0xc1, 0x53,
		0xb2, 0x52, 0x15, 0x53, 0x2d, 0x78, 0xa0, 0xf5,
		0xec, 0x43, 0x4f, 0xa4, 0xa3, 0x56, 0x47, 0x93,
		0x6d, 0x38, 0x87, 0x2d, 0x28, 0xbb, 0x1d, 0xa5
	},

	/* IAK */
	.iak = {
		0x01, 0x10, 0x6d, 0x97, 0x21, 0x67, 0x87, 0xd7,
		0x7c, 0xf0, 0x38, 0x5e, 0xeb, 0x08, 0x20, 0x21,
		0x59, 0x7d, 0xab, 0x32, 0xde, 0x2a, 0x56, 0x0b,
		0xe8, 0xcf, 0x35, 0x94, 0x37, 0x74, 0xbf, 0x98
	},

	/* IAK len */
	.iak_len = {INT2LE(32)},

#ifdef SYMMETRIC_INITIAL_ATTESTATION
	/* IAK type */
	.iak_type = {INT2LE(PSA_ALG_HMAC(PSA_ALG_SHA_256))},
#else
	/* IAK type */
	.iak_type = {INT2LE(PSA_ECC_FAMILY_SECP_R1)},
#endif /* SYMMETRIC_INITIAL_ATTESTATION */

	/* IAK id [32] */
	.iak_id = {'Z', 'e', 'p', 'h', 'y', 'r', ' ', 't', 'r', 'u', 's', 't', 'e', 'd', '-',
		   'f', 'i', 'r', 'm', 'w', 'a', 'r', 'e', '-', 'm', '\0'},

	/* boot seed */
	.boot_seed = {
		0x5c, 0xff, 0x23, 0xde, 0x30, 0xc4, 0x1c, 0x2a,
		0x0a, 0xc5, 0x27, 0xb3, 0xbc, 0xcf, 0x62, 0xf0,
		0x5d, 0x51, 0xbc, 0x18, 0xdd, 0x37, 0x39, 0x3f,
		0x4c, 0x86, 0x6d, 0x40, 0xfb, 0x8e, 0x7e, 0x2d
	},

	.lcs = {INT2LE(PLAT_OTP_LCS_SECURED)},

	/* implementation id */
	.implementation_id = {
		0xdd, 0x8d, 0x94, 0x26, 0xd5, 0xb8, 0xba, 0x40,
		0x3d, 0x6d, 0x3d, 0x27, 0x32, 0xed, 0x54, 0x2a,
		0xf7, 0x91, 0x1c, 0x67, 0x96, 0x1a, 0x90, 0x96,
		0xf1, 0xfd, 0xa7, 0x94, 0x56, 0xb7, 0x40, 0xbe
	},

	/* certification reference */
	.cert_ref = {
		'z', 'e', 'p', 'h', 'y', 'r', 'R', 'T', 'O', 'S', ' ',
		'T', 'F', '-', 'M', '2', '2', '0'
	},

	/* verification_service_url */
	.verification_service_url = "www.trustedfirmware.org",

	/* attestation_profile_definition */
	.profile_definition = "PSA_IOT_PROFILE_1",

	.bl2_rotpk_0 = {
		0xce, 0x37, 0x7c, 0x05, 0xee, 0x7b, 0x7c, 0x35,
		0xbf, 0x24, 0xdb, 0x3d, 0xd2, 0x91, 0x46, 0x56,
		0x8a, 0x85, 0xe8, 0x83, 0x79, 0xb4, 0x97, 0x8c,
		0xd2, 0xf3, 0xe5, 0x92, 0x7a, 0x79, 0xdf, 0x38
	},

	.bl2_rotpk_1 = {
		0xd3, 0x74, 0x82, 0x85, 0xbd, 0x72, 0x82, 0x0a,
		0x32, 0xe4, 0x28, 0x9c, 0x69, 0xbe, 0xe3, 0x7f,
		0x2f, 0x9b, 0xbe, 0xb9, 0xc7, 0x8e, 0x0b, 0x99,
		0x13, 0x96, 0x8e, 0x17, 0xc9, 0x52, 0xe1, 0xb9
	},

	.bl2_nv_counter_0 = { INT64NULL },
	.bl2_nv_counter_1 = { INT64NULL },
	.bl2_nv_counter_2 = { INT64NULL },

#if (MCUBOOT_IMAGE_NUMBER > 2)
	.bl2_rotpk_2 = {

	},
#else
	.bl2_rotpk_2 =  {
		0xd3, 0x74, 0x82, 0x85, 0xbd, 0x72, 0x82, 0x0a,
		0x32, 0xe4, 0x28, 0x9c, 0x69, 0xbe, 0xe3, 0x7f,
		0x2f, 0x9b, 0xbe, 0xb9, 0xc7, 0x8e, 0x0b, 0x99,
		0x13, 0x96, 0x8e, 0x17, 0xc9, 0x52, 0xe1, 0xb9
	},
#endif /* MCUBOOT_IMAGE_NUMBER > 2 */
	/* Entropy seed */
	.entropy_seed = {
		0x60, 0xc6, 0x08, 0x59, 0x60, 0x5e, 0xe2, 0x8a,
		0xa4, 0x87, 0x23, 0xf7, 0xec, 0xca, 0xb0, 0xc2,
		0xf7, 0x22, 0x25, 0x3a, 0x75, 0x84, 0xdb, 0x82,
		0x01, 0x9d, 0x73, 0x28, 0xca, 0x94, 0x8a, 0xd9,
		0x0c, 0x13, 0x42, 0xd9, 0x31, 0x0f, 0x90, 0x34,
		0x95, 0x2c, 0x27, 0x78, 0xe7, 0xcd, 0x05, 0x53,
		0xfb, 0xa2, 0x2d, 0x41, 0xb9, 0x52, 0xab, 0x8d,
		0xac, 0x0b, 0x55, 0xb1, 0x87, 0x66, 0x1f, 0xa6
	},
#ifdef PLATFORM_DEFAULT_NV_COUNTERS
	.flash_nv_counters = { 0x0, 0x0, 0x0 },
#endif
	.swap_count =  1
};
