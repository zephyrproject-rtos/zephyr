//! Zephyr Kernel Objects
//!
//! Zephyr has a concept of a 'kernel object' that is handled a bit magically.  In kernel mode
//! threads, these are just pointers to the data structures that Zephyr uses to manage that item.
//! In userspace, they are still pointers, but those data structures aren't accessible to the
//! thread.  When making syscalls, the kernel validates that the objects are both valid kernel
//! objects and that the are supposed to be accessible to this thread.
//!
//! In many Zephyr apps, the kernel objects in the app are defined as static, using special macros.
//! These macros make sure that the objects get registered so that they are accessible to userspace
//! (at least after that access is granted).
//!
//! There are also kernel objects that are synthesized as part of the build.  Most notably, there
//! are ones generated by the device tree.
//!
//! There are some funny rules about references and mutable references to memory that is
//! inaccessible.  Basically, it is never valid to have a reference to something that isn't
//! accessible.  However, we can have `*mut ktype` or `*const ktype`.  In Rust, having multiple
//! `*mut` pointers live is undefined behavior.  Zephyr makes extensive use of shared mutable
//! pointers (or sometimes immutable).  We will not dereference these in Rust code, but merely pass
//! them to APIs in Zephyr that require them.
//!
//! Most kernel objects use mutable pointers, and it makes sense to require the wrapper structure
//! to be mutable to these accesses.  There a few cases, mostly generated ones that live in
//! read-only memory, notably device instances, that need const pointers.  These will be
//! represented by a separate wrapper.
//!
//! TODO: Document how the wrappers work once we figure out how to implement them.

use core::{cell::UnsafeCell, mem};

#[cfg(CONFIG_RUST_CHECK_KOBJ_INIT)]
use core::{sync::atomic::{AtomicUsize, Ordering}};

/// A kernel object represented statically in Rust code.  These should not be declared directly by
/// the user, as they generally need linker decorations to be properly registered in Zephyr as
/// kernel objects.  The object has the underlying Zephyr type T, and the wrapper type W.
/// TODO: Handling const-defined alignment for these.
pub struct StaticKernelObject<T> {
    /// The underlying zephyr kernel object.
    value: UnsafeCell<T>,
    /// Initialization status of this object.  Most objects will start uninitialized and be
    /// initialized manually.
    #[cfg(CONFIG_RUST_CHECK_KOBJ_INIT)]
    init: AtomicUsize,
}

/// These raw kernel objects have a way to get the raw pointer out.
pub trait KobjGet<T> {
    fn get_ptr(&self) -> *mut T;
}

impl<T> KobjGet<T> for StaticKernelObject<T> {
    fn get_ptr(&self) -> *mut T {
        self.value.get()
    }
}

pub const KOBJ_UNINITIALIZED: usize = 0;
pub const KOBJ_INITING: usize = 1;
pub const KOBJ_INITIALIZED: usize = 2;

impl<T> StaticKernelObject<T> {
    /// Construct an empty of these objects, with the zephyr data zero-filled.  This is safe in the
    /// sense that Zephyr we track the initialization, and they start in the uninitialized state.
    pub const fn new() -> StaticKernelObject<T> {
        StaticKernelObject {
            value: unsafe { mem::zeroed() },
            #[cfg(CONFIG_RUST_CHECK_KOBJ_INIT)]
            init: AtomicUsize::new(KOBJ_UNINITIALIZED),
        }
    }

    /// An initialization helper.  Runs the code in `f` if the object is uninitialized. Panics if
    /// the initialization state is incorrect.
    #[cfg(CONFIG_RUST_CHECK_KOBJ_INIT)]
    pub fn init_help<R, F: FnOnce(*mut T) -> R>(&self, f: F) -> R {
        if let Err(_) = self.init.compare_exchange(
            KOBJ_UNINITIALIZED,
            KOBJ_INITING,
            Ordering::AcqRel,
            Ordering::Acquire)
        {
            panic!("Duplicate kobject initialization");
        }
        let result = f(self.get_ptr());
        self.init.store(KOBJ_INITIALIZED, Ordering::Release);
        result
    }

    #[cfg(not(CONFIG_RUST_CHECK_KOBJ_INIT))]
    pub fn init_help<R, F: FnOnce(*mut T) -> R>(&self, f: F) -> R {
        f(self.get_ptr())
    }
}

/// Kernel object wrappers implement this trait so construct themselves out of the underlying
/// pointer.
pub trait KobjInit<T, W> where Self: KobjGet<T> + Sized {
    // The implementation provides the wrapper to build the wrapper object.
    fn get(&self) -> W {
        let ptr = self.get_ptr();
        Self::wrap(ptr)
    }

    // This constructs the wrapper for 'get'.
    fn wrap(ptr: *mut T) -> W;
}
