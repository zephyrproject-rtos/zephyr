/*
** ###################################################################
**     Compilers:           Keil ARM C/C++ Compiler
**                          Freescale C/C++ for Embedded ARM
**                          GNU C Compiler
**                          GNU C Compiler - CodeSourcery Sourcery G++
**                          IAR ANSI C/C++ Compiler for ARM
**
**     Reference manual:    MKW40Z160RM, Rev. 1.1, 4/2015
**     Version:             rev. 1.2, 2015-05-07
**     Build:               b150713
**
**     Abstract:
**         Extension to the CMSIS register access layer header.
**
**     Copyright (c) 2015 Freescale Semiconductor, Inc.
**     All rights reserved.
**
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
**     http:                 www.freescale.com
**     mail:                 support@freescale.com
**
**     Revisions:
**     - rev. 1.0 (2014-07-17)
**         Initial version.
**     - rev. 1.1 (2015-03-05)
**         Update with reference manual rev 1.0
**     - rev. 1.2 (2015-05-07)
**         Update with reference manual rev 1.1
**
** ###################################################################
*/

/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __MKW40Z4_EXTENSION_H__
#define __MKW40Z4_EXTENSION_H__

#include "MKW40Z4.h"
#include "fsl_bitaccess.h"

#if defined(__IAR_SYSTEMS_ICC__)
  /*
   * Suppress "Error[Pm008]: sections of code should not be 'commented out' (MISRA C 2004 rule 2.4)"
   * as some register descriptions contain code examples
   */
  #pragma diag_suppress=pm008
#endif

/*
 * MKW40Z4 ADC
 *
 * Analog-to-Digital Converter
 *
 * Registers defined in this header file:
 * - ADC_SC1 - ADC Status and Control Registers 1
 * - ADC_CFG1 - ADC Configuration Register 1
 * - ADC_CFG2 - ADC Configuration Register 2
 * - ADC_R - ADC Data Result Register
 * - ADC_CV1 - Compare Value Registers
 * - ADC_CV2 - Compare Value Registers
 * - ADC_SC2 - Status and Control Register 2
 * - ADC_SC3 - Status and Control Register 3
 * - ADC_OFS - ADC Offset Correction Register
 * - ADC_PG - ADC Plus-Side Gain Register
 * - ADC_MG - ADC Minus-Side Gain Register
 * - ADC_CLPD - ADC Plus-Side General Calibration Value Register
 * - ADC_CLPS - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP4 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP3 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP2 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP1 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP0 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLMD - ADC Minus-Side General Calibration Value Register
 * - ADC_CLMS - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM4 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM3 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM2 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM1 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM0 - ADC Minus-Side General Calibration Value Register
 */

#define ADC_INSTANCE_COUNT (1U) /*!< Number of instances of the ADC module. */
#define ADC0_IDX (0U) /*!< Instance number for ADC0. */

/*******************************************************************************
 * ADC_SC1 - ADC Status and Control Registers 1
 ******************************************************************************/

/*!
 * @brief ADC_SC1 - ADC Status and Control Registers 1 (RW)
 *
 * Reset value: 0x0000001FU
 *
 * SC1A is used for both software and hardware trigger modes of operation. To
 * allow sequential conversions of the ADC to be triggered by internal peripherals,
 * the ADC can have more than one status and control register: one for each
 * conversion. The SC1B-SC1n registers indicate potentially multiple SC1 registers
 * for use only in hardware trigger mode. See the chip configuration information
 * about the number of SC1n registers specific to this device. The SC1n registers
 * have identical fields, and are used in a "ping-pong" approach to control ADC
 * operation. At any one point in time, only one of the SC1n registers is actively
 * controlling ADC conversions. Updating SC1A while SC1n is actively controlling
 * a conversion is allowed, and vice-versa for any of the SC1n registers specific
 * to this MCU. Writing SC1A while SC1A is actively controlling a conversion
 * aborts the current conversion. In Software Trigger mode, when SC2[ADTRG]=0,
 * writes to SC1A subsequently initiate a new conversion, if SC1[ADCH] contains a
 * value other than all 1s (module disabled). Writing any of the SC1n registers while
 * that specific SC1n register is actively controlling a conversion aborts the
 * current conversion. None of the SC1B-SC1n registers are used for software
 * trigger operation and therefore writes to the SC1B-SC1n registers do not initiate a
 * new conversion.
 */
/*!
 * @name Constants and macros for entire ADC_SC1 register
 */
/*@{*/
#define ADC_RD_SC1(base, index)  (ADC_SC1_REG(base, index))
#define ADC_WR_SC1(base, index, value) (ADC_SC1_REG(base, index) = (value))
#define ADC_RMW_SC1(base, index, mask, value) (ADC_WR_SC1(base, index, (ADC_RD_SC1(base, index) & ~(mask)) | (value)))
#define ADC_SET_SC1(base, index, value) (BME_OR32(&ADC_SC1_REG(base, index), (uint32_t)(value)))
#define ADC_CLR_SC1(base, index, value) (BME_AND32(&ADC_SC1_REG(base, index), (uint32_t)(~(value))))
#define ADC_TOG_SC1(base, index, value) (BME_XOR32(&ADC_SC1_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC1 bitfields
 */

/*!
 * @name Register ADC_SC1, field ADCH[4:0] (RW)
 *
 * Selects one of the input channels. The input channel decode depends on the
 * value of DIFF. DAD0-DAD3 are associated with the input pin pairs DADPx and
 * DADMx. Some of the input channel options in the bitfield-setting descriptions might
 * not be available for your device. For the actual ADC channel assignments for
 * your device, see the Chip Configuration details. The successive approximation
 * converter subsystem is turned off when the channel select bits are all set,
 * that is, ADCH = 11111. This feature allows explicit disabling of the ADC and
 * isolation of the input channel from all sources. Terminating continuous
 * conversions this way prevents an additional single conversion from being performed. It
 * is not necessary to set ADCH to all 1s to place the ADC in a low-power state
 * when continuous conversions are not enabled because the module automatically
 * enters a low-power state when a conversion completes.
 *
 * Values:
 * - 0b00000 - When DIFF=0, DADP0 is selected as input; when DIFF=1, DAD0 is
 *     selected as input.
 * - 0b00001 - When DIFF=0, DADP1 is selected as input; when DIFF=1, DAD1 is
 *     selected as input.
 * - 0b00010 - When DIFF=0, DADP2 is selected as input; when DIFF=1, DAD2 is
 *     selected as input.
 * - 0b00011 - When DIFF=0, DADP3 is selected as input; when DIFF=1, DAD3 is
 *     selected as input.
 * - 0b00100 - When DIFF=0, AD4 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b00101 - When DIFF=0, AD5 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b00110 - When DIFF=0, AD6 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b00111 - When DIFF=0, AD7 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01000 - When DIFF=0, AD8 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01001 - When DIFF=0, AD9 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01010 - When DIFF=0, AD10 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01011 - When DIFF=0, AD11 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01100 - When DIFF=0, AD12 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01101 - When DIFF=0, AD13 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01110 - When DIFF=0, AD14 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01111 - When DIFF=0, AD15 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10000 - When DIFF=0, AD16 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10001 - When DIFF=0, AD17 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10010 - When DIFF=0, AD18 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10011 - When DIFF=0, AD19 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10100 - When DIFF=0, AD20 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10101 - When DIFF=0, AD21 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10110 - When DIFF=0, AD22 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10111 - When DIFF=0, AD23 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b11000 - Reserved.
 * - 0b11001 - Reserved.
 * - 0b11010 - When DIFF=0, Temp Sensor (single-ended) is selected as input;
 *     when DIFF=1, Temp Sensor (differential) is selected as input.
 * - 0b11011 - When DIFF=0, Bandgap (single-ended) is selected as input; when
 *     DIFF=1, Bandgap (differential) is selected as input.
 * - 0b11100 - Reserved.
 * - 0b11101 - When DIFF=0,VREFSH is selected as input; when DIFF=1, -VREFSH
 *     (differential) is selected as input. Voltage reference selected is determined
 *     by SC2[REFSEL].
 * - 0b11110 - When DIFF=0,VREFSL is selected as input; when DIFF=1, it is
 *     reserved. Voltage reference selected is determined by SC2[REFSEL].
 * - 0b11111 - Module is disabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_ADCH field. */
#define ADC_RD_SC1_ADCH(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_ADCH_MASK) >> ADC_SC1_ADCH_SHIFT)
#define ADC_BRD_SC1_ADCH(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_ADCH_SHIFT, ADC_SC1_ADCH_WIDTH))

/*! @brief Set the ADCH field to a new value. */
#define ADC_WR_SC1_ADCH(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_ADCH_MASK, ADC_SC1_ADCH(value)))
#define ADC_BWR_SC1_ADCH(base, index, value) (BME_BFI32(&ADC_SC1_REG(base, index), ((uint32_t)(value) << ADC_SC1_ADCH_SHIFT), ADC_SC1_ADCH_SHIFT, ADC_SC1_ADCH_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC1, field DIFF[5] (RW)
 *
 * Configures the ADC to operate in differential mode. When enabled, this mode
 * automatically selects from the differential channels, and changes the
 * conversion algorithm and the number of cycles to complete a conversion.
 *
 * Values:
 * - 0b0 - Single-ended conversions and input channels are selected.
 * - 0b1 - Differential conversions and input channels are selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_DIFF field. */
#define ADC_RD_SC1_DIFF(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_DIFF_MASK) >> ADC_SC1_DIFF_SHIFT)
#define ADC_BRD_SC1_DIFF(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_DIFF_SHIFT, ADC_SC1_DIFF_WIDTH))

/*! @brief Set the DIFF field to a new value. */
#define ADC_WR_SC1_DIFF(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_DIFF_MASK, ADC_SC1_DIFF(value)))
#define ADC_BWR_SC1_DIFF(base, index, value) (BME_BFI32(&ADC_SC1_REG(base, index), ((uint32_t)(value) << ADC_SC1_DIFF_SHIFT), ADC_SC1_DIFF_SHIFT, ADC_SC1_DIFF_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC1, field AIEN[6] (RW)
 *
 * Enables conversion complete interrupts. When COCO becomes set while the
 * respective AIEN is high, an interrupt is asserted.
 *
 * Values:
 * - 0b0 - Conversion complete interrupt is disabled.
 * - 0b1 - Conversion complete interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_AIEN field. */
#define ADC_RD_SC1_AIEN(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_AIEN_MASK) >> ADC_SC1_AIEN_SHIFT)
#define ADC_BRD_SC1_AIEN(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_AIEN_SHIFT, ADC_SC1_AIEN_WIDTH))

/*! @brief Set the AIEN field to a new value. */
#define ADC_WR_SC1_AIEN(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_AIEN_MASK, ADC_SC1_AIEN(value)))
#define ADC_BWR_SC1_AIEN(base, index, value) (BME_BFI32(&ADC_SC1_REG(base, index), ((uint32_t)(value) << ADC_SC1_AIEN_SHIFT), ADC_SC1_AIEN_SHIFT, ADC_SC1_AIEN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC1, field COCO[7] (RO)
 *
 * This is a read-only field that is set each time a conversion is completed
 * when the compare function is disabled, or SC2[ACFE]=0 and the hardware average
 * function is disabled, or SC3[AVGE]=0. When the compare function is enabled, or
 * SC2[ACFE]=1, COCO is set upon completion of a conversion only if the compare
 * result is true. When the hardware average function is enabled, or SC3[AVGE]=1,
 * COCO is set upon completion of the selected number of conversions (determined
 * by AVGS). COCO in SC1A is also set at the completion of a calibration sequence.
 * COCO is cleared when the respective SC1n register is written or when the
 * respective Rn register is read.
 *
 * Values:
 * - 0b0 - Conversion is not completed.
 * - 0b1 - Conversion is completed.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_COCO field. */
#define ADC_RD_SC1_COCO(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_COCO_MASK) >> ADC_SC1_COCO_SHIFT)
#define ADC_BRD_SC1_COCO(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_COCO_SHIFT, ADC_SC1_COCO_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CFG1 - ADC Configuration Register 1
 ******************************************************************************/

/*!
 * @brief ADC_CFG1 - ADC Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The configuration Register 1 (CFG1) selects the mode of operation, clock
 * source, clock divide, and configuration for low power or long sample time.
 */
/*!
 * @name Constants and macros for entire ADC_CFG1 register
 */
/*@{*/
#define ADC_RD_CFG1(base)        (ADC_CFG1_REG(base))
#define ADC_WR_CFG1(base, value) (ADC_CFG1_REG(base) = (value))
#define ADC_RMW_CFG1(base, mask, value) (ADC_WR_CFG1(base, (ADC_RD_CFG1(base) & ~(mask)) | (value)))
#define ADC_SET_CFG1(base, value) (BME_OR32(&ADC_CFG1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CFG1(base, value) (BME_AND32(&ADC_CFG1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CFG1(base, value) (BME_XOR32(&ADC_CFG1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG1 bitfields
 */

/*!
 * @name Register ADC_CFG1, field ADICLK[1:0] (RW)
 *
 * Selects the input clock source to generate the internal clock, ADCK. Note
 * that when the ADACK clock source is selected, it is not required to be active
 * prior to conversion start. When it is selected and it is not active prior to a
 * conversion start, when CFG2[ADACKEN]=0, the asynchronous clock is activated at
 * the start of a conversion and deactivated when conversions are terminated. In
 * this case, there is an associated clock startup delay each time the clock
 * source is re-activated.
 *
 * Values:
 * - 0b00 - Bus clock
 * - 0b01 - Bus clock divided by 2(BUSCLK/2)
 * - 0b10 - Alternate clock (ALTCLK)
 * - 0b11 - Asynchronous clock (ADACK)
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADICLK field. */
#define ADC_RD_CFG1_ADICLK(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADICLK_MASK) >> ADC_CFG1_ADICLK_SHIFT)
#define ADC_BRD_CFG1_ADICLK(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADICLK_SHIFT, ADC_CFG1_ADICLK_WIDTH))

/*! @brief Set the ADICLK field to a new value. */
#define ADC_WR_CFG1_ADICLK(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADICLK_MASK, ADC_CFG1_ADICLK(value)))
#define ADC_BWR_CFG1_ADICLK(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADICLK_SHIFT), ADC_CFG1_ADICLK_SHIFT, ADC_CFG1_ADICLK_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field MODE[3:2] (RW)
 *
 * Selects the ADC resolution mode.
 *
 * Values:
 * - 0b00 - When DIFF=0:It is single-ended 8-bit conversion; when DIFF=1, it is
 *     differential 9-bit conversion with 2's complement output.
 * - 0b01 - When DIFF=0:It is single-ended 12-bit conversion ; when DIFF=1, it
 *     is differential 13-bit conversion with 2's complement output.
 * - 0b10 - When DIFF=0:It is single-ended 10-bit conversion. ; when DIFF=1, it
 *     is differential 11-bit conversion with 2's complement output
 * - 0b11 - When DIFF=0:It is single-ended 16-bit conversion..; when DIFF=1, it
 *     is differential 16-bit conversion with 2's complement output
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_MODE field. */
#define ADC_RD_CFG1_MODE(base) ((ADC_CFG1_REG(base) & ADC_CFG1_MODE_MASK) >> ADC_CFG1_MODE_SHIFT)
#define ADC_BRD_CFG1_MODE(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_MODE_SHIFT, ADC_CFG1_MODE_WIDTH))

/*! @brief Set the MODE field to a new value. */
#define ADC_WR_CFG1_MODE(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_MODE_MASK, ADC_CFG1_MODE(value)))
#define ADC_BWR_CFG1_MODE(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_MODE_SHIFT), ADC_CFG1_MODE_SHIFT, ADC_CFG1_MODE_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLSMP[4] (RW)
 *
 * Selects between different sample times based on the conversion mode selected.
 * This field adjusts the sample period to allow higher impedance inputs to be
 * accurately sampled or to maximize conversion speed for lower impedance inputs.
 * Longer sample times can also be used to lower overall power consumption if
 * continuous conversions are enabled and high conversion rates are not required.
 * When ADLSMP=1, the long sample time select bits, (ADLSTS[1:0]), can select the
 * extent of the long sample time.
 *
 * Values:
 * - 0b0 - Short sample time.
 * - 0b1 - Long sample time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADLSMP field. */
#define ADC_RD_CFG1_ADLSMP(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADLSMP_MASK) >> ADC_CFG1_ADLSMP_SHIFT)
#define ADC_BRD_CFG1_ADLSMP(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADLSMP_SHIFT, ADC_CFG1_ADLSMP_WIDTH))

/*! @brief Set the ADLSMP field to a new value. */
#define ADC_WR_CFG1_ADLSMP(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADLSMP_MASK, ADC_CFG1_ADLSMP(value)))
#define ADC_BWR_CFG1_ADLSMP(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADLSMP_SHIFT), ADC_CFG1_ADLSMP_SHIFT, ADC_CFG1_ADLSMP_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADIV[6:5] (RW)
 *
 * Selects the divide ratio used by the ADC to generate the internal clock ADCK.
 *
 * Values:
 * - 0b00 - The divide ratio is 1 and the clock rate is input clock.
 * - 0b01 - The divide ratio is 2 and the clock rate is (input clock)/2.
 * - 0b10 - The divide ratio is 4 and the clock rate is (input clock)/4.
 * - 0b11 - The divide ratio is 8 and the clock rate is (input clock)/8.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADIV field. */
#define ADC_RD_CFG1_ADIV(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADIV_MASK) >> ADC_CFG1_ADIV_SHIFT)
#define ADC_BRD_CFG1_ADIV(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADIV_SHIFT, ADC_CFG1_ADIV_WIDTH))

/*! @brief Set the ADIV field to a new value. */
#define ADC_WR_CFG1_ADIV(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADIV_MASK, ADC_CFG1_ADIV(value)))
#define ADC_BWR_CFG1_ADIV(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADIV_SHIFT), ADC_CFG1_ADIV_SHIFT, ADC_CFG1_ADIV_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLPC[7] (RW)
 *
 * Controls the power configuration of the successive approximation converter.
 * This optimizes power consumption when higher sample rates are not required.
 *
 * Values:
 * - 0b0 - Normal power configuration.
 * - 0b1 - Low-power configuration. The power is reduced at the expense of
 *     maximum clock speed.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADLPC field. */
#define ADC_RD_CFG1_ADLPC(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADLPC_MASK) >> ADC_CFG1_ADLPC_SHIFT)
#define ADC_BRD_CFG1_ADLPC(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADLPC_SHIFT, ADC_CFG1_ADLPC_WIDTH))

/*! @brief Set the ADLPC field to a new value. */
#define ADC_WR_CFG1_ADLPC(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADLPC_MASK, ADC_CFG1_ADLPC(value)))
#define ADC_BWR_CFG1_ADLPC(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADLPC_SHIFT), ADC_CFG1_ADLPC_SHIFT, ADC_CFG1_ADLPC_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CFG2 - ADC Configuration Register 2
 ******************************************************************************/

/*!
 * @brief ADC_CFG2 - ADC Configuration Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Configuration Register 2 (CFG2) selects the special high-speed configuration
 * for very high speed conversions and selects the long sample time duration
 * during long sample mode.
 */
/*!
 * @name Constants and macros for entire ADC_CFG2 register
 */
/*@{*/
#define ADC_RD_CFG2(base)        (ADC_CFG2_REG(base))
#define ADC_WR_CFG2(base, value) (ADC_CFG2_REG(base) = (value))
#define ADC_RMW_CFG2(base, mask, value) (ADC_WR_CFG2(base, (ADC_RD_CFG2(base) & ~(mask)) | (value)))
#define ADC_SET_CFG2(base, value) (BME_OR32(&ADC_CFG2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CFG2(base, value) (BME_AND32(&ADC_CFG2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CFG2(base, value) (BME_XOR32(&ADC_CFG2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG2 bitfields
 */

/*!
 * @name Register ADC_CFG2, field ADLSTS[1:0] (RW)
 *
 * Selects between the extended sample times when long sample time is selected,
 * that is, when CFG1[ADLSMP]=1. This allows higher impedance inputs to be
 * accurately sampled or to maximize conversion speed for lower impedance inputs.
 * Longer sample times can also be used to lower overall power consumption when
 * continuous conversions are enabled if high conversion rates are not required.
 *
 * Values:
 * - 0b00 - Default longest sample time; 20 extra ADCK cycles; 24 ADCK cycles
 *     total.
 * - 0b01 - 12 extra ADCK cycles; 16 ADCK cycles total sample time.
 * - 0b10 - 6 extra ADCK cycles; 10 ADCK cycles total sample time.
 * - 0b11 - 2 extra ADCK cycles; 6 ADCK cycles total sample time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADLSTS field. */
#define ADC_RD_CFG2_ADLSTS(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADLSTS_MASK) >> ADC_CFG2_ADLSTS_SHIFT)
#define ADC_BRD_CFG2_ADLSTS(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_ADLSTS_SHIFT, ADC_CFG2_ADLSTS_WIDTH))

/*! @brief Set the ADLSTS field to a new value. */
#define ADC_WR_CFG2_ADLSTS(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADLSTS_MASK, ADC_CFG2_ADLSTS(value)))
#define ADC_BWR_CFG2_ADLSTS(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_ADLSTS_SHIFT), ADC_CFG2_ADLSTS_SHIFT, ADC_CFG2_ADLSTS_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADHSC[2] (RW)
 *
 * Configures the ADC for very high-speed operation. The conversion sequence is
 * altered with 2 ADCK cycles added to the conversion time to allow higher speed
 * conversion clocks.
 *
 * Values:
 * - 0b0 - Normal conversion sequence selected.
 * - 0b1 - High-speed conversion sequence selected with 2 additional ADCK cycles
 *     to total conversion time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADHSC field. */
#define ADC_RD_CFG2_ADHSC(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADHSC_MASK) >> ADC_CFG2_ADHSC_SHIFT)
#define ADC_BRD_CFG2_ADHSC(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_ADHSC_SHIFT, ADC_CFG2_ADHSC_WIDTH))

/*! @brief Set the ADHSC field to a new value. */
#define ADC_WR_CFG2_ADHSC(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADHSC_MASK, ADC_CFG2_ADHSC(value)))
#define ADC_BWR_CFG2_ADHSC(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_ADHSC_SHIFT), ADC_CFG2_ADHSC_SHIFT, ADC_CFG2_ADHSC_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADACKEN[3] (RW)
 *
 * Enables the asynchronous clock source and the clock source output regardless
 * of the conversion and status of CFG1[ADICLK]. Based on MCU configuration, the
 * asynchronous clock may be used by other modules. See chip configuration
 * information. Setting this field allows the clock to be used even while the ADC is
 * idle or operating from a different clock source. Also, latency of initiating a
 * single or first-continuous conversion with the asynchronous clock selected is
 * reduced because the ADACK clock is already operational.
 *
 * Values:
 * - 0b0 - Asynchronous clock output disabled; Asynchronous clock is enabled
 *     only if selected by ADICLK and a conversion is active.
 * - 0b1 - Asynchronous clock and clock output is enabled regardless of the
 *     state of the ADC.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADACKEN field. */
#define ADC_RD_CFG2_ADACKEN(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADACKEN_MASK) >> ADC_CFG2_ADACKEN_SHIFT)
#define ADC_BRD_CFG2_ADACKEN(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_ADACKEN_SHIFT, ADC_CFG2_ADACKEN_WIDTH))

/*! @brief Set the ADACKEN field to a new value. */
#define ADC_WR_CFG2_ADACKEN(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADACKEN_MASK, ADC_CFG2_ADACKEN(value)))
#define ADC_BWR_CFG2_ADACKEN(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_ADACKEN_SHIFT), ADC_CFG2_ADACKEN_SHIFT, ADC_CFG2_ADACKEN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG2, field MUXSEL[4] (RW)
 *
 * Changes the ADC mux setting to select between alternate sets of ADC channels.
 *
 * Values:
 * - 0b0 - ADxxa channels are selected.
 * - 0b1 - ADxxb channels are selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_MUXSEL field. */
#define ADC_RD_CFG2_MUXSEL(base) ((ADC_CFG2_REG(base) & ADC_CFG2_MUXSEL_MASK) >> ADC_CFG2_MUXSEL_SHIFT)
#define ADC_BRD_CFG2_MUXSEL(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_MUXSEL_SHIFT, ADC_CFG2_MUXSEL_WIDTH))

/*! @brief Set the MUXSEL field to a new value. */
#define ADC_WR_CFG2_MUXSEL(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_MUXSEL_MASK, ADC_CFG2_MUXSEL(value)))
#define ADC_BWR_CFG2_MUXSEL(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_MUXSEL_SHIFT), ADC_CFG2_MUXSEL_SHIFT, ADC_CFG2_MUXSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_R - ADC Data Result Register
 ******************************************************************************/

/*!
 * @brief ADC_R - ADC Data Result Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The data result registers (Rn) contain the result of an ADC conversion of the
 * channel selected by the corresponding status and channel control register
 * (SC1A:SC1n). For every status and channel control register, there is a
 * corresponding data result register. Final result value stored in the data result
 * register (R) will include the conversion result whose raw result is affected by a
 * shift value that varies on mode configurations (see the table below), the OFS
 * offset value, CLP/CLPM calibration values, and a factor of 1/32 (0x0800) that
 * gets added upon certain conditions. Final conversion equation result is: Conv.
 * Result = Raw conv. result (RCR) + shift - OFS - sum(CLPx) + sum(CLMx) - 0x0800 +
 * CLPD RCR = Plus-side conversion - Minus-side conversion In equation above,
 * the sum of CLPx does not include CLPD value and CLMD never has any affect on
 * final conversion result. The factor of 0x0800 only gets subtracted only if plus
 * compare output is a logic 1 after completion of minus-side conversion and prior
 * to start of plus-side conversion. Shift values Mode Shift value 00 0x0040 01
 * 0x0004 10 0x0010 11 0x0000 Unused bits in R n are cleared in unsigned
 * right-aligned modes and carry the sign bit (MSB) in sign-extended 2's complement
 * modes. For example, when configured for 10-bit single-ended mode, D[15:10] are
 * cleared. When configured for 11-bit differential mode, D[15:10] carry the sign
 * bit, that is, bit 10 extended through bit 15. The following table describes the
 * behavior of the data result registers in the different modes of operation. Data
 * result register description Conversion mode D15 D14 D13 D12 D11 D10 D9 D8 D7
 * D6 D5 D4 D3 D2 D1 D0 Format 16-bit differential S D D D D D D D D D D D D D D
 * D Signed 2's complement 16-bit single-ended D D D D D D D D D D D D D D D D
 * Unsigned right justified 13-bit differential S S S S D D D D D D D D D D D D
 * Sign-extended 2's complement 12-bit single-ended 0 0 0 0 D D D D D D D D D D D D
 * Unsigned right-justified 11-bit differential S S S S S S D D D D D D D D D D
 * Sign-extended 2's complement 10-bit single-ended 0 0 0 0 0 0 D D D D D D D D D
 * D Unsigned right-justified 9-bit differential S S S S S S S S D D D D D D D D
 * Sign-extended 2's complement 8-bit single-ended 0 0 0 0 0 0 0 0 D D D D D D D
 * D Unsigned right-justified S: Sign bit or sign bit extension; D: Data, which
 * is 2's complement data if indicated
 */
/*!
 * @name Constants and macros for entire ADC_R register
 */
/*@{*/
#define ADC_RD_R(base, index)    (ADC_R_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual ADC_R bitfields
 */

/*!
 * @name Register ADC_R, field D[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ADC_R_D field. */
#define ADC_RD_R_D(base, index) ((ADC_R_REG(base, index) & ADC_R_D_MASK) >> ADC_R_D_SHIFT)
#define ADC_BRD_R_D(base, index) (BME_UBFX32(&ADC_R_REG(base, index), ADC_R_D_SHIFT, ADC_R_D_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CV1 - Compare Value Registers
 ******************************************************************************/

/*!
 * @brief ADC_CV1 - Compare Value Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Compare Value Registers (CV1 and CV2) contain a compare value used to
 * compare the conversion result when the compare function is enabled, that is,
 * SC2[ACFE]=1. This register is formatted in the same way as the Rn registers in
 * different modes of operation for both bit position definition and value format
 * using unsigned or sign-extended 2's complement. Therefore, the compare function
 * uses only the CVn fields that are related to the ADC mode of operation. The
 * compare value 2 register (CV2) is used only when the compare range function is
 * enabled, that is, SC2[ACREN]=1.
 */
/*!
 * @name Constants and macros for entire ADC_CV1 register
 */
/*@{*/
#define ADC_RD_CV1(base)         (ADC_CV1_REG(base))
#define ADC_WR_CV1(base, value)  (ADC_CV1_REG(base) = (value))
#define ADC_RMW_CV1(base, mask, value) (ADC_WR_CV1(base, (ADC_RD_CV1(base) & ~(mask)) | (value)))
#define ADC_SET_CV1(base, value) (BME_OR32(&ADC_CV1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CV1(base, value) (BME_AND32(&ADC_CV1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CV1(base, value) (BME_XOR32(&ADC_CV1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV1 bitfields
 */

/*!
 * @name Register ADC_CV1, field CV[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_CV1_CV field. */
#define ADC_RD_CV1_CV(base)  ((ADC_CV1_REG(base) & ADC_CV1_CV_MASK) >> ADC_CV1_CV_SHIFT)
#define ADC_BRD_CV1_CV(base) (BME_UBFX32(&ADC_CV1_REG(base), ADC_CV1_CV_SHIFT, ADC_CV1_CV_WIDTH))

/*! @brief Set the CV field to a new value. */
#define ADC_WR_CV1_CV(base, value) (ADC_RMW_CV1(base, ADC_CV1_CV_MASK, ADC_CV1_CV(value)))
#define ADC_BWR_CV1_CV(base, value) (BME_BFI32(&ADC_CV1_REG(base), ((uint32_t)(value) << ADC_CV1_CV_SHIFT), ADC_CV1_CV_SHIFT, ADC_CV1_CV_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CV2 - Compare Value Registers
 ******************************************************************************/

/*!
 * @brief ADC_CV2 - Compare Value Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Compare Value Registers (CV1 and CV2) contain a compare value used to
 * compare the conversion result when the compare function is enabled, that is,
 * SC2[ACFE]=1. This register is formatted in the same way as the Rn registers in
 * different modes of operation for both bit position definition and value format
 * using unsigned or sign-extended 2's complement. Therefore, the compare function
 * uses only the CVn fields that are related to the ADC mode of operation. The
 * compare value 2 register (CV2) is used only when the compare range function is
 * enabled, that is, SC2[ACREN]=1.
 */
/*!
 * @name Constants and macros for entire ADC_CV2 register
 */
/*@{*/
#define ADC_RD_CV2(base)         (ADC_CV2_REG(base))
#define ADC_WR_CV2(base, value)  (ADC_CV2_REG(base) = (value))
#define ADC_RMW_CV2(base, mask, value) (ADC_WR_CV2(base, (ADC_RD_CV2(base) & ~(mask)) | (value)))
#define ADC_SET_CV2(base, value) (BME_OR32(&ADC_CV2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CV2(base, value) (BME_AND32(&ADC_CV2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CV2(base, value) (BME_XOR32(&ADC_CV2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV2 bitfields
 */

/*!
 * @name Register ADC_CV2, field CV[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_CV2_CV field. */
#define ADC_RD_CV2_CV(base)  ((ADC_CV2_REG(base) & ADC_CV2_CV_MASK) >> ADC_CV2_CV_SHIFT)
#define ADC_BRD_CV2_CV(base) (BME_UBFX32(&ADC_CV2_REG(base), ADC_CV2_CV_SHIFT, ADC_CV2_CV_WIDTH))

/*! @brief Set the CV field to a new value. */
#define ADC_WR_CV2_CV(base, value) (ADC_RMW_CV2(base, ADC_CV2_CV_MASK, ADC_CV2_CV(value)))
#define ADC_BWR_CV2_CV(base, value) (BME_BFI32(&ADC_CV2_REG(base), ((uint32_t)(value) << ADC_CV2_CV_SHIFT), ADC_CV2_CV_SHIFT, ADC_CV2_CV_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_SC2 - Status and Control Register 2
 ******************************************************************************/

/*!
 * @brief ADC_SC2 - Status and Control Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The status and control register 2 (SC2) contains the conversion active,
 * hardware/software trigger select, compare function, and voltage reference select of
 * the ADC module.
 */
/*!
 * @name Constants and macros for entire ADC_SC2 register
 */
/*@{*/
#define ADC_RD_SC2(base)         (ADC_SC2_REG(base))
#define ADC_WR_SC2(base, value)  (ADC_SC2_REG(base) = (value))
#define ADC_RMW_SC2(base, mask, value) (ADC_WR_SC2(base, (ADC_RD_SC2(base) & ~(mask)) | (value)))
#define ADC_SET_SC2(base, value) (BME_OR32(&ADC_SC2_REG(base), (uint32_t)(value)))
#define ADC_CLR_SC2(base, value) (BME_AND32(&ADC_SC2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_SC2(base, value) (BME_XOR32(&ADC_SC2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC2 bitfields
 */

/*!
 * @name Register ADC_SC2, field REFSEL[1:0] (RW)
 *
 * Selects the voltage reference source used for conversions.
 *
 * Values:
 * - 0b00 - Default voltage reference pin pair, that is, external pins VREFH and
 *     VREFL
 * - 0b01 - Alternate reference pair, that is, VALTH and VALTL . This pair may
 *     be additional external pins or internal sources depending on the MCU
 *     configuration. See the chip configuration information for details specific to
 *     this MCU
 * - 0b10 - Reserved
 * - 0b11 - Reserved - Selects default voltage reference (V REFH and V REFL )
 *     pin pair.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_REFSEL field. */
#define ADC_RD_SC2_REFSEL(base) ((ADC_SC2_REG(base) & ADC_SC2_REFSEL_MASK) >> ADC_SC2_REFSEL_SHIFT)
#define ADC_BRD_SC2_REFSEL(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_REFSEL_SHIFT, ADC_SC2_REFSEL_WIDTH))

/*! @brief Set the REFSEL field to a new value. */
#define ADC_WR_SC2_REFSEL(base, value) (ADC_RMW_SC2(base, ADC_SC2_REFSEL_MASK, ADC_SC2_REFSEL(value)))
#define ADC_BWR_SC2_REFSEL(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_REFSEL_SHIFT), ADC_SC2_REFSEL_SHIFT, ADC_SC2_REFSEL_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field DMAEN[2] (RW)
 *
 * Values:
 * - 0b0 - DMA is disabled.
 * - 0b1 - DMA is enabled and will assert the ADC DMA request during an ADC
 *     conversion complete event noted when any of the SC1n[COCO] flags is asserted.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_DMAEN field. */
#define ADC_RD_SC2_DMAEN(base) ((ADC_SC2_REG(base) & ADC_SC2_DMAEN_MASK) >> ADC_SC2_DMAEN_SHIFT)
#define ADC_BRD_SC2_DMAEN(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_DMAEN_SHIFT, ADC_SC2_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define ADC_WR_SC2_DMAEN(base, value) (ADC_RMW_SC2(base, ADC_SC2_DMAEN_MASK, ADC_SC2_DMAEN(value)))
#define ADC_BWR_SC2_DMAEN(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_DMAEN_SHIFT), ADC_SC2_DMAEN_SHIFT, ADC_SC2_DMAEN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACREN[3] (RW)
 *
 * Configures the compare function to check if the conversion result of the
 * input being monitored is either between or outside the range formed by CV1 and CV2
 * determined by the value of ACFGT. ACFE must be set for ACFGT to have any
 * effect.
 *
 * Values:
 * - 0b0 - Range function disabled. Only CV1 is compared.
 * - 0b1 - Range function enabled. Both CV1 and CV2 are compared.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACREN field. */
#define ADC_RD_SC2_ACREN(base) ((ADC_SC2_REG(base) & ADC_SC2_ACREN_MASK) >> ADC_SC2_ACREN_SHIFT)
#define ADC_BRD_SC2_ACREN(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ACREN_SHIFT, ADC_SC2_ACREN_WIDTH))

/*! @brief Set the ACREN field to a new value. */
#define ADC_WR_SC2_ACREN(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACREN_MASK, ADC_SC2_ACREN(value)))
#define ADC_BWR_SC2_ACREN(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ACREN_SHIFT), ADC_SC2_ACREN_SHIFT, ADC_SC2_ACREN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFGT[4] (RW)
 *
 * Configures the compare function to check the conversion result relative to
 * the CV1 and CV2 based upon the value of ACREN. ACFE must be set for ACFGT to
 * have any effect.
 *
 * Values:
 * - 0b0 - Configures less than threshold, outside range not inclusive and
 *     inside range not inclusive; functionality based on the values placed in CV1 and
 *     CV2.
 * - 0b1 - Configures greater than or equal to threshold, outside and inside
 *     ranges inclusive; functionality based on the values placed in CV1 and CV2.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACFGT field. */
#define ADC_RD_SC2_ACFGT(base) ((ADC_SC2_REG(base) & ADC_SC2_ACFGT_MASK) >> ADC_SC2_ACFGT_SHIFT)
#define ADC_BRD_SC2_ACFGT(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ACFGT_SHIFT, ADC_SC2_ACFGT_WIDTH))

/*! @brief Set the ACFGT field to a new value. */
#define ADC_WR_SC2_ACFGT(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACFGT_MASK, ADC_SC2_ACFGT(value)))
#define ADC_BWR_SC2_ACFGT(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ACFGT_SHIFT), ADC_SC2_ACFGT_SHIFT, ADC_SC2_ACFGT_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFE[5] (RW)
 *
 * Enables the compare function.
 *
 * Values:
 * - 0b0 - Compare function disabled.
 * - 0b1 - Compare function enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACFE field. */
#define ADC_RD_SC2_ACFE(base) ((ADC_SC2_REG(base) & ADC_SC2_ACFE_MASK) >> ADC_SC2_ACFE_SHIFT)
#define ADC_BRD_SC2_ACFE(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ACFE_SHIFT, ADC_SC2_ACFE_WIDTH))

/*! @brief Set the ACFE field to a new value. */
#define ADC_WR_SC2_ACFE(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACFE_MASK, ADC_SC2_ACFE(value)))
#define ADC_BWR_SC2_ACFE(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ACFE_SHIFT), ADC_SC2_ACFE_SHIFT, ADC_SC2_ACFE_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADTRG[6] (RW)
 *
 * Selects the type of trigger used for initiating a conversion. Two types of
 * trigger are selectable: Software trigger: When software trigger is selected, a
 * conversion is initiated following a write to SC1A. Hardware trigger: When
 * hardware trigger is selected, a conversion is initiated following the assertion of
 * the ADHWT input after a pulse of the ADHWTSn input.
 *
 * Values:
 * - 0b0 - Software trigger selected.
 * - 0b1 - Hardware trigger selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ADTRG field. */
#define ADC_RD_SC2_ADTRG(base) ((ADC_SC2_REG(base) & ADC_SC2_ADTRG_MASK) >> ADC_SC2_ADTRG_SHIFT)
#define ADC_BRD_SC2_ADTRG(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ADTRG_SHIFT, ADC_SC2_ADTRG_WIDTH))

/*! @brief Set the ADTRG field to a new value. */
#define ADC_WR_SC2_ADTRG(base, value) (ADC_RMW_SC2(base, ADC_SC2_ADTRG_MASK, ADC_SC2_ADTRG(value)))
#define ADC_BWR_SC2_ADTRG(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ADTRG_SHIFT), ADC_SC2_ADTRG_SHIFT, ADC_SC2_ADTRG_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADACT[7] (RO)
 *
 * Indicates that a conversion or hardware averaging is in progress. ADACT is
 * set when a conversion is initiated and cleared when a conversion is completed or
 * aborted.
 *
 * Values:
 * - 0b0 - Conversion not in progress.
 * - 0b1 - Conversion in progress.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ADACT field. */
#define ADC_RD_SC2_ADACT(base) ((ADC_SC2_REG(base) & ADC_SC2_ADACT_MASK) >> ADC_SC2_ADACT_SHIFT)
#define ADC_BRD_SC2_ADACT(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ADACT_SHIFT, ADC_SC2_ADACT_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_SC3 - Status and Control Register 3
 ******************************************************************************/

/*!
 * @brief ADC_SC3 - Status and Control Register 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Status and Control Register 3 (SC3) controls the calibration, continuous
 * convert, and hardware averaging functions of the ADC module.
 */
/*!
 * @name Constants and macros for entire ADC_SC3 register
 */
/*@{*/
#define ADC_RD_SC3(base)         (ADC_SC3_REG(base))
#define ADC_WR_SC3(base, value)  (ADC_SC3_REG(base) = (value))
#define ADC_RMW_SC3(base, mask, value) (ADC_WR_SC3(base, (ADC_RD_SC3(base) & ~(mask)) | (value)))
#define ADC_SET_SC3(base, value) (BME_OR32(&ADC_SC3_REG(base), (uint32_t)(value)))
#define ADC_CLR_SC3(base, value) (BME_AND32(&ADC_SC3_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_SC3(base, value) (BME_XOR32(&ADC_SC3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC3 bitfields
 */

/*!
 * @name Register ADC_SC3, field AVGS[1:0] (RW)
 *
 * Determines how many ADC conversions will be averaged to create the ADC
 * average result.
 *
 * Values:
 * - 0b00 - 4 samples averaged.
 * - 0b01 - 8 samples averaged.
 * - 0b10 - 16 samples averaged.
 * - 0b11 - 32 samples averaged.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_AVGS field. */
#define ADC_RD_SC3_AVGS(base) ((ADC_SC3_REG(base) & ADC_SC3_AVGS_MASK) >> ADC_SC3_AVGS_SHIFT)
#define ADC_BRD_SC3_AVGS(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_AVGS_SHIFT, ADC_SC3_AVGS_WIDTH))

/*! @brief Set the AVGS field to a new value. */
#define ADC_WR_SC3_AVGS(base, value) (ADC_RMW_SC3(base, (ADC_SC3_AVGS_MASK | ADC_SC3_CALF_MASK), ADC_SC3_AVGS(value)))
#define ADC_BWR_SC3_AVGS(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_AVGS_SHIFT), ADC_SC3_AVGS_SHIFT, ADC_SC3_AVGS_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field AVGE[2] (RW)
 *
 * Enables the hardware average function of the ADC.
 *
 * Values:
 * - 0b0 - Hardware average function disabled.
 * - 0b1 - Hardware average function enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_AVGE field. */
#define ADC_RD_SC3_AVGE(base) ((ADC_SC3_REG(base) & ADC_SC3_AVGE_MASK) >> ADC_SC3_AVGE_SHIFT)
#define ADC_BRD_SC3_AVGE(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_AVGE_SHIFT, ADC_SC3_AVGE_WIDTH))

/*! @brief Set the AVGE field to a new value. */
#define ADC_WR_SC3_AVGE(base, value) (ADC_RMW_SC3(base, (ADC_SC3_AVGE_MASK | ADC_SC3_CALF_MASK), ADC_SC3_AVGE(value)))
#define ADC_BWR_SC3_AVGE(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_AVGE_SHIFT), ADC_SC3_AVGE_SHIFT, ADC_SC3_AVGE_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field ADCO[3] (RW)
 *
 * Enables continuous conversions.
 *
 * Values:
 * - 0b0 - One conversion or one set of conversions if the hardware average
 *     function is enabled, that is, AVGE=1, after initiating a conversion.
 * - 0b1 - Continuous conversions or sets of conversions if the hardware average
 *     function is enabled, that is, AVGE=1, after initiating a conversion.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_ADCO field. */
#define ADC_RD_SC3_ADCO(base) ((ADC_SC3_REG(base) & ADC_SC3_ADCO_MASK) >> ADC_SC3_ADCO_SHIFT)
#define ADC_BRD_SC3_ADCO(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_ADCO_SHIFT, ADC_SC3_ADCO_WIDTH))

/*! @brief Set the ADCO field to a new value. */
#define ADC_WR_SC3_ADCO(base, value) (ADC_RMW_SC3(base, (ADC_SC3_ADCO_MASK | ADC_SC3_CALF_MASK), ADC_SC3_ADCO(value)))
#define ADC_BWR_SC3_ADCO(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_ADCO_SHIFT), ADC_SC3_ADCO_SHIFT, ADC_SC3_ADCO_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field CALF[6] (W1C)
 *
 * Displays the result of the calibration sequence. The calibration sequence
 * will fail if SC2[ADTRG] = 1, any ADC register is written, or any stop mode is
 * entered before the calibration sequence completes. Writing 1 to CALF clears it.
 *
 * Values:
 * - 0b0 - Calibration completed normally.
 * - 0b1 - Calibration failed. ADC accuracy specifications are not guaranteed.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_CALF field. */
#define ADC_RD_SC3_CALF(base) ((ADC_SC3_REG(base) & ADC_SC3_CALF_MASK) >> ADC_SC3_CALF_SHIFT)
#define ADC_BRD_SC3_CALF(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_CALF_SHIFT, ADC_SC3_CALF_WIDTH))

/*! @brief Set the CALF field to a new value. */
#define ADC_WR_SC3_CALF(base, value) (ADC_RMW_SC3(base, ADC_SC3_CALF_MASK, ADC_SC3_CALF(value)))
#define ADC_BWR_SC3_CALF(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_CALF_SHIFT), ADC_SC3_CALF_SHIFT, ADC_SC3_CALF_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field CAL[7] (RW)
 *
 * Begins the calibration sequence when set. This field stays set while the
 * calibration is in progress and is cleared when the calibration sequence is
 * completed. CALF must be checked to determine the result of the calibration sequence.
 * Once started, the calibration routine cannot be interrupted by writes to the
 * ADC registers or the results will be invalid and CALF will set. Setting CAL
 * will abort any current conversion.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_CAL field. */
#define ADC_RD_SC3_CAL(base) ((ADC_SC3_REG(base) & ADC_SC3_CAL_MASK) >> ADC_SC3_CAL_SHIFT)
#define ADC_BRD_SC3_CAL(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_CAL_SHIFT, ADC_SC3_CAL_WIDTH))

/*! @brief Set the CAL field to a new value. */
#define ADC_WR_SC3_CAL(base, value) (ADC_RMW_SC3(base, (ADC_SC3_CAL_MASK | ADC_SC3_CALF_MASK), ADC_SC3_CAL(value)))
#define ADC_BWR_SC3_CAL(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_CAL_SHIFT), ADC_SC3_CAL_SHIFT, ADC_SC3_CAL_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_OFS - ADC Offset Correction Register
 ******************************************************************************/

/*!
 * @brief ADC_OFS - ADC Offset Correction Register (RW)
 *
 * Reset value: 0x00000004U
 *
 * The ADC Offset Correction Register (OFS) contains the user-selected or
 * calibration-generated offset error correction value. This register is a 2's
 * complement, left-justified, 16-bit value . The value in OFS is subtracted from the
 * conversion and the result is transferred into the result registers, Rn. If the
 * result is greater than the maximum or less than the minimum result value, it is
 * forced to the appropriate limit for the current mode of operation. It is
 * forced to 0xFFFF if over and 0x0000 if lower The formatting of the ADC offset
 * correction register is different from the data result registers (Rn) to preserve
 * the resolution of the calibration value regardless of the conversion mode
 * selected. Lower order bits are ignored in lower resolution modes. For example, in
 * 8-bit single-ended mode, the bits OFS[14:7] are subtracted from D[7:0]; bit
 * OFS[15] indicates the sign (negative numbers are effectively added to the result)
 * and bits OFS[6:0] are ignored. The same bits are used in 9-bit differential
 * mode since bit OFS[15] indicates the sign bit, which maps to bit D[8]. For
 * 16-bit differential mode, all bits OFS[15:0] are directly subtracted from the
 * conversion result data D[15:0]. Finally, in 16-bit single-ended mode, there is no
 * bit in the ADC offset correction register corresponding to the least
 * significant result bit D[0], so odd values (-1 or +1, and so on) cannot be subtracted
 * from the result. There is an effective limit to the offset values that can be
 * set by the user. If the magnitude of the offset is too great the results of the
 * conversions will cap off at the limits. OFS is automatically set according to
 * calibration requirements once the self calibration sequence is done (CAL is
 * cleared). The user may write OFS to override the calibration result if desired.
 * If the ADC offset correction register is written by the user to a value that
 * is different from the calibration value, the ADC error specifications may not
 * be met. It is recommended that the value generated by the calibration function
 * be stored in memory before overwriting with a user specified value. For more
 * information regarding the calibration procedure, please refer to the
 * Calibration functionThe ADC contains a self-calibration function that is required to
 * achieve the specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_OFS register
 */
/*@{*/
#define ADC_RD_OFS(base)         (ADC_OFS_REG(base))
#define ADC_WR_OFS(base, value)  (ADC_OFS_REG(base) = (value))
#define ADC_RMW_OFS(base, mask, value) (ADC_WR_OFS(base, (ADC_RD_OFS(base) & ~(mask)) | (value)))
#define ADC_SET_OFS(base, value) (BME_OR32(&ADC_OFS_REG(base), (uint32_t)(value)))
#define ADC_CLR_OFS(base, value) (BME_AND32(&ADC_OFS_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_OFS(base, value) (BME_XOR32(&ADC_OFS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_OFS bitfields
 */

/*!
 * @name Register ADC_OFS, field OFS[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_OFS_OFS field. */
#define ADC_RD_OFS_OFS(base) ((ADC_OFS_REG(base) & ADC_OFS_OFS_MASK) >> ADC_OFS_OFS_SHIFT)
#define ADC_BRD_OFS_OFS(base) (BME_UBFX32(&ADC_OFS_REG(base), ADC_OFS_OFS_SHIFT, ADC_OFS_OFS_WIDTH))

/*! @brief Set the OFS field to a new value. */
#define ADC_WR_OFS_OFS(base, value) (ADC_RMW_OFS(base, ADC_OFS_OFS_MASK, ADC_OFS_OFS(value)))
#define ADC_BWR_OFS_OFS(base, value) (BME_BFI32(&ADC_OFS_REG(base), ((uint32_t)(value) << ADC_OFS_OFS_SHIFT), ADC_OFS_OFS_SHIFT, ADC_OFS_OFS_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_PG - ADC Plus-Side Gain Register
 ******************************************************************************/

/*!
 * @brief ADC_PG - ADC Plus-Side Gain Register (RW)
 *
 * Reset value: 0x00008200U
 *
 * In non-16-bit half-sample mode (Mode[1:0] not equal to 11), the plus-side
 * gain is automatically loaded from CLP4[9:0] and the MSBs are forced to half (bits
 * 16-10 = 0100000). The Plus-Side Gain Register (PG) contains the gain error
 * correction for the plus-side input in differential mode or the overall
 * conversion in single-ended mode. PG, a 16-bit real number in binary format, is the gain
 * adjustment factor, with the radix point fixed between PG[15] and PG[14]. This
 * register must be written by the user with the value described in the
 * calibration procedure. Otherwise, the gain error specifications may not be met. The
 * allowable range is from 0.25 (PGH:PGL = 0x2000) to 1.03122 (PGH:PGL = 0x83FF).
 * If this register is written to values outside this range the ADC will not
 * operate correctly. For more information regarding the calibration procedure, please
 * refer to the Calibration functionThe ADC contains a self-calibration function
 * that is required to achieve the specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_PG register
 */
/*@{*/
#define ADC_RD_PG(base)          (ADC_PG_REG(base))
#define ADC_WR_PG(base, value)   (ADC_PG_REG(base) = (value))
#define ADC_RMW_PG(base, mask, value) (ADC_WR_PG(base, (ADC_RD_PG(base) & ~(mask)) | (value)))
#define ADC_SET_PG(base, value)  (BME_OR32(&ADC_PG_REG(base), (uint32_t)(value)))
#define ADC_CLR_PG(base, value)  (BME_AND32(&ADC_PG_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_PG(base, value)  (BME_XOR32(&ADC_PG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_PG bitfields
 */

/*!
 * @name Register ADC_PG, field PG[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_PG_PG field. */
#define ADC_RD_PG_PG(base)   ((ADC_PG_REG(base) & ADC_PG_PG_MASK) >> ADC_PG_PG_SHIFT)
#define ADC_BRD_PG_PG(base)  (BME_UBFX32(&ADC_PG_REG(base), ADC_PG_PG_SHIFT, ADC_PG_PG_WIDTH))

/*! @brief Set the PG field to a new value. */
#define ADC_WR_PG_PG(base, value) (ADC_RMW_PG(base, ADC_PG_PG_MASK, ADC_PG_PG(value)))
#define ADC_BWR_PG_PG(base, value) (BME_BFI32(&ADC_PG_REG(base), ((uint32_t)(value) << ADC_PG_PG_SHIFT), ADC_PG_PG_SHIFT, ADC_PG_PG_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_MG - ADC Minus-Side Gain Register
 ******************************************************************************/

/*!
 * @brief ADC_MG - ADC Minus-Side Gain Register (RW)
 *
 * Reset value: 0x00008200U
 *
 * The Minus-Side Gain Register (MG) contains the gain error correction for the
 * minus-side input in differential mode. This register is ignored in
 * single-ended mode. MG, a 16-bit real number in binary format, is the gain adjustment
 * factor, with the radix point fixed between MG[15] and MG[14]. This register must
 * be written by the user with the value described in the calibration procedure.
 * Otherwise, the gain error specifications may not be met. The allowable range is
 * from 0.25 (MG = 0x2000) to 1.03122 (MG = 0x83FF). If this register is written
 * to values outside this range the ADC will not operate correctly. For more
 * information regarding the calibration procedure, please refer to the Calibration
 * functionThe ADC contains a self-calibration function that is required to
 * achieve the specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_MG register
 */
/*@{*/
#define ADC_RD_MG(base)          (ADC_MG_REG(base))
#define ADC_WR_MG(base, value)   (ADC_MG_REG(base) = (value))
#define ADC_RMW_MG(base, mask, value) (ADC_WR_MG(base, (ADC_RD_MG(base) & ~(mask)) | (value)))
#define ADC_SET_MG(base, value)  (BME_OR32(&ADC_MG_REG(base), (uint32_t)(value)))
#define ADC_CLR_MG(base, value)  (BME_AND32(&ADC_MG_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_MG(base, value)  (BME_XOR32(&ADC_MG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_MG bitfields
 */

/*!
 * @name Register ADC_MG, field MG[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_MG_MG field. */
#define ADC_RD_MG_MG(base)   ((ADC_MG_REG(base) & ADC_MG_MG_MASK) >> ADC_MG_MG_SHIFT)
#define ADC_BRD_MG_MG(base)  (BME_UBFX32(&ADC_MG_REG(base), ADC_MG_MG_SHIFT, ADC_MG_MG_WIDTH))

/*! @brief Set the MG field to a new value. */
#define ADC_WR_MG_MG(base, value) (ADC_RMW_MG(base, ADC_MG_MG_MASK, ADC_MG_MG(value)))
#define ADC_BWR_MG_MG(base, value) (BME_BFI32(&ADC_MG_REG(base), ((uint32_t)(value) << ADC_MG_MG_SHIFT), ADC_MG_MG_SHIFT, ADC_MG_MG_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLPD - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLPD - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * The Plus-Side General Calibration Value Registers (CLPx) contain calibration
 * information that is generated by the calibration function. These registers
 * contain seven calibration values of varying widths: CLP0[5:0], CLP1[6:0],
 * CLP2[7:0], CLP3[8:0], CLP4[9:0], CLPS[5:0], and CLPD[5:0]. CLPx are automatically set
 * when the self-calibration sequence is done, that is, CAL is cleared. If these
 * registers are written by the user after calibration, the linearity error
 * specifications may not be met. These calibration values (CLPx) will affect the end
 * conversion result by having there values subtracted from the conversion
 * before end result is transferred into the result register. (CLP4 is only subtracted
 * from conversion result if the compare output value from ADC hard block is
 * equal to logic 0 during the 1st and 2nd compare cycle. CLPS register value is
 * subtracted from conversion result if ADC is configured in 16-bit Mode and the
 * compare output value from the ADC hard block is equal to logic 0 during 1st, 2nd,
 * 3rd, and the 4th compare cycles.) For more information regarding the
 * calibration procedure, please refer to the Calibration functionThe ADC contains a
 * self-calibration function that is required to achieve the specified accuracy.
 * section.
 */
/*!
 * @name Constants and macros for entire ADC_CLPD register
 */
/*@{*/
#define ADC_RD_CLPD(base)        (ADC_CLPD_REG(base))
#define ADC_WR_CLPD(base, value) (ADC_CLPD_REG(base) = (value))
#define ADC_RMW_CLPD(base, mask, value) (ADC_WR_CLPD(base, (ADC_RD_CLPD(base) & ~(mask)) | (value)))
#define ADC_SET_CLPD(base, value) (BME_OR32(&ADC_CLPD_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLPD(base, value) (BME_AND32(&ADC_CLPD_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLPD(base, value) (BME_XOR32(&ADC_CLPD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPD bitfields
 */

/*!
 * @name Register ADC_CLPD, field CLPD[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPD_CLPD field. */
#define ADC_RD_CLPD_CLPD(base) ((ADC_CLPD_REG(base) & ADC_CLPD_CLPD_MASK) >> ADC_CLPD_CLPD_SHIFT)
#define ADC_BRD_CLPD_CLPD(base) (BME_UBFX32(&ADC_CLPD_REG(base), ADC_CLPD_CLPD_SHIFT, ADC_CLPD_CLPD_WIDTH))

/*! @brief Set the CLPD field to a new value. */
#define ADC_WR_CLPD_CLPD(base, value) (ADC_RMW_CLPD(base, ADC_CLPD_CLPD_MASK, ADC_CLPD_CLPD(value)))
#define ADC_BWR_CLPD_CLPD(base, value) (BME_BFI32(&ADC_CLPD_REG(base), ((uint32_t)(value) << ADC_CLPD_CLPD_SHIFT), ADC_CLPD_CLPD_SHIFT, ADC_CLPD_CLPD_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLPS - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLPS - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLPS register
 */
/*@{*/
#define ADC_RD_CLPS(base)        (ADC_CLPS_REG(base))
#define ADC_WR_CLPS(base, value) (ADC_CLPS_REG(base) = (value))
#define ADC_RMW_CLPS(base, mask, value) (ADC_WR_CLPS(base, (ADC_RD_CLPS(base) & ~(mask)) | (value)))
#define ADC_SET_CLPS(base, value) (BME_OR32(&ADC_CLPS_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLPS(base, value) (BME_AND32(&ADC_CLPS_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLPS(base, value) (BME_XOR32(&ADC_CLPS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPS bitfields
 */

/*!
 * @name Register ADC_CLPS, field CLPS[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPS_CLPS field. */
#define ADC_RD_CLPS_CLPS(base) ((ADC_CLPS_REG(base) & ADC_CLPS_CLPS_MASK) >> ADC_CLPS_CLPS_SHIFT)
#define ADC_BRD_CLPS_CLPS(base) (BME_UBFX32(&ADC_CLPS_REG(base), ADC_CLPS_CLPS_SHIFT, ADC_CLPS_CLPS_WIDTH))

/*! @brief Set the CLPS field to a new value. */
#define ADC_WR_CLPS_CLPS(base, value) (ADC_RMW_CLPS(base, ADC_CLPS_CLPS_MASK, ADC_CLPS_CLPS(value)))
#define ADC_BWR_CLPS_CLPS(base, value) (BME_BFI32(&ADC_CLPS_REG(base), ((uint32_t)(value) << ADC_CLPS_CLPS_SHIFT), ADC_CLPS_CLPS_SHIFT, ADC_CLPS_CLPS_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP4 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP4 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000200U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP4 register
 */
/*@{*/
#define ADC_RD_CLP4(base)        (ADC_CLP4_REG(base))
#define ADC_WR_CLP4(base, value) (ADC_CLP4_REG(base) = (value))
#define ADC_RMW_CLP4(base, mask, value) (ADC_WR_CLP4(base, (ADC_RD_CLP4(base) & ~(mask)) | (value)))
#define ADC_SET_CLP4(base, value) (BME_OR32(&ADC_CLP4_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP4(base, value) (BME_AND32(&ADC_CLP4_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP4(base, value) (BME_XOR32(&ADC_CLP4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP4 bitfields
 */

/*!
 * @name Register ADC_CLP4, field CLP4[9:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP4_CLP4 field. */
#define ADC_RD_CLP4_CLP4(base) ((ADC_CLP4_REG(base) & ADC_CLP4_CLP4_MASK) >> ADC_CLP4_CLP4_SHIFT)
#define ADC_BRD_CLP4_CLP4(base) (BME_UBFX32(&ADC_CLP4_REG(base), ADC_CLP4_CLP4_SHIFT, ADC_CLP4_CLP4_WIDTH))

/*! @brief Set the CLP4 field to a new value. */
#define ADC_WR_CLP4_CLP4(base, value) (ADC_RMW_CLP4(base, ADC_CLP4_CLP4_MASK, ADC_CLP4_CLP4(value)))
#define ADC_BWR_CLP4_CLP4(base, value) (BME_BFI32(&ADC_CLP4_REG(base), ((uint32_t)(value) << ADC_CLP4_CLP4_SHIFT), ADC_CLP4_CLP4_SHIFT, ADC_CLP4_CLP4_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP3 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP3 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000100U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP3 register
 */
/*@{*/
#define ADC_RD_CLP3(base)        (ADC_CLP3_REG(base))
#define ADC_WR_CLP3(base, value) (ADC_CLP3_REG(base) = (value))
#define ADC_RMW_CLP3(base, mask, value) (ADC_WR_CLP3(base, (ADC_RD_CLP3(base) & ~(mask)) | (value)))
#define ADC_SET_CLP3(base, value) (BME_OR32(&ADC_CLP3_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP3(base, value) (BME_AND32(&ADC_CLP3_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP3(base, value) (BME_XOR32(&ADC_CLP3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP3 bitfields
 */

/*!
 * @name Register ADC_CLP3, field CLP3[8:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP3_CLP3 field. */
#define ADC_RD_CLP3_CLP3(base) ((ADC_CLP3_REG(base) & ADC_CLP3_CLP3_MASK) >> ADC_CLP3_CLP3_SHIFT)
#define ADC_BRD_CLP3_CLP3(base) (BME_UBFX32(&ADC_CLP3_REG(base), ADC_CLP3_CLP3_SHIFT, ADC_CLP3_CLP3_WIDTH))

/*! @brief Set the CLP3 field to a new value. */
#define ADC_WR_CLP3_CLP3(base, value) (ADC_RMW_CLP3(base, ADC_CLP3_CLP3_MASK, ADC_CLP3_CLP3(value)))
#define ADC_BWR_CLP3_CLP3(base, value) (BME_BFI32(&ADC_CLP3_REG(base), ((uint32_t)(value) << ADC_CLP3_CLP3_SHIFT), ADC_CLP3_CLP3_SHIFT, ADC_CLP3_CLP3_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP2 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP2 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP2 register
 */
/*@{*/
#define ADC_RD_CLP2(base)        (ADC_CLP2_REG(base))
#define ADC_WR_CLP2(base, value) (ADC_CLP2_REG(base) = (value))
#define ADC_RMW_CLP2(base, mask, value) (ADC_WR_CLP2(base, (ADC_RD_CLP2(base) & ~(mask)) | (value)))
#define ADC_SET_CLP2(base, value) (BME_OR32(&ADC_CLP2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP2(base, value) (BME_AND32(&ADC_CLP2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP2(base, value) (BME_XOR32(&ADC_CLP2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP2 bitfields
 */

/*!
 * @name Register ADC_CLP2, field CLP2[7:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP2_CLP2 field. */
#define ADC_RD_CLP2_CLP2(base) ((ADC_CLP2_REG(base) & ADC_CLP2_CLP2_MASK) >> ADC_CLP2_CLP2_SHIFT)
#define ADC_BRD_CLP2_CLP2(base) (BME_UBFX32(&ADC_CLP2_REG(base), ADC_CLP2_CLP2_SHIFT, ADC_CLP2_CLP2_WIDTH))

/*! @brief Set the CLP2 field to a new value. */
#define ADC_WR_CLP2_CLP2(base, value) (ADC_RMW_CLP2(base, ADC_CLP2_CLP2_MASK, ADC_CLP2_CLP2(value)))
#define ADC_BWR_CLP2_CLP2(base, value) (BME_BFI32(&ADC_CLP2_REG(base), ((uint32_t)(value) << ADC_CLP2_CLP2_SHIFT), ADC_CLP2_CLP2_SHIFT, ADC_CLP2_CLP2_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP1 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP1 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000040U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP1 register
 */
/*@{*/
#define ADC_RD_CLP1(base)        (ADC_CLP1_REG(base))
#define ADC_WR_CLP1(base, value) (ADC_CLP1_REG(base) = (value))
#define ADC_RMW_CLP1(base, mask, value) (ADC_WR_CLP1(base, (ADC_RD_CLP1(base) & ~(mask)) | (value)))
#define ADC_SET_CLP1(base, value) (BME_OR32(&ADC_CLP1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP1(base, value) (BME_AND32(&ADC_CLP1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP1(base, value) (BME_XOR32(&ADC_CLP1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP1 bitfields
 */

/*!
 * @name Register ADC_CLP1, field CLP1[6:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP1_CLP1 field. */
#define ADC_RD_CLP1_CLP1(base) ((ADC_CLP1_REG(base) & ADC_CLP1_CLP1_MASK) >> ADC_CLP1_CLP1_SHIFT)
#define ADC_BRD_CLP1_CLP1(base) (BME_UBFX32(&ADC_CLP1_REG(base), ADC_CLP1_CLP1_SHIFT, ADC_CLP1_CLP1_WIDTH))

/*! @brief Set the CLP1 field to a new value. */
#define ADC_WR_CLP1_CLP1(base, value) (ADC_RMW_CLP1(base, ADC_CLP1_CLP1_MASK, ADC_CLP1_CLP1(value)))
#define ADC_BWR_CLP1_CLP1(base, value) (BME_BFI32(&ADC_CLP1_REG(base), ((uint32_t)(value) << ADC_CLP1_CLP1_SHIFT), ADC_CLP1_CLP1_SHIFT, ADC_CLP1_CLP1_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP0 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP0 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP0 register
 */
/*@{*/
#define ADC_RD_CLP0(base)        (ADC_CLP0_REG(base))
#define ADC_WR_CLP0(base, value) (ADC_CLP0_REG(base) = (value))
#define ADC_RMW_CLP0(base, mask, value) (ADC_WR_CLP0(base, (ADC_RD_CLP0(base) & ~(mask)) | (value)))
#define ADC_SET_CLP0(base, value) (BME_OR32(&ADC_CLP0_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP0(base, value) (BME_AND32(&ADC_CLP0_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP0(base, value) (BME_XOR32(&ADC_CLP0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP0 bitfields
 */

/*!
 * @name Register ADC_CLP0, field CLP0[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP0_CLP0 field. */
#define ADC_RD_CLP0_CLP0(base) ((ADC_CLP0_REG(base) & ADC_CLP0_CLP0_MASK) >> ADC_CLP0_CLP0_SHIFT)
#define ADC_BRD_CLP0_CLP0(base) (BME_UBFX32(&ADC_CLP0_REG(base), ADC_CLP0_CLP0_SHIFT, ADC_CLP0_CLP0_WIDTH))

/*! @brief Set the CLP0 field to a new value. */
#define ADC_WR_CLP0_CLP0(base, value) (ADC_RMW_CLP0(base, ADC_CLP0_CLP0_MASK, ADC_CLP0_CLP0(value)))
#define ADC_BWR_CLP0_CLP0(base, value) (BME_BFI32(&ADC_CLP0_REG(base), ((uint32_t)(value) << ADC_CLP0_CLP0_SHIFT), ADC_CLP0_CLP0_SHIFT, ADC_CLP0_CLP0_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLMD - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLMD - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * The Minus-Side General Calibration Value (CLMx) registers contain calibration
 * information that is generated by the calibration function. These registers
 * contain seven calibration values of varying widths: CLM0[5:0], CLM1[6:0],
 * CLM2[7:0], CLM3[8:0], CLM4[9:0], CLMS[5:0], and CLMD[5:0]. CLMx are automatically
 * set when the self-calibration sequence is done, that is, CAL is cleared. If
 * these registers are written by the user after calibration, the linearity error
 * specifications may not be met. If Differential is enabled (DIFF=1), these
 * calibration values (CLMx) with the exception of CLMD will affect the end conversion
 * result by having there values subtracted from the conversion before end result
 * is transferred into the result register. (CLM4 is only subtracted from
 * conversion result if the compare output value from ADC hard block is equal to logic 0
 * during the 1st and 2nd compare cycle. CLMS register value is subtracted from
 * conversion result if ADC is configured in 16-bit Mode and the compare output
 * value from the ADC hard block is equal to logic 0 during 1st, 2nd, 3rd, and the
 * 4th compare cycles.) For more information regarding the calibration
 * procedure, please refer to the Calibration functionThe ADC contains a self-calibration
 * function that is required to achieve the specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_CLMD register
 */
/*@{*/
#define ADC_RD_CLMD(base)        (ADC_CLMD_REG(base))
#define ADC_WR_CLMD(base, value) (ADC_CLMD_REG(base) = (value))
#define ADC_RMW_CLMD(base, mask, value) (ADC_WR_CLMD(base, (ADC_RD_CLMD(base) & ~(mask)) | (value)))
#define ADC_SET_CLMD(base, value) (BME_OR32(&ADC_CLMD_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLMD(base, value) (BME_AND32(&ADC_CLMD_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLMD(base, value) (BME_XOR32(&ADC_CLMD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLMD bitfields
 */

/*!
 * @name Register ADC_CLMD, field CLMD[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLMD_CLMD field. */
#define ADC_RD_CLMD_CLMD(base) ((ADC_CLMD_REG(base) & ADC_CLMD_CLMD_MASK) >> ADC_CLMD_CLMD_SHIFT)
#define ADC_BRD_CLMD_CLMD(base) (BME_UBFX32(&ADC_CLMD_REG(base), ADC_CLMD_CLMD_SHIFT, ADC_CLMD_CLMD_WIDTH))

/*! @brief Set the CLMD field to a new value. */
#define ADC_WR_CLMD_CLMD(base, value) (ADC_RMW_CLMD(base, ADC_CLMD_CLMD_MASK, ADC_CLMD_CLMD(value)))
#define ADC_BWR_CLMD_CLMD(base, value) (BME_BFI32(&ADC_CLMD_REG(base), ((uint32_t)(value) << ADC_CLMD_CLMD_SHIFT), ADC_CLMD_CLMD_SHIFT, ADC_CLMD_CLMD_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLMS - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLMS - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLMS register
 */
/*@{*/
#define ADC_RD_CLMS(base)        (ADC_CLMS_REG(base))
#define ADC_WR_CLMS(base, value) (ADC_CLMS_REG(base) = (value))
#define ADC_RMW_CLMS(base, mask, value) (ADC_WR_CLMS(base, (ADC_RD_CLMS(base) & ~(mask)) | (value)))
#define ADC_SET_CLMS(base, value) (BME_OR32(&ADC_CLMS_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLMS(base, value) (BME_AND32(&ADC_CLMS_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLMS(base, value) (BME_XOR32(&ADC_CLMS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLMS bitfields
 */

/*!
 * @name Register ADC_CLMS, field CLMS[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLMS_CLMS field. */
#define ADC_RD_CLMS_CLMS(base) ((ADC_CLMS_REG(base) & ADC_CLMS_CLMS_MASK) >> ADC_CLMS_CLMS_SHIFT)
#define ADC_BRD_CLMS_CLMS(base) (BME_UBFX32(&ADC_CLMS_REG(base), ADC_CLMS_CLMS_SHIFT, ADC_CLMS_CLMS_WIDTH))

/*! @brief Set the CLMS field to a new value. */
#define ADC_WR_CLMS_CLMS(base, value) (ADC_RMW_CLMS(base, ADC_CLMS_CLMS_MASK, ADC_CLMS_CLMS(value)))
#define ADC_BWR_CLMS_CLMS(base, value) (BME_BFI32(&ADC_CLMS_REG(base), ((uint32_t)(value) << ADC_CLMS_CLMS_SHIFT), ADC_CLMS_CLMS_SHIFT, ADC_CLMS_CLMS_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLM4 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM4 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000200U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM4 register
 */
/*@{*/
#define ADC_RD_CLM4(base)        (ADC_CLM4_REG(base))
#define ADC_WR_CLM4(base, value) (ADC_CLM4_REG(base) = (value))
#define ADC_RMW_CLM4(base, mask, value) (ADC_WR_CLM4(base, (ADC_RD_CLM4(base) & ~(mask)) | (value)))
#define ADC_SET_CLM4(base, value) (BME_OR32(&ADC_CLM4_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM4(base, value) (BME_AND32(&ADC_CLM4_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM4(base, value) (BME_XOR32(&ADC_CLM4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM4 bitfields
 */

/*!
 * @name Register ADC_CLM4, field CLM4[9:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM4_CLM4 field. */
#define ADC_RD_CLM4_CLM4(base) ((ADC_CLM4_REG(base) & ADC_CLM4_CLM4_MASK) >> ADC_CLM4_CLM4_SHIFT)
#define ADC_BRD_CLM4_CLM4(base) (BME_UBFX32(&ADC_CLM4_REG(base), ADC_CLM4_CLM4_SHIFT, ADC_CLM4_CLM4_WIDTH))

/*! @brief Set the CLM4 field to a new value. */
#define ADC_WR_CLM4_CLM4(base, value) (ADC_RMW_CLM4(base, ADC_CLM4_CLM4_MASK, ADC_CLM4_CLM4(value)))
#define ADC_BWR_CLM4_CLM4(base, value) (BME_BFI32(&ADC_CLM4_REG(base), ((uint32_t)(value) << ADC_CLM4_CLM4_SHIFT), ADC_CLM4_CLM4_SHIFT, ADC_CLM4_CLM4_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLM3 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM3 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000100U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM3 register
 */
/*@{*/
#define ADC_RD_CLM3(base)        (ADC_CLM3_REG(base))
#define ADC_WR_CLM3(base, value) (ADC_CLM3_REG(base) = (value))
#define ADC_RMW_CLM3(base, mask, value) (ADC_WR_CLM3(base, (ADC_RD_CLM3(base) & ~(mask)) | (value)))
#define ADC_SET_CLM3(base, value) (BME_OR32(&ADC_CLM3_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM3(base, value) (BME_AND32(&ADC_CLM3_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM3(base, value) (BME_XOR32(&ADC_CLM3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM3 bitfields
 */

/*!
 * @name Register ADC_CLM3, field CLM3[8:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM3_CLM3 field. */
#define ADC_RD_CLM3_CLM3(base) ((ADC_CLM3_REG(base) & ADC_CLM3_CLM3_MASK) >> ADC_CLM3_CLM3_SHIFT)
#define ADC_BRD_CLM3_CLM3(base) (BME_UBFX32(&ADC_CLM3_REG(base), ADC_CLM3_CLM3_SHIFT, ADC_CLM3_CLM3_WIDTH))

/*! @brief Set the CLM3 field to a new value. */
#define ADC_WR_CLM3_CLM3(base, value) (ADC_RMW_CLM3(base, ADC_CLM3_CLM3_MASK, ADC_CLM3_CLM3(value)))
#define ADC_BWR_CLM3_CLM3(base, value) (BME_BFI32(&ADC_CLM3_REG(base), ((uint32_t)(value) << ADC_CLM3_CLM3_SHIFT), ADC_CLM3_CLM3_SHIFT, ADC_CLM3_CLM3_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLM2 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM2 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM2 register
 */
/*@{*/
#define ADC_RD_CLM2(base)        (ADC_CLM2_REG(base))
#define ADC_WR_CLM2(base, value) (ADC_CLM2_REG(base) = (value))
#define ADC_RMW_CLM2(base, mask, value) (ADC_WR_CLM2(base, (ADC_RD_CLM2(base) & ~(mask)) | (value)))
#define ADC_SET_CLM2(base, value) (BME_OR32(&ADC_CLM2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM2(base, value) (BME_AND32(&ADC_CLM2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM2(base, value) (BME_XOR32(&ADC_CLM2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM2 bitfields
 */

/*!
 * @name Register ADC_CLM2, field CLM2[7:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM2_CLM2 field. */
#define ADC_RD_CLM2_CLM2(base) ((ADC_CLM2_REG(base) & ADC_CLM2_CLM2_MASK) >> ADC_CLM2_CLM2_SHIFT)
#define ADC_BRD_CLM2_CLM2(base) (BME_UBFX32(&ADC_CLM2_REG(base), ADC_CLM2_CLM2_SHIFT, ADC_CLM2_CLM2_WIDTH))

/*! @brief Set the CLM2 field to a new value. */
#define ADC_WR_CLM2_CLM2(base, value) (ADC_RMW_CLM2(base, ADC_CLM2_CLM2_MASK, ADC_CLM2_CLM2(value)))
#define ADC_BWR_CLM2_CLM2(base, value) (BME_BFI32(&ADC_CLM2_REG(base), ((uint32_t)(value) << ADC_CLM2_CLM2_SHIFT), ADC_CLM2_CLM2_SHIFT, ADC_CLM2_CLM2_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLM1 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM1 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000040U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM1 register
 */
/*@{*/
#define ADC_RD_CLM1(base)        (ADC_CLM1_REG(base))
#define ADC_WR_CLM1(base, value) (ADC_CLM1_REG(base) = (value))
#define ADC_RMW_CLM1(base, mask, value) (ADC_WR_CLM1(base, (ADC_RD_CLM1(base) & ~(mask)) | (value)))
#define ADC_SET_CLM1(base, value) (BME_OR32(&ADC_CLM1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM1(base, value) (BME_AND32(&ADC_CLM1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM1(base, value) (BME_XOR32(&ADC_CLM1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM1 bitfields
 */

/*!
 * @name Register ADC_CLM1, field CLM1[6:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM1_CLM1 field. */
#define ADC_RD_CLM1_CLM1(base) ((ADC_CLM1_REG(base) & ADC_CLM1_CLM1_MASK) >> ADC_CLM1_CLM1_SHIFT)
#define ADC_BRD_CLM1_CLM1(base) (BME_UBFX32(&ADC_CLM1_REG(base), ADC_CLM1_CLM1_SHIFT, ADC_CLM1_CLM1_WIDTH))

/*! @brief Set the CLM1 field to a new value. */
#define ADC_WR_CLM1_CLM1(base, value) (ADC_RMW_CLM1(base, ADC_CLM1_CLM1_MASK, ADC_CLM1_CLM1(value)))
#define ADC_BWR_CLM1_CLM1(base, value) (BME_BFI32(&ADC_CLM1_REG(base), ((uint32_t)(value) << ADC_CLM1_CLM1_SHIFT), ADC_CLM1_CLM1_SHIFT, ADC_CLM1_CLM1_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLM0 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM0 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM0 register
 */
/*@{*/
#define ADC_RD_CLM0(base)        (ADC_CLM0_REG(base))
#define ADC_WR_CLM0(base, value) (ADC_CLM0_REG(base) = (value))
#define ADC_RMW_CLM0(base, mask, value) (ADC_WR_CLM0(base, (ADC_RD_CLM0(base) & ~(mask)) | (value)))
#define ADC_SET_CLM0(base, value) (BME_OR32(&ADC_CLM0_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM0(base, value) (BME_AND32(&ADC_CLM0_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM0(base, value) (BME_XOR32(&ADC_CLM0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM0 bitfields
 */

/*!
 * @name Register ADC_CLM0, field CLM0[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM0_CLM0 field. */
#define ADC_RD_CLM0_CLM0(base) ((ADC_CLM0_REG(base) & ADC_CLM0_CLM0_MASK) >> ADC_CLM0_CLM0_SHIFT)
#define ADC_BRD_CLM0_CLM0(base) (BME_UBFX32(&ADC_CLM0_REG(base), ADC_CLM0_CLM0_SHIFT, ADC_CLM0_CLM0_WIDTH))

/*! @brief Set the CLM0 field to a new value. */
#define ADC_WR_CLM0_CLM0(base, value) (ADC_RMW_CLM0(base, ADC_CLM0_CLM0_MASK, ADC_CLM0_CLM0(value)))
#define ADC_BWR_CLM0_CLM0(base, value) (BME_BFI32(&ADC_CLM0_REG(base), ((uint32_t)(value) << ADC_CLM0_CLM0_SHIFT), ADC_CLM0_CLM0_SHIFT, ADC_CLM0_CLM0_WIDTH))
/*@}*/

/*
 * MKW40Z4 BLE_RF_REGS
 *
 * Bluetooth Low Energy RF Registers
 *
 * Registers defined in this header file:
 * - BLE_RF_REGS_BLE_PART_ID - Bluetooth Low Energy Part ID
 * - BLE_RF_REGS_DSM_STATUS - DSM Status
 * - BLE_RF_REGS_BLE_AFC - Bluetooth Low Energy AFC
 * - BLE_RF_REGS_BLE_BSM - Bluetooth Low Energy BSM
 */

#define BLE_RF_REGS_INSTANCE_COUNT (1U) /*!< Number of instances of the BLE_RF_REGS module. */
#define BLE_RF_REGS_IDX (0U) /*!< Instance number for BLE_RF_REGS. */

/*******************************************************************************
 * BLE_RF_REGS_BLE_PART_ID - Bluetooth Low Energy Part ID
 ******************************************************************************/

/*!
 * @brief BLE_RF_REGS_BLE_PART_ID - Bluetooth Low Energy Part ID (RO)
 *
 * Reset value: 0x0001U
 */
/*!
 * @name Constants and macros for entire BLE_RF_REGS_BLE_PART_ID register
 */
/*@{*/
#define BLE_RF_REGS_RD_BLE_PART_ID(base) (BLE_RF_REGS_BLE_PART_ID_REG(base))
/*@}*/

/*******************************************************************************
 * BLE_RF_REGS_DSM_STATUS - DSM Status
 ******************************************************************************/

/*!
 * @brief BLE_RF_REGS_DSM_STATUS - DSM Status (RO)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire BLE_RF_REGS_DSM_STATUS register
 */
/*@{*/
#define BLE_RF_REGS_RD_DSM_STATUS(base) (BLE_RF_REGS_DSM_STATUS_REG(base))
/*@}*/

/*
 * Constants & macros for individual BLE_RF_REGS_DSM_STATUS bitfields
 */

/*!
 * @name Register BLE_RF_REGS_DSM_STATUS, field ORF_SYSCLK_REQ[0] (RO)
 *
 * Reflects the state of the BLE LL output of the same name, the control signal
 * used to enable/disable the RF Oscillator for entry and exit from DSM (deep
 * sleep mode).
 */
/*@{*/
/*! @brief Read current value of the BLE_RF_REGS_DSM_STATUS_ORF_SYSCLK_REQ field. */
#define BLE_RF_REGS_RD_DSM_STATUS_ORF_SYSCLK_REQ(base) ((BLE_RF_REGS_DSM_STATUS_REG(base) & BLE_RF_REGS_DSM_STATUS_ORF_SYSCLK_REQ_MASK) >> BLE_RF_REGS_DSM_STATUS_ORF_SYSCLK_REQ_SHIFT)
#define BLE_RF_REGS_BRD_DSM_STATUS_ORF_SYSCLK_REQ(base) (BME_UBFX16(&BLE_RF_REGS_DSM_STATUS_REG(base), BLE_RF_REGS_DSM_STATUS_ORF_SYSCLK_REQ_SHIFT, BLE_RF_REGS_DSM_STATUS_ORF_SYSCLK_REQ_WIDTH))
/*@}*/

/*!
 * @name Register BLE_RF_REGS_DSM_STATUS, field RIF_LL_ACTIVE[1] (RO)
 *
 * Reflects the state of the BLE LL output of the same name, the signal to be
 * used by the host as an 'early' indication to prevent host to do any operations
 * while the BLE block is doing transceiver operations, so as to reduce the peak
 * power and noise.
 */
/*@{*/
/*! @brief Read current value of the BLE_RF_REGS_DSM_STATUS_RIF_LL_ACTIVE field. */
#define BLE_RF_REGS_RD_DSM_STATUS_RIF_LL_ACTIVE(base) ((BLE_RF_REGS_DSM_STATUS_REG(base) & BLE_RF_REGS_DSM_STATUS_RIF_LL_ACTIVE_MASK) >> BLE_RF_REGS_DSM_STATUS_RIF_LL_ACTIVE_SHIFT)
#define BLE_RF_REGS_BRD_DSM_STATUS_RIF_LL_ACTIVE(base) (BME_UBFX16(&BLE_RF_REGS_DSM_STATUS_REG(base), BLE_RF_REGS_DSM_STATUS_RIF_LL_ACTIVE_SHIFT, BLE_RF_REGS_DSM_STATUS_RIF_LL_ACTIVE_WIDTH))
/*@}*/

/*******************************************************************************
 * BLE_RF_REGS_BLE_AFC - Bluetooth Low Energy AFC
 ******************************************************************************/

/*!
 * @brief BLE_RF_REGS_BLE_AFC - Bluetooth Low Energy AFC (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire BLE_RF_REGS_BLE_AFC register
 */
/*@{*/
#define BLE_RF_REGS_RD_BLE_AFC(base) (BLE_RF_REGS_BLE_AFC_REG(base))
#define BLE_RF_REGS_WR_BLE_AFC(base, value) (BLE_RF_REGS_BLE_AFC_REG(base) = (value))
#define BLE_RF_REGS_RMW_BLE_AFC(base, mask, value) (BLE_RF_REGS_WR_BLE_AFC(base, (BLE_RF_REGS_RD_BLE_AFC(base) & ~(mask)) | (value)))
#define BLE_RF_REGS_SET_BLE_AFC(base, value) (BME_OR16(&BLE_RF_REGS_BLE_AFC_REG(base), (uint16_t)(value)))
#define BLE_RF_REGS_CLR_BLE_AFC(base, value) (BME_AND16(&BLE_RF_REGS_BLE_AFC_REG(base), (uint16_t)(~(value))))
#define BLE_RF_REGS_TOG_BLE_AFC(base, value) (BME_XOR16(&BLE_RF_REGS_BLE_AFC_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual BLE_RF_REGS_BLE_AFC bitfields
 */

/*!
 * @name Register BLE_RF_REGS_BLE_AFC, field BLE_AFC[13:0] (RO)
 *
 * This field holds the result of the most recent BLE RX AFC (Automatic
 * Frequency Correction) estimation. A new AFC estimation will be generated whenever
 * preamble is detected. If LATCH_AFC_ON_ACCESS_MATCH=1, BLE_AFC will be latched on
 * access address match, and will not change until the next access address match.
 * Otherwise, BLE_AFC will be updated whenever preamble is detected. This is a
 * 14-bit, signed, two's complement value.
 */
/*@{*/
/*! @brief Read current value of the BLE_RF_REGS_BLE_AFC_BLE_AFC field. */
#define BLE_RF_REGS_RD_BLE_AFC_BLE_AFC(base) ((BLE_RF_REGS_BLE_AFC_REG(base) & BLE_RF_REGS_BLE_AFC_BLE_AFC_MASK) >> BLE_RF_REGS_BLE_AFC_BLE_AFC_SHIFT)
#define BLE_RF_REGS_BRD_BLE_AFC_BLE_AFC(base) (BME_UBFX16(&BLE_RF_REGS_BLE_AFC_REG(base), BLE_RF_REGS_BLE_AFC_BLE_AFC_SHIFT, BLE_RF_REGS_BLE_AFC_BLE_AFC_WIDTH))
/*@}*/

/*!
 * @name Register BLE_RF_REGS_BLE_AFC, field LATCH_AFC_ON_ACCESS_MATCH[15] (RW)
 *
 * Values:
 * - 0b0 - BLE_AFC[13:0] is updated whenever preamble is detected
 * - 0b1 - BLE_AFC[13:0] is latched at access address match, and will not be
 *     updated until the next access address match.
 */
/*@{*/
/*! @brief Read current value of the BLE_RF_REGS_BLE_AFC_LATCH_AFC_ON_ACCESS_MATCH field. */
#define BLE_RF_REGS_RD_BLE_AFC_LATCH_AFC_ON_ACCESS_MATCH(base) ((BLE_RF_REGS_BLE_AFC_REG(base) & BLE_RF_REGS_BLE_AFC_LATCH_AFC_ON_ACCESS_MATCH_MASK) >> BLE_RF_REGS_BLE_AFC_LATCH_AFC_ON_ACCESS_MATCH_SHIFT)
#define BLE_RF_REGS_BRD_BLE_AFC_LATCH_AFC_ON_ACCESS_MATCH(base) (BME_UBFX16(&BLE_RF_REGS_BLE_AFC_REG(base), BLE_RF_REGS_BLE_AFC_LATCH_AFC_ON_ACCESS_MATCH_SHIFT, BLE_RF_REGS_BLE_AFC_LATCH_AFC_ON_ACCESS_MATCH_WIDTH))

/*! @brief Set the LATCH_AFC_ON_ACCESS_MATCH field to a new value. */
#define BLE_RF_REGS_WR_BLE_AFC_LATCH_AFC_ON_ACCESS_MATCH(base, value) (BLE_RF_REGS_RMW_BLE_AFC(base, BLE_RF_REGS_BLE_AFC_LATCH_AFC_ON_ACCESS_MATCH_MASK, BLE_RF_REGS_BLE_AFC_LATCH_AFC_ON_ACCESS_MATCH(value)))
#define BLE_RF_REGS_BWR_BLE_AFC_LATCH_AFC_ON_ACCESS_MATCH(base, value) (BME_BFI16(&BLE_RF_REGS_BLE_AFC_REG(base), ((uint16_t)(value) << BLE_RF_REGS_BLE_AFC_LATCH_AFC_ON_ACCESS_MATCH_SHIFT), BLE_RF_REGS_BLE_AFC_LATCH_AFC_ON_ACCESS_MATCH_SHIFT, BLE_RF_REGS_BLE_AFC_LATCH_AFC_ON_ACCESS_MATCH_WIDTH))
/*@}*/

/*******************************************************************************
 * BLE_RF_REGS_BLE_BSM - Bluetooth Low Energy BSM
 ******************************************************************************/

/*!
 * @brief BLE_RF_REGS_BLE_BSM - Bluetooth Low Energy BSM (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire BLE_RF_REGS_BLE_BSM register
 */
/*@{*/
#define BLE_RF_REGS_RD_BLE_BSM(base) (BLE_RF_REGS_BLE_BSM_REG(base))
#define BLE_RF_REGS_WR_BLE_BSM(base, value) (BLE_RF_REGS_BLE_BSM_REG(base) = (value))
#define BLE_RF_REGS_RMW_BLE_BSM(base, mask, value) (BLE_RF_REGS_WR_BLE_BSM(base, (BLE_RF_REGS_RD_BLE_BSM(base) & ~(mask)) | (value)))
#define BLE_RF_REGS_SET_BLE_BSM(base, value) (BME_OR16(&BLE_RF_REGS_BLE_BSM_REG(base), (uint16_t)(value)))
#define BLE_RF_REGS_CLR_BLE_BSM(base, value) (BME_AND16(&BLE_RF_REGS_BLE_BSM_REG(base), (uint16_t)(~(value))))
#define BLE_RF_REGS_TOG_BLE_BSM(base, value) (BME_XOR16(&BLE_RF_REGS_BLE_BSM_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual BLE_RF_REGS_BLE_BSM bitfields
 */

/*!
 * @name Register BLE_RF_REGS_BLE_BSM, field BSM_EN_BLE[0] (RW)
 *
 * When enabled, the 3 BSM outputs (BSM_DATA, BSM_FRAME, and BSM_BLK) appear on
 * the BSM interface pins of the SoC. In Apache, these are alternate, muxed-GPIO
 * pins, so the appropriate port programming is required.
 *
 * Values:
 * - 0b0 - BLE Bit Streaming Mode disabled
 * - 0b1 - BLE Bit Streaming Mode enabled
 */
/*@{*/
/*! @brief Read current value of the BLE_RF_REGS_BLE_BSM_BSM_EN_BLE field. */
#define BLE_RF_REGS_RD_BLE_BSM_BSM_EN_BLE(base) ((BLE_RF_REGS_BLE_BSM_REG(base) & BLE_RF_REGS_BLE_BSM_BSM_EN_BLE_MASK) >> BLE_RF_REGS_BLE_BSM_BSM_EN_BLE_SHIFT)
#define BLE_RF_REGS_BRD_BLE_BSM_BSM_EN_BLE(base) (BME_UBFX16(&BLE_RF_REGS_BLE_BSM_REG(base), BLE_RF_REGS_BLE_BSM_BSM_EN_BLE_SHIFT, BLE_RF_REGS_BLE_BSM_BSM_EN_BLE_WIDTH))

/*! @brief Set the BSM_EN_BLE field to a new value. */
#define BLE_RF_REGS_WR_BLE_BSM_BSM_EN_BLE(base, value) (BLE_RF_REGS_RMW_BLE_BSM(base, BLE_RF_REGS_BLE_BSM_BSM_EN_BLE_MASK, BLE_RF_REGS_BLE_BSM_BSM_EN_BLE(value)))
#define BLE_RF_REGS_BWR_BLE_BSM_BSM_EN_BLE(base, value) (BME_BFI16(&BLE_RF_REGS_BLE_BSM_REG(base), ((uint16_t)(value) << BLE_RF_REGS_BLE_BSM_BSM_EN_BLE_SHIFT), BLE_RF_REGS_BLE_BSM_BSM_EN_BLE_SHIFT, BLE_RF_REGS_BLE_BSM_BSM_EN_BLE_WIDTH))
/*@}*/

/*
 * MKW40Z4 CMP
 *
 * High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
 *
 * Registers defined in this header file:
 * - CMP_CR0 - CMP Control Register 0
 * - CMP_CR1 - CMP Control Register 1
 * - CMP_FPR - CMP Filter Period Register
 * - CMP_SCR - CMP Status and Control Register
 * - CMP_DACCR - DAC Control Register
 * - CMP_MUXCR - MUX Control Register
 */

#define CMP_INSTANCE_COUNT (1U) /*!< Number of instances of the CMP module. */
#define CMP0_IDX (0U) /*!< Instance number for CMP0. */

/*******************************************************************************
 * CMP_CR0 - CMP Control Register 0
 ******************************************************************************/

/*!
 * @brief CMP_CR0 - CMP Control Register 0 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_CR0 register
 */
/*@{*/
#define CMP_RD_CR0(base)         (CMP_CR0_REG(base))
#define CMP_WR_CR0(base, value)  (CMP_CR0_REG(base) = (value))
#define CMP_RMW_CR0(base, mask, value) (CMP_WR_CR0(base, (CMP_RD_CR0(base) & ~(mask)) | (value)))
#define CMP_SET_CR0(base, value) (BME_OR8(&CMP_CR0_REG(base), (uint8_t)(value)))
#define CMP_CLR_CR0(base, value) (BME_AND8(&CMP_CR0_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_CR0(base, value) (BME_XOR8(&CMP_CR0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_CR0 bitfields
 */

/*!
 * @name Register CMP_CR0, field HYSTCTR[1:0] (RW)
 *
 * Defines the programmable hysteresis level. The hysteresis values associated
 * with each level are device-specific. See the Data Sheet of the device for the
 * exact values.
 *
 * Values:
 * - 0b00 - Level 0 The hard block output has no hysteresis internally.
 * - 0b01 - Level 1 The hard block output has 20 mv hysteresis internally.
 * - 0b10 - Level 2 The hard block output has 40 mv hysteresis internally.
 * - 0b11 - Level 3 The hard block output has 60 mv hysteresis internally.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR0_HYSTCTR field. */
#define CMP_RD_CR0_HYSTCTR(base) ((CMP_CR0_REG(base) & CMP_CR0_HYSTCTR_MASK) >> CMP_CR0_HYSTCTR_SHIFT)
#define CMP_BRD_CR0_HYSTCTR(base) (BME_UBFX8(&CMP_CR0_REG(base), CMP_CR0_HYSTCTR_SHIFT, CMP_CR0_HYSTCTR_WIDTH))

/*! @brief Set the HYSTCTR field to a new value. */
#define CMP_WR_CR0_HYSTCTR(base, value) (CMP_RMW_CR0(base, CMP_CR0_HYSTCTR_MASK, CMP_CR0_HYSTCTR(value)))
#define CMP_BWR_CR0_HYSTCTR(base, value) (BME_BFI8(&CMP_CR0_REG(base), ((uint8_t)(value) << CMP_CR0_HYSTCTR_SHIFT), CMP_CR0_HYSTCTR_SHIFT, CMP_CR0_HYSTCTR_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR0, field FILTER_CNT[6:4] (RW)
 *
 * Represents the number of consecutive samples that must agree prior to the
 * comparator ouput filter accepting a new output state. For information regarding
 * filter programming and latency, see the Functional descriptionThe CMP module
 * can be used to compare two analog input voltages applied to INP and INM. .
 *
 * Values:
 * - 0b000 - Filter is disabled. SE = 0, COUT = COUTA.
 * - 0b001 - One sample must agree. The comparator output is simply sampled.
 * - 0b010 - 2 consecutive samples must agree.
 * - 0b011 - 3 consecutive samples must agree.
 * - 0b100 - 4 consecutive samples must agree.
 * - 0b101 - 5 consecutive samples must agree.
 * - 0b110 - 6 consecutive samples must agree.
 * - 0b111 - 7 consecutive samples must agree.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR0_FILTER_CNT field. */
#define CMP_RD_CR0_FILTER_CNT(base) ((CMP_CR0_REG(base) & CMP_CR0_FILTER_CNT_MASK) >> CMP_CR0_FILTER_CNT_SHIFT)
#define CMP_BRD_CR0_FILTER_CNT(base) (BME_UBFX8(&CMP_CR0_REG(base), CMP_CR0_FILTER_CNT_SHIFT, CMP_CR0_FILTER_CNT_WIDTH))

/*! @brief Set the FILTER_CNT field to a new value. */
#define CMP_WR_CR0_FILTER_CNT(base, value) (CMP_RMW_CR0(base, CMP_CR0_FILTER_CNT_MASK, CMP_CR0_FILTER_CNT(value)))
#define CMP_BWR_CR0_FILTER_CNT(base, value) (BME_BFI8(&CMP_CR0_REG(base), ((uint8_t)(value) << CMP_CR0_FILTER_CNT_SHIFT), CMP_CR0_FILTER_CNT_SHIFT, CMP_CR0_FILTER_CNT_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_CR1 - CMP Control Register 1
 ******************************************************************************/

/*!
 * @brief CMP_CR1 - CMP Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_CR1 register
 */
/*@{*/
#define CMP_RD_CR1(base)         (CMP_CR1_REG(base))
#define CMP_WR_CR1(base, value)  (CMP_CR1_REG(base) = (value))
#define CMP_RMW_CR1(base, mask, value) (CMP_WR_CR1(base, (CMP_RD_CR1(base) & ~(mask)) | (value)))
#define CMP_SET_CR1(base, value) (BME_OR8(&CMP_CR1_REG(base), (uint8_t)(value)))
#define CMP_CLR_CR1(base, value) (BME_AND8(&CMP_CR1_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_CR1(base, value) (BME_XOR8(&CMP_CR1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_CR1 bitfields
 */

/*!
 * @name Register CMP_CR1, field EN[0] (RW)
 *
 * Enables the Analog Comparator module. When the module is not enabled, it
 * remains in the off state, and consumes no power. When the user selects the same
 * input from analog mux to the positive and negative port, the comparator is
 * disabled automatically.
 *
 * Values:
 * - 0b0 - Analog Comparator is disabled.
 * - 0b1 - Analog Comparator is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_EN field. */
#define CMP_RD_CR1_EN(base)  ((CMP_CR1_REG(base) & CMP_CR1_EN_MASK) >> CMP_CR1_EN_SHIFT)
#define CMP_BRD_CR1_EN(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_EN_SHIFT, CMP_CR1_EN_WIDTH))

/*! @brief Set the EN field to a new value. */
#define CMP_WR_CR1_EN(base, value) (CMP_RMW_CR1(base, CMP_CR1_EN_MASK, CMP_CR1_EN(value)))
#define CMP_BWR_CR1_EN(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_EN_SHIFT), CMP_CR1_EN_SHIFT, CMP_CR1_EN_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field OPE[1] (RW)
 *
 * Operation of the OPE bit varies, depending on how it is encapsulated within
 * the system. There are two cases.
 *
 * Values:
 * - 0b0 - CMPO is not available on the associated CMPO output pin. For devices
 *     that use explicit muxing control to I/O pin functions (DSC and non-Flexis
 *     ColdFire devices): If the comparator does not own the pin, this field has
 *     no effect.
 * - 0b1 - CMPO is available on the associated CMPO output pin. For devices that
 *     use explicit muxing control to I/O pin functions (DSC and non-Flexis
 *     ColdFire devices): The comparator output (CMPO) is driven out on the
 *     associated CMPO output pin if the comparator owns the pin. If the comparator does
 *     not own the field, this bit has no effect.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_OPE field. */
#define CMP_RD_CR1_OPE(base) ((CMP_CR1_REG(base) & CMP_CR1_OPE_MASK) >> CMP_CR1_OPE_SHIFT)
#define CMP_BRD_CR1_OPE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_OPE_SHIFT, CMP_CR1_OPE_WIDTH))

/*! @brief Set the OPE field to a new value. */
#define CMP_WR_CR1_OPE(base, value) (CMP_RMW_CR1(base, CMP_CR1_OPE_MASK, CMP_CR1_OPE(value)))
#define CMP_BWR_CR1_OPE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_OPE_SHIFT), CMP_CR1_OPE_SHIFT, CMP_CR1_OPE_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field COS[2] (RW)
 *
 * Values:
 * - 0b0 - Set the filtered comparator output (CMPO) to equal COUT.
 * - 0b1 - Set the unfiltered comparator output (CMPO) to equal COUTA.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_COS field. */
#define CMP_RD_CR1_COS(base) ((CMP_CR1_REG(base) & CMP_CR1_COS_MASK) >> CMP_CR1_COS_SHIFT)
#define CMP_BRD_CR1_COS(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_COS_SHIFT, CMP_CR1_COS_WIDTH))

/*! @brief Set the COS field to a new value. */
#define CMP_WR_CR1_COS(base, value) (CMP_RMW_CR1(base, CMP_CR1_COS_MASK, CMP_CR1_COS(value)))
#define CMP_BWR_CR1_COS(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_COS_SHIFT), CMP_CR1_COS_SHIFT, CMP_CR1_COS_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field INV[3] (RW)
 *
 * Allows selection of the polarity of the analog comparator function. It is
 * also driven to the COUT output, on both the device pin and as SCR[COUT], when
 * OPE=0.
 *
 * Values:
 * - 0b0 - Does not invert the comparator output.
 * - 0b1 - Inverts the comparator output.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_INV field. */
#define CMP_RD_CR1_INV(base) ((CMP_CR1_REG(base) & CMP_CR1_INV_MASK) >> CMP_CR1_INV_SHIFT)
#define CMP_BRD_CR1_INV(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_INV_SHIFT, CMP_CR1_INV_WIDTH))

/*! @brief Set the INV field to a new value. */
#define CMP_WR_CR1_INV(base, value) (CMP_RMW_CR1(base, CMP_CR1_INV_MASK, CMP_CR1_INV(value)))
#define CMP_BWR_CR1_INV(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_INV_SHIFT), CMP_CR1_INV_SHIFT, CMP_CR1_INV_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field PMODE[4] (RW)
 *
 * See the electrical specifications table in the device Data Sheet for details.
 *
 * Values:
 * - 0b0 - Low-Speed (LS) Comparison mode selected. In this mode, CMP has slower
 *     output propagation delay and lower current consumption.
 * - 0b1 - High-Speed (HS) Comparison mode selected. In this mode, CMP has
 *     faster output propagation delay and higher current consumption.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_PMODE field. */
#define CMP_RD_CR1_PMODE(base) ((CMP_CR1_REG(base) & CMP_CR1_PMODE_MASK) >> CMP_CR1_PMODE_SHIFT)
#define CMP_BRD_CR1_PMODE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_PMODE_SHIFT, CMP_CR1_PMODE_WIDTH))

/*! @brief Set the PMODE field to a new value. */
#define CMP_WR_CR1_PMODE(base, value) (CMP_RMW_CR1(base, CMP_CR1_PMODE_MASK, CMP_CR1_PMODE(value)))
#define CMP_BWR_CR1_PMODE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_PMODE_SHIFT), CMP_CR1_PMODE_SHIFT, CMP_CR1_PMODE_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field TRIGM[5] (RW)
 *
 * CMP and DAC are configured to CMP Trigger mode when CMP_CR1[TRIGM] is set to
 * 1. In addition, the CMP should be enabled. If the DAC is to be used as a
 * reference to the CMP, it should also be enabled. CMP Trigger mode depends on an
 * external timer resource to periodically enable the CMP and 6-bit DAC in order to
 * generate a triggered compare. Upon setting TRIGM, the CMP and DAC are placed
 * in a standby state until an external timer resource trigger is received. See
 * the chip configuration for details about the external timer resource.
 *
 * Values:
 * - 0b0 - Trigger mode is disabled.
 * - 0b1 - Trigger mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_TRIGM field. */
#define CMP_RD_CR1_TRIGM(base) ((CMP_CR1_REG(base) & CMP_CR1_TRIGM_MASK) >> CMP_CR1_TRIGM_SHIFT)
#define CMP_BRD_CR1_TRIGM(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_TRIGM_SHIFT, CMP_CR1_TRIGM_WIDTH))

/*! @brief Set the TRIGM field to a new value. */
#define CMP_WR_CR1_TRIGM(base, value) (CMP_RMW_CR1(base, CMP_CR1_TRIGM_MASK, CMP_CR1_TRIGM(value)))
#define CMP_BWR_CR1_TRIGM(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_TRIGM_SHIFT), CMP_CR1_TRIGM_SHIFT, CMP_CR1_TRIGM_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field WE[6] (RW)
 *
 * The CMP does not support window compare function and a 0 must always be
 * written to WE.
 *
 * Values:
 * - 0b0 - Windowing mode is not selected.
 * - 0b1 - Windowing mode is selected.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_WE field. */
#define CMP_RD_CR1_WE(base)  ((CMP_CR1_REG(base) & CMP_CR1_WE_MASK) >> CMP_CR1_WE_SHIFT)
#define CMP_BRD_CR1_WE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_WE_SHIFT, CMP_CR1_WE_WIDTH))

/*! @brief Set the WE field to a new value. */
#define CMP_WR_CR1_WE(base, value) (CMP_RMW_CR1(base, CMP_CR1_WE_MASK, CMP_CR1_WE(value)))
#define CMP_BWR_CR1_WE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_WE_SHIFT), CMP_CR1_WE_SHIFT, CMP_CR1_WE_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field SE[7] (RW)
 *
 * SE must be clear to 0 and usage of sample operation is limited to a divided
 * version of the bus clock.
 *
 * Values:
 * - 0b0 - Sampling mode is not selected.
 * - 0b1 - Sampling mode is selected.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_SE field. */
#define CMP_RD_CR1_SE(base)  ((CMP_CR1_REG(base) & CMP_CR1_SE_MASK) >> CMP_CR1_SE_SHIFT)
#define CMP_BRD_CR1_SE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_SE_SHIFT, CMP_CR1_SE_WIDTH))

/*! @brief Set the SE field to a new value. */
#define CMP_WR_CR1_SE(base, value) (CMP_RMW_CR1(base, CMP_CR1_SE_MASK, CMP_CR1_SE(value)))
#define CMP_BWR_CR1_SE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_SE_SHIFT), CMP_CR1_SE_SHIFT, CMP_CR1_SE_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_FPR - CMP Filter Period Register
 ******************************************************************************/

/*!
 * @brief CMP_FPR - CMP Filter Period Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_FPR register
 */
/*@{*/
#define CMP_RD_FPR(base)         (CMP_FPR_REG(base))
#define CMP_WR_FPR(base, value)  (CMP_FPR_REG(base) = (value))
#define CMP_RMW_FPR(base, mask, value) (CMP_WR_FPR(base, (CMP_RD_FPR(base) & ~(mask)) | (value)))
#define CMP_SET_FPR(base, value) (BME_OR8(&CMP_FPR_REG(base), (uint8_t)(value)))
#define CMP_CLR_FPR(base, value) (BME_AND8(&CMP_FPR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_FPR(base, value) (BME_XOR8(&CMP_FPR_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CMP_SCR - CMP Status and Control Register
 ******************************************************************************/

/*!
 * @brief CMP_SCR - CMP Status and Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_SCR register
 */
/*@{*/
#define CMP_RD_SCR(base)         (CMP_SCR_REG(base))
#define CMP_WR_SCR(base, value)  (CMP_SCR_REG(base) = (value))
#define CMP_RMW_SCR(base, mask, value) (CMP_WR_SCR(base, (CMP_RD_SCR(base) & ~(mask)) | (value)))
#define CMP_SET_SCR(base, value) (BME_OR8(&CMP_SCR_REG(base), (uint8_t)(value)))
#define CMP_CLR_SCR(base, value) (BME_AND8(&CMP_SCR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_SCR(base, value) (BME_XOR8(&CMP_SCR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_SCR bitfields
 */

/*!
 * @name Register CMP_SCR, field COUT[0] (RO)
 *
 * Returns the current value of the Analog Comparator output, when read. The
 * field is reset to 0 and will read as CR1[INV] when the Analog Comparator module
 * is disabled, that is, when CR1[EN] = 0. Writes to this field are ignored.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_COUT field. */
#define CMP_RD_SCR_COUT(base) ((CMP_SCR_REG(base) & CMP_SCR_COUT_MASK) >> CMP_SCR_COUT_SHIFT)
#define CMP_BRD_SCR_COUT(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_COUT_SHIFT, CMP_SCR_COUT_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field CFF[1] (W1C)
 *
 * Detects a falling-edge on COUT, when set, during normal operation. CFF is
 * cleared by writing 1 to it. During Stop modes, CFF is level sensitive .
 *
 * Values:
 * - 0b0 - Falling-edge on COUT has not been detected.
 * - 0b1 - Falling-edge on COUT has occurred.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_CFF field. */
#define CMP_RD_SCR_CFF(base) ((CMP_SCR_REG(base) & CMP_SCR_CFF_MASK) >> CMP_SCR_CFF_SHIFT)
#define CMP_BRD_SCR_CFF(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_CFF_SHIFT, CMP_SCR_CFF_WIDTH))

/*! @brief Set the CFF field to a new value. */
#define CMP_WR_SCR_CFF(base, value) (CMP_RMW_SCR(base, (CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_CFF(value)))
#define CMP_BWR_SCR_CFF(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_CFF_SHIFT), CMP_SCR_CFF_SHIFT, CMP_SCR_CFF_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field CFR[2] (W1C)
 *
 * Detects a rising-edge on COUT, when set, during normal operation. CFR is
 * cleared by writing 1 to it. During Stop modes, CFR is level sensitive .
 *
 * Values:
 * - 0b0 - Rising-edge on COUT has not been detected.
 * - 0b1 - Rising-edge on COUT has occurred.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_CFR field. */
#define CMP_RD_SCR_CFR(base) ((CMP_SCR_REG(base) & CMP_SCR_CFR_MASK) >> CMP_SCR_CFR_SHIFT)
#define CMP_BRD_SCR_CFR(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_CFR_SHIFT, CMP_SCR_CFR_WIDTH))

/*! @brief Set the CFR field to a new value. */
#define CMP_WR_SCR_CFR(base, value) (CMP_RMW_SCR(base, (CMP_SCR_CFR_MASK | CMP_SCR_CFF_MASK), CMP_SCR_CFR(value)))
#define CMP_BWR_SCR_CFR(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_CFR_SHIFT), CMP_SCR_CFR_SHIFT, CMP_SCR_CFR_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field IEF[3] (RW)
 *
 * Enables the CFF interrupt from the CMP. When this field is set, an interrupt
 * will be asserted when CFF is set.
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_IEF field. */
#define CMP_RD_SCR_IEF(base) ((CMP_SCR_REG(base) & CMP_SCR_IEF_MASK) >> CMP_SCR_IEF_SHIFT)
#define CMP_BRD_SCR_IEF(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_IEF_SHIFT, CMP_SCR_IEF_WIDTH))

/*! @brief Set the IEF field to a new value. */
#define CMP_WR_SCR_IEF(base, value) (CMP_RMW_SCR(base, (CMP_SCR_IEF_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_IEF(value)))
#define CMP_BWR_SCR_IEF(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_IEF_SHIFT), CMP_SCR_IEF_SHIFT, CMP_SCR_IEF_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field IER[4] (RW)
 *
 * Enables the CFR interrupt from the CMP. When this field is set, an interrupt
 * will be asserted when CFR is set.
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_IER field. */
#define CMP_RD_SCR_IER(base) ((CMP_SCR_REG(base) & CMP_SCR_IER_MASK) >> CMP_SCR_IER_SHIFT)
#define CMP_BRD_SCR_IER(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_IER_SHIFT, CMP_SCR_IER_WIDTH))

/*! @brief Set the IER field to a new value. */
#define CMP_WR_SCR_IER(base, value) (CMP_RMW_SCR(base, (CMP_SCR_IER_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_IER(value)))
#define CMP_BWR_SCR_IER(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_IER_SHIFT), CMP_SCR_IER_SHIFT, CMP_SCR_IER_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field DMAEN[6] (RW)
 *
 * Enables the DMA transfer triggered from the CMP module. When this field is
 * set, a DMA request is asserted when CFR or CFF is set.
 *
 * Values:
 * - 0b0 - DMA is disabled.
 * - 0b1 - DMA is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_DMAEN field. */
#define CMP_RD_SCR_DMAEN(base) ((CMP_SCR_REG(base) & CMP_SCR_DMAEN_MASK) >> CMP_SCR_DMAEN_SHIFT)
#define CMP_BRD_SCR_DMAEN(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_DMAEN_SHIFT, CMP_SCR_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define CMP_WR_SCR_DMAEN(base, value) (CMP_RMW_SCR(base, (CMP_SCR_DMAEN_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_DMAEN(value)))
#define CMP_BWR_SCR_DMAEN(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_DMAEN_SHIFT), CMP_SCR_DMAEN_SHIFT, CMP_SCR_DMAEN_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_DACCR - DAC Control Register
 ******************************************************************************/

/*!
 * @brief CMP_DACCR - DAC Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_DACCR register
 */
/*@{*/
#define CMP_RD_DACCR(base)       (CMP_DACCR_REG(base))
#define CMP_WR_DACCR(base, value) (CMP_DACCR_REG(base) = (value))
#define CMP_RMW_DACCR(base, mask, value) (CMP_WR_DACCR(base, (CMP_RD_DACCR(base) & ~(mask)) | (value)))
#define CMP_SET_DACCR(base, value) (BME_OR8(&CMP_DACCR_REG(base), (uint8_t)(value)))
#define CMP_CLR_DACCR(base, value) (BME_AND8(&CMP_DACCR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_DACCR(base, value) (BME_XOR8(&CMP_DACCR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_DACCR bitfields
 */

/*!
 * @name Register CMP_DACCR, field VOSEL[5:0] (RW)
 *
 * Selects an output voltage from one of 64 distinct levels. DACO = (V in /64) *
 * (VOSEL[5:0] + 1) , so the DACO range is from V in /64 to V in .
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_VOSEL field. */
#define CMP_RD_DACCR_VOSEL(base) ((CMP_DACCR_REG(base) & CMP_DACCR_VOSEL_MASK) >> CMP_DACCR_VOSEL_SHIFT)
#define CMP_BRD_DACCR_VOSEL(base) (BME_UBFX8(&CMP_DACCR_REG(base), CMP_DACCR_VOSEL_SHIFT, CMP_DACCR_VOSEL_WIDTH))

/*! @brief Set the VOSEL field to a new value. */
#define CMP_WR_DACCR_VOSEL(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_VOSEL_MASK, CMP_DACCR_VOSEL(value)))
#define CMP_BWR_DACCR_VOSEL(base, value) (BME_BFI8(&CMP_DACCR_REG(base), ((uint8_t)(value) << CMP_DACCR_VOSEL_SHIFT), CMP_DACCR_VOSEL_SHIFT, CMP_DACCR_VOSEL_WIDTH))
/*@}*/

/*!
 * @name Register CMP_DACCR, field VRSEL[6] (RW)
 *
 * Values:
 * - 0b0 - Vin1 is selected as resistor ladder network supply reference.
 * - 0b1 - Vin2 is selected as resistor ladder network supply reference.
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_VRSEL field. */
#define CMP_RD_DACCR_VRSEL(base) ((CMP_DACCR_REG(base) & CMP_DACCR_VRSEL_MASK) >> CMP_DACCR_VRSEL_SHIFT)
#define CMP_BRD_DACCR_VRSEL(base) (BME_UBFX8(&CMP_DACCR_REG(base), CMP_DACCR_VRSEL_SHIFT, CMP_DACCR_VRSEL_WIDTH))

/*! @brief Set the VRSEL field to a new value. */
#define CMP_WR_DACCR_VRSEL(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_VRSEL_MASK, CMP_DACCR_VRSEL(value)))
#define CMP_BWR_DACCR_VRSEL(base, value) (BME_BFI8(&CMP_DACCR_REG(base), ((uint8_t)(value) << CMP_DACCR_VRSEL_SHIFT), CMP_DACCR_VRSEL_SHIFT, CMP_DACCR_VRSEL_WIDTH))
/*@}*/

/*!
 * @name Register CMP_DACCR, field DACEN[7] (RW)
 *
 * Enables the DAC. When the DAC is disabled, it is powered down to conserve
 * power.
 *
 * Values:
 * - 0b0 - DAC is disabled.
 * - 0b1 - DAC is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_DACEN field. */
#define CMP_RD_DACCR_DACEN(base) ((CMP_DACCR_REG(base) & CMP_DACCR_DACEN_MASK) >> CMP_DACCR_DACEN_SHIFT)
#define CMP_BRD_DACCR_DACEN(base) (BME_UBFX8(&CMP_DACCR_REG(base), CMP_DACCR_DACEN_SHIFT, CMP_DACCR_DACEN_WIDTH))

/*! @brief Set the DACEN field to a new value. */
#define CMP_WR_DACCR_DACEN(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_DACEN_MASK, CMP_DACCR_DACEN(value)))
#define CMP_BWR_DACCR_DACEN(base, value) (BME_BFI8(&CMP_DACCR_REG(base), ((uint8_t)(value) << CMP_DACCR_DACEN_SHIFT), CMP_DACCR_DACEN_SHIFT, CMP_DACCR_DACEN_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_MUXCR - MUX Control Register
 ******************************************************************************/

/*!
 * @brief CMP_MUXCR - MUX Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_MUXCR register
 */
/*@{*/
#define CMP_RD_MUXCR(base)       (CMP_MUXCR_REG(base))
#define CMP_WR_MUXCR(base, value) (CMP_MUXCR_REG(base) = (value))
#define CMP_RMW_MUXCR(base, mask, value) (CMP_WR_MUXCR(base, (CMP_RD_MUXCR(base) & ~(mask)) | (value)))
#define CMP_SET_MUXCR(base, value) (BME_OR8(&CMP_MUXCR_REG(base), (uint8_t)(value)))
#define CMP_CLR_MUXCR(base, value) (BME_AND8(&CMP_MUXCR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_MUXCR(base, value) (BME_XOR8(&CMP_MUXCR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_MUXCR bitfields
 */

/*!
 * @name Register CMP_MUXCR, field MSEL[2:0] (RW)
 *
 * Determines which input is selected for the minus input of the comparator. For
 * INx inputs, see CMP, DAC, and ANMUX block diagrams. When an inappropriate
 * operation selects the same input for both muxes, the comparator automatically
 * shuts down to prevent itself from becoming a noise generator.
 *
 * Values:
 * - 0b000 - IN0
 * - 0b001 - IN1
 * - 0b010 - IN2
 * - 0b011 - IN3
 * - 0b100 - IN4
 * - 0b101 - IN5
 * - 0b110 - IN6
 * - 0b111 - IN7
 */
/*@{*/
/*! @brief Read current value of the CMP_MUXCR_MSEL field. */
#define CMP_RD_MUXCR_MSEL(base) ((CMP_MUXCR_REG(base) & CMP_MUXCR_MSEL_MASK) >> CMP_MUXCR_MSEL_SHIFT)
#define CMP_BRD_MUXCR_MSEL(base) (BME_UBFX8(&CMP_MUXCR_REG(base), CMP_MUXCR_MSEL_SHIFT, CMP_MUXCR_MSEL_WIDTH))

/*! @brief Set the MSEL field to a new value. */
#define CMP_WR_MUXCR_MSEL(base, value) (CMP_RMW_MUXCR(base, CMP_MUXCR_MSEL_MASK, CMP_MUXCR_MSEL(value)))
#define CMP_BWR_MUXCR_MSEL(base, value) (BME_BFI8(&CMP_MUXCR_REG(base), ((uint8_t)(value) << CMP_MUXCR_MSEL_SHIFT), CMP_MUXCR_MSEL_SHIFT, CMP_MUXCR_MSEL_WIDTH))
/*@}*/

/*!
 * @name Register CMP_MUXCR, field PSEL[5:3] (RW)
 *
 * Determines which input is selected for the plus input of the comparator. For
 * INx inputs, see CMP, DAC, and ANMUX block diagrams. When an inappropriate
 * operation selects the same input for both muxes, the comparator automatically
 * shuts down to prevent itself from becoming a noise generator.
 *
 * Values:
 * - 0b000 - IN0
 * - 0b001 - IN1
 * - 0b010 - IN2
 * - 0b011 - IN3
 * - 0b100 - IN4
 * - 0b101 - IN5
 * - 0b110 - IN6
 * - 0b111 - IN7
 */
/*@{*/
/*! @brief Read current value of the CMP_MUXCR_PSEL field. */
#define CMP_RD_MUXCR_PSEL(base) ((CMP_MUXCR_REG(base) & CMP_MUXCR_PSEL_MASK) >> CMP_MUXCR_PSEL_SHIFT)
#define CMP_BRD_MUXCR_PSEL(base) (BME_UBFX8(&CMP_MUXCR_REG(base), CMP_MUXCR_PSEL_SHIFT, CMP_MUXCR_PSEL_WIDTH))

/*! @brief Set the PSEL field to a new value. */
#define CMP_WR_MUXCR_PSEL(base, value) (CMP_RMW_MUXCR(base, CMP_MUXCR_PSEL_MASK, CMP_MUXCR_PSEL(value)))
#define CMP_BWR_MUXCR_PSEL(base, value) (BME_BFI8(&CMP_MUXCR_REG(base), ((uint8_t)(value) << CMP_MUXCR_PSEL_SHIFT), CMP_MUXCR_PSEL_SHIFT, CMP_MUXCR_PSEL_WIDTH))
/*@}*/

/*!
 * @name Register CMP_MUXCR, field PSTM[7] (RW)
 *
 * This bit is used to enable to MUX pass through mode. Pass through mode is
 * always available but for some devices this feature must be always disabled due to
 * the lack of package pins.
 *
 * Values:
 * - 0b0 - Pass Through Mode is disabled.
 * - 0b1 - Pass Through Mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_MUXCR_PSTM field. */
#define CMP_RD_MUXCR_PSTM(base) ((CMP_MUXCR_REG(base) & CMP_MUXCR_PSTM_MASK) >> CMP_MUXCR_PSTM_SHIFT)
#define CMP_BRD_MUXCR_PSTM(base) (BME_UBFX8(&CMP_MUXCR_REG(base), CMP_MUXCR_PSTM_SHIFT, CMP_MUXCR_PSTM_WIDTH))

/*! @brief Set the PSTM field to a new value. */
#define CMP_WR_MUXCR_PSTM(base, value) (CMP_RMW_MUXCR(base, CMP_MUXCR_PSTM_MASK, CMP_MUXCR_PSTM(value)))
#define CMP_BWR_MUXCR_PSTM(base, value) (BME_BFI8(&CMP_MUXCR_REG(base), ((uint8_t)(value) << CMP_MUXCR_PSTM_SHIFT), CMP_MUXCR_PSTM_SHIFT, CMP_MUXCR_PSTM_WIDTH))
/*@}*/

/*
 * MKW40Z4 CMT
 *
 * Carrier Modulator Transmitter
 *
 * Registers defined in this header file:
 * - CMT_CGH1 - CMT Carrier Generator High Data Register 1
 * - CMT_CGL1 - CMT Carrier Generator Low Data Register 1
 * - CMT_CGH2 - CMT Carrier Generator High Data Register 2
 * - CMT_CGL2 - CMT Carrier Generator Low Data Register 2
 * - CMT_OC - CMT Output Control Register
 * - CMT_MSC - CMT Modulator Status and Control Register
 * - CMT_CMD1 - CMT Modulator Data Register Mark High
 * - CMT_CMD2 - CMT Modulator Data Register Mark Low
 * - CMT_CMD3 - CMT Modulator Data Register Space High
 * - CMT_CMD4 - CMT Modulator Data Register Space Low
 * - CMT_PPS - CMT Primary Prescaler Register
 * - CMT_DMA - CMT Direct Memory Access Register
 */

#define CMT_INSTANCE_COUNT (1U) /*!< Number of instances of the CMT module. */
#define CMT_IDX (0U) /*!< Instance number for CMT. */

/*******************************************************************************
 * CMT_CGH1 - CMT Carrier Generator High Data Register 1
 ******************************************************************************/

/*!
 * @brief CMT_CGH1 - CMT Carrier Generator High Data Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This data register contains the primary high value for generating the carrier
 * output.
 */
/*!
 * @name Constants and macros for entire CMT_CGH1 register
 */
/*@{*/
#define CMT_RD_CGH1(base)        (CMT_CGH1_REG(base))
#define CMT_WR_CGH1(base, value) (CMT_CGH1_REG(base) = (value))
#define CMT_RMW_CGH1(base, mask, value) (CMT_WR_CGH1(base, (CMT_RD_CGH1(base) & ~(mask)) | (value)))
#define CMT_SET_CGH1(base, value) (BME_OR8(&CMT_CGH1_REG(base), (uint8_t)(value)))
#define CMT_CLR_CGH1(base, value) (BME_AND8(&CMT_CGH1_REG(base), (uint8_t)(~(value))))
#define CMT_TOG_CGH1(base, value) (BME_XOR8(&CMT_CGH1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CMT_CGL1 - CMT Carrier Generator Low Data Register 1
 ******************************************************************************/

/*!
 * @brief CMT_CGL1 - CMT Carrier Generator Low Data Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This data register contains the primary low value for generating the carrier
 * output.
 */
/*!
 * @name Constants and macros for entire CMT_CGL1 register
 */
/*@{*/
#define CMT_RD_CGL1(base)        (CMT_CGL1_REG(base))
#define CMT_WR_CGL1(base, value) (CMT_CGL1_REG(base) = (value))
#define CMT_RMW_CGL1(base, mask, value) (CMT_WR_CGL1(base, (CMT_RD_CGL1(base) & ~(mask)) | (value)))
#define CMT_SET_CGL1(base, value) (BME_OR8(&CMT_CGL1_REG(base), (uint8_t)(value)))
#define CMT_CLR_CGL1(base, value) (BME_AND8(&CMT_CGL1_REG(base), (uint8_t)(~(value))))
#define CMT_TOG_CGL1(base, value) (BME_XOR8(&CMT_CGL1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CMT_CGH2 - CMT Carrier Generator High Data Register 2
 ******************************************************************************/

/*!
 * @brief CMT_CGH2 - CMT Carrier Generator High Data Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This data register contains the secondary high value for generating the
 * carrier output.
 */
/*!
 * @name Constants and macros for entire CMT_CGH2 register
 */
/*@{*/
#define CMT_RD_CGH2(base)        (CMT_CGH2_REG(base))
#define CMT_WR_CGH2(base, value) (CMT_CGH2_REG(base) = (value))
#define CMT_RMW_CGH2(base, mask, value) (CMT_WR_CGH2(base, (CMT_RD_CGH2(base) & ~(mask)) | (value)))
#define CMT_SET_CGH2(base, value) (BME_OR8(&CMT_CGH2_REG(base), (uint8_t)(value)))
#define CMT_CLR_CGH2(base, value) (BME_AND8(&CMT_CGH2_REG(base), (uint8_t)(~(value))))
#define CMT_TOG_CGH2(base, value) (BME_XOR8(&CMT_CGH2_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CMT_CGL2 - CMT Carrier Generator Low Data Register 2
 ******************************************************************************/

/*!
 * @brief CMT_CGL2 - CMT Carrier Generator Low Data Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This data register contains the secondary low value for generating the
 * carrier output.
 */
/*!
 * @name Constants and macros for entire CMT_CGL2 register
 */
/*@{*/
#define CMT_RD_CGL2(base)        (CMT_CGL2_REG(base))
#define CMT_WR_CGL2(base, value) (CMT_CGL2_REG(base) = (value))
#define CMT_RMW_CGL2(base, mask, value) (CMT_WR_CGL2(base, (CMT_RD_CGL2(base) & ~(mask)) | (value)))
#define CMT_SET_CGL2(base, value) (BME_OR8(&CMT_CGL2_REG(base), (uint8_t)(value)))
#define CMT_CLR_CGL2(base, value) (BME_AND8(&CMT_CGL2_REG(base), (uint8_t)(~(value))))
#define CMT_TOG_CGL2(base, value) (BME_XOR8(&CMT_CGL2_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CMT_OC - CMT Output Control Register
 ******************************************************************************/

/*!
 * @brief CMT_OC - CMT Output Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is used to control the IRO signal of the CMT module.
 */
/*!
 * @name Constants and macros for entire CMT_OC register
 */
/*@{*/
#define CMT_RD_OC(base)          (CMT_OC_REG(base))
#define CMT_WR_OC(base, value)   (CMT_OC_REG(base) = (value))
#define CMT_RMW_OC(base, mask, value) (CMT_WR_OC(base, (CMT_RD_OC(base) & ~(mask)) | (value)))
#define CMT_SET_OC(base, value)  (BME_OR8(&CMT_OC_REG(base), (uint8_t)(value)))
#define CMT_CLR_OC(base, value)  (BME_AND8(&CMT_OC_REG(base), (uint8_t)(~(value))))
#define CMT_TOG_OC(base, value)  (BME_XOR8(&CMT_OC_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMT_OC bitfields
 */

/*!
 * @name Register CMT_OC, field IROPEN[5] (RW)
 *
 * Enables and disables the IRO signal. When the IRO signal is enabled, it is an
 * output that drives out either the CMT transmitter output or the state of IROL
 * depending on whether MSC[MCGEN] is set or not. Also, the state of output is
 * either inverted or non-inverted, depending on the state of CMTPOL. When the IRO
 * signal is disabled, it is in a high-impedance state and is unable to draw any
 * current. This signal is disabled during reset.
 *
 * Values:
 * - 0b0 - The IRO signal is disabled.
 * - 0b1 - The IRO signal is enabled as output.
 */
/*@{*/
/*! @brief Read current value of the CMT_OC_IROPEN field. */
#define CMT_RD_OC_IROPEN(base) ((CMT_OC_REG(base) & CMT_OC_IROPEN_MASK) >> CMT_OC_IROPEN_SHIFT)
#define CMT_BRD_OC_IROPEN(base) (BME_UBFX8(&CMT_OC_REG(base), CMT_OC_IROPEN_SHIFT, CMT_OC_IROPEN_WIDTH))

/*! @brief Set the IROPEN field to a new value. */
#define CMT_WR_OC_IROPEN(base, value) (CMT_RMW_OC(base, CMT_OC_IROPEN_MASK, CMT_OC_IROPEN(value)))
#define CMT_BWR_OC_IROPEN(base, value) (BME_BFI8(&CMT_OC_REG(base), ((uint8_t)(value) << CMT_OC_IROPEN_SHIFT), CMT_OC_IROPEN_SHIFT, CMT_OC_IROPEN_WIDTH))
/*@}*/

/*!
 * @name Register CMT_OC, field CMTPOL[6] (RW)
 *
 * Controls the polarity of the IRO signal.
 *
 * Values:
 * - 0b0 - The IRO signal is active-low.
 * - 0b1 - The IRO signal is active-high.
 */
/*@{*/
/*! @brief Read current value of the CMT_OC_CMTPOL field. */
#define CMT_RD_OC_CMTPOL(base) ((CMT_OC_REG(base) & CMT_OC_CMTPOL_MASK) >> CMT_OC_CMTPOL_SHIFT)
#define CMT_BRD_OC_CMTPOL(base) (BME_UBFX8(&CMT_OC_REG(base), CMT_OC_CMTPOL_SHIFT, CMT_OC_CMTPOL_WIDTH))

/*! @brief Set the CMTPOL field to a new value. */
#define CMT_WR_OC_CMTPOL(base, value) (CMT_RMW_OC(base, CMT_OC_CMTPOL_MASK, CMT_OC_CMTPOL(value)))
#define CMT_BWR_OC_CMTPOL(base, value) (BME_BFI8(&CMT_OC_REG(base), ((uint8_t)(value) << CMT_OC_CMTPOL_SHIFT), CMT_OC_CMTPOL_SHIFT, CMT_OC_CMTPOL_WIDTH))
/*@}*/

/*!
 * @name Register CMT_OC, field IROL[7] (RW)
 *
 * Reads the state of the IRO latch. Writing to IROL changes the state of the
 * IRO signal when MSC[MCGEN] is cleared and IROPEN is set.
 */
/*@{*/
/*! @brief Read current value of the CMT_OC_IROL field. */
#define CMT_RD_OC_IROL(base) ((CMT_OC_REG(base) & CMT_OC_IROL_MASK) >> CMT_OC_IROL_SHIFT)
#define CMT_BRD_OC_IROL(base) (BME_UBFX8(&CMT_OC_REG(base), CMT_OC_IROL_SHIFT, CMT_OC_IROL_WIDTH))

/*! @brief Set the IROL field to a new value. */
#define CMT_WR_OC_IROL(base, value) (CMT_RMW_OC(base, CMT_OC_IROL_MASK, CMT_OC_IROL(value)))
#define CMT_BWR_OC_IROL(base, value) (BME_BFI8(&CMT_OC_REG(base), ((uint8_t)(value) << CMT_OC_IROL_SHIFT), CMT_OC_IROL_SHIFT, CMT_OC_IROL_WIDTH))
/*@}*/

/*******************************************************************************
 * CMT_MSC - CMT Modulator Status and Control Register
 ******************************************************************************/

/*!
 * @brief CMT_MSC - CMT Modulator Status and Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains the modulator and carrier generator enable (MCGEN),
 * end of cycle interrupt enable (EOCIE), FSK mode select (FSK), baseband enable
 * (BASE), extended space (EXSPC), prescaler (CMTDIV) bits, and the end of cycle
 * (EOCF) status bit.
 */
/*!
 * @name Constants and macros for entire CMT_MSC register
 */
/*@{*/
#define CMT_RD_MSC(base)         (CMT_MSC_REG(base))
#define CMT_WR_MSC(base, value)  (CMT_MSC_REG(base) = (value))
#define CMT_RMW_MSC(base, mask, value) (CMT_WR_MSC(base, (CMT_RD_MSC(base) & ~(mask)) | (value)))
#define CMT_SET_MSC(base, value) (BME_OR8(&CMT_MSC_REG(base), (uint8_t)(value)))
#define CMT_CLR_MSC(base, value) (BME_AND8(&CMT_MSC_REG(base), (uint8_t)(~(value))))
#define CMT_TOG_MSC(base, value) (BME_XOR8(&CMT_MSC_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMT_MSC bitfields
 */

/*!
 * @name Register CMT_MSC, field MCGEN[0] (RW)
 *
 * Setting MCGEN will initialize the carrier generator and modulator and will
 * enable all clocks. When enabled, the carrier generator and modulator will
 * function continuously. When MCGEN is cleared, the current modulator cycle will be
 * allowed to expire before all carrier and modulator clocks are disabled to save
 * power and the modulator output is forced low. To prevent spurious operation,
 * the user should initialize all data and control registers before enabling the
 * system.
 *
 * Values:
 * - 0b0 - Modulator and carrier generator disabled
 * - 0b1 - Modulator and carrier generator enabled
 */
/*@{*/
/*! @brief Read current value of the CMT_MSC_MCGEN field. */
#define CMT_RD_MSC_MCGEN(base) ((CMT_MSC_REG(base) & CMT_MSC_MCGEN_MASK) >> CMT_MSC_MCGEN_SHIFT)
#define CMT_BRD_MSC_MCGEN(base) (BME_UBFX8(&CMT_MSC_REG(base), CMT_MSC_MCGEN_SHIFT, CMT_MSC_MCGEN_WIDTH))

/*! @brief Set the MCGEN field to a new value. */
#define CMT_WR_MSC_MCGEN(base, value) (CMT_RMW_MSC(base, CMT_MSC_MCGEN_MASK, CMT_MSC_MCGEN(value)))
#define CMT_BWR_MSC_MCGEN(base, value) (BME_BFI8(&CMT_MSC_REG(base), ((uint8_t)(value) << CMT_MSC_MCGEN_SHIFT), CMT_MSC_MCGEN_SHIFT, CMT_MSC_MCGEN_WIDTH))
/*@}*/

/*!
 * @name Register CMT_MSC, field EOCIE[1] (RW)
 *
 * Requests to enable a CPU interrupt when EOCF is set if EOCIE is high.
 *
 * Values:
 * - 0b0 - CPU interrupt is disabled.
 * - 0b1 - CPU interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMT_MSC_EOCIE field. */
#define CMT_RD_MSC_EOCIE(base) ((CMT_MSC_REG(base) & CMT_MSC_EOCIE_MASK) >> CMT_MSC_EOCIE_SHIFT)
#define CMT_BRD_MSC_EOCIE(base) (BME_UBFX8(&CMT_MSC_REG(base), CMT_MSC_EOCIE_SHIFT, CMT_MSC_EOCIE_WIDTH))

/*! @brief Set the EOCIE field to a new value. */
#define CMT_WR_MSC_EOCIE(base, value) (CMT_RMW_MSC(base, CMT_MSC_EOCIE_MASK, CMT_MSC_EOCIE(value)))
#define CMT_BWR_MSC_EOCIE(base, value) (BME_BFI8(&CMT_MSC_REG(base), ((uint8_t)(value) << CMT_MSC_EOCIE_SHIFT), CMT_MSC_EOCIE_SHIFT, CMT_MSC_EOCIE_WIDTH))
/*@}*/

/*!
 * @name Register CMT_MSC, field FSK[2] (RW)
 *
 * Enables FSK operation.
 *
 * Values:
 * - 0b0 - The CMT operates in Time or Baseband mode.
 * - 0b1 - The CMT operates in FSK mode.
 */
/*@{*/
/*! @brief Read current value of the CMT_MSC_FSK field. */
#define CMT_RD_MSC_FSK(base) ((CMT_MSC_REG(base) & CMT_MSC_FSK_MASK) >> CMT_MSC_FSK_SHIFT)
#define CMT_BRD_MSC_FSK(base) (BME_UBFX8(&CMT_MSC_REG(base), CMT_MSC_FSK_SHIFT, CMT_MSC_FSK_WIDTH))

/*! @brief Set the FSK field to a new value. */
#define CMT_WR_MSC_FSK(base, value) (CMT_RMW_MSC(base, CMT_MSC_FSK_MASK, CMT_MSC_FSK(value)))
#define CMT_BWR_MSC_FSK(base, value) (BME_BFI8(&CMT_MSC_REG(base), ((uint8_t)(value) << CMT_MSC_FSK_SHIFT), CMT_MSC_FSK_SHIFT, CMT_MSC_FSK_WIDTH))
/*@}*/

/*!
 * @name Register CMT_MSC, field BASE[3] (RW)
 *
 * When set, BASE disables the carrier generator and forces the carrier output
 * high for generation of baseband protocols. When BASE is cleared, the carrier
 * generator is enabled and the carrier output toggles at the frequency determined
 * by values stored in the carrier data registers. This field is cleared by
 * reset. This field is not double-buffered and must not be written to during a
 * transmission.
 *
 * Values:
 * - 0b0 - Baseband mode is disabled.
 * - 0b1 - Baseband mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMT_MSC_BASE field. */
#define CMT_RD_MSC_BASE(base) ((CMT_MSC_REG(base) & CMT_MSC_BASE_MASK) >> CMT_MSC_BASE_SHIFT)
#define CMT_BRD_MSC_BASE(base) (BME_UBFX8(&CMT_MSC_REG(base), CMT_MSC_BASE_SHIFT, CMT_MSC_BASE_WIDTH))

/*! @brief Set the BASE field to a new value. */
#define CMT_WR_MSC_BASE(base, value) (CMT_RMW_MSC(base, CMT_MSC_BASE_MASK, CMT_MSC_BASE(value)))
#define CMT_BWR_MSC_BASE(base, value) (BME_BFI8(&CMT_MSC_REG(base), ((uint8_t)(value) << CMT_MSC_BASE_SHIFT), CMT_MSC_BASE_SHIFT, CMT_MSC_BASE_WIDTH))
/*@}*/

/*!
 * @name Register CMT_MSC, field EXSPC[4] (RW)
 *
 * Enables the extended space operation.
 *
 * Values:
 * - 0b0 - Extended space is disabled.
 * - 0b1 - Extended space is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMT_MSC_EXSPC field. */
#define CMT_RD_MSC_EXSPC(base) ((CMT_MSC_REG(base) & CMT_MSC_EXSPC_MASK) >> CMT_MSC_EXSPC_SHIFT)
#define CMT_BRD_MSC_EXSPC(base) (BME_UBFX8(&CMT_MSC_REG(base), CMT_MSC_EXSPC_SHIFT, CMT_MSC_EXSPC_WIDTH))

/*! @brief Set the EXSPC field to a new value. */
#define CMT_WR_MSC_EXSPC(base, value) (CMT_RMW_MSC(base, CMT_MSC_EXSPC_MASK, CMT_MSC_EXSPC(value)))
#define CMT_BWR_MSC_EXSPC(base, value) (BME_BFI8(&CMT_MSC_REG(base), ((uint8_t)(value) << CMT_MSC_EXSPC_SHIFT), CMT_MSC_EXSPC_SHIFT, CMT_MSC_EXSPC_WIDTH))
/*@}*/

/*!
 * @name Register CMT_MSC, field CMTDIV[6:5] (RW)
 *
 * Causes the CMT to be clocked at the IF signal frequency, or the IF frequency
 * divided by 2 ,4, or 8 . This field must not be changed during a transmission
 * because it is not double-buffered.
 *
 * Values:
 * - 0b00 - IF * 1
 * - 0b01 - IF * 2
 * - 0b10 - IF * 4
 * - 0b11 - IF * 8
 */
/*@{*/
/*! @brief Read current value of the CMT_MSC_CMTDIV field. */
#define CMT_RD_MSC_CMTDIV(base) ((CMT_MSC_REG(base) & CMT_MSC_CMTDIV_MASK) >> CMT_MSC_CMTDIV_SHIFT)
#define CMT_BRD_MSC_CMTDIV(base) (BME_UBFX8(&CMT_MSC_REG(base), CMT_MSC_CMTDIV_SHIFT, CMT_MSC_CMTDIV_WIDTH))

/*! @brief Set the CMTDIV field to a new value. */
#define CMT_WR_MSC_CMTDIV(base, value) (CMT_RMW_MSC(base, CMT_MSC_CMTDIV_MASK, CMT_MSC_CMTDIV(value)))
#define CMT_BWR_MSC_CMTDIV(base, value) (BME_BFI8(&CMT_MSC_REG(base), ((uint8_t)(value) << CMT_MSC_CMTDIV_SHIFT), CMT_MSC_CMTDIV_SHIFT, CMT_MSC_CMTDIV_WIDTH))
/*@}*/

/*!
 * @name Register CMT_MSC, field EOCF[7] (RO)
 *
 * Sets when: The modulator is not currently active and MCGEN is set to begin
 * the initial CMT transmission. At the end of each modulation cycle while MCGEN is
 * set. This is recognized when a match occurs between the contents of the space
 * period register and the down counter. At this time, the counter is
 * initialized with, possibly new contents of the mark period buffer, CMD1 and CMD2, and
 * the space period register is loaded with, possibly new contents of the space
 * period buffer, CMD3 and CMD4. This flag is cleared by reading MSC followed by an
 * access of CMD2 or CMD4, or by the DMA transfer.
 *
 * Values:
 * - 0b0 - End of modulation cycle has not occured since the flag last cleared.
 * - 0b1 - End of modulator cycle has occurred.
 */
/*@{*/
/*! @brief Read current value of the CMT_MSC_EOCF field. */
#define CMT_RD_MSC_EOCF(base) ((CMT_MSC_REG(base) & CMT_MSC_EOCF_MASK) >> CMT_MSC_EOCF_SHIFT)
#define CMT_BRD_MSC_EOCF(base) (BME_UBFX8(&CMT_MSC_REG(base), CMT_MSC_EOCF_SHIFT, CMT_MSC_EOCF_WIDTH))
/*@}*/

/*******************************************************************************
 * CMT_CMD1 - CMT Modulator Data Register Mark High
 ******************************************************************************/

/*!
 * @brief CMT_CMD1 - CMT Modulator Data Register Mark High (RW)
 *
 * Reset value: 0x00U
 *
 * The contents of this register are transferred to the modulator down counter
 * upon the completion of a modulation period.
 */
/*!
 * @name Constants and macros for entire CMT_CMD1 register
 */
/*@{*/
#define CMT_RD_CMD1(base)        (CMT_CMD1_REG(base))
#define CMT_WR_CMD1(base, value) (CMT_CMD1_REG(base) = (value))
#define CMT_RMW_CMD1(base, mask, value) (CMT_WR_CMD1(base, (CMT_RD_CMD1(base) & ~(mask)) | (value)))
#define CMT_SET_CMD1(base, value) (BME_OR8(&CMT_CMD1_REG(base), (uint8_t)(value)))
#define CMT_CLR_CMD1(base, value) (BME_AND8(&CMT_CMD1_REG(base), (uint8_t)(~(value))))
#define CMT_TOG_CMD1(base, value) (BME_XOR8(&CMT_CMD1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CMT_CMD2 - CMT Modulator Data Register Mark Low
 ******************************************************************************/

/*!
 * @brief CMT_CMD2 - CMT Modulator Data Register Mark Low (RW)
 *
 * Reset value: 0x00U
 *
 * The contents of this register are transferred to the modulator down counter
 * upon the completion of a modulation period.
 */
/*!
 * @name Constants and macros for entire CMT_CMD2 register
 */
/*@{*/
#define CMT_RD_CMD2(base)        (CMT_CMD2_REG(base))
#define CMT_WR_CMD2(base, value) (CMT_CMD2_REG(base) = (value))
#define CMT_RMW_CMD2(base, mask, value) (CMT_WR_CMD2(base, (CMT_RD_CMD2(base) & ~(mask)) | (value)))
#define CMT_SET_CMD2(base, value) (BME_OR8(&CMT_CMD2_REG(base), (uint8_t)(value)))
#define CMT_CLR_CMD2(base, value) (BME_AND8(&CMT_CMD2_REG(base), (uint8_t)(~(value))))
#define CMT_TOG_CMD2(base, value) (BME_XOR8(&CMT_CMD2_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CMT_CMD3 - CMT Modulator Data Register Space High
 ******************************************************************************/

/*!
 * @brief CMT_CMD3 - CMT Modulator Data Register Space High (RW)
 *
 * Reset value: 0x00U
 *
 * The contents of this register are transferred to the space period register
 * upon the completion of a modulation period.
 */
/*!
 * @name Constants and macros for entire CMT_CMD3 register
 */
/*@{*/
#define CMT_RD_CMD3(base)        (CMT_CMD3_REG(base))
#define CMT_WR_CMD3(base, value) (CMT_CMD3_REG(base) = (value))
#define CMT_RMW_CMD3(base, mask, value) (CMT_WR_CMD3(base, (CMT_RD_CMD3(base) & ~(mask)) | (value)))
#define CMT_SET_CMD3(base, value) (BME_OR8(&CMT_CMD3_REG(base), (uint8_t)(value)))
#define CMT_CLR_CMD3(base, value) (BME_AND8(&CMT_CMD3_REG(base), (uint8_t)(~(value))))
#define CMT_TOG_CMD3(base, value) (BME_XOR8(&CMT_CMD3_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CMT_CMD4 - CMT Modulator Data Register Space Low
 ******************************************************************************/

/*!
 * @brief CMT_CMD4 - CMT Modulator Data Register Space Low (RW)
 *
 * Reset value: 0x00U
 *
 * The contents of this register are transferred to the space period register
 * upon the completion of a modulation period.
 */
/*!
 * @name Constants and macros for entire CMT_CMD4 register
 */
/*@{*/
#define CMT_RD_CMD4(base)        (CMT_CMD4_REG(base))
#define CMT_WR_CMD4(base, value) (CMT_CMD4_REG(base) = (value))
#define CMT_RMW_CMD4(base, mask, value) (CMT_WR_CMD4(base, (CMT_RD_CMD4(base) & ~(mask)) | (value)))
#define CMT_SET_CMD4(base, value) (BME_OR8(&CMT_CMD4_REG(base), (uint8_t)(value)))
#define CMT_CLR_CMD4(base, value) (BME_AND8(&CMT_CMD4_REG(base), (uint8_t)(~(value))))
#define CMT_TOG_CMD4(base, value) (BME_XOR8(&CMT_CMD4_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CMT_PPS - CMT Primary Prescaler Register
 ******************************************************************************/

/*!
 * @brief CMT_PPS - CMT Primary Prescaler Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is used to set the Primary Prescaler Divider field (PPSDIV).
 */
/*!
 * @name Constants and macros for entire CMT_PPS register
 */
/*@{*/
#define CMT_RD_PPS(base)         (CMT_PPS_REG(base))
#define CMT_WR_PPS(base, value)  (CMT_PPS_REG(base) = (value))
#define CMT_RMW_PPS(base, mask, value) (CMT_WR_PPS(base, (CMT_RD_PPS(base) & ~(mask)) | (value)))
#define CMT_SET_PPS(base, value) (BME_OR8(&CMT_PPS_REG(base), (uint8_t)(value)))
#define CMT_CLR_PPS(base, value) (BME_AND8(&CMT_PPS_REG(base), (uint8_t)(~(value))))
#define CMT_TOG_PPS(base, value) (BME_XOR8(&CMT_PPS_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMT_PPS bitfields
 */

/*!
 * @name Register CMT_PPS, field PPSDIV[3:0] (RW)
 *
 * Divides the CMT clock to generate the Intermediate Frequency clock enable to
 * the secondary prescaler.
 *
 * Values:
 * - 0b0000 - Bus clock * 1
 * - 0b0001 - Bus clock * 2
 * - 0b0010 - Bus clock * 3
 * - 0b0011 - Bus clock * 4
 * - 0b0100 - Bus clock * 5
 * - 0b0101 - Bus clock * 6
 * - 0b0110 - Bus clock * 7
 * - 0b0111 - Bus clock * 8
 * - 0b1000 - Bus clock * 9
 * - 0b1001 - Bus clock * 10
 * - 0b1010 - Bus clock * 11
 * - 0b1011 - Bus clock * 12
 * - 0b1100 - Bus clock * 13
 * - 0b1101 - Bus clock * 14
 * - 0b1110 - Bus clock * 15
 * - 0b1111 - Bus clock * 16
 */
/*@{*/
/*! @brief Read current value of the CMT_PPS_PPSDIV field. */
#define CMT_RD_PPS_PPSDIV(base) ((CMT_PPS_REG(base) & CMT_PPS_PPSDIV_MASK) >> CMT_PPS_PPSDIV_SHIFT)
#define CMT_BRD_PPS_PPSDIV(base) (BME_UBFX8(&CMT_PPS_REG(base), CMT_PPS_PPSDIV_SHIFT, CMT_PPS_PPSDIV_WIDTH))

/*! @brief Set the PPSDIV field to a new value. */
#define CMT_WR_PPS_PPSDIV(base, value) (CMT_RMW_PPS(base, CMT_PPS_PPSDIV_MASK, CMT_PPS_PPSDIV(value)))
#define CMT_BWR_PPS_PPSDIV(base, value) (BME_BFI8(&CMT_PPS_REG(base), ((uint8_t)(value) << CMT_PPS_PPSDIV_SHIFT), CMT_PPS_PPSDIV_SHIFT, CMT_PPS_PPSDIV_WIDTH))
/*@}*/

/*******************************************************************************
 * CMT_DMA - CMT Direct Memory Access Register
 ******************************************************************************/

/*!
 * @brief CMT_DMA - CMT Direct Memory Access Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is used to enable/disable direct memory access (DMA).
 */
/*!
 * @name Constants and macros for entire CMT_DMA register
 */
/*@{*/
#define CMT_RD_DMA(base)         (CMT_DMA_REG(base))
#define CMT_WR_DMA(base, value)  (CMT_DMA_REG(base) = (value))
#define CMT_RMW_DMA(base, mask, value) (CMT_WR_DMA(base, (CMT_RD_DMA(base) & ~(mask)) | (value)))
#define CMT_SET_DMA(base, value) (BME_OR8(&CMT_DMA_REG(base), (uint8_t)(value)))
#define CMT_CLR_DMA(base, value) (BME_AND8(&CMT_DMA_REG(base), (uint8_t)(~(value))))
#define CMT_TOG_DMA(base, value) (BME_XOR8(&CMT_DMA_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMT_DMA bitfields
 */

/*!
 * @name Register CMT_DMA, field DMA[0] (RW)
 *
 * Enables the DMA protocol.
 *
 * Values:
 * - 0b0 - DMA transfer request and done are disabled.
 * - 0b1 - DMA transfer request and done are enabled.
 */
/*@{*/
/*! @brief Read current value of the CMT_DMA_DMA field. */
#define CMT_RD_DMA_DMA(base) ((CMT_DMA_REG(base) & CMT_DMA_DMA_MASK) >> CMT_DMA_DMA_SHIFT)
#define CMT_BRD_DMA_DMA(base) (BME_UBFX8(&CMT_DMA_REG(base), CMT_DMA_DMA_SHIFT, CMT_DMA_DMA_WIDTH))

/*! @brief Set the DMA field to a new value. */
#define CMT_WR_DMA_DMA(base, value) (CMT_RMW_DMA(base, CMT_DMA_DMA_MASK, CMT_DMA_DMA(value)))
#define CMT_BWR_DMA_DMA(base, value) (BME_BFI8(&CMT_DMA_REG(base), ((uint8_t)(value) << CMT_DMA_DMA_SHIFT), CMT_DMA_DMA_SHIFT, CMT_DMA_DMA_WIDTH))
/*@}*/

/*
 * MKW40Z4 DAC
 *
 * 12-Bit Digital-to-Analog Converter
 *
 * Registers defined in this header file:
 * - DAC_DATL - DAC Data Low Register
 * - DAC_DATH - DAC Data High Register
 * - DAC_SR - DAC Status Register
 * - DAC_C0 - DAC Control Register
 * - DAC_C1 - DAC Control Register 1
 * - DAC_C2 - DAC Control Register 2
 */

#define DAC_INSTANCE_COUNT (1U) /*!< Number of instances of the DAC module. */
#define DAC0_IDX (0U) /*!< Instance number for DAC0. */

/*******************************************************************************
 * DAC_DATL - DAC Data Low Register
 ******************************************************************************/

/*!
 * @brief DAC_DATL - DAC Data Low Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire DAC_DATL register
 */
/*@{*/
#define DAC_RD_DATL(base, index) (DAC_DATL_REG(base, index))
#define DAC_WR_DATL(base, index, value) (DAC_DATL_REG(base, index) = (value))
#define DAC_RMW_DATL(base, index, mask, value) (DAC_WR_DATL(base, index, (DAC_RD_DATL(base, index) & ~(mask)) | (value)))
#define DAC_SET_DATL(base, index, value) (BME_OR8(&DAC_DATL_REG(base, index), (uint8_t)(value)))
#define DAC_CLR_DATL(base, index, value) (BME_AND8(&DAC_DATL_REG(base, index), (uint8_t)(~(value))))
#define DAC_TOG_DATL(base, index, value) (BME_XOR8(&DAC_DATL_REG(base, index), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * DAC_DATH - DAC Data High Register
 ******************************************************************************/

/*!
 * @brief DAC_DATH - DAC Data High Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire DAC_DATH register
 */
/*@{*/
#define DAC_RD_DATH(base, index) (DAC_DATH_REG(base, index))
#define DAC_WR_DATH(base, index, value) (DAC_DATH_REG(base, index) = (value))
#define DAC_RMW_DATH(base, index, mask, value) (DAC_WR_DATH(base, index, (DAC_RD_DATH(base, index) & ~(mask)) | (value)))
#define DAC_SET_DATH(base, index, value) (BME_OR8(&DAC_DATH_REG(base, index), (uint8_t)(value)))
#define DAC_CLR_DATH(base, index, value) (BME_AND8(&DAC_DATH_REG(base, index), (uint8_t)(~(value))))
#define DAC_TOG_DATH(base, index, value) (BME_XOR8(&DAC_DATH_REG(base, index), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_DATH bitfields
 */

/*!
 * @name Register DAC_DATH, field DATA1[3:0] (RW)
 *
 * When the DAC Buffer is not enabled, DATA[11:0] controls the output voltage
 * based on the following formula. V out = V in * (1 + DACDAT0[11:0])/4096 When the
 * DAC buffer is enabled, DATA[11:0] is mapped to the 16-word buffer.
 */
/*@{*/
/*! @brief Read current value of the DAC_DATH_DATA1 field. */
#define DAC_RD_DATH_DATA1(base, index) ((DAC_DATH_REG(base, index) & DAC_DATH_DATA1_MASK) >> DAC_DATH_DATA1_SHIFT)
#define DAC_BRD_DATH_DATA1(base, index) (BME_UBFX8(&DAC_DATH_REG(base, index), DAC_DATH_DATA1_SHIFT, DAC_DATH_DATA1_WIDTH))

/*! @brief Set the DATA1 field to a new value. */
#define DAC_WR_DATH_DATA1(base, index, value) (DAC_RMW_DATH(base, index, DAC_DATH_DATA1_MASK, DAC_DATH_DATA1(value)))
#define DAC_BWR_DATH_DATA1(base, index, value) (BME_BFI8(&DAC_DATH_REG(base, index), ((uint8_t)(value) << DAC_DATH_DATA1_SHIFT), DAC_DATH_DATA1_SHIFT, DAC_DATH_DATA1_WIDTH))
/*@}*/

/*******************************************************************************
 * DAC_SR - DAC Status Register
 ******************************************************************************/

/*!
 * @brief DAC_SR - DAC Status Register (RW)
 *
 * Reset value: 0x02U
 *
 * If DMA is enabled, the flags can be cleared automatically by DMA when the DMA
 * request is done. Writing 0 to a field clears it whereas writing 1 has no
 * effect. After reset, DACBFRPTF is set and can be cleared by software, if needed.
 * The flags are set only when the data buffer status is changed. Do not use
 * 32/16-bit accesses to this register.
 */
/*!
 * @name Constants and macros for entire DAC_SR register
 */
/*@{*/
#define DAC_RD_SR(base)          (DAC_SR_REG(base))
#define DAC_WR_SR(base, value)   (DAC_SR_REG(base) = (value))
#define DAC_RMW_SR(base, mask, value) (DAC_WR_SR(base, (DAC_RD_SR(base) & ~(mask)) | (value)))
#define DAC_SET_SR(base, value)  (BME_OR8(&DAC_SR_REG(base), (uint8_t)(value)))
#define DAC_CLR_SR(base, value)  (BME_AND8(&DAC_SR_REG(base), (uint8_t)(~(value))))
#define DAC_TOG_SR(base, value)  (BME_XOR8(&DAC_SR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_SR bitfields
 */

/*!
 * @name Register DAC_SR, field DACBFRPBF[0] (RW)
 *
 * Values:
 * - 0b0 - The DAC buffer read pointer is not equal to C2[DACBFUP].
 * - 0b1 - The DAC buffer read pointer is equal to C2[DACBFUP].
 */
/*@{*/
/*! @brief Read current value of the DAC_SR_DACBFRPBF field. */
#define DAC_RD_SR_DACBFRPBF(base) ((DAC_SR_REG(base) & DAC_SR_DACBFRPBF_MASK) >> DAC_SR_DACBFRPBF_SHIFT)
#define DAC_BRD_SR_DACBFRPBF(base) (BME_UBFX8(&DAC_SR_REG(base), DAC_SR_DACBFRPBF_SHIFT, DAC_SR_DACBFRPBF_WIDTH))

/*! @brief Set the DACBFRPBF field to a new value. */
#define DAC_WR_SR_DACBFRPBF(base, value) (DAC_RMW_SR(base, DAC_SR_DACBFRPBF_MASK, DAC_SR_DACBFRPBF(value)))
#define DAC_BWR_SR_DACBFRPBF(base, value) (BME_BFI8(&DAC_SR_REG(base), ((uint8_t)(value) << DAC_SR_DACBFRPBF_SHIFT), DAC_SR_DACBFRPBF_SHIFT, DAC_SR_DACBFRPBF_WIDTH))
/*@}*/

/*!
 * @name Register DAC_SR, field DACBFRPTF[1] (RW)
 *
 * Values:
 * - 0b0 - The DAC buffer read pointer is not zero.
 * - 0b1 - The DAC buffer read pointer is zero.
 */
/*@{*/
/*! @brief Read current value of the DAC_SR_DACBFRPTF field. */
#define DAC_RD_SR_DACBFRPTF(base) ((DAC_SR_REG(base) & DAC_SR_DACBFRPTF_MASK) >> DAC_SR_DACBFRPTF_SHIFT)
#define DAC_BRD_SR_DACBFRPTF(base) (BME_UBFX8(&DAC_SR_REG(base), DAC_SR_DACBFRPTF_SHIFT, DAC_SR_DACBFRPTF_WIDTH))

/*! @brief Set the DACBFRPTF field to a new value. */
#define DAC_WR_SR_DACBFRPTF(base, value) (DAC_RMW_SR(base, DAC_SR_DACBFRPTF_MASK, DAC_SR_DACBFRPTF(value)))
#define DAC_BWR_SR_DACBFRPTF(base, value) (BME_BFI8(&DAC_SR_REG(base), ((uint8_t)(value) << DAC_SR_DACBFRPTF_SHIFT), DAC_SR_DACBFRPTF_SHIFT, DAC_SR_DACBFRPTF_WIDTH))
/*@}*/

/*******************************************************************************
 * DAC_C0 - DAC Control Register
 ******************************************************************************/

/*!
 * @brief DAC_C0 - DAC Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * Do not use 32- or 16-bit accesses to this register.
 */
/*!
 * @name Constants and macros for entire DAC_C0 register
 */
/*@{*/
#define DAC_RD_C0(base)          (DAC_C0_REG(base))
#define DAC_WR_C0(base, value)   (DAC_C0_REG(base) = (value))
#define DAC_RMW_C0(base, mask, value) (DAC_WR_C0(base, (DAC_RD_C0(base) & ~(mask)) | (value)))
#define DAC_SET_C0(base, value)  (BME_OR8(&DAC_C0_REG(base), (uint8_t)(value)))
#define DAC_CLR_C0(base, value)  (BME_AND8(&DAC_C0_REG(base), (uint8_t)(~(value))))
#define DAC_TOG_C0(base, value)  (BME_XOR8(&DAC_C0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_C0 bitfields
 */

/*!
 * @name Register DAC_C0, field DACBBIEN[0] (RW)
 *
 * Values:
 * - 0b0 - The DAC buffer read pointer bottom flag interrupt is disabled.
 * - 0b1 - The DAC buffer read pointer bottom flag interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACBBIEN field. */
#define DAC_RD_C0_DACBBIEN(base) ((DAC_C0_REG(base) & DAC_C0_DACBBIEN_MASK) >> DAC_C0_DACBBIEN_SHIFT)
#define DAC_BRD_C0_DACBBIEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACBBIEN_SHIFT, DAC_C0_DACBBIEN_WIDTH))

/*! @brief Set the DACBBIEN field to a new value. */
#define DAC_WR_C0_DACBBIEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACBBIEN_MASK, DAC_C0_DACBBIEN(value)))
#define DAC_BWR_C0_DACBBIEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACBBIEN_SHIFT), DAC_C0_DACBBIEN_SHIFT, DAC_C0_DACBBIEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACBTIEN[1] (RW)
 *
 * Values:
 * - 0b0 - The DAC buffer read pointer top flag interrupt is disabled.
 * - 0b1 - The DAC buffer read pointer top flag interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACBTIEN field. */
#define DAC_RD_C0_DACBTIEN(base) ((DAC_C0_REG(base) & DAC_C0_DACBTIEN_MASK) >> DAC_C0_DACBTIEN_SHIFT)
#define DAC_BRD_C0_DACBTIEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACBTIEN_SHIFT, DAC_C0_DACBTIEN_WIDTH))

/*! @brief Set the DACBTIEN field to a new value. */
#define DAC_WR_C0_DACBTIEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACBTIEN_MASK, DAC_C0_DACBTIEN(value)))
#define DAC_BWR_C0_DACBTIEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACBTIEN_SHIFT), DAC_C0_DACBTIEN_SHIFT, DAC_C0_DACBTIEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field LPEN[3] (RW)
 *
 * See the 12-bit DAC electrical characteristics of the device data sheet for
 * details on the impact of the modes below.
 *
 * Values:
 * - 0b0 - High-Power mode
 * - 0b1 - Low-Power mode
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_LPEN field. */
#define DAC_RD_C0_LPEN(base) ((DAC_C0_REG(base) & DAC_C0_LPEN_MASK) >> DAC_C0_LPEN_SHIFT)
#define DAC_BRD_C0_LPEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_LPEN_SHIFT, DAC_C0_LPEN_WIDTH))

/*! @brief Set the LPEN field to a new value. */
#define DAC_WR_C0_LPEN(base, value) (DAC_RMW_C0(base, DAC_C0_LPEN_MASK, DAC_C0_LPEN(value)))
#define DAC_BWR_C0_LPEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_LPEN_SHIFT), DAC_C0_LPEN_SHIFT, DAC_C0_LPEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACSWTRG[4] (WORZ)
 *
 * Active high. This is a write-only field, which always reads 0. If DAC
 * software trigger is selected and buffer is enabled, writing 1 to this field will
 * advance the buffer read pointer once.
 *
 * Values:
 * - 0b0 - The DAC soft trigger is not valid.
 * - 0b1 - The DAC soft trigger is valid.
 */
/*@{*/
/*! @brief Set the DACSWTRG field to a new value. */
#define DAC_WR_C0_DACSWTRG(base, value) (DAC_RMW_C0(base, DAC_C0_DACSWTRG_MASK, DAC_C0_DACSWTRG(value)))
#define DAC_BWR_C0_DACSWTRG(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACSWTRG_SHIFT), DAC_C0_DACSWTRG_SHIFT, DAC_C0_DACSWTRG_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACTRGSEL[5] (RW)
 *
 * Values:
 * - 0b0 - The DAC hardware trigger is selected.
 * - 0b1 - The DAC software trigger is selected.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACTRGSEL field. */
#define DAC_RD_C0_DACTRGSEL(base) ((DAC_C0_REG(base) & DAC_C0_DACTRGSEL_MASK) >> DAC_C0_DACTRGSEL_SHIFT)
#define DAC_BRD_C0_DACTRGSEL(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACTRGSEL_SHIFT, DAC_C0_DACTRGSEL_WIDTH))

/*! @brief Set the DACTRGSEL field to a new value. */
#define DAC_WR_C0_DACTRGSEL(base, value) (DAC_RMW_C0(base, DAC_C0_DACTRGSEL_MASK, DAC_C0_DACTRGSEL(value)))
#define DAC_BWR_C0_DACTRGSEL(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACTRGSEL_SHIFT), DAC_C0_DACTRGSEL_SHIFT, DAC_C0_DACTRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACRFS[6] (RW)
 *
 * Values:
 * - 0b0 - The DAC selects DACREF_1 as the reference voltage.
 * - 0b1 - The DAC selects DACREF_2 as the reference voltage.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACRFS field. */
#define DAC_RD_C0_DACRFS(base) ((DAC_C0_REG(base) & DAC_C0_DACRFS_MASK) >> DAC_C0_DACRFS_SHIFT)
#define DAC_BRD_C0_DACRFS(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACRFS_SHIFT, DAC_C0_DACRFS_WIDTH))

/*! @brief Set the DACRFS field to a new value. */
#define DAC_WR_C0_DACRFS(base, value) (DAC_RMW_C0(base, DAC_C0_DACRFS_MASK, DAC_C0_DACRFS(value)))
#define DAC_BWR_C0_DACRFS(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACRFS_SHIFT), DAC_C0_DACRFS_SHIFT, DAC_C0_DACRFS_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACEN[7] (RW)
 *
 * Starts the Programmable Reference Generator operation.
 *
 * Values:
 * - 0b0 - The DAC system is disabled.
 * - 0b1 - The DAC system is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACEN field. */
#define DAC_RD_C0_DACEN(base) ((DAC_C0_REG(base) & DAC_C0_DACEN_MASK) >> DAC_C0_DACEN_SHIFT)
#define DAC_BRD_C0_DACEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACEN_SHIFT, DAC_C0_DACEN_WIDTH))

/*! @brief Set the DACEN field to a new value. */
#define DAC_WR_C0_DACEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACEN_MASK, DAC_C0_DACEN(value)))
#define DAC_BWR_C0_DACEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACEN_SHIFT), DAC_C0_DACEN_SHIFT, DAC_C0_DACEN_WIDTH))
/*@}*/

/*******************************************************************************
 * DAC_C1 - DAC Control Register 1
 ******************************************************************************/

/*!
 * @brief DAC_C1 - DAC Control Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * Do not use 32- or 16-bit accesses to this register.
 */
/*!
 * @name Constants and macros for entire DAC_C1 register
 */
/*@{*/
#define DAC_RD_C1(base)          (DAC_C1_REG(base))
#define DAC_WR_C1(base, value)   (DAC_C1_REG(base) = (value))
#define DAC_RMW_C1(base, mask, value) (DAC_WR_C1(base, (DAC_RD_C1(base) & ~(mask)) | (value)))
#define DAC_SET_C1(base, value)  (BME_OR8(&DAC_C1_REG(base), (uint8_t)(value)))
#define DAC_CLR_C1(base, value)  (BME_AND8(&DAC_C1_REG(base), (uint8_t)(~(value))))
#define DAC_TOG_C1(base, value)  (BME_XOR8(&DAC_C1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_C1 bitfields
 */

/*!
 * @name Register DAC_C1, field DACBFEN[0] (RW)
 *
 * Values:
 * - 0b0 - Buffer read pointer is disabled. The converted data is always the
 *     first word of the buffer.
 * - 0b1 - Buffer read pointer is enabled. The converted data is the word that
 *     the read pointer points to. It means converted data can be from any word of
 *     the buffer.
 */
/*@{*/
/*! @brief Read current value of the DAC_C1_DACBFEN field. */
#define DAC_RD_C1_DACBFEN(base) ((DAC_C1_REG(base) & DAC_C1_DACBFEN_MASK) >> DAC_C1_DACBFEN_SHIFT)
#define DAC_BRD_C1_DACBFEN(base) (BME_UBFX8(&DAC_C1_REG(base), DAC_C1_DACBFEN_SHIFT, DAC_C1_DACBFEN_WIDTH))

/*! @brief Set the DACBFEN field to a new value. */
#define DAC_WR_C1_DACBFEN(base, value) (DAC_RMW_C1(base, DAC_C1_DACBFEN_MASK, DAC_C1_DACBFEN(value)))
#define DAC_BWR_C1_DACBFEN(base, value) (BME_BFI8(&DAC_C1_REG(base), ((uint8_t)(value) << DAC_C1_DACBFEN_SHIFT), DAC_C1_DACBFEN_SHIFT, DAC_C1_DACBFEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C1, field DACBFMD[2] (RW)
 *
 * Values:
 * - 0b0 - Normal mode
 * - 0b1 - One-Time Scan mode
 */
/*@{*/
/*! @brief Read current value of the DAC_C1_DACBFMD field. */
#define DAC_RD_C1_DACBFMD(base) ((DAC_C1_REG(base) & DAC_C1_DACBFMD_MASK) >> DAC_C1_DACBFMD_SHIFT)
#define DAC_BRD_C1_DACBFMD(base) (BME_UBFX8(&DAC_C1_REG(base), DAC_C1_DACBFMD_SHIFT, DAC_C1_DACBFMD_WIDTH))

/*! @brief Set the DACBFMD field to a new value. */
#define DAC_WR_C1_DACBFMD(base, value) (DAC_RMW_C1(base, DAC_C1_DACBFMD_MASK, DAC_C1_DACBFMD(value)))
#define DAC_BWR_C1_DACBFMD(base, value) (BME_BFI8(&DAC_C1_REG(base), ((uint8_t)(value) << DAC_C1_DACBFMD_SHIFT), DAC_C1_DACBFMD_SHIFT, DAC_C1_DACBFMD_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C1, field DMAEN[7] (RW)
 *
 * Values:
 * - 0b0 - DMA is disabled.
 * - 0b1 - DMA is enabled. When DMA is enabled, the DMA request will be
 *     generated by original interrupts. The interrupts will not be presented on this
 *     module at the same time.
 */
/*@{*/
/*! @brief Read current value of the DAC_C1_DMAEN field. */
#define DAC_RD_C1_DMAEN(base) ((DAC_C1_REG(base) & DAC_C1_DMAEN_MASK) >> DAC_C1_DMAEN_SHIFT)
#define DAC_BRD_C1_DMAEN(base) (BME_UBFX8(&DAC_C1_REG(base), DAC_C1_DMAEN_SHIFT, DAC_C1_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define DAC_WR_C1_DMAEN(base, value) (DAC_RMW_C1(base, DAC_C1_DMAEN_MASK, DAC_C1_DMAEN(value)))
#define DAC_BWR_C1_DMAEN(base, value) (BME_BFI8(&DAC_C1_REG(base), ((uint8_t)(value) << DAC_C1_DMAEN_SHIFT), DAC_C1_DMAEN_SHIFT, DAC_C1_DMAEN_WIDTH))
/*@}*/

/*******************************************************************************
 * DAC_C2 - DAC Control Register 2
 ******************************************************************************/

/*!
 * @brief DAC_C2 - DAC Control Register 2 (RW)
 *
 * Reset value: 0x01U
 */
/*!
 * @name Constants and macros for entire DAC_C2 register
 */
/*@{*/
#define DAC_RD_C2(base)          (DAC_C2_REG(base))
#define DAC_WR_C2(base, value)   (DAC_C2_REG(base) = (value))
#define DAC_RMW_C2(base, mask, value) (DAC_WR_C2(base, (DAC_RD_C2(base) & ~(mask)) | (value)))
#define DAC_SET_C2(base, value)  (BME_OR8(&DAC_C2_REG(base), (uint8_t)(value)))
#define DAC_CLR_C2(base, value)  (BME_AND8(&DAC_C2_REG(base), (uint8_t)(~(value))))
#define DAC_TOG_C2(base, value)  (BME_XOR8(&DAC_C2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_C2 bitfields
 */

/*!
 * @name Register DAC_C2, field DACBFUP[0] (RW)
 *
 * Selects the upper limit of the DAC buffer. The buffer read pointer cannot
 * exceed it.
 */
/*@{*/
/*! @brief Read current value of the DAC_C2_DACBFUP field. */
#define DAC_RD_C2_DACBFUP(base) ((DAC_C2_REG(base) & DAC_C2_DACBFUP_MASK) >> DAC_C2_DACBFUP_SHIFT)
#define DAC_BRD_C2_DACBFUP(base) (BME_UBFX8(&DAC_C2_REG(base), DAC_C2_DACBFUP_SHIFT, DAC_C2_DACBFUP_WIDTH))

/*! @brief Set the DACBFUP field to a new value. */
#define DAC_WR_C2_DACBFUP(base, value) (DAC_RMW_C2(base, DAC_C2_DACBFUP_MASK, DAC_C2_DACBFUP(value)))
#define DAC_BWR_C2_DACBFUP(base, value) (BME_BFI8(&DAC_C2_REG(base), ((uint8_t)(value) << DAC_C2_DACBFUP_SHIFT), DAC_C2_DACBFUP_SHIFT, DAC_C2_DACBFUP_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C2, field DACBFRP[4] (RW)
 *
 * Keeps the current value of the buffer read pointer.
 */
/*@{*/
/*! @brief Read current value of the DAC_C2_DACBFRP field. */
#define DAC_RD_C2_DACBFRP(base) ((DAC_C2_REG(base) & DAC_C2_DACBFRP_MASK) >> DAC_C2_DACBFRP_SHIFT)
#define DAC_BRD_C2_DACBFRP(base) (BME_UBFX8(&DAC_C2_REG(base), DAC_C2_DACBFRP_SHIFT, DAC_C2_DACBFRP_WIDTH))

/*! @brief Set the DACBFRP field to a new value. */
#define DAC_WR_C2_DACBFRP(base, value) (DAC_RMW_C2(base, DAC_C2_DACBFRP_MASK, DAC_C2_DACBFRP(value)))
#define DAC_BWR_C2_DACBFRP(base, value) (BME_BFI8(&DAC_C2_REG(base), ((uint8_t)(value) << DAC_C2_DACBFRP_SHIFT), DAC_C2_DACBFRP_SHIFT, DAC_C2_DACBFRP_WIDTH))
/*@}*/

/*
 * MKW40Z4 DCDC
 *
 * DC to DC Converter
 *
 * Registers defined in this header file:
 * - DCDC_REG0 - DCDC REGISTER 0
 * - DCDC_REG1 - DCDC REGISTER 1
 * - DCDC_REG2 - DCDC REGISTER 2
 * - DCDC_REG3 - DCDC REGISTER 3
 * - DCDC_REG4 - DCDC REGISTER 4
 * - DCDC_REG6 - DCDC REGISTER 6
 * - DCDC_REG7 - DCDC REGISTER 7
 */

#define DCDC_INSTANCE_COUNT (1U) /*!< Number of instances of the DCDC module. */
#define DCDC_IDX (0U) /*!< Instance number for DCDC. */

/*******************************************************************************
 * DCDC_REG0 - DCDC REGISTER 0
 ******************************************************************************/

/*!
 * @brief DCDC_REG0 - DCDC REGISTER 0 (RW)
 *
 * Reset value: 0x04180000U
 */
/*!
 * @name Constants and macros for entire DCDC_REG0 register
 */
/*@{*/
#define DCDC_RD_REG0(base)       (DCDC_REG0_REG(base))
#define DCDC_WR_REG0(base, value) (DCDC_REG0_REG(base) = (value))
#define DCDC_RMW_REG0(base, mask, value) (DCDC_WR_REG0(base, (DCDC_RD_REG0(base) & ~(mask)) | (value)))
#define DCDC_SET_REG0(base, value) (BME_OR32(&DCDC_REG0_REG(base), (uint32_t)(value)))
#define DCDC_CLR_REG0(base, value) (BME_AND32(&DCDC_REG0_REG(base), (uint32_t)(~(value))))
#define DCDC_TOG_REG0(base, value) (BME_XOR32(&DCDC_REG0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DCDC_REG0 bitfields
 */

/*!
 * @name Register DCDC_REG0, field DCDC_DISABLE_AUTO_CLK_SWITCH[1] (RW)
 *
 * Disable automatic clock switch from internal oscillator to external clock.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG0_DCDC_DISABLE_AUTO_CLK_SWITCH field. */
#define DCDC_RD_REG0_DCDC_DISABLE_AUTO_CLK_SWITCH(base) ((DCDC_REG0_REG(base) & DCDC_REG0_DCDC_DISABLE_AUTO_CLK_SWITCH_MASK) >> DCDC_REG0_DCDC_DISABLE_AUTO_CLK_SWITCH_SHIFT)
#define DCDC_BRD_REG0_DCDC_DISABLE_AUTO_CLK_SWITCH(base) (BME_UBFX32(&DCDC_REG0_REG(base), DCDC_REG0_DCDC_DISABLE_AUTO_CLK_SWITCH_SHIFT, DCDC_REG0_DCDC_DISABLE_AUTO_CLK_SWITCH_WIDTH))

/*! @brief Set the DCDC_DISABLE_AUTO_CLK_SWITCH field to a new value. */
#define DCDC_WR_REG0_DCDC_DISABLE_AUTO_CLK_SWITCH(base, value) (DCDC_RMW_REG0(base, DCDC_REG0_DCDC_DISABLE_AUTO_CLK_SWITCH_MASK, DCDC_REG0_DCDC_DISABLE_AUTO_CLK_SWITCH(value)))
#define DCDC_BWR_REG0_DCDC_DISABLE_AUTO_CLK_SWITCH(base, value) (BME_BFI32(&DCDC_REG0_REG(base), ((uint32_t)(value) << DCDC_REG0_DCDC_DISABLE_AUTO_CLK_SWITCH_SHIFT), DCDC_REG0_DCDC_DISABLE_AUTO_CLK_SWITCH_SHIFT, DCDC_REG0_DCDC_DISABLE_AUTO_CLK_SWITCH_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG0, field DCDC_SEL_CLK[2] (RW)
 *
 * Select external clock for DCDC when DCDC_DISABLE_AUTO_CLK_SWITCH is set.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG0_DCDC_SEL_CLK field. */
#define DCDC_RD_REG0_DCDC_SEL_CLK(base) ((DCDC_REG0_REG(base) & DCDC_REG0_DCDC_SEL_CLK_MASK) >> DCDC_REG0_DCDC_SEL_CLK_SHIFT)
#define DCDC_BRD_REG0_DCDC_SEL_CLK(base) (BME_UBFX32(&DCDC_REG0_REG(base), DCDC_REG0_DCDC_SEL_CLK_SHIFT, DCDC_REG0_DCDC_SEL_CLK_WIDTH))

/*! @brief Set the DCDC_SEL_CLK field to a new value. */
#define DCDC_WR_REG0_DCDC_SEL_CLK(base, value) (DCDC_RMW_REG0(base, DCDC_REG0_DCDC_SEL_CLK_MASK, DCDC_REG0_DCDC_SEL_CLK(value)))
#define DCDC_BWR_REG0_DCDC_SEL_CLK(base, value) (BME_BFI32(&DCDC_REG0_REG(base), ((uint32_t)(value) << DCDC_REG0_DCDC_SEL_CLK_SHIFT), DCDC_REG0_DCDC_SEL_CLK_SHIFT, DCDC_REG0_DCDC_SEL_CLK_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG0, field DCDC_PWD_OSC_INT[3] (RW)
 *
 * Power down internal oscillator. Only set this bit when 32M crystal oscillator
 * is available.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG0_DCDC_PWD_OSC_INT field. */
#define DCDC_RD_REG0_DCDC_PWD_OSC_INT(base) ((DCDC_REG0_REG(base) & DCDC_REG0_DCDC_PWD_OSC_INT_MASK) >> DCDC_REG0_DCDC_PWD_OSC_INT_SHIFT)
#define DCDC_BRD_REG0_DCDC_PWD_OSC_INT(base) (BME_UBFX32(&DCDC_REG0_REG(base), DCDC_REG0_DCDC_PWD_OSC_INT_SHIFT, DCDC_REG0_DCDC_PWD_OSC_INT_WIDTH))

/*! @brief Set the DCDC_PWD_OSC_INT field to a new value. */
#define DCDC_WR_REG0_DCDC_PWD_OSC_INT(base, value) (DCDC_RMW_REG0(base, DCDC_REG0_DCDC_PWD_OSC_INT_MASK, DCDC_REG0_DCDC_PWD_OSC_INT(value)))
#define DCDC_BWR_REG0_DCDC_PWD_OSC_INT(base, value) (BME_BFI32(&DCDC_REG0_REG(base), ((uint32_t)(value) << DCDC_REG0_DCDC_PWD_OSC_INT_SHIFT), DCDC_REG0_DCDC_PWD_OSC_INT_SHIFT, DCDC_REG0_DCDC_PWD_OSC_INT_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG0, field DCDC_LP_DF_CMP_ENABLE[9] (RW)
 *
 * Enable low power differential comparators, to sense lower supply in pulsed
 * mode. This can reduce the ripple in pulsed mode.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG0_DCDC_LP_DF_CMP_ENABLE field. */
#define DCDC_RD_REG0_DCDC_LP_DF_CMP_ENABLE(base) ((DCDC_REG0_REG(base) & DCDC_REG0_DCDC_LP_DF_CMP_ENABLE_MASK) >> DCDC_REG0_DCDC_LP_DF_CMP_ENABLE_SHIFT)
#define DCDC_BRD_REG0_DCDC_LP_DF_CMP_ENABLE(base) (BME_UBFX32(&DCDC_REG0_REG(base), DCDC_REG0_DCDC_LP_DF_CMP_ENABLE_SHIFT, DCDC_REG0_DCDC_LP_DF_CMP_ENABLE_WIDTH))

/*! @brief Set the DCDC_LP_DF_CMP_ENABLE field to a new value. */
#define DCDC_WR_REG0_DCDC_LP_DF_CMP_ENABLE(base, value) (DCDC_RMW_REG0(base, DCDC_REG0_DCDC_LP_DF_CMP_ENABLE_MASK, DCDC_REG0_DCDC_LP_DF_CMP_ENABLE(value)))
#define DCDC_BWR_REG0_DCDC_LP_DF_CMP_ENABLE(base, value) (BME_BFI32(&DCDC_REG0_REG(base), ((uint32_t)(value) << DCDC_REG0_DCDC_LP_DF_CMP_ENABLE_SHIFT), DCDC_REG0_DCDC_LP_DF_CMP_ENABLE_SHIFT, DCDC_REG0_DCDC_LP_DF_CMP_ENABLE_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG0, field DCDC_VBAT_DIV_CTRL[11:10] (RW)
 *
 * Controls VBAT voltage divider. The divided VBAT output is input to an ADC
 * channel which allows the battery voltage to be measured.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG0_DCDC_VBAT_DIV_CTRL field. */
#define DCDC_RD_REG0_DCDC_VBAT_DIV_CTRL(base) ((DCDC_REG0_REG(base) & DCDC_REG0_DCDC_VBAT_DIV_CTRL_MASK) >> DCDC_REG0_DCDC_VBAT_DIV_CTRL_SHIFT)
#define DCDC_BRD_REG0_DCDC_VBAT_DIV_CTRL(base) (BME_UBFX32(&DCDC_REG0_REG(base), DCDC_REG0_DCDC_VBAT_DIV_CTRL_SHIFT, DCDC_REG0_DCDC_VBAT_DIV_CTRL_WIDTH))

/*! @brief Set the DCDC_VBAT_DIV_CTRL field to a new value. */
#define DCDC_WR_REG0_DCDC_VBAT_DIV_CTRL(base, value) (DCDC_RMW_REG0(base, DCDC_REG0_DCDC_VBAT_DIV_CTRL_MASK, DCDC_REG0_DCDC_VBAT_DIV_CTRL(value)))
#define DCDC_BWR_REG0_DCDC_VBAT_DIV_CTRL(base, value) (BME_BFI32(&DCDC_REG0_REG(base), ((uint32_t)(value) << DCDC_REG0_DCDC_VBAT_DIV_CTRL_SHIFT), DCDC_REG0_DCDC_VBAT_DIV_CTRL_SHIFT, DCDC_REG0_DCDC_VBAT_DIV_CTRL_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG0, field DCDC_LP_STATE_HYS_L[18:17] (RW)
 *
 * Configure the hysteretic lower threshold value in low power mode. It
 * determines the hysteretic value of the output voltage in pulsed mode.
 *
 * Values:
 * - 0b00 - Target voltage value - 0 mV
 * - 0b01 - Target voltage value - 25 mV
 * - 0b10 - Target voltage value - 50 mV
 * - 0b11 - Target voltage value - 75 mV
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG0_DCDC_LP_STATE_HYS_L field. */
#define DCDC_RD_REG0_DCDC_LP_STATE_HYS_L(base) ((DCDC_REG0_REG(base) & DCDC_REG0_DCDC_LP_STATE_HYS_L_MASK) >> DCDC_REG0_DCDC_LP_STATE_HYS_L_SHIFT)
#define DCDC_BRD_REG0_DCDC_LP_STATE_HYS_L(base) (BME_UBFX32(&DCDC_REG0_REG(base), DCDC_REG0_DCDC_LP_STATE_HYS_L_SHIFT, DCDC_REG0_DCDC_LP_STATE_HYS_L_WIDTH))

/*! @brief Set the DCDC_LP_STATE_HYS_L field to a new value. */
#define DCDC_WR_REG0_DCDC_LP_STATE_HYS_L(base, value) (DCDC_RMW_REG0(base, DCDC_REG0_DCDC_LP_STATE_HYS_L_MASK, DCDC_REG0_DCDC_LP_STATE_HYS_L(value)))
#define DCDC_BWR_REG0_DCDC_LP_STATE_HYS_L(base, value) (BME_BFI32(&DCDC_REG0_REG(base), ((uint32_t)(value) << DCDC_REG0_DCDC_LP_STATE_HYS_L_SHIFT), DCDC_REG0_DCDC_LP_STATE_HYS_L_SHIFT, DCDC_REG0_DCDC_LP_STATE_HYS_L_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG0, field DCDC_LP_STATE_HYS_H[20:19] (RW)
 *
 * Configure the hysteretic upper threshold value in low power mode. It
 * determines the hysteretic value of the output voltage in pulsed mode.
 *
 * Values:
 * - 0b00 - Target voltage value + 0 mV
 * - 0b01 - Target voltage value + 25 mV
 * - 0b10 - Target voltage value + 50 mV
 * - 0b11 - Target voltage value + 75 mV
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG0_DCDC_LP_STATE_HYS_H field. */
#define DCDC_RD_REG0_DCDC_LP_STATE_HYS_H(base) ((DCDC_REG0_REG(base) & DCDC_REG0_DCDC_LP_STATE_HYS_H_MASK) >> DCDC_REG0_DCDC_LP_STATE_HYS_H_SHIFT)
#define DCDC_BRD_REG0_DCDC_LP_STATE_HYS_H(base) (BME_UBFX32(&DCDC_REG0_REG(base), DCDC_REG0_DCDC_LP_STATE_HYS_H_SHIFT, DCDC_REG0_DCDC_LP_STATE_HYS_H_WIDTH))

/*! @brief Set the DCDC_LP_STATE_HYS_H field to a new value. */
#define DCDC_WR_REG0_DCDC_LP_STATE_HYS_H(base, value) (DCDC_RMW_REG0(base, DCDC_REG0_DCDC_LP_STATE_HYS_H_MASK, DCDC_REG0_DCDC_LP_STATE_HYS_H(value)))
#define DCDC_BWR_REG0_DCDC_LP_STATE_HYS_H(base, value) (BME_BFI32(&DCDC_REG0_REG(base), ((uint32_t)(value) << DCDC_REG0_DCDC_LP_STATE_HYS_H_SHIFT), DCDC_REG0_DCDC_LP_STATE_HYS_H_SHIFT, DCDC_REG0_DCDC_LP_STATE_HYS_H_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG0, field HYST_LP_COMP_ADJ[21] (RW)
 *
 * Adjust hysteretic value in low power comparator.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG0_HYST_LP_COMP_ADJ field. */
#define DCDC_RD_REG0_HYST_LP_COMP_ADJ(base) ((DCDC_REG0_REG(base) & DCDC_REG0_HYST_LP_COMP_ADJ_MASK) >> DCDC_REG0_HYST_LP_COMP_ADJ_SHIFT)
#define DCDC_BRD_REG0_HYST_LP_COMP_ADJ(base) (BME_UBFX32(&DCDC_REG0_REG(base), DCDC_REG0_HYST_LP_COMP_ADJ_SHIFT, DCDC_REG0_HYST_LP_COMP_ADJ_WIDTH))

/*! @brief Set the HYST_LP_COMP_ADJ field to a new value. */
#define DCDC_WR_REG0_HYST_LP_COMP_ADJ(base, value) (DCDC_RMW_REG0(base, DCDC_REG0_HYST_LP_COMP_ADJ_MASK, DCDC_REG0_HYST_LP_COMP_ADJ(value)))
#define DCDC_BWR_REG0_HYST_LP_COMP_ADJ(base, value) (BME_BFI32(&DCDC_REG0_REG(base), ((uint32_t)(value) << DCDC_REG0_HYST_LP_COMP_ADJ_SHIFT), DCDC_REG0_HYST_LP_COMP_ADJ_SHIFT, DCDC_REG0_HYST_LP_COMP_ADJ_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG0, field HYST_LP_CMP_DISABLE[22] (RW)
 *
 * Disable hysteresis in low power comparator.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG0_HYST_LP_CMP_DISABLE field. */
#define DCDC_RD_REG0_HYST_LP_CMP_DISABLE(base) ((DCDC_REG0_REG(base) & DCDC_REG0_HYST_LP_CMP_DISABLE_MASK) >> DCDC_REG0_HYST_LP_CMP_DISABLE_SHIFT)
#define DCDC_BRD_REG0_HYST_LP_CMP_DISABLE(base) (BME_UBFX32(&DCDC_REG0_REG(base), DCDC_REG0_HYST_LP_CMP_DISABLE_SHIFT, DCDC_REG0_HYST_LP_CMP_DISABLE_WIDTH))

/*! @brief Set the HYST_LP_CMP_DISABLE field to a new value. */
#define DCDC_WR_REG0_HYST_LP_CMP_DISABLE(base, value) (DCDC_RMW_REG0(base, DCDC_REG0_HYST_LP_CMP_DISABLE_MASK, DCDC_REG0_HYST_LP_CMP_DISABLE(value)))
#define DCDC_BWR_REG0_HYST_LP_CMP_DISABLE(base, value) (BME_BFI32(&DCDC_REG0_REG(base), ((uint32_t)(value) << DCDC_REG0_HYST_LP_CMP_DISABLE_SHIFT), DCDC_REG0_HYST_LP_CMP_DISABLE_SHIFT, DCDC_REG0_HYST_LP_CMP_DISABLE_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG0, field OFFSET_RSNS_LP_ADJ[23] (RW)
 *
 * Adjust hysteretic value in low power voltage sense.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG0_OFFSET_RSNS_LP_ADJ field. */
#define DCDC_RD_REG0_OFFSET_RSNS_LP_ADJ(base) ((DCDC_REG0_REG(base) & DCDC_REG0_OFFSET_RSNS_LP_ADJ_MASK) >> DCDC_REG0_OFFSET_RSNS_LP_ADJ_SHIFT)
#define DCDC_BRD_REG0_OFFSET_RSNS_LP_ADJ(base) (BME_UBFX32(&DCDC_REG0_REG(base), DCDC_REG0_OFFSET_RSNS_LP_ADJ_SHIFT, DCDC_REG0_OFFSET_RSNS_LP_ADJ_WIDTH))

/*! @brief Set the OFFSET_RSNS_LP_ADJ field to a new value. */
#define DCDC_WR_REG0_OFFSET_RSNS_LP_ADJ(base, value) (DCDC_RMW_REG0(base, DCDC_REG0_OFFSET_RSNS_LP_ADJ_MASK, DCDC_REG0_OFFSET_RSNS_LP_ADJ(value)))
#define DCDC_BWR_REG0_OFFSET_RSNS_LP_ADJ(base, value) (BME_BFI32(&DCDC_REG0_REG(base), ((uint32_t)(value) << DCDC_REG0_OFFSET_RSNS_LP_ADJ_SHIFT), DCDC_REG0_OFFSET_RSNS_LP_ADJ_SHIFT, DCDC_REG0_OFFSET_RSNS_LP_ADJ_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG0, field OFFSET_RSNS_LP_DISABLE[24] (RW)
 *
 * Disable hysteresis in low power voltage sense.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG0_OFFSET_RSNS_LP_DISABLE field. */
#define DCDC_RD_REG0_OFFSET_RSNS_LP_DISABLE(base) ((DCDC_REG0_REG(base) & DCDC_REG0_OFFSET_RSNS_LP_DISABLE_MASK) >> DCDC_REG0_OFFSET_RSNS_LP_DISABLE_SHIFT)
#define DCDC_BRD_REG0_OFFSET_RSNS_LP_DISABLE(base) (BME_UBFX32(&DCDC_REG0_REG(base), DCDC_REG0_OFFSET_RSNS_LP_DISABLE_SHIFT, DCDC_REG0_OFFSET_RSNS_LP_DISABLE_WIDTH))

/*! @brief Set the OFFSET_RSNS_LP_DISABLE field to a new value. */
#define DCDC_WR_REG0_OFFSET_RSNS_LP_DISABLE(base, value) (DCDC_RMW_REG0(base, DCDC_REG0_OFFSET_RSNS_LP_DISABLE_MASK, DCDC_REG0_OFFSET_RSNS_LP_DISABLE(value)))
#define DCDC_BWR_REG0_OFFSET_RSNS_LP_DISABLE(base, value) (BME_BFI32(&DCDC_REG0_REG(base), ((uint32_t)(value) << DCDC_REG0_OFFSET_RSNS_LP_DISABLE_SHIFT), DCDC_REG0_OFFSET_RSNS_LP_DISABLE_SHIFT, DCDC_REG0_OFFSET_RSNS_LP_DISABLE_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG0, field DCDC_LESS_I[25] (RW)
 *
 * Reduce DCDC current. It will save approximately 20uA in RUN.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG0_DCDC_LESS_I field. */
#define DCDC_RD_REG0_DCDC_LESS_I(base) ((DCDC_REG0_REG(base) & DCDC_REG0_DCDC_LESS_I_MASK) >> DCDC_REG0_DCDC_LESS_I_SHIFT)
#define DCDC_BRD_REG0_DCDC_LESS_I(base) (BME_UBFX32(&DCDC_REG0_REG(base), DCDC_REG0_DCDC_LESS_I_SHIFT, DCDC_REG0_DCDC_LESS_I_WIDTH))

/*! @brief Set the DCDC_LESS_I field to a new value. */
#define DCDC_WR_REG0_DCDC_LESS_I(base, value) (DCDC_RMW_REG0(base, DCDC_REG0_DCDC_LESS_I_MASK, DCDC_REG0_DCDC_LESS_I(value)))
#define DCDC_BWR_REG0_DCDC_LESS_I(base, value) (BME_BFI32(&DCDC_REG0_REG(base), ((uint32_t)(value) << DCDC_REG0_DCDC_LESS_I_SHIFT), DCDC_REG0_DCDC_LESS_I_SHIFT, DCDC_REG0_DCDC_LESS_I_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG0, field PWD_CMP_OFFSET[26] (RW)
 *
 * Power down output range comparator
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG0_PWD_CMP_OFFSET field. */
#define DCDC_RD_REG0_PWD_CMP_OFFSET(base) ((DCDC_REG0_REG(base) & DCDC_REG0_PWD_CMP_OFFSET_MASK) >> DCDC_REG0_PWD_CMP_OFFSET_SHIFT)
#define DCDC_BRD_REG0_PWD_CMP_OFFSET(base) (BME_UBFX32(&DCDC_REG0_REG(base), DCDC_REG0_PWD_CMP_OFFSET_SHIFT, DCDC_REG0_PWD_CMP_OFFSET_WIDTH))

/*! @brief Set the PWD_CMP_OFFSET field to a new value. */
#define DCDC_WR_REG0_PWD_CMP_OFFSET(base, value) (DCDC_RMW_REG0(base, DCDC_REG0_PWD_CMP_OFFSET_MASK, DCDC_REG0_PWD_CMP_OFFSET(value)))
#define DCDC_BWR_REG0_PWD_CMP_OFFSET(base, value) (BME_BFI32(&DCDC_REG0_REG(base), ((uint32_t)(value) << DCDC_REG0_PWD_CMP_OFFSET_SHIFT), DCDC_REG0_PWD_CMP_OFFSET_SHIFT, DCDC_REG0_PWD_CMP_OFFSET_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG0, field DCDC_XTALOK_DISABLE[27] (RW)
 *
 * Disable xtalok detection circuit.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG0_DCDC_XTALOK_DISABLE field. */
#define DCDC_RD_REG0_DCDC_XTALOK_DISABLE(base) ((DCDC_REG0_REG(base) & DCDC_REG0_DCDC_XTALOK_DISABLE_MASK) >> DCDC_REG0_DCDC_XTALOK_DISABLE_SHIFT)
#define DCDC_BRD_REG0_DCDC_XTALOK_DISABLE(base) (BME_UBFX32(&DCDC_REG0_REG(base), DCDC_REG0_DCDC_XTALOK_DISABLE_SHIFT, DCDC_REG0_DCDC_XTALOK_DISABLE_WIDTH))

/*! @brief Set the DCDC_XTALOK_DISABLE field to a new value. */
#define DCDC_WR_REG0_DCDC_XTALOK_DISABLE(base, value) (DCDC_RMW_REG0(base, DCDC_REG0_DCDC_XTALOK_DISABLE_MASK, DCDC_REG0_DCDC_XTALOK_DISABLE(value)))
#define DCDC_BWR_REG0_DCDC_XTALOK_DISABLE(base, value) (BME_BFI32(&DCDC_REG0_REG(base), ((uint32_t)(value) << DCDC_REG0_DCDC_XTALOK_DISABLE_SHIFT), DCDC_REG0_DCDC_XTALOK_DISABLE_SHIFT, DCDC_REG0_DCDC_XTALOK_DISABLE_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG0, field PSWITCH_STATUS[28] (RO)
 *
 * Status register to indicate PSWITCH status
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG0_PSWITCH_STATUS field. */
#define DCDC_RD_REG0_PSWITCH_STATUS(base) ((DCDC_REG0_REG(base) & DCDC_REG0_PSWITCH_STATUS_MASK) >> DCDC_REG0_PSWITCH_STATUS_SHIFT)
#define DCDC_BRD_REG0_PSWITCH_STATUS(base) (BME_UBFX32(&DCDC_REG0_REG(base), DCDC_REG0_PSWITCH_STATUS_SHIFT, DCDC_REG0_PSWITCH_STATUS_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG0, field VLPS_CONFIG_DCDC_HP[29] (RW)
 *
 * Selects behavior of DCDC in device VLPS low power mode. Pulsed mode is a
 * lower power mode. It can be used if the loads are small (<=0.5mA) in VLPx modes.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG0_VLPS_CONFIG_DCDC_HP field. */
#define DCDC_RD_REG0_VLPS_CONFIG_DCDC_HP(base) ((DCDC_REG0_REG(base) & DCDC_REG0_VLPS_CONFIG_DCDC_HP_MASK) >> DCDC_REG0_VLPS_CONFIG_DCDC_HP_SHIFT)
#define DCDC_BRD_REG0_VLPS_CONFIG_DCDC_HP(base) (BME_UBFX32(&DCDC_REG0_REG(base), DCDC_REG0_VLPS_CONFIG_DCDC_HP_SHIFT, DCDC_REG0_VLPS_CONFIG_DCDC_HP_WIDTH))

/*! @brief Set the VLPS_CONFIG_DCDC_HP field to a new value. */
#define DCDC_WR_REG0_VLPS_CONFIG_DCDC_HP(base, value) (DCDC_RMW_REG0(base, DCDC_REG0_VLPS_CONFIG_DCDC_HP_MASK, DCDC_REG0_VLPS_CONFIG_DCDC_HP(value)))
#define DCDC_BWR_REG0_VLPS_CONFIG_DCDC_HP(base, value) (BME_BFI32(&DCDC_REG0_REG(base), ((uint32_t)(value) << DCDC_REG0_VLPS_CONFIG_DCDC_HP_SHIFT), DCDC_REG0_VLPS_CONFIG_DCDC_HP_SHIFT, DCDC_REG0_VLPS_CONFIG_DCDC_HP_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG0, field VLPR_VLPW_CONFIG_DCDC_HP[30] (RW)
 *
 * Selects behavior of DCDC in device VLPR and VLPW low power modes. Pulsed mode
 * is a lower power mode. It can be used if the loads are small (<=0.5mA) in
 * VLPx modes.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG0_VLPR_VLPW_CONFIG_DCDC_HP field. */
#define DCDC_RD_REG0_VLPR_VLPW_CONFIG_DCDC_HP(base) ((DCDC_REG0_REG(base) & DCDC_REG0_VLPR_VLPW_CONFIG_DCDC_HP_MASK) >> DCDC_REG0_VLPR_VLPW_CONFIG_DCDC_HP_SHIFT)
#define DCDC_BRD_REG0_VLPR_VLPW_CONFIG_DCDC_HP(base) (BME_UBFX32(&DCDC_REG0_REG(base), DCDC_REG0_VLPR_VLPW_CONFIG_DCDC_HP_SHIFT, DCDC_REG0_VLPR_VLPW_CONFIG_DCDC_HP_WIDTH))

/*! @brief Set the VLPR_VLPW_CONFIG_DCDC_HP field to a new value. */
#define DCDC_WR_REG0_VLPR_VLPW_CONFIG_DCDC_HP(base, value) (DCDC_RMW_REG0(base, DCDC_REG0_VLPR_VLPW_CONFIG_DCDC_HP_MASK, DCDC_REG0_VLPR_VLPW_CONFIG_DCDC_HP(value)))
#define DCDC_BWR_REG0_VLPR_VLPW_CONFIG_DCDC_HP(base, value) (BME_BFI32(&DCDC_REG0_REG(base), ((uint32_t)(value) << DCDC_REG0_VLPR_VLPW_CONFIG_DCDC_HP_SHIFT), DCDC_REG0_VLPR_VLPW_CONFIG_DCDC_HP_SHIFT, DCDC_REG0_VLPR_VLPW_CONFIG_DCDC_HP_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG0, field DCDC_STS_DC_OK[31] (RO)
 *
 * Status register to indicate DCDC lock. The lock time depends on the loading
 * and the DCDC mode. When changing output voltage target, it will take
 * approximately (0.5ms* target change steps). In pulsed mode, it will take approximately
 * 5ms. In startup, it will take approximately 50ms.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG0_DCDC_STS_DC_OK field. */
#define DCDC_RD_REG0_DCDC_STS_DC_OK(base) ((DCDC_REG0_REG(base) & DCDC_REG0_DCDC_STS_DC_OK_MASK) >> DCDC_REG0_DCDC_STS_DC_OK_SHIFT)
#define DCDC_BRD_REG0_DCDC_STS_DC_OK(base) (BME_UBFX32(&DCDC_REG0_REG(base), DCDC_REG0_DCDC_STS_DC_OK_SHIFT, DCDC_REG0_DCDC_STS_DC_OK_WIDTH))
/*@}*/

/*******************************************************************************
 * DCDC_REG1 - DCDC REGISTER 1
 ******************************************************************************/

/*!
 * @brief DCDC_REG1 - DCDC REGISTER 1 (RW)
 *
 * Reset value: 0x0017C21CU
 */
/*!
 * @name Constants and macros for entire DCDC_REG1 register
 */
/*@{*/
#define DCDC_RD_REG1(base)       (DCDC_REG1_REG(base))
#define DCDC_WR_REG1(base, value) (DCDC_REG1_REG(base) = (value))
#define DCDC_RMW_REG1(base, mask, value) (DCDC_WR_REG1(base, (DCDC_RD_REG1(base) & ~(mask)) | (value)))
#define DCDC_SET_REG1(base, value) (BME_OR32(&DCDC_REG1_REG(base), (uint32_t)(value)))
#define DCDC_CLR_REG1(base, value) (BME_AND32(&DCDC_REG1_REG(base), (uint32_t)(~(value))))
#define DCDC_TOG_REG1(base, value) (BME_XOR32(&DCDC_REG1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DCDC_REG1 bitfields
 */

/*!
 * @name Register DCDC_REG1, field POSLIMIT_BUCK_IN[6:0] (RW)
 *
 * Upper limit duty cycle limit in DC-DC converter. This field limits the
 * maximum VDDIO achievable for a given battery voltage, and its value may be increased
 * if very low battery operation is met.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG1_POSLIMIT_BUCK_IN field. */
#define DCDC_RD_REG1_POSLIMIT_BUCK_IN(base) ((DCDC_REG1_REG(base) & DCDC_REG1_POSLIMIT_BUCK_IN_MASK) >> DCDC_REG1_POSLIMIT_BUCK_IN_SHIFT)
#define DCDC_BRD_REG1_POSLIMIT_BUCK_IN(base) (BME_UBFX32(&DCDC_REG1_REG(base), DCDC_REG1_POSLIMIT_BUCK_IN_SHIFT, DCDC_REG1_POSLIMIT_BUCK_IN_WIDTH))

/*! @brief Set the POSLIMIT_BUCK_IN field to a new value. */
#define DCDC_WR_REG1_POSLIMIT_BUCK_IN(base, value) (DCDC_RMW_REG1(base, DCDC_REG1_POSLIMIT_BUCK_IN_MASK, DCDC_REG1_POSLIMIT_BUCK_IN(value)))
#define DCDC_BWR_REG1_POSLIMIT_BUCK_IN(base, value) (BME_BFI32(&DCDC_REG1_REG(base), ((uint32_t)(value) << DCDC_REG1_POSLIMIT_BUCK_IN_SHIFT), DCDC_REG1_POSLIMIT_BUCK_IN_SHIFT, DCDC_REG1_POSLIMIT_BUCK_IN_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG1, field POSLIMIT_BOOST_IN[13:7] (RW)
 *
 * Upper limit duty cycle limit in DC-DC converter. This field limits the
 * maximum VDDIO achievable for a given battery voltage, and its value may be increased
 * if very low battery operation is met.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG1_POSLIMIT_BOOST_IN field. */
#define DCDC_RD_REG1_POSLIMIT_BOOST_IN(base) ((DCDC_REG1_REG(base) & DCDC_REG1_POSLIMIT_BOOST_IN_MASK) >> DCDC_REG1_POSLIMIT_BOOST_IN_SHIFT)
#define DCDC_BRD_REG1_POSLIMIT_BOOST_IN(base) (BME_UBFX32(&DCDC_REG1_REG(base), DCDC_REG1_POSLIMIT_BOOST_IN_SHIFT, DCDC_REG1_POSLIMIT_BOOST_IN_WIDTH))

/*! @brief Set the POSLIMIT_BOOST_IN field to a new value. */
#define DCDC_WR_REG1_POSLIMIT_BOOST_IN(base, value) (DCDC_RMW_REG1(base, DCDC_REG1_POSLIMIT_BOOST_IN_MASK, DCDC_REG1_POSLIMIT_BOOST_IN(value)))
#define DCDC_BWR_REG1_POSLIMIT_BOOST_IN(base, value) (BME_BFI32(&DCDC_REG1_REG(base), ((uint32_t)(value) << DCDC_REG1_POSLIMIT_BOOST_IN_SHIFT), DCDC_REG1_POSLIMIT_BOOST_IN_SHIFT, DCDC_REG1_POSLIMIT_BOOST_IN_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG1, field DCDC_LOOPCTRL_CM_HST_THRESH[21] (RW)
 *
 * Enable hysteresis in switching converter common mode analog comparators. This
 * feature improves transient supply ripple and efficiency.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG1_DCDC_LOOPCTRL_CM_HST_THRESH field. */
#define DCDC_RD_REG1_DCDC_LOOPCTRL_CM_HST_THRESH(base) ((DCDC_REG1_REG(base) & DCDC_REG1_DCDC_LOOPCTRL_CM_HST_THRESH_MASK) >> DCDC_REG1_DCDC_LOOPCTRL_CM_HST_THRESH_SHIFT)
#define DCDC_BRD_REG1_DCDC_LOOPCTRL_CM_HST_THRESH(base) (BME_UBFX32(&DCDC_REG1_REG(base), DCDC_REG1_DCDC_LOOPCTRL_CM_HST_THRESH_SHIFT, DCDC_REG1_DCDC_LOOPCTRL_CM_HST_THRESH_WIDTH))

/*! @brief Set the DCDC_LOOPCTRL_CM_HST_THRESH field to a new value. */
#define DCDC_WR_REG1_DCDC_LOOPCTRL_CM_HST_THRESH(base, value) (DCDC_RMW_REG1(base, DCDC_REG1_DCDC_LOOPCTRL_CM_HST_THRESH_MASK, DCDC_REG1_DCDC_LOOPCTRL_CM_HST_THRESH(value)))
#define DCDC_BWR_REG1_DCDC_LOOPCTRL_CM_HST_THRESH(base, value) (BME_BFI32(&DCDC_REG1_REG(base), ((uint32_t)(value) << DCDC_REG1_DCDC_LOOPCTRL_CM_HST_THRESH_SHIFT), DCDC_REG1_DCDC_LOOPCTRL_CM_HST_THRESH_SHIFT, DCDC_REG1_DCDC_LOOPCTRL_CM_HST_THRESH_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG1, field DCDC_LOOPCTRL_DF_HST_THRESH[22] (RW)
 *
 * Enable hysteresis in switching converter differential mode analog
 * comparators. This feature improves transient supply ripple and efficiency.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG1_DCDC_LOOPCTRL_DF_HST_THRESH field. */
#define DCDC_RD_REG1_DCDC_LOOPCTRL_DF_HST_THRESH(base) ((DCDC_REG1_REG(base) & DCDC_REG1_DCDC_LOOPCTRL_DF_HST_THRESH_MASK) >> DCDC_REG1_DCDC_LOOPCTRL_DF_HST_THRESH_SHIFT)
#define DCDC_BRD_REG1_DCDC_LOOPCTRL_DF_HST_THRESH(base) (BME_UBFX32(&DCDC_REG1_REG(base), DCDC_REG1_DCDC_LOOPCTRL_DF_HST_THRESH_SHIFT, DCDC_REG1_DCDC_LOOPCTRL_DF_HST_THRESH_WIDTH))

/*! @brief Set the DCDC_LOOPCTRL_DF_HST_THRESH field to a new value. */
#define DCDC_WR_REG1_DCDC_LOOPCTRL_DF_HST_THRESH(base, value) (DCDC_RMW_REG1(base, DCDC_REG1_DCDC_LOOPCTRL_DF_HST_THRESH_MASK, DCDC_REG1_DCDC_LOOPCTRL_DF_HST_THRESH(value)))
#define DCDC_BWR_REG1_DCDC_LOOPCTRL_DF_HST_THRESH(base, value) (BME_BFI32(&DCDC_REG1_REG(base), ((uint32_t)(value) << DCDC_REG1_DCDC_LOOPCTRL_DF_HST_THRESH_SHIFT), DCDC_REG1_DCDC_LOOPCTRL_DF_HST_THRESH_SHIFT, DCDC_REG1_DCDC_LOOPCTRL_DF_HST_THRESH_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG1, field DCDC_LOOPCTRL_EN_CM_HYST[23] (RW)
 *
 * Enable hysteresis in switching converter common mode analog comparators. This
 * feature improves transient supply ripple and efficiency.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG1_DCDC_LOOPCTRL_EN_CM_HYST field. */
#define DCDC_RD_REG1_DCDC_LOOPCTRL_EN_CM_HYST(base) ((DCDC_REG1_REG(base) & DCDC_REG1_DCDC_LOOPCTRL_EN_CM_HYST_MASK) >> DCDC_REG1_DCDC_LOOPCTRL_EN_CM_HYST_SHIFT)
#define DCDC_BRD_REG1_DCDC_LOOPCTRL_EN_CM_HYST(base) (BME_UBFX32(&DCDC_REG1_REG(base), DCDC_REG1_DCDC_LOOPCTRL_EN_CM_HYST_SHIFT, DCDC_REG1_DCDC_LOOPCTRL_EN_CM_HYST_WIDTH))

/*! @brief Set the DCDC_LOOPCTRL_EN_CM_HYST field to a new value. */
#define DCDC_WR_REG1_DCDC_LOOPCTRL_EN_CM_HYST(base, value) (DCDC_RMW_REG1(base, DCDC_REG1_DCDC_LOOPCTRL_EN_CM_HYST_MASK, DCDC_REG1_DCDC_LOOPCTRL_EN_CM_HYST(value)))
#define DCDC_BWR_REG1_DCDC_LOOPCTRL_EN_CM_HYST(base, value) (BME_BFI32(&DCDC_REG1_REG(base), ((uint32_t)(value) << DCDC_REG1_DCDC_LOOPCTRL_EN_CM_HYST_SHIFT), DCDC_REG1_DCDC_LOOPCTRL_EN_CM_HYST_SHIFT, DCDC_REG1_DCDC_LOOPCTRL_EN_CM_HYST_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG1, field DCDC_LOOPCTRL_EN_DF_HYST[24] (RW)
 *
 * Enable hysteresis in switching converter differential mode analog
 * comparators. This feature improves transient supply ripple and efficiency.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG1_DCDC_LOOPCTRL_EN_DF_HYST field. */
#define DCDC_RD_REG1_DCDC_LOOPCTRL_EN_DF_HYST(base) ((DCDC_REG1_REG(base) & DCDC_REG1_DCDC_LOOPCTRL_EN_DF_HYST_MASK) >> DCDC_REG1_DCDC_LOOPCTRL_EN_DF_HYST_SHIFT)
#define DCDC_BRD_REG1_DCDC_LOOPCTRL_EN_DF_HYST(base) (BME_UBFX32(&DCDC_REG1_REG(base), DCDC_REG1_DCDC_LOOPCTRL_EN_DF_HYST_SHIFT, DCDC_REG1_DCDC_LOOPCTRL_EN_DF_HYST_WIDTH))

/*! @brief Set the DCDC_LOOPCTRL_EN_DF_HYST field to a new value. */
#define DCDC_WR_REG1_DCDC_LOOPCTRL_EN_DF_HYST(base, value) (DCDC_RMW_REG1(base, DCDC_REG1_DCDC_LOOPCTRL_EN_DF_HYST_MASK, DCDC_REG1_DCDC_LOOPCTRL_EN_DF_HYST(value)))
#define DCDC_BWR_REG1_DCDC_LOOPCTRL_EN_DF_HYST(base, value) (BME_BFI32(&DCDC_REG1_REG(base), ((uint32_t)(value) << DCDC_REG1_DCDC_LOOPCTRL_EN_DF_HYST_SHIFT), DCDC_REG1_DCDC_LOOPCTRL_EN_DF_HYST_SHIFT, DCDC_REG1_DCDC_LOOPCTRL_EN_DF_HYST_WIDTH))
/*@}*/

/*******************************************************************************
 * DCDC_REG2 - DCDC REGISTER 2
 ******************************************************************************/

/*!
 * @brief DCDC_REG2 - DCDC REGISTER 2 (RW)
 *
 * Reset value: 0x00004009U
 */
/*!
 * @name Constants and macros for entire DCDC_REG2 register
 */
/*@{*/
#define DCDC_RD_REG2(base)       (DCDC_REG2_REG(base))
#define DCDC_WR_REG2(base, value) (DCDC_REG2_REG(base) = (value))
#define DCDC_RMW_REG2(base, mask, value) (DCDC_WR_REG2(base, (DCDC_RD_REG2(base) & ~(mask)) | (value)))
#define DCDC_SET_REG2(base, value) (BME_OR32(&DCDC_REG2_REG(base), (uint32_t)(value)))
#define DCDC_CLR_REG2(base, value) (BME_AND32(&DCDC_REG2_REG(base), (uint32_t)(~(value))))
#define DCDC_TOG_REG2(base, value) (BME_XOR32(&DCDC_REG2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DCDC_REG2 bitfields
 */

/*!
 * @name Register DCDC_REG2, field DCDC_LOOPCTRL_DC_C[1:0] (RW)
 *
 * Ratio of integral control parameter to proportional control parameter in the
 * switching DC-DC converter, it can be used to optimize efficiency and loop
 * response.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG2_DCDC_LOOPCTRL_DC_C field. */
#define DCDC_RD_REG2_DCDC_LOOPCTRL_DC_C(base) ((DCDC_REG2_REG(base) & DCDC_REG2_DCDC_LOOPCTRL_DC_C_MASK) >> DCDC_REG2_DCDC_LOOPCTRL_DC_C_SHIFT)
#define DCDC_BRD_REG2_DCDC_LOOPCTRL_DC_C(base) (BME_UBFX32(&DCDC_REG2_REG(base), DCDC_REG2_DCDC_LOOPCTRL_DC_C_SHIFT, DCDC_REG2_DCDC_LOOPCTRL_DC_C_WIDTH))

/*! @brief Set the DCDC_LOOPCTRL_DC_C field to a new value. */
#define DCDC_WR_REG2_DCDC_LOOPCTRL_DC_C(base, value) (DCDC_RMW_REG2(base, DCDC_REG2_DCDC_LOOPCTRL_DC_C_MASK, DCDC_REG2_DCDC_LOOPCTRL_DC_C(value)))
#define DCDC_BWR_REG2_DCDC_LOOPCTRL_DC_C(base, value) (BME_BFI32(&DCDC_REG2_REG(base), ((uint32_t)(value) << DCDC_REG2_DCDC_LOOPCTRL_DC_C_SHIFT), DCDC_REG2_DCDC_LOOPCTRL_DC_C_SHIFT, DCDC_REG2_DCDC_LOOPCTRL_DC_C_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG2, field DCDC_LOOPCTRL_DC_FF[8:6] (RW)
 *
 * Two complement feed forward step in duty cycle in the switching DC-DC
 * converter. Each time this bit makes a transition from 0x0, the loop filter of the
 * DC-DC converter is stepped once by a value proportional to the change. This can
 * be used to force a certain control loop behavior, such as improving response
 * under known heavy load transients.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG2_DCDC_LOOPCTRL_DC_FF field. */
#define DCDC_RD_REG2_DCDC_LOOPCTRL_DC_FF(base) ((DCDC_REG2_REG(base) & DCDC_REG2_DCDC_LOOPCTRL_DC_FF_MASK) >> DCDC_REG2_DCDC_LOOPCTRL_DC_FF_SHIFT)
#define DCDC_BRD_REG2_DCDC_LOOPCTRL_DC_FF(base) (BME_UBFX32(&DCDC_REG2_REG(base), DCDC_REG2_DCDC_LOOPCTRL_DC_FF_SHIFT, DCDC_REG2_DCDC_LOOPCTRL_DC_FF_WIDTH))

/*! @brief Set the DCDC_LOOPCTRL_DC_FF field to a new value. */
#define DCDC_WR_REG2_DCDC_LOOPCTRL_DC_FF(base, value) (DCDC_RMW_REG2(base, DCDC_REG2_DCDC_LOOPCTRL_DC_FF_MASK, DCDC_REG2_DCDC_LOOPCTRL_DC_FF(value)))
#define DCDC_BWR_REG2_DCDC_LOOPCTRL_DC_FF(base, value) (BME_BFI32(&DCDC_REG2_REG(base), ((uint32_t)(value) << DCDC_REG2_DCDC_LOOPCTRL_DC_FF_SHIFT), DCDC_REG2_DCDC_LOOPCTRL_DC_FF_SHIFT, DCDC_REG2_DCDC_LOOPCTRL_DC_FF_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG2, field DCDC_LOOPCTRL_HYST_SIGN[13] (RW)
 *
 * Invert the sign of the hysteresis in DC-DC analog comparators. This bit is
 * set when in limp mode.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG2_DCDC_LOOPCTRL_HYST_SIGN field. */
#define DCDC_RD_REG2_DCDC_LOOPCTRL_HYST_SIGN(base) ((DCDC_REG2_REG(base) & DCDC_REG2_DCDC_LOOPCTRL_HYST_SIGN_MASK) >> DCDC_REG2_DCDC_LOOPCTRL_HYST_SIGN_SHIFT)
#define DCDC_BRD_REG2_DCDC_LOOPCTRL_HYST_SIGN(base) (BME_UBFX32(&DCDC_REG2_REG(base), DCDC_REG2_DCDC_LOOPCTRL_HYST_SIGN_SHIFT, DCDC_REG2_DCDC_LOOPCTRL_HYST_SIGN_WIDTH))

/*! @brief Set the DCDC_LOOPCTRL_HYST_SIGN field to a new value. */
#define DCDC_WR_REG2_DCDC_LOOPCTRL_HYST_SIGN(base, value) (DCDC_RMW_REG2(base, DCDC_REG2_DCDC_LOOPCTRL_HYST_SIGN_MASK, DCDC_REG2_DCDC_LOOPCTRL_HYST_SIGN(value)))
#define DCDC_BWR_REG2_DCDC_LOOPCTRL_HYST_SIGN(base, value) (BME_BFI32(&DCDC_REG2_REG(base), ((uint32_t)(value) << DCDC_REG2_DCDC_LOOPCTRL_HYST_SIGN_SHIFT), DCDC_REG2_DCDC_LOOPCTRL_HYST_SIGN_SHIFT, DCDC_REG2_DCDC_LOOPCTRL_HYST_SIGN_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG2, field DCDC_LOOPCTRL_TOGGLE_DIF[14] (RW)
 *
 * Set high to enable supply stepping to change, only after the differential
 * control loop has toggled. This bit eliminates any chance of large transients when
 * supply voltage changes are made.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG2_DCDC_LOOPCTRL_TOGGLE_DIF field. */
#define DCDC_RD_REG2_DCDC_LOOPCTRL_TOGGLE_DIF(base) ((DCDC_REG2_REG(base) & DCDC_REG2_DCDC_LOOPCTRL_TOGGLE_DIF_MASK) >> DCDC_REG2_DCDC_LOOPCTRL_TOGGLE_DIF_SHIFT)
#define DCDC_BRD_REG2_DCDC_LOOPCTRL_TOGGLE_DIF(base) (BME_UBFX32(&DCDC_REG2_REG(base), DCDC_REG2_DCDC_LOOPCTRL_TOGGLE_DIF_SHIFT, DCDC_REG2_DCDC_LOOPCTRL_TOGGLE_DIF_WIDTH))

/*! @brief Set the DCDC_LOOPCTRL_TOGGLE_DIF field to a new value. */
#define DCDC_WR_REG2_DCDC_LOOPCTRL_TOGGLE_DIF(base, value) (DCDC_RMW_REG2(base, DCDC_REG2_DCDC_LOOPCTRL_TOGGLE_DIF_MASK, DCDC_REG2_DCDC_LOOPCTRL_TOGGLE_DIF(value)))
#define DCDC_BWR_REG2_DCDC_LOOPCTRL_TOGGLE_DIF(base, value) (BME_BFI32(&DCDC_REG2_REG(base), ((uint32_t)(value) << DCDC_REG2_DCDC_LOOPCTRL_TOGGLE_DIF_SHIFT), DCDC_REG2_DCDC_LOOPCTRL_TOGGLE_DIF_SHIFT, DCDC_REG2_DCDC_LOOPCTRL_TOGGLE_DIF_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG2, field DCDC_BATTMONITOR_EN_BATADJ[15] (RW)
 *
 * This bit enables the DC-DC to improve efficiency and minimize ripple using
 * the information from the BATT_VAL field. The BATT_VAL contains accurate
 * information before setting EN_BATADJ.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG2_DCDC_BATTMONITOR_EN_BATADJ field. */
#define DCDC_RD_REG2_DCDC_BATTMONITOR_EN_BATADJ(base) ((DCDC_REG2_REG(base) & DCDC_REG2_DCDC_BATTMONITOR_EN_BATADJ_MASK) >> DCDC_REG2_DCDC_BATTMONITOR_EN_BATADJ_SHIFT)
#define DCDC_BRD_REG2_DCDC_BATTMONITOR_EN_BATADJ(base) (BME_UBFX32(&DCDC_REG2_REG(base), DCDC_REG2_DCDC_BATTMONITOR_EN_BATADJ_SHIFT, DCDC_REG2_DCDC_BATTMONITOR_EN_BATADJ_WIDTH))

/*! @brief Set the DCDC_BATTMONITOR_EN_BATADJ field to a new value. */
#define DCDC_WR_REG2_DCDC_BATTMONITOR_EN_BATADJ(base, value) (DCDC_RMW_REG2(base, DCDC_REG2_DCDC_BATTMONITOR_EN_BATADJ_MASK, DCDC_REG2_DCDC_BATTMONITOR_EN_BATADJ(value)))
#define DCDC_BWR_REG2_DCDC_BATTMONITOR_EN_BATADJ(base, value) (BME_BFI32(&DCDC_REG2_REG(base), ((uint32_t)(value) << DCDC_REG2_DCDC_BATTMONITOR_EN_BATADJ_SHIFT), DCDC_REG2_DCDC_BATTMONITOR_EN_BATADJ_SHIFT, DCDC_REG2_DCDC_BATTMONITOR_EN_BATADJ_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG2, field DCDC_BATTMONITOR_BATT_VAL[25:16] (RW)
 *
 * Software should be configured to place the battery voltage in this register
 * measured with an 8 mV LSB resolution through the ADC. This value is used by the
 * DC-DC converter and must be proper configured before setting EN_BATADJ.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG2_DCDC_BATTMONITOR_BATT_VAL field. */
#define DCDC_RD_REG2_DCDC_BATTMONITOR_BATT_VAL(base) ((DCDC_REG2_REG(base) & DCDC_REG2_DCDC_BATTMONITOR_BATT_VAL_MASK) >> DCDC_REG2_DCDC_BATTMONITOR_BATT_VAL_SHIFT)
#define DCDC_BRD_REG2_DCDC_BATTMONITOR_BATT_VAL(base) (BME_UBFX32(&DCDC_REG2_REG(base), DCDC_REG2_DCDC_BATTMONITOR_BATT_VAL_SHIFT, DCDC_REG2_DCDC_BATTMONITOR_BATT_VAL_WIDTH))

/*! @brief Set the DCDC_BATTMONITOR_BATT_VAL field to a new value. */
#define DCDC_WR_REG2_DCDC_BATTMONITOR_BATT_VAL(base, value) (DCDC_RMW_REG2(base, DCDC_REG2_DCDC_BATTMONITOR_BATT_VAL_MASK, DCDC_REG2_DCDC_BATTMONITOR_BATT_VAL(value)))
#define DCDC_BWR_REG2_DCDC_BATTMONITOR_BATT_VAL(base, value) (BME_BFI32(&DCDC_REG2_REG(base), ((uint32_t)(value) << DCDC_REG2_DCDC_BATTMONITOR_BATT_VAL_SHIFT), DCDC_REG2_DCDC_BATTMONITOR_BATT_VAL_SHIFT, DCDC_REG2_DCDC_BATTMONITOR_BATT_VAL_WIDTH))
/*@}*/

/*******************************************************************************
 * DCDC_REG3 - DCDC REGISTER 3
 ******************************************************************************/

/*!
 * @brief DCDC_REG3 - DCDC REGISTER 3 (RW)
 *
 * Reset value: 0x0000A9C6U
 */
/*!
 * @name Constants and macros for entire DCDC_REG3 register
 */
/*@{*/
#define DCDC_RD_REG3(base)       (DCDC_REG3_REG(base))
#define DCDC_WR_REG3(base, value) (DCDC_REG3_REG(base) = (value))
#define DCDC_RMW_REG3(base, mask, value) (DCDC_WR_REG3(base, (DCDC_RD_REG3(base) & ~(mask)) | (value)))
#define DCDC_SET_REG3(base, value) (BME_OR32(&DCDC_REG3_REG(base), (uint32_t)(value)))
#define DCDC_CLR_REG3(base, value) (BME_AND32(&DCDC_REG3_REG(base), (uint32_t)(~(value))))
#define DCDC_TOG_REG3(base, value) (BME_XOR32(&DCDC_REG3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DCDC_REG3 bitfields
 */

/*!
 * @name Register DCDC_REG3, field DCDC_VDD1P8CTRL_TRG[5:0] (RW)
 *
 * Target value of VDD1P8, 25 mV each step in two ranges, from 0x00 to 0x11 and
 * 0x20 to 0x3F.
 *
 * Values:
 * - 0b000000 - 1.65 V
 * - 0b000110 - 1.8 V
 * - 0b010001 - 2.075 V
 * - 0b100000 - 2.8 V
 * - 0b110100 - 3.3 V
 * - 0b111111 - 3.575 V
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG3_DCDC_VDD1P8CTRL_TRG field. */
#define DCDC_RD_REG3_DCDC_VDD1P8CTRL_TRG(base) ((DCDC_REG3_REG(base) & DCDC_REG3_DCDC_VDD1P8CTRL_TRG_MASK) >> DCDC_REG3_DCDC_VDD1P8CTRL_TRG_SHIFT)
#define DCDC_BRD_REG3_DCDC_VDD1P8CTRL_TRG(base) (BME_UBFX32(&DCDC_REG3_REG(base), DCDC_REG3_DCDC_VDD1P8CTRL_TRG_SHIFT, DCDC_REG3_DCDC_VDD1P8CTRL_TRG_WIDTH))

/*! @brief Set the DCDC_VDD1P8CTRL_TRG field to a new value. */
#define DCDC_WR_REG3_DCDC_VDD1P8CTRL_TRG(base, value) (DCDC_RMW_REG3(base, DCDC_REG3_DCDC_VDD1P8CTRL_TRG_MASK, DCDC_REG3_DCDC_VDD1P8CTRL_TRG(value)))
#define DCDC_BWR_REG3_DCDC_VDD1P8CTRL_TRG(base, value) (BME_BFI32(&DCDC_REG3_REG(base), ((uint32_t)(value) << DCDC_REG3_DCDC_VDD1P8CTRL_TRG_SHIFT), DCDC_REG3_DCDC_VDD1P8CTRL_TRG_SHIFT, DCDC_REG3_DCDC_VDD1P8CTRL_TRG_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG3, field DCDC_VDD1P45CTRL_TRG_BUCK[10:6] (RW)
 *
 * Target value of VDD1p45 in buck mode, 25 mV each step from 0x00 to 0x0F
 *
 * Values:
 * - 0b01111 - 1.65 V
 * - 0b00111 - 1.45 V
 * - 0b00000 - 1.275 V
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BUCK field. */
#define DCDC_RD_REG3_DCDC_VDD1P45CTRL_TRG_BUCK(base) ((DCDC_REG3_REG(base) & DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BUCK_MASK) >> DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BUCK_SHIFT)
#define DCDC_BRD_REG3_DCDC_VDD1P45CTRL_TRG_BUCK(base) (BME_UBFX32(&DCDC_REG3_REG(base), DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BUCK_SHIFT, DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BUCK_WIDTH))

/*! @brief Set the DCDC_VDD1P45CTRL_TRG_BUCK field to a new value. */
#define DCDC_WR_REG3_DCDC_VDD1P45CTRL_TRG_BUCK(base, value) (DCDC_RMW_REG3(base, DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BUCK_MASK, DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BUCK(value)))
#define DCDC_BWR_REG3_DCDC_VDD1P45CTRL_TRG_BUCK(base, value) (BME_BFI32(&DCDC_REG3_REG(base), ((uint32_t)(value) << DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BUCK_SHIFT), DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BUCK_SHIFT, DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BUCK_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG3, field DCDC_VDD1P45CTRL_TRG_BOOST[15:11] (RW)
 *
 * Target value of VDD1P45 in bost mode, 25 mV each step from 0x00 to 0x0F. In
 * boost mode, DCDC boosts VDD1P45 to 1.8 V by default, software need to measure
 * battery voltage in light load, then adjust the target value accordingly. If the
 * total load current < 10mA, it is considered to be light load. It depends on
 * the internal resistance of the battery type.
 *
 * Values:
 * - 0b10101 - 1.8 V
 * - 0b01111 - 1.65 V
 * - 0b00111 - 1.45 V
 * - 0b00000 - 1.275 V
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BOOST field. */
#define DCDC_RD_REG3_DCDC_VDD1P45CTRL_TRG_BOOST(base) ((DCDC_REG3_REG(base) & DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BOOST_MASK) >> DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BOOST_SHIFT)
#define DCDC_BRD_REG3_DCDC_VDD1P45CTRL_TRG_BOOST(base) (BME_UBFX32(&DCDC_REG3_REG(base), DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BOOST_SHIFT, DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BOOST_WIDTH))

/*! @brief Set the DCDC_VDD1P45CTRL_TRG_BOOST field to a new value. */
#define DCDC_WR_REG3_DCDC_VDD1P45CTRL_TRG_BOOST(base, value) (DCDC_RMW_REG3(base, DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BOOST_MASK, DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BOOST(value)))
#define DCDC_BWR_REG3_DCDC_VDD1P45CTRL_TRG_BOOST(base, value) (BME_BFI32(&DCDC_REG3_REG(base), ((uint32_t)(value) << DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BOOST_SHIFT), DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BOOST_SHIFT, DCDC_REG3_DCDC_VDD1P45CTRL_TRG_BOOST_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG3, field DCDC_VDD1P45CTRL_ADJTN[20:17] (RW)
 *
 * Adjust value of duty cycle when switching between VDD1P45 and VDD1P8. The
 * unit is 1/32 or 3.125%.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG3_DCDC_VDD1P45CTRL_ADJTN field. */
#define DCDC_RD_REG3_DCDC_VDD1P45CTRL_ADJTN(base) ((DCDC_REG3_REG(base) & DCDC_REG3_DCDC_VDD1P45CTRL_ADJTN_MASK) >> DCDC_REG3_DCDC_VDD1P45CTRL_ADJTN_SHIFT)
#define DCDC_BRD_REG3_DCDC_VDD1P45CTRL_ADJTN(base) (BME_UBFX32(&DCDC_REG3_REG(base), DCDC_REG3_DCDC_VDD1P45CTRL_ADJTN_SHIFT, DCDC_REG3_DCDC_VDD1P45CTRL_ADJTN_WIDTH))

/*! @brief Set the DCDC_VDD1P45CTRL_ADJTN field to a new value. */
#define DCDC_WR_REG3_DCDC_VDD1P45CTRL_ADJTN(base, value) (DCDC_RMW_REG3(base, DCDC_REG3_DCDC_VDD1P45CTRL_ADJTN_MASK, DCDC_REG3_DCDC_VDD1P45CTRL_ADJTN(value)))
#define DCDC_BWR_REG3_DCDC_VDD1P45CTRL_ADJTN(base, value) (BME_BFI32(&DCDC_REG3_REG(base), ((uint32_t)(value) << DCDC_REG3_DCDC_VDD1P45CTRL_ADJTN_SHIFT), DCDC_REG3_DCDC_VDD1P45CTRL_ADJTN_SHIFT, DCDC_REG3_DCDC_VDD1P45CTRL_ADJTN_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG3, field DCDC_MINPWR_DC_HALFCLK_LIMP[21] (RW)
 *
 * Set DCDC clock to half frequency for the limp mode.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG3_DCDC_MINPWR_DC_HALFCLK_LIMP field. */
#define DCDC_RD_REG3_DCDC_MINPWR_DC_HALFCLK_LIMP(base) ((DCDC_REG3_REG(base) & DCDC_REG3_DCDC_MINPWR_DC_HALFCLK_LIMP_MASK) >> DCDC_REG3_DCDC_MINPWR_DC_HALFCLK_LIMP_SHIFT)
#define DCDC_BRD_REG3_DCDC_MINPWR_DC_HALFCLK_LIMP(base) (BME_UBFX32(&DCDC_REG3_REG(base), DCDC_REG3_DCDC_MINPWR_DC_HALFCLK_LIMP_SHIFT, DCDC_REG3_DCDC_MINPWR_DC_HALFCLK_LIMP_WIDTH))

/*! @brief Set the DCDC_MINPWR_DC_HALFCLK_LIMP field to a new value. */
#define DCDC_WR_REG3_DCDC_MINPWR_DC_HALFCLK_LIMP(base, value) (DCDC_RMW_REG3(base, DCDC_REG3_DCDC_MINPWR_DC_HALFCLK_LIMP_MASK, DCDC_REG3_DCDC_MINPWR_DC_HALFCLK_LIMP(value)))
#define DCDC_BWR_REG3_DCDC_MINPWR_DC_HALFCLK_LIMP(base, value) (BME_BFI32(&DCDC_REG3_REG(base), ((uint32_t)(value) << DCDC_REG3_DCDC_MINPWR_DC_HALFCLK_LIMP_SHIFT), DCDC_REG3_DCDC_MINPWR_DC_HALFCLK_LIMP_SHIFT, DCDC_REG3_DCDC_MINPWR_DC_HALFCLK_LIMP_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG3, field DCDC_MINPWR_DOUBLE_FETS_LIMP[22] (RW)
 *
 * Use double switch FET for the limp mode.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS_LIMP field. */
#define DCDC_RD_REG3_DCDC_MINPWR_DOUBLE_FETS_LIMP(base) ((DCDC_REG3_REG(base) & DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS_LIMP_MASK) >> DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS_LIMP_SHIFT)
#define DCDC_BRD_REG3_DCDC_MINPWR_DOUBLE_FETS_LIMP(base) (BME_UBFX32(&DCDC_REG3_REG(base), DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS_LIMP_SHIFT, DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS_LIMP_WIDTH))

/*! @brief Set the DCDC_MINPWR_DOUBLE_FETS_LIMP field to a new value. */
#define DCDC_WR_REG3_DCDC_MINPWR_DOUBLE_FETS_LIMP(base, value) (DCDC_RMW_REG3(base, DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS_LIMP_MASK, DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS_LIMP(value)))
#define DCDC_BWR_REG3_DCDC_MINPWR_DOUBLE_FETS_LIMP(base, value) (BME_BFI32(&DCDC_REG3_REG(base), ((uint32_t)(value) << DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS_LIMP_SHIFT), DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS_LIMP_SHIFT, DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS_LIMP_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG3, field DCDC_MINPWR_HALF_FETS_LIMP[23] (RW)
 *
 * Use half switch FET for the limp mode.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG3_DCDC_MINPWR_HALF_FETS_LIMP field. */
#define DCDC_RD_REG3_DCDC_MINPWR_HALF_FETS_LIMP(base) ((DCDC_REG3_REG(base) & DCDC_REG3_DCDC_MINPWR_HALF_FETS_LIMP_MASK) >> DCDC_REG3_DCDC_MINPWR_HALF_FETS_LIMP_SHIFT)
#define DCDC_BRD_REG3_DCDC_MINPWR_HALF_FETS_LIMP(base) (BME_UBFX32(&DCDC_REG3_REG(base), DCDC_REG3_DCDC_MINPWR_HALF_FETS_LIMP_SHIFT, DCDC_REG3_DCDC_MINPWR_HALF_FETS_LIMP_WIDTH))

/*! @brief Set the DCDC_MINPWR_HALF_FETS_LIMP field to a new value. */
#define DCDC_WR_REG3_DCDC_MINPWR_HALF_FETS_LIMP(base, value) (DCDC_RMW_REG3(base, DCDC_REG3_DCDC_MINPWR_HALF_FETS_LIMP_MASK, DCDC_REG3_DCDC_MINPWR_HALF_FETS_LIMP(value)))
#define DCDC_BWR_REG3_DCDC_MINPWR_HALF_FETS_LIMP(base, value) (BME_BFI32(&DCDC_REG3_REG(base), ((uint32_t)(value) << DCDC_REG3_DCDC_MINPWR_HALF_FETS_LIMP_SHIFT), DCDC_REG3_DCDC_MINPWR_HALF_FETS_LIMP_SHIFT, DCDC_REG3_DCDC_MINPWR_HALF_FETS_LIMP_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG3, field DCDC_MINPWR_DC_HALFCLK[24] (RW)
 *
 * Set DCDC clock to half frequency for the continuous mode.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG3_DCDC_MINPWR_DC_HALFCLK field. */
#define DCDC_RD_REG3_DCDC_MINPWR_DC_HALFCLK(base) ((DCDC_REG3_REG(base) & DCDC_REG3_DCDC_MINPWR_DC_HALFCLK_MASK) >> DCDC_REG3_DCDC_MINPWR_DC_HALFCLK_SHIFT)
#define DCDC_BRD_REG3_DCDC_MINPWR_DC_HALFCLK(base) (BME_UBFX32(&DCDC_REG3_REG(base), DCDC_REG3_DCDC_MINPWR_DC_HALFCLK_SHIFT, DCDC_REG3_DCDC_MINPWR_DC_HALFCLK_WIDTH))

/*! @brief Set the DCDC_MINPWR_DC_HALFCLK field to a new value. */
#define DCDC_WR_REG3_DCDC_MINPWR_DC_HALFCLK(base, value) (DCDC_RMW_REG3(base, DCDC_REG3_DCDC_MINPWR_DC_HALFCLK_MASK, DCDC_REG3_DCDC_MINPWR_DC_HALFCLK(value)))
#define DCDC_BWR_REG3_DCDC_MINPWR_DC_HALFCLK(base, value) (BME_BFI32(&DCDC_REG3_REG(base), ((uint32_t)(value) << DCDC_REG3_DCDC_MINPWR_DC_HALFCLK_SHIFT), DCDC_REG3_DCDC_MINPWR_DC_HALFCLK_SHIFT, DCDC_REG3_DCDC_MINPWR_DC_HALFCLK_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG3, field DCDC_MINPWR_DOUBLE_FETS[25] (RW)
 *
 * Use double switch FET for the continuous mode.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS field. */
#define DCDC_RD_REG3_DCDC_MINPWR_DOUBLE_FETS(base) ((DCDC_REG3_REG(base) & DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS_MASK) >> DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS_SHIFT)
#define DCDC_BRD_REG3_DCDC_MINPWR_DOUBLE_FETS(base) (BME_UBFX32(&DCDC_REG3_REG(base), DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS_SHIFT, DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS_WIDTH))

/*! @brief Set the DCDC_MINPWR_DOUBLE_FETS field to a new value. */
#define DCDC_WR_REG3_DCDC_MINPWR_DOUBLE_FETS(base, value) (DCDC_RMW_REG3(base, DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS_MASK, DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS(value)))
#define DCDC_BWR_REG3_DCDC_MINPWR_DOUBLE_FETS(base, value) (BME_BFI32(&DCDC_REG3_REG(base), ((uint32_t)(value) << DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS_SHIFT), DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS_SHIFT, DCDC_REG3_DCDC_MINPWR_DOUBLE_FETS_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG3, field DCDC_MINPWR_HALF_FETS[26] (RW)
 *
 * Use half switch FET for the continuous mode.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG3_DCDC_MINPWR_HALF_FETS field. */
#define DCDC_RD_REG3_DCDC_MINPWR_HALF_FETS(base) ((DCDC_REG3_REG(base) & DCDC_REG3_DCDC_MINPWR_HALF_FETS_MASK) >> DCDC_REG3_DCDC_MINPWR_HALF_FETS_SHIFT)
#define DCDC_BRD_REG3_DCDC_MINPWR_HALF_FETS(base) (BME_UBFX32(&DCDC_REG3_REG(base), DCDC_REG3_DCDC_MINPWR_HALF_FETS_SHIFT, DCDC_REG3_DCDC_MINPWR_HALF_FETS_WIDTH))

/*! @brief Set the DCDC_MINPWR_HALF_FETS field to a new value. */
#define DCDC_WR_REG3_DCDC_MINPWR_HALF_FETS(base, value) (DCDC_RMW_REG3(base, DCDC_REG3_DCDC_MINPWR_HALF_FETS_MASK, DCDC_REG3_DCDC_MINPWR_HALF_FETS(value)))
#define DCDC_BWR_REG3_DCDC_MINPWR_HALF_FETS(base, value) (BME_BFI32(&DCDC_REG3_REG(base), ((uint32_t)(value) << DCDC_REG3_DCDC_MINPWR_HALF_FETS_SHIFT), DCDC_REG3_DCDC_MINPWR_HALF_FETS_SHIFT, DCDC_REG3_DCDC_MINPWR_HALF_FETS_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG3, field DCDC_VDD1P45CTRL_DISABLE_STEP[29] (RW)
 *
 * Disable stepping for VDD1P45. Must set this bit before enter low power modes.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG3_DCDC_VDD1P45CTRL_DISABLE_STEP field. */
#define DCDC_RD_REG3_DCDC_VDD1P45CTRL_DISABLE_STEP(base) ((DCDC_REG3_REG(base) & DCDC_REG3_DCDC_VDD1P45CTRL_DISABLE_STEP_MASK) >> DCDC_REG3_DCDC_VDD1P45CTRL_DISABLE_STEP_SHIFT)
#define DCDC_BRD_REG3_DCDC_VDD1P45CTRL_DISABLE_STEP(base) (BME_UBFX32(&DCDC_REG3_REG(base), DCDC_REG3_DCDC_VDD1P45CTRL_DISABLE_STEP_SHIFT, DCDC_REG3_DCDC_VDD1P45CTRL_DISABLE_STEP_WIDTH))

/*! @brief Set the DCDC_VDD1P45CTRL_DISABLE_STEP field to a new value. */
#define DCDC_WR_REG3_DCDC_VDD1P45CTRL_DISABLE_STEP(base, value) (DCDC_RMW_REG3(base, DCDC_REG3_DCDC_VDD1P45CTRL_DISABLE_STEP_MASK, DCDC_REG3_DCDC_VDD1P45CTRL_DISABLE_STEP(value)))
#define DCDC_BWR_REG3_DCDC_VDD1P45CTRL_DISABLE_STEP(base, value) (BME_BFI32(&DCDC_REG3_REG(base), ((uint32_t)(value) << DCDC_REG3_DCDC_VDD1P45CTRL_DISABLE_STEP_SHIFT), DCDC_REG3_DCDC_VDD1P45CTRL_DISABLE_STEP_SHIFT, DCDC_REG3_DCDC_VDD1P45CTRL_DISABLE_STEP_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG3, field DCDC_VDD1P8CTRL_DISABLE_STEP[30] (RW)
 *
 * Disable stepping for VDD1P8. Must set this bit before enter low power modes.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG3_DCDC_VDD1P8CTRL_DISABLE_STEP field. */
#define DCDC_RD_REG3_DCDC_VDD1P8CTRL_DISABLE_STEP(base) ((DCDC_REG3_REG(base) & DCDC_REG3_DCDC_VDD1P8CTRL_DISABLE_STEP_MASK) >> DCDC_REG3_DCDC_VDD1P8CTRL_DISABLE_STEP_SHIFT)
#define DCDC_BRD_REG3_DCDC_VDD1P8CTRL_DISABLE_STEP(base) (BME_UBFX32(&DCDC_REG3_REG(base), DCDC_REG3_DCDC_VDD1P8CTRL_DISABLE_STEP_SHIFT, DCDC_REG3_DCDC_VDD1P8CTRL_DISABLE_STEP_WIDTH))

/*! @brief Set the DCDC_VDD1P8CTRL_DISABLE_STEP field to a new value. */
#define DCDC_WR_REG3_DCDC_VDD1P8CTRL_DISABLE_STEP(base, value) (DCDC_RMW_REG3(base, DCDC_REG3_DCDC_VDD1P8CTRL_DISABLE_STEP_MASK, DCDC_REG3_DCDC_VDD1P8CTRL_DISABLE_STEP(value)))
#define DCDC_BWR_REG3_DCDC_VDD1P8CTRL_DISABLE_STEP(base, value) (BME_BFI32(&DCDC_REG3_REG(base), ((uint32_t)(value) << DCDC_REG3_DCDC_VDD1P8CTRL_DISABLE_STEP_SHIFT), DCDC_REG3_DCDC_VDD1P8CTRL_DISABLE_STEP_SHIFT, DCDC_REG3_DCDC_VDD1P8CTRL_DISABLE_STEP_WIDTH))
/*@}*/

/*******************************************************************************
 * DCDC_REG4 - DCDC REGISTER 4
 ******************************************************************************/

/*!
 * @brief DCDC_REG4 - DCDC REGISTER 4 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DCDC_REG4 register
 */
/*@{*/
#define DCDC_RD_REG4(base)       (DCDC_REG4_REG(base))
#define DCDC_WR_REG4(base, value) (DCDC_REG4_REG(base) = (value))
#define DCDC_RMW_REG4(base, mask, value) (DCDC_WR_REG4(base, (DCDC_RD_REG4(base) & ~(mask)) | (value)))
#define DCDC_SET_REG4(base, value) (BME_OR32(&DCDC_REG4_REG(base), (uint32_t)(value)))
#define DCDC_CLR_REG4(base, value) (BME_AND32(&DCDC_REG4_REG(base), (uint32_t)(~(value))))
#define DCDC_TOG_REG4(base, value) (BME_XOR32(&DCDC_REG4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DCDC_REG4 bitfields
 */

/*!
 * @name Register DCDC_REG4, field DCDC_SW_SHUTDOWN[0] (RW)
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG4_DCDC_SW_SHUTDOWN field. */
#define DCDC_RD_REG4_DCDC_SW_SHUTDOWN(base) ((DCDC_REG4_REG(base) & DCDC_REG4_DCDC_SW_SHUTDOWN_MASK) >> DCDC_REG4_DCDC_SW_SHUTDOWN_SHIFT)
#define DCDC_BRD_REG4_DCDC_SW_SHUTDOWN(base) (BME_UBFX32(&DCDC_REG4_REG(base), DCDC_REG4_DCDC_SW_SHUTDOWN_SHIFT, DCDC_REG4_DCDC_SW_SHUTDOWN_WIDTH))

/*! @brief Set the DCDC_SW_SHUTDOWN field to a new value. */
#define DCDC_WR_REG4_DCDC_SW_SHUTDOWN(base, value) (DCDC_RMW_REG4(base, DCDC_REG4_DCDC_SW_SHUTDOWN_MASK, DCDC_REG4_DCDC_SW_SHUTDOWN(value)))
#define DCDC_BWR_REG4_DCDC_SW_SHUTDOWN(base, value) (BME_BFI32(&DCDC_REG4_REG(base), ((uint32_t)(value) << DCDC_REG4_DCDC_SW_SHUTDOWN_SHIFT), DCDC_REG4_DCDC_SW_SHUTDOWN_SHIFT, DCDC_REG4_DCDC_SW_SHUTDOWN_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG4, field UNLOCK[31:16] (RW)
 *
 * 0x3E77 KEY-Key needed to unlock HW_POWER_RESET register. Write 0x3E77 to
 * unlock this register and allow other bits to be changed. This register must be
 * unlocked on a write-by-write basis, so the UNLOCK bit can contain the correct key
 * value during all writes to this register in order to update any other bit
 * values in the register.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG4_UNLOCK field. */
#define DCDC_RD_REG4_UNLOCK(base) ((DCDC_REG4_REG(base) & DCDC_REG4_UNLOCK_MASK) >> DCDC_REG4_UNLOCK_SHIFT)
#define DCDC_BRD_REG4_UNLOCK(base) (BME_UBFX32(&DCDC_REG4_REG(base), DCDC_REG4_UNLOCK_SHIFT, DCDC_REG4_UNLOCK_WIDTH))

/*! @brief Set the UNLOCK field to a new value. */
#define DCDC_WR_REG4_UNLOCK(base, value) (DCDC_RMW_REG4(base, DCDC_REG4_UNLOCK_MASK, DCDC_REG4_UNLOCK(value)))
#define DCDC_BWR_REG4_UNLOCK(base, value) (BME_BFI32(&DCDC_REG4_REG(base), ((uint32_t)(value) << DCDC_REG4_UNLOCK_SHIFT), DCDC_REG4_UNLOCK_SHIFT, DCDC_REG4_UNLOCK_WIDTH))
/*@}*/

/*******************************************************************************
 * DCDC_REG6 - DCDC REGISTER 6
 ******************************************************************************/

/*!
 * @brief DCDC_REG6 - DCDC REGISTER 6 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DCDC_REG6 register
 */
/*@{*/
#define DCDC_RD_REG6(base)       (DCDC_REG6_REG(base))
#define DCDC_WR_REG6(base, value) (DCDC_REG6_REG(base) = (value))
#define DCDC_RMW_REG6(base, mask, value) (DCDC_WR_REG6(base, (DCDC_RD_REG6(base) & ~(mask)) | (value)))
#define DCDC_SET_REG6(base, value) (BME_OR32(&DCDC_REG6_REG(base), (uint32_t)(value)))
#define DCDC_CLR_REG6(base, value) (BME_AND32(&DCDC_REG6_REG(base), (uint32_t)(~(value))))
#define DCDC_TOG_REG6(base, value) (BME_XOR32(&DCDC_REG6_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DCDC_REG6 bitfields
 */

/*!
 * @name Register DCDC_REG6, field PSWITCH_INT_RISE_EN[0] (RW)
 *
 * Enable rising edge detect for interrupt.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG6_PSWITCH_INT_RISE_EN field. */
#define DCDC_RD_REG6_PSWITCH_INT_RISE_EN(base) ((DCDC_REG6_REG(base) & DCDC_REG6_PSWITCH_INT_RISE_EN_MASK) >> DCDC_REG6_PSWITCH_INT_RISE_EN_SHIFT)
#define DCDC_BRD_REG6_PSWITCH_INT_RISE_EN(base) (BME_UBFX32(&DCDC_REG6_REG(base), DCDC_REG6_PSWITCH_INT_RISE_EN_SHIFT, DCDC_REG6_PSWITCH_INT_RISE_EN_WIDTH))

/*! @brief Set the PSWITCH_INT_RISE_EN field to a new value. */
#define DCDC_WR_REG6_PSWITCH_INT_RISE_EN(base, value) (DCDC_RMW_REG6(base, DCDC_REG6_PSWITCH_INT_RISE_EN_MASK, DCDC_REG6_PSWITCH_INT_RISE_EN(value)))
#define DCDC_BWR_REG6_PSWITCH_INT_RISE_EN(base, value) (BME_BFI32(&DCDC_REG6_REG(base), ((uint32_t)(value) << DCDC_REG6_PSWITCH_INT_RISE_EN_SHIFT), DCDC_REG6_PSWITCH_INT_RISE_EN_SHIFT, DCDC_REG6_PSWITCH_INT_RISE_EN_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG6, field PSWITCH_INT_FALL_EN[1] (RW)
 *
 * Enable falling edge detect for interrupt.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG6_PSWITCH_INT_FALL_EN field. */
#define DCDC_RD_REG6_PSWITCH_INT_FALL_EN(base) ((DCDC_REG6_REG(base) & DCDC_REG6_PSWITCH_INT_FALL_EN_MASK) >> DCDC_REG6_PSWITCH_INT_FALL_EN_SHIFT)
#define DCDC_BRD_REG6_PSWITCH_INT_FALL_EN(base) (BME_UBFX32(&DCDC_REG6_REG(base), DCDC_REG6_PSWITCH_INT_FALL_EN_SHIFT, DCDC_REG6_PSWITCH_INT_FALL_EN_WIDTH))

/*! @brief Set the PSWITCH_INT_FALL_EN field to a new value. */
#define DCDC_WR_REG6_PSWITCH_INT_FALL_EN(base, value) (DCDC_RMW_REG6(base, DCDC_REG6_PSWITCH_INT_FALL_EN_MASK, DCDC_REG6_PSWITCH_INT_FALL_EN(value)))
#define DCDC_BWR_REG6_PSWITCH_INT_FALL_EN(base, value) (BME_BFI32(&DCDC_REG6_REG(base), ((uint32_t)(value) << DCDC_REG6_PSWITCH_INT_FALL_EN_SHIFT), DCDC_REG6_PSWITCH_INT_FALL_EN_SHIFT, DCDC_REG6_PSWITCH_INT_FALL_EN_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG6, field PSWITCH_INT_CLEAR[2] (RW)
 *
 * Write 1 to clear interrupt. Set to 0 after clear.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG6_PSWITCH_INT_CLEAR field. */
#define DCDC_RD_REG6_PSWITCH_INT_CLEAR(base) ((DCDC_REG6_REG(base) & DCDC_REG6_PSWITCH_INT_CLEAR_MASK) >> DCDC_REG6_PSWITCH_INT_CLEAR_SHIFT)
#define DCDC_BRD_REG6_PSWITCH_INT_CLEAR(base) (BME_UBFX32(&DCDC_REG6_REG(base), DCDC_REG6_PSWITCH_INT_CLEAR_SHIFT, DCDC_REG6_PSWITCH_INT_CLEAR_WIDTH))

/*! @brief Set the PSWITCH_INT_CLEAR field to a new value. */
#define DCDC_WR_REG6_PSWITCH_INT_CLEAR(base, value) (DCDC_RMW_REG6(base, DCDC_REG6_PSWITCH_INT_CLEAR_MASK, DCDC_REG6_PSWITCH_INT_CLEAR(value)))
#define DCDC_BWR_REG6_PSWITCH_INT_CLEAR(base, value) (BME_BFI32(&DCDC_REG6_REG(base), ((uint32_t)(value) << DCDC_REG6_PSWITCH_INT_CLEAR_SHIFT), DCDC_REG6_PSWITCH_INT_CLEAR_SHIFT, DCDC_REG6_PSWITCH_INT_CLEAR_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG6, field PSWITCH_INT_MUTE[3] (RW)
 *
 * Mask interrupt to SoC, edge detection result can be read from PSIWTCH_INT_STS.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG6_PSWITCH_INT_MUTE field. */
#define DCDC_RD_REG6_PSWITCH_INT_MUTE(base) ((DCDC_REG6_REG(base) & DCDC_REG6_PSWITCH_INT_MUTE_MASK) >> DCDC_REG6_PSWITCH_INT_MUTE_SHIFT)
#define DCDC_BRD_REG6_PSWITCH_INT_MUTE(base) (BME_UBFX32(&DCDC_REG6_REG(base), DCDC_REG6_PSWITCH_INT_MUTE_SHIFT, DCDC_REG6_PSWITCH_INT_MUTE_WIDTH))

/*! @brief Set the PSWITCH_INT_MUTE field to a new value. */
#define DCDC_WR_REG6_PSWITCH_INT_MUTE(base, value) (DCDC_RMW_REG6(base, DCDC_REG6_PSWITCH_INT_MUTE_MASK, DCDC_REG6_PSWITCH_INT_MUTE(value)))
#define DCDC_BWR_REG6_PSWITCH_INT_MUTE(base, value) (BME_BFI32(&DCDC_REG6_REG(base), ((uint32_t)(value) << DCDC_REG6_PSWITCH_INT_MUTE_SHIFT), DCDC_REG6_PSWITCH_INT_MUTE_SHIFT, DCDC_REG6_PSWITCH_INT_MUTE_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG6, field PSWITCH_INT_STS[31] (RO)
 *
 * PSWITCH edge detection interrupt status
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG6_PSWITCH_INT_STS field. */
#define DCDC_RD_REG6_PSWITCH_INT_STS(base) ((DCDC_REG6_REG(base) & DCDC_REG6_PSWITCH_INT_STS_MASK) >> DCDC_REG6_PSWITCH_INT_STS_SHIFT)
#define DCDC_BRD_REG6_PSWITCH_INT_STS(base) (BME_UBFX32(&DCDC_REG6_REG(base), DCDC_REG6_PSWITCH_INT_STS_SHIFT, DCDC_REG6_PSWITCH_INT_STS_WIDTH))
/*@}*/

/*******************************************************************************
 * DCDC_REG7 - DCDC REGISTER 7
 ******************************************************************************/

/*!
 * @brief DCDC_REG7 - DCDC REGISTER 7 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DCDC_REG7 register
 */
/*@{*/
#define DCDC_RD_REG7(base)       (DCDC_REG7_REG(base))
#define DCDC_WR_REG7(base, value) (DCDC_REG7_REG(base) = (value))
#define DCDC_RMW_REG7(base, mask, value) (DCDC_WR_REG7(base, (DCDC_RD_REG7(base) & ~(mask)) | (value)))
#define DCDC_SET_REG7(base, value) (BME_OR32(&DCDC_REG7_REG(base), (uint32_t)(value)))
#define DCDC_CLR_REG7(base, value) (BME_AND32(&DCDC_REG7_REG(base), (uint32_t)(~(value))))
#define DCDC_TOG_REG7(base, value) (BME_XOR32(&DCDC_REG7_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DCDC_REG7 bitfields
 */

/*!
 * @name Register DCDC_REG7, field INTEGRATOR_VALUE[18:0] (RW)
 *
 * Integrator value which can be loaded in pulsed mode. Software can program
 * this value according to battery voltage and VDD1P45 output target value before
 * goes to the pulsed mode. It is signed number. The register value = (Dutycycle *
 * 32 - 16) * 2 ^ 13 For buck mode, dutycycle = VDD1P45 / Vbat.For boost mode,
 * dutycycle = (VDD1P45 - Vbat) / VDD1P45.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG7_INTEGRATOR_VALUE field. */
#define DCDC_RD_REG7_INTEGRATOR_VALUE(base) ((DCDC_REG7_REG(base) & DCDC_REG7_INTEGRATOR_VALUE_MASK) >> DCDC_REG7_INTEGRATOR_VALUE_SHIFT)
#define DCDC_BRD_REG7_INTEGRATOR_VALUE(base) (DCDC_RD_REG7_INTEGRATOR_VALUE(base))

/*! @brief Set the INTEGRATOR_VALUE field to a new value. */
#define DCDC_WR_REG7_INTEGRATOR_VALUE(base, value) (DCDC_RMW_REG7(base, DCDC_REG7_INTEGRATOR_VALUE_MASK, DCDC_REG7_INTEGRATOR_VALUE(value)))
#define DCDC_BWR_REG7_INTEGRATOR_VALUE(base, value) (DCDC_WR_REG7_INTEGRATOR_VALUE(base, value))
/*@}*/

/*!
 * @name Register DCDC_REG7, field INTEGRATOR_VALUE_SEL[19] (RW)
 *
 * Select the integrator value from above register or saved value in hardware.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG7_INTEGRATOR_VALUE_SEL field. */
#define DCDC_RD_REG7_INTEGRATOR_VALUE_SEL(base) ((DCDC_REG7_REG(base) & DCDC_REG7_INTEGRATOR_VALUE_SEL_MASK) >> DCDC_REG7_INTEGRATOR_VALUE_SEL_SHIFT)
#define DCDC_BRD_REG7_INTEGRATOR_VALUE_SEL(base) (BME_UBFX32(&DCDC_REG7_REG(base), DCDC_REG7_INTEGRATOR_VALUE_SEL_SHIFT, DCDC_REG7_INTEGRATOR_VALUE_SEL_WIDTH))

/*! @brief Set the INTEGRATOR_VALUE_SEL field to a new value. */
#define DCDC_WR_REG7_INTEGRATOR_VALUE_SEL(base, value) (DCDC_RMW_REG7(base, DCDC_REG7_INTEGRATOR_VALUE_SEL_MASK, DCDC_REG7_INTEGRATOR_VALUE_SEL(value)))
#define DCDC_BWR_REG7_INTEGRATOR_VALUE_SEL(base, value) (BME_BFI32(&DCDC_REG7_REG(base), ((uint32_t)(value) << DCDC_REG7_INTEGRATOR_VALUE_SEL_SHIFT), DCDC_REG7_INTEGRATOR_VALUE_SEL_SHIFT, DCDC_REG7_INTEGRATOR_VALUE_SEL_WIDTH))
/*@}*/

/*!
 * @name Register DCDC_REG7, field PULSE_RUN_SPEEDUP[20] (RW)
 *
 * Enable pulse run speedup. Before setting this bit, INTEGRATOR_VALUE_SEL must
 * be set to 1'b1 and integrator value must be programmed.
 */
/*@{*/
/*! @brief Read current value of the DCDC_REG7_PULSE_RUN_SPEEDUP field. */
#define DCDC_RD_REG7_PULSE_RUN_SPEEDUP(base) ((DCDC_REG7_REG(base) & DCDC_REG7_PULSE_RUN_SPEEDUP_MASK) >> DCDC_REG7_PULSE_RUN_SPEEDUP_SHIFT)
#define DCDC_BRD_REG7_PULSE_RUN_SPEEDUP(base) (BME_UBFX32(&DCDC_REG7_REG(base), DCDC_REG7_PULSE_RUN_SPEEDUP_SHIFT, DCDC_REG7_PULSE_RUN_SPEEDUP_WIDTH))

/*! @brief Set the PULSE_RUN_SPEEDUP field to a new value. */
#define DCDC_WR_REG7_PULSE_RUN_SPEEDUP(base, value) (DCDC_RMW_REG7(base, DCDC_REG7_PULSE_RUN_SPEEDUP_MASK, DCDC_REG7_PULSE_RUN_SPEEDUP(value)))
#define DCDC_BWR_REG7_PULSE_RUN_SPEEDUP(base, value) (BME_BFI32(&DCDC_REG7_REG(base), ((uint32_t)(value) << DCDC_REG7_PULSE_RUN_SPEEDUP_SHIFT), DCDC_REG7_PULSE_RUN_SPEEDUP_SHIFT, DCDC_REG7_PULSE_RUN_SPEEDUP_WIDTH))
/*@}*/

/*
 * MKW40Z4 DMA
 *
 * DMA Controller
 *
 * Registers defined in this header file:
 * - DMA_SAR - Source Address Register
 * - DMA_DAR - Destination Address Register
 * - DMA_DSR - DMA_DSR0 register.
 * - DMA_DSR_BCR - DMA Status Register / Byte Count Register
 * - DMA_DCR - DMA Control Register
 */

#define DMA_INSTANCE_COUNT (1U) /*!< Number of instances of the DMA module. */
#define DMA_IDX (0U) /*!< Instance number for DMA. */

/*******************************************************************************
 * DMA_SAR - Source Address Register
 ******************************************************************************/

/*!
 * @brief DMA_SAR - Source Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * For this register: Only 32-bit writes are allowed. 16-bit and 8-bit writes
 * result in a bus error. Only several values are allowed to be written to bits
 * 31-20 of this register, see the value list in the field description. A write of
 * any other value to these bits causes a configuration error when the channel
 * starts to execute. For more information about the configuration error, see the
 * description of the CEConfiguration Error field of DSR.
 */
/*!
 * @name Constants and macros for entire DMA_SAR register
 */
/*@{*/
#define DMA_RD_SAR(base, index)  (DMA_SAR_REG(base, index))
#define DMA_WR_SAR(base, index, value) (DMA_SAR_REG(base, index) = (value))
#define DMA_RMW_SAR(base, index, mask, value) (DMA_WR_SAR(base, index, (DMA_RD_SAR(base, index) & ~(mask)) | (value)))
#define DMA_SET_SAR(base, index, value) (BME_OR32(&DMA_SAR_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_SAR(base, index, value) (BME_AND32(&DMA_SAR_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_SAR(base, index, value) (BME_XOR32(&DMA_SAR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_DAR - Destination Address Register
 ******************************************************************************/

/*!
 * @brief DMA_DAR - Destination Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * For this register: Only 32-bit writes are allowed. 16-bit and 8-bit writes
 * result in a bus error. Only several values are allowed to be written to bits
 * 31-20 of this register, see the value list in the field description. A write of
 * any other value to these bits causes a configuration error when the channel
 * starts to execute. For more information about the configuration error, see the
 * description of the CEConfiguration Error field of DSR.
 */
/*!
 * @name Constants and macros for entire DMA_DAR register
 */
/*@{*/
#define DMA_RD_DAR(base, index)  (DMA_DAR_REG(base, index))
#define DMA_WR_DAR(base, index, value) (DMA_DAR_REG(base, index) = (value))
#define DMA_RMW_DAR(base, index, mask, value) (DMA_WR_DAR(base, index, (DMA_RD_DAR(base, index) & ~(mask)) | (value)))
#define DMA_SET_DAR(base, index, value) (BME_OR32(&DMA_DAR_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_DAR(base, index, value) (BME_AND32(&DMA_DAR_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_DAR(base, index, value) (BME_XOR32(&DMA_DAR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_DSR_BCR - DMA Status Register / Byte Count Register
 ******************************************************************************/

/*!
 * @brief DMA_DSR_BCR - DMA Status Register / Byte Count Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * DSR and BCR are two logical registers that occupy one 32-bit address. DSRn
 * occupies bits 31-24, and BCRn occupies bits 23-0. DSRn contains flags indicating
 * the channel status, and BCRn contains the number of bytes yet to be
 * transferred for a given block. On the successful completion of the write transfer, BCRn
 * decrements by 1, 2, or 4 for 8-bit, 16-bit, or 32-bit accesses, respectively.
 * BCRn is cleared if a 1 is written to DSR[DONE]. In response to an event, the
 * DMA controller writes to the appropriate DSRn bit. Only a write to DSRn[DONE]
 * results in action. DSRn[DONE] is set when the block transfer is complete. When
 * a transfer sequence is initiated and BCRn[BCR] is not a multiple of 4 or 2
 * when the DMA is configured for 32-bit or 16-bit transfers, respectively,
 * DSRn[CE] is set and no transfer occurs.
 */
/*!
 * @name Constants and macros for entire DMA_DSR_BCR register
 */
/*@{*/
#define DMA_RD_DSR_BCR(base, index) (DMA_DSR_BCR_REG(base, index))
#define DMA_WR_DSR_BCR(base, index, value) (DMA_DSR_BCR_REG(base, index) = (value))
#define DMA_RMW_DSR_BCR(base, index, mask, value) (DMA_WR_DSR_BCR(base, index, (DMA_RD_DSR_BCR(base, index) & ~(mask)) | (value)))
#define DMA_SET_DSR_BCR(base, index, value) (BME_OR32(&DMA_DSR_BCR_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_DSR_BCR(base, index, value) (BME_AND32(&DMA_DSR_BCR_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_DSR_BCR(base, index, value) (BME_XOR32(&DMA_DSR_BCR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DSR_BCR bitfields
 */

/*!
 * @name Register DMA_DSR_BCR, field BCR[23:0] (RW)
 *
 * This field contains the number of bytes yet to be transferred for a given
 * block. BCR must be written with a value equal to or less than 0F_FFFFh. After
 * being written with a value in this range, bits 23-20 of BCR read back as 0000b. A
 * write to BCR of a value greater than 0F_FFFFh causes a configuration error
 * when the channel starts to execute. After being written with a value in this
 * range, bits 23-20 of BCR read back as 0001b.
 */
/*@{*/
/*! @brief Read current value of the DMA_DSR_BCR_BCR field. */
#define DMA_RD_DSR_BCR_BCR(base, index) ((DMA_DSR_BCR_REG(base, index) & DMA_DSR_BCR_BCR_MASK) >> DMA_DSR_BCR_BCR_SHIFT)
#define DMA_BRD_DSR_BCR_BCR(base, index) (DMA_RD_DSR_BCR_BCR(base, index))

/*! @brief Set the BCR field to a new value. */
#define DMA_WR_DSR_BCR_BCR(base, index, value) (DMA_RMW_DSR_BCR(base, index, (DMA_DSR_BCR_BCR_MASK | DMA_DSR_BCR_DONE_MASK), DMA_DSR_BCR_BCR(value)))
#define DMA_BWR_DSR_BCR_BCR(base, index, value) (DMA_WR_DSR_BCR_BCR(base, index, value))
/*@}*/

/*!
 * @name Register DMA_DSR_BCR, field DONE[24] (W1C)
 *
 * Set when all DMA controller transactions complete as determined by transfer
 * count, or based on error conditions. When BCR reaches 0, DONE is set when the
 * final transfer completes successfully. DONE can also be used to abort a
 * transfer by resetting the status bits. When a transfer completes, software must clear
 * DONE before reprogramming the DMA.
 *
 * Values:
 * - 0b0 - DMA transfer is not yet complete. Writing a 0 has no effect.
 * - 0b1 - DMA transfer completed. Writing a 1 to this bit clears all DMA status
 *     bits and should be used in an interrupt service routine to clear the DMA
 *     interrupt and error bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_DSR_BCR_DONE field. */
#define DMA_RD_DSR_BCR_DONE(base, index) ((DMA_DSR_BCR_REG(base, index) & DMA_DSR_BCR_DONE_MASK) >> DMA_DSR_BCR_DONE_SHIFT)
#define DMA_BRD_DSR_BCR_DONE(base, index) (BME_UBFX32(&DMA_DSR_BCR_REG(base, index), DMA_DSR_BCR_DONE_SHIFT, DMA_DSR_BCR_DONE_WIDTH))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_DSR_BCR_DONE(base, index, value) (DMA_RMW_DSR_BCR(base, index, DMA_DSR_BCR_DONE_MASK, DMA_DSR_BCR_DONE(value)))
#define DMA_BWR_DSR_BCR_DONE(base, index, value) (BME_BFI32(&DMA_DSR_BCR_REG(base, index), ((uint32_t)(value) << DMA_DSR_BCR_DONE_SHIFT), DMA_DSR_BCR_DONE_SHIFT, DMA_DSR_BCR_DONE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DSR_BCR, field BSY[25] (RO)
 *
 * Values:
 * - 0b0 - DMA channel is inactive. Cleared when the DMA has finished the last
 *     transaction.
 * - 0b1 - BSY is set the first time the channel is enabled after a transfer is
 *     initiated.
 */
/*@{*/
/*! @brief Read current value of the DMA_DSR_BCR_BSY field. */
#define DMA_RD_DSR_BCR_BSY(base, index) ((DMA_DSR_BCR_REG(base, index) & DMA_DSR_BCR_BSY_MASK) >> DMA_DSR_BCR_BSY_SHIFT)
#define DMA_BRD_DSR_BCR_BSY(base, index) (BME_UBFX32(&DMA_DSR_BCR_REG(base, index), DMA_DSR_BCR_BSY_SHIFT, DMA_DSR_BCR_BSY_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DSR_BCR, field REQ[26] (RO)
 *
 * Values:
 * - 0b0 - No request is pending or the channel is currently active. Cleared
 *     when the channel is selected.
 * - 0b1 - The DMA channel has a transfer remaining and the channel is not
 *     selected.
 */
/*@{*/
/*! @brief Read current value of the DMA_DSR_BCR_REQ field. */
#define DMA_RD_DSR_BCR_REQ(base, index) ((DMA_DSR_BCR_REG(base, index) & DMA_DSR_BCR_REQ_MASK) >> DMA_DSR_BCR_REQ_SHIFT)
#define DMA_BRD_DSR_BCR_REQ(base, index) (BME_UBFX32(&DMA_DSR_BCR_REG(base, index), DMA_DSR_BCR_REQ_SHIFT, DMA_DSR_BCR_REQ_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DSR_BCR, field BED[28] (RO)
 *
 * BED is cleared at hardware reset or by writing a 1 to DONE.
 *
 * Values:
 * - 0b0 - No bus error occurred.
 * - 0b1 - The DMA channel terminated with a bus error during the write portion
 *     of a transfer.
 */
/*@{*/
/*! @brief Read current value of the DMA_DSR_BCR_BED field. */
#define DMA_RD_DSR_BCR_BED(base, index) ((DMA_DSR_BCR_REG(base, index) & DMA_DSR_BCR_BED_MASK) >> DMA_DSR_BCR_BED_SHIFT)
#define DMA_BRD_DSR_BCR_BED(base, index) (BME_UBFX32(&DMA_DSR_BCR_REG(base, index), DMA_DSR_BCR_BED_SHIFT, DMA_DSR_BCR_BED_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DSR_BCR, field BES[29] (RO)
 *
 * BES is cleared at hardware reset or by writing a 1 to DONE.
 *
 * Values:
 * - 0b0 - No bus error occurred.
 * - 0b1 - The DMA channel terminated with a bus error during the read portion
 *     of a transfer.
 */
/*@{*/
/*! @brief Read current value of the DMA_DSR_BCR_BES field. */
#define DMA_RD_DSR_BCR_BES(base, index) ((DMA_DSR_BCR_REG(base, index) & DMA_DSR_BCR_BES_MASK) >> DMA_DSR_BCR_BES_SHIFT)
#define DMA_BRD_DSR_BCR_BES(base, index) (BME_UBFX32(&DMA_DSR_BCR_REG(base, index), DMA_DSR_BCR_BES_SHIFT, DMA_DSR_BCR_BES_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DSR_BCR, field CE[30] (RO)
 *
 * Any of the following conditions causes a configuration error: BCR, SAR, or
 * DAR does not match the requested transfer size. A value greater than 0F_FFFFh is
 * written to BCR. Bits 31-20 of SAR or DAR are written with a value other than
 * one of the allowed values. See SARSAR and DARDAR . SSIZE or DSIZE is set to an
 * unsupported value. BCR equals 0 when the DMA receives a start condition. CE
 * is cleared at hardware reset or by writing a 1 to DONE.
 *
 * Values:
 * - 0b0 - No configuration error exists.
 * - 0b1 - A configuration error has occurred.
 */
/*@{*/
/*! @brief Read current value of the DMA_DSR_BCR_CE field. */
#define DMA_RD_DSR_BCR_CE(base, index) ((DMA_DSR_BCR_REG(base, index) & DMA_DSR_BCR_CE_MASK) >> DMA_DSR_BCR_CE_SHIFT)
#define DMA_BRD_DSR_BCR_CE(base, index) (BME_UBFX32(&DMA_DSR_BCR_REG(base, index), DMA_DSR_BCR_CE_SHIFT, DMA_DSR_BCR_CE_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DSR - DMA_DSR0 register.
 ******************************************************************************/

/*!
 * @brief DMA_DSR - DMA_DSR0 register. (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire DMA_DSR register
 */
/*@{*/
#define DMA_RD_DSR(base, index)  (DMA_DSR_REG(base, index))
#define DMA_WR_DSR(base, index, value) (DMA_DSR_REG(base, index) = (value))
#define DMA_RMW_DSR(base, index, mask, value) (DMA_WR_DSR(base, index, (DMA_RD_DSR(base, index) & ~(mask)) | (value)))
#define DMA_SET_DSR(base, index, value) (BME_OR8(&DMA_DSR_REG(base, index), (uint8_t)(value)))
#define DMA_CLR_DSR(base, index, value) (BME_AND8(&DMA_DSR_REG(base, index), (uint8_t)(~(value))))
#define DMA_TOG_DSR(base, index, value) (BME_XOR8(&DMA_DSR_REG(base, index), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_DCR - DMA Control Register
 ******************************************************************************/

/*!
 * @brief DMA_DCR - DMA Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_DCR register
 */
/*@{*/
#define DMA_RD_DCR(base, index)  (DMA_DCR_REG(base, index))
#define DMA_WR_DCR(base, index, value) (DMA_DCR_REG(base, index) = (value))
#define DMA_RMW_DCR(base, index, mask, value) (DMA_WR_DCR(base, index, (DMA_RD_DCR(base, index) & ~(mask)) | (value)))
#define DMA_SET_DCR(base, index, value) (BME_OR32(&DMA_DCR_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_DCR(base, index, value) (BME_AND32(&DMA_DCR_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_DCR(base, index, value) (BME_XOR32(&DMA_DCR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCR bitfields
 */

/*!
 * @name Register DMA_DCR, field LCH2[1:0] (RW)
 *
 * The 2-bit link channel number under control of the encoded link control
 * field, LINKCC.
 *
 * Values:
 * - 0b00 - DMA Channel 0
 * - 0b01 - DMA Channel 1
 * - 0b10 - DMA Channel 2
 * - 0b11 - DMA Channel 3
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_LCH2 field. */
#define DMA_RD_DCR_LCH2(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_LCH2_MASK) >> DMA_DCR_LCH2_SHIFT)
#define DMA_BRD_DCR_LCH2(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_LCH2_SHIFT, DMA_DCR_LCH2_WIDTH))

/*! @brief Set the LCH2 field to a new value. */
#define DMA_WR_DCR_LCH2(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_LCH2_MASK, DMA_DCR_LCH2(value)))
#define DMA_BWR_DCR_LCH2(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_LCH2_SHIFT), DMA_DCR_LCH2_SHIFT, DMA_DCR_LCH2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field LCH1[3:2] (RW)
 *
 * The 2-bit link channel number under control of the encoded link control
 * field, LINKCC.
 *
 * Values:
 * - 0b00 - DMA Channel 0
 * - 0b01 - DMA Channel 1
 * - 0b10 - DMA Channel 2
 * - 0b11 - DMA Channel 3
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_LCH1 field. */
#define DMA_RD_DCR_LCH1(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_LCH1_MASK) >> DMA_DCR_LCH1_SHIFT)
#define DMA_BRD_DCR_LCH1(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_LCH1_SHIFT, DMA_DCR_LCH1_WIDTH))

/*! @brief Set the LCH1 field to a new value. */
#define DMA_WR_DCR_LCH1(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_LCH1_MASK, DMA_DCR_LCH1(value)))
#define DMA_BWR_DCR_LCH1(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_LCH1_SHIFT), DMA_DCR_LCH1_SHIFT, DMA_DCR_LCH1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field LINKCC[5:4] (RW)
 *
 * The LINKCC field provides a 2-bit encoded value defining the applicable
 * channel-to-channel linking. If not in cycle steal mode (DCRn[CS]=0) and LINKCC
 * equals 01 or 10, no link to LCH1 occurs. The link channel (LCH1, LCH2) number
 * cannot be the same as the currently executing channel, and generates a
 * configuration error if this is attempted (DSRn[CE] is set). This type of configuration
 * error sets both DSRn[7:6]. The DSRn[CE] bit is set the standard configuration
 * error flag, while DSRn[7] is a new flag to explicitly signal an linking
 * configuration error. If LINKCC equals 01, a link to LCH1 is created after each
 * cycle-steal transfer except the last one is completed. As the last cycle-steal is
 * performed and the BCR is done, then the link to LCH1 is closed and a link to LCH2
 * is created.
 *
 * Values:
 * - 0b00 - No channel-to-channel linking
 * - 0b01 - Perform a link to channel LCH1 after each cycle-steal transfer
 *     followed by a link to LCH2 after the BCR decrements to 0.
 * - 0b10 - Perform a link to channel LCH1 after each cycle-steal transfer
 * - 0b11 - Perform a link to channel LCH1 after the BCR decrements to 0.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_LINKCC field. */
#define DMA_RD_DCR_LINKCC(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_LINKCC_MASK) >> DMA_DCR_LINKCC_SHIFT)
#define DMA_BRD_DCR_LINKCC(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_LINKCC_SHIFT, DMA_DCR_LINKCC_WIDTH))

/*! @brief Set the LINKCC field to a new value. */
#define DMA_WR_DCR_LINKCC(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_LINKCC_MASK, DMA_DCR_LINKCC(value)))
#define DMA_BWR_DCR_LINKCC(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_LINKCC_SHIFT), DMA_DCR_LINKCC_SHIFT, DMA_DCR_LINKCC_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field D_REQ[7] (RW)
 *
 * If this flag is set, the DMA hardware automatically clears the corresponding
 * DCRn[ERQ] bit when the byte count register reaches 0.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the BCR is exhausted.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_D_REQ field. */
#define DMA_RD_DCR_D_REQ(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_D_REQ_MASK) >> DMA_DCR_D_REQ_SHIFT)
#define DMA_BRD_DCR_D_REQ(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_D_REQ_SHIFT, DMA_DCR_D_REQ_WIDTH))

/*! @brief Set the D_REQ field to a new value. */
#define DMA_WR_DCR_D_REQ(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_D_REQ_MASK, DMA_DCR_D_REQ(value)))
#define DMA_BWR_DCR_D_REQ(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_D_REQ_SHIFT), DMA_DCR_D_REQ_SHIFT, DMA_DCR_D_REQ_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field DMOD[11:8] (RW)
 *
 * Defines the size of the destination data circular buffer used by the DMA
 * Controller. If enabled (DMOD value is non-zero), the buffer base address is
 * located on a boundary of the buffer size. The value of this boundary depends on the
 * initial destination address (DAR). The base address should be aligned to a
 * 0-modulo-(circular buffer size) boundary. Misaligned buffers are not possible.
 * The boundary is forced to the value determined by the upper address bits in the
 * field selection. Same functionality as SMOD, except it is applied to the
 * destination address generation.
 *
 * Values:
 * - 0b0000 - Buffer disabled
 * - 0b0001 - Circular buffer size is 16 bytes
 * - 0b0010 - Circular buffer size is 32 bytes
 * - 0b0011 - Circular buffer size is 64 bytes
 * - 0b0100 - Circular buffer size is 128 bytes
 * - 0b0101 - Circular buffer size is 256 bytes
 * - 0b0110 - Circular buffer size is 512 bytes
 * - 0b0111 - Circular buffer size is 1 KB
 * - 0b1000 - Circular buffer size is 2 KB
 * - 0b1001 - Circular buffer size is 4 KB
 * - 0b1010 - Circular buffer size is 8 KB
 * - 0b1011 - Circular buffer size is 16 KB
 * - 0b1100 - Circular buffer size is 32 KB
 * - 0b1101 - Circular buffer size is 64 KB
 * - 0b1110 - Circular buffer size is 128 KB
 * - 0b1111 - Circular buffer size is 256 KB
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_DMOD field. */
#define DMA_RD_DCR_DMOD(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_DMOD_MASK) >> DMA_DCR_DMOD_SHIFT)
#define DMA_BRD_DCR_DMOD(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_DMOD_SHIFT, DMA_DCR_DMOD_WIDTH))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_DCR_DMOD(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_DMOD_MASK, DMA_DCR_DMOD(value)))
#define DMA_BWR_DCR_DMOD(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_DMOD_SHIFT), DMA_DCR_DMOD_SHIFT, DMA_DCR_DMOD_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field SMOD[15:12] (RW)
 *
 * Defines the size of the source data circular buffer used by the DMA
 * Controller. If enabled (SMOD is non-zero), the buffer base address is located on a
 * boundary of the buffer size. The value of this boundary is based upon the initial
 * source address (SAR). The base address should be aligned to a
 * 0-modulo-(circular buffer size) boundary. Misaligned buffers are not possible. The boundary is
 * forced to the value determined by the upper address bits in the field
 * selection. 0 Source address modulo feature is disabled. non-0: The value defines each
 * address bit which is selected to be either the value after next-state SAR
 * calculation is performed or the current SAR register value. This feature provides
 * the ability to easily implement circular data queues. For data queues
 * requiring power-of-2 "size" bytes, the queue should be based at a 0-modulo-size
 * address and the SMOD field set to the appropriate value to effectively freeze the
 * upper address bits. The bit select is defined as ((1 << SMOD+3) - 1) where a
 * resulting 1 in a bit location selects the next state address for the
 * corresponding address bit location and a 0 selects the original register value for the
 * corresponding address bit location. The modulo implementation includes 32
 * one-bit 2-to-1 muxes connected to the source address register and the output of an
 * adder used to generate the next-state address. The adder sums the source
 * address register with an offset calculated based on the transfer size and increment
 * control (DCRn[SSIZE, SINC]). The 32-bit wide select vector is formed using the
 * expression noted above and is then used to select either the source address
 * register bit (select = 0) or the corresponding bit position from the adder
 * output (select = 1) for each bit of the next-state source address. This
 * functionality supports circular queues ranging in size from 16 bytes (SMOD = 1) to 256
 * KB (SMOD = 15).
 *
 * Values:
 * - 0b0000 - Buffer disabled
 * - 0b0001 - Circular buffer size is 16 bytes.
 * - 0b0010 - Circular buffer size is 32 bytes.
 * - 0b0011 - Circular buffer size is 64 bytes.
 * - 0b0100 - Circular buffer size is 128 bytes.
 * - 0b0101 - Circular buffer size is 256 bytes.
 * - 0b0110 - Circular buffer size is 512 bytes.
 * - 0b0111 - Circular buffer size is 1 KB.
 * - 0b1000 - Circular buffer size is 2 KB.
 * - 0b1001 - Circular buffer size is 4 KB.
 * - 0b1010 - Circular buffer size is 8 KB.
 * - 0b1011 - Circular buffer size is 16 KB.
 * - 0b1100 - Circular buffer size is 32 KB.
 * - 0b1101 - Circular buffer size is 64 KB.
 * - 0b1110 - Circular buffer size is 128 KB.
 * - 0b1111 - Circular buffer size is 256 KB.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_SMOD field. */
#define DMA_RD_DCR_SMOD(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_SMOD_MASK) >> DMA_DCR_SMOD_SHIFT)
#define DMA_BRD_DCR_SMOD(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_SMOD_SHIFT, DMA_DCR_SMOD_WIDTH))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_DCR_SMOD(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_SMOD_MASK, DMA_DCR_SMOD(value)))
#define DMA_BWR_DCR_SMOD(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_SMOD_SHIFT), DMA_DCR_SMOD_SHIFT, DMA_DCR_SMOD_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field START[16] (WORZ)
 *
 * Values:
 * - 0b0 - DMA inactive
 * - 0b1 - The DMA begins the transfer in accordance to the values in the TCDn.
 *     START is cleared automatically after one module clock and always reads as
 *     logic 0.
 */
/*@{*/
/*! @brief Set the START field to a new value. */
#define DMA_WR_DCR_START(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_START_MASK, DMA_DCR_START(value)))
#define DMA_BWR_DCR_START(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_START_SHIFT), DMA_DCR_START_SHIFT, DMA_DCR_START_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field DSIZE[18:17] (RW)
 *
 * Determines the data size of the destination bus cycle for the DMA controller.
 *
 * Values:
 * - 0b00 - 32-bit
 * - 0b01 - 8-bit
 * - 0b10 - 16-bit
 * - 0b11 - Reserved (generates a configuration error (DSRn[CE]) if incorrectly
 *     specified at time of channel activation)
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_DSIZE field. */
#define DMA_RD_DCR_DSIZE(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_DSIZE_MASK) >> DMA_DCR_DSIZE_SHIFT)
#define DMA_BRD_DCR_DSIZE(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_DSIZE_SHIFT, DMA_DCR_DSIZE_WIDTH))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_DCR_DSIZE(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_DSIZE_MASK, DMA_DCR_DSIZE(value)))
#define DMA_BWR_DCR_DSIZE(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_DSIZE_SHIFT), DMA_DCR_DSIZE_SHIFT, DMA_DCR_DSIZE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field DINC[19] (RW)
 *
 * Controls whether the destination address increments after each successful
 * transfer.
 *
 * Values:
 * - 0b0 - No change to the DAR after a successful transfer.
 * - 0b1 - The DAR increments by 1, 2, 4 depending upon the size of the transfer.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_DINC field. */
#define DMA_RD_DCR_DINC(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_DINC_MASK) >> DMA_DCR_DINC_SHIFT)
#define DMA_BRD_DCR_DINC(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_DINC_SHIFT, DMA_DCR_DINC_WIDTH))

/*! @brief Set the DINC field to a new value. */
#define DMA_WR_DCR_DINC(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_DINC_MASK, DMA_DCR_DINC(value)))
#define DMA_BWR_DCR_DINC(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_DINC_SHIFT), DMA_DCR_DINC_SHIFT, DMA_DCR_DINC_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field SSIZE[21:20] (RW)
 *
 * Determines the data size of the source bus cycle for the DMA controller.
 *
 * Values:
 * - 0b00 - 32-bit
 * - 0b01 - 8-bit
 * - 0b10 - 16-bit
 * - 0b11 - Reserved (generates a configuration error (DSRn[CE]) if incorrectly
 *     specified at time of channel activation)
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_SSIZE field. */
#define DMA_RD_DCR_SSIZE(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_SSIZE_MASK) >> DMA_DCR_SSIZE_SHIFT)
#define DMA_BRD_DCR_SSIZE(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_SSIZE_SHIFT, DMA_DCR_SSIZE_WIDTH))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_DCR_SSIZE(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_SSIZE_MASK, DMA_DCR_SSIZE(value)))
#define DMA_BWR_DCR_SSIZE(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_SSIZE_SHIFT), DMA_DCR_SSIZE_SHIFT, DMA_DCR_SSIZE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field SINC[22] (RW)
 *
 * Controls whether the source address increments after each successful transfer.
 *
 * Values:
 * - 0b0 - No change to SAR after a successful transfer.
 * - 0b1 - The SAR increments by 1, 2, 4 as determined by the transfer size.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_SINC field. */
#define DMA_RD_DCR_SINC(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_SINC_MASK) >> DMA_DCR_SINC_SHIFT)
#define DMA_BRD_DCR_SINC(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_SINC_SHIFT, DMA_DCR_SINC_WIDTH))

/*! @brief Set the SINC field to a new value. */
#define DMA_WR_DCR_SINC(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_SINC_MASK, DMA_DCR_SINC(value)))
#define DMA_BWR_DCR_SINC(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_SINC_SHIFT), DMA_DCR_SINC_SHIFT, DMA_DCR_SINC_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field EADREQ[23] (RW)
 *
 * Enables the channel to support asynchronous DREQs while the MCU is in Stop
 * mode.
 *
 * Values:
 * - 0b0 - Disabled
 * - 0b1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_EADREQ field. */
#define DMA_RD_DCR_EADREQ(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_EADREQ_MASK) >> DMA_DCR_EADREQ_SHIFT)
#define DMA_BRD_DCR_EADREQ(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_EADREQ_SHIFT, DMA_DCR_EADREQ_WIDTH))

/*! @brief Set the EADREQ field to a new value. */
#define DMA_WR_DCR_EADREQ(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_EADREQ_MASK, DMA_DCR_EADREQ(value)))
#define DMA_BWR_DCR_EADREQ(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_EADREQ_SHIFT), DMA_DCR_EADREQ_SHIFT, DMA_DCR_EADREQ_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field AA[28] (RW)
 *
 * AA and SIZE bits determine whether the source or destination is auto-aligned;
 * that is, transfers are optimized based on the address and size.
 *
 * Values:
 * - 0b0 - Auto-align disabled
 * - 0b1 - If SSIZE indicates a transfer no smaller than DSIZE, source accesses
 *     are auto-aligned; otherwise, destination accesses are auto-aligned. Source
 *     alignment takes precedence over destination alignment. If auto-alignment
 *     is enabled, the appropriate address register increments, regardless of
 *     DINC or SINC.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_AA field. */
#define DMA_RD_DCR_AA(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_AA_MASK) >> DMA_DCR_AA_SHIFT)
#define DMA_BRD_DCR_AA(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_AA_SHIFT, DMA_DCR_AA_WIDTH))

/*! @brief Set the AA field to a new value. */
#define DMA_WR_DCR_AA(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_AA_MASK, DMA_DCR_AA(value)))
#define DMA_BWR_DCR_AA(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_AA_SHIFT), DMA_DCR_AA_SHIFT, DMA_DCR_AA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field CS[29] (RW)
 *
 * Values:
 * - 0b0 - DMA continuously makes read/write transfers until the BCR decrements
 *     to 0.
 * - 0b1 - Forces a single read/write transfer per request.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_CS field. */
#define DMA_RD_DCR_CS(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_CS_MASK) >> DMA_DCR_CS_SHIFT)
#define DMA_BRD_DCR_CS(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_CS_SHIFT, DMA_DCR_CS_WIDTH))

/*! @brief Set the CS field to a new value. */
#define DMA_WR_DCR_CS(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_CS_MASK, DMA_DCR_CS(value)))
#define DMA_BWR_DCR_CS(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_CS_SHIFT), DMA_DCR_CS_SHIFT, DMA_DCR_CS_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field ERQ[30] (RW)
 *
 * Be careful: a collision can occur between START and D_REQ when ERQ is 1.
 *
 * Values:
 * - 0b0 - Peripheral request is ignored.
 * - 0b1 - Enables peripheral request to initiate transfer. A software-initiated
 *     request (setting START) is always enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_ERQ field. */
#define DMA_RD_DCR_ERQ(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_ERQ_MASK) >> DMA_DCR_ERQ_SHIFT)
#define DMA_BRD_DCR_ERQ(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_ERQ_SHIFT, DMA_DCR_ERQ_WIDTH))

/*! @brief Set the ERQ field to a new value. */
#define DMA_WR_DCR_ERQ(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_ERQ_MASK, DMA_DCR_ERQ(value)))
#define DMA_BWR_DCR_ERQ(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_ERQ_SHIFT), DMA_DCR_ERQ_SHIFT, DMA_DCR_ERQ_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field EINT[31] (RW)
 *
 * Determines whether an interrupt is generated by completing a transfer or by
 * the occurrence of an error condition.
 *
 * Values:
 * - 0b0 - No interrupt is generated.
 * - 0b1 - SINT asserts. Interrupt signal is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_EINT field. */
#define DMA_RD_DCR_EINT(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_EINT_MASK) >> DMA_DCR_EINT_SHIFT)
#define DMA_BRD_DCR_EINT(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_EINT_SHIFT, DMA_DCR_EINT_WIDTH))

/*! @brief Set the EINT field to a new value. */
#define DMA_WR_DCR_EINT(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_EINT_MASK, DMA_DCR_EINT(value)))
#define DMA_BWR_DCR_EINT(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_EINT_SHIFT), DMA_DCR_EINT_SHIFT, DMA_DCR_EINT_WIDTH))
/*@}*/

/*
 * MKW40Z4 DMAMUX
 *
 * DMA channel multiplexor
 *
 * Registers defined in this header file:
 * - DMAMUX_CHCFG - Channel Configuration register
 */

#define DMAMUX_INSTANCE_COUNT (1U) /*!< Number of instances of the DMAMUX module. */
#define DMAMUX0_IDX (0U) /*!< Instance number for DMAMUX0. */

/*******************************************************************************
 * DMAMUX_CHCFG - Channel Configuration register
 ******************************************************************************/

/*!
 * @brief DMAMUX_CHCFG - Channel Configuration register (RW)
 *
 * Reset value: 0x00U
 *
 * Each of the DMA channels can be independently enabled/disabled and associated
 * with one of the DMA slots (peripheral slots or always-on slots) in the
 * system. Setting multiple CHCFG registers with the same source value will result in
 * unpredictable behavior. This is true, even if a channel is disabled (ENBL==0).
 * Before changing the trigger or source settings, a DMA channel must be disabled
 * via CHCFGn[ENBL].
 */
/*!
 * @name Constants and macros for entire DMAMUX_CHCFG register
 */
/*@{*/
#define DMAMUX_RD_CHCFG(base, index) (DMAMUX_CHCFG_REG(base, index))
#define DMAMUX_WR_CHCFG(base, index, value) (DMAMUX_CHCFG_REG(base, index) = (value))
#define DMAMUX_RMW_CHCFG(base, index, mask, value) (DMAMUX_WR_CHCFG(base, index, (DMAMUX_RD_CHCFG(base, index) & ~(mask)) | (value)))
#define DMAMUX_SET_CHCFG(base, index, value) (BME_OR8(&DMAMUX_CHCFG_REG(base, index), (uint8_t)(value)))
#define DMAMUX_CLR_CHCFG(base, index, value) (BME_AND8(&DMAMUX_CHCFG_REG(base, index), (uint8_t)(~(value))))
#define DMAMUX_TOG_CHCFG(base, index, value) (BME_XOR8(&DMAMUX_CHCFG_REG(base, index), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMAMUX_CHCFG bitfields
 */

/*!
 * @name Register DMAMUX_CHCFG, field SOURCE[5:0] (RW)
 *
 * Specifies which DMA source, if any, is routed to a particular DMA channel.
 * See the chip-specific DMAMUX information for details about the peripherals and
 * their slot numbers.
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_SOURCE field. */
#define DMAMUX_RD_CHCFG_SOURCE(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_SOURCE_MASK) >> DMAMUX_CHCFG_SOURCE_SHIFT)
#define DMAMUX_BRD_CHCFG_SOURCE(base, index) (BME_UBFX8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_SOURCE_SHIFT, DMAMUX_CHCFG_SOURCE_WIDTH))

/*! @brief Set the SOURCE field to a new value. */
#define DMAMUX_WR_CHCFG_SOURCE(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_SOURCE_MASK, DMAMUX_CHCFG_SOURCE(value)))
#define DMAMUX_BWR_CHCFG_SOURCE(base, index, value) (BME_BFI8(&DMAMUX_CHCFG_REG(base, index), ((uint8_t)(value) << DMAMUX_CHCFG_SOURCE_SHIFT), DMAMUX_CHCFG_SOURCE_SHIFT, DMAMUX_CHCFG_SOURCE_WIDTH))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFG, field TRIG[6] (RW)
 *
 * Enables the periodic trigger capability for the triggered DMA channel.
 *
 * Values:
 * - 0b0 - Triggering is disabled. If triggering is disabled and ENBL is set,
 *     the DMA Channel will simply route the specified source to the DMA channel.
 *     (Normal mode)
 * - 0b1 - Triggering is enabled. If triggering is enabled and ENBL is set, the
 *     DMAMUX is in Periodic Trigger mode.
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_TRIG field. */
#define DMAMUX_RD_CHCFG_TRIG(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_TRIG_MASK) >> DMAMUX_CHCFG_TRIG_SHIFT)
#define DMAMUX_BRD_CHCFG_TRIG(base, index) (BME_UBFX8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_TRIG_SHIFT, DMAMUX_CHCFG_TRIG_WIDTH))

/*! @brief Set the TRIG field to a new value. */
#define DMAMUX_WR_CHCFG_TRIG(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_TRIG_MASK, DMAMUX_CHCFG_TRIG(value)))
#define DMAMUX_BWR_CHCFG_TRIG(base, index, value) (BME_BFI8(&DMAMUX_CHCFG_REG(base, index), ((uint8_t)(value) << DMAMUX_CHCFG_TRIG_SHIFT), DMAMUX_CHCFG_TRIG_SHIFT, DMAMUX_CHCFG_TRIG_WIDTH))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFG, field ENBL[7] (RW)
 *
 * Enables the DMA channel.
 *
 * Values:
 * - 0b0 - DMA channel is disabled. This mode is primarily used during
 *     configuration of the DMAMux. The DMA has separate channel enables/disables, which
 *     should be used to disable or reconfigure a DMA channel.
 * - 0b1 - DMA channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_ENBL field. */
#define DMAMUX_RD_CHCFG_ENBL(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_ENBL_MASK) >> DMAMUX_CHCFG_ENBL_SHIFT)
#define DMAMUX_BRD_CHCFG_ENBL(base, index) (BME_UBFX8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_ENBL_SHIFT, DMAMUX_CHCFG_ENBL_WIDTH))

/*! @brief Set the ENBL field to a new value. */
#define DMAMUX_WR_CHCFG_ENBL(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_ENBL_MASK, DMAMUX_CHCFG_ENBL(value)))
#define DMAMUX_BWR_CHCFG_ENBL(base, index, value) (BME_BFI8(&DMAMUX_CHCFG_REG(base, index), ((uint8_t)(value) << DMAMUX_CHCFG_ENBL_SHIFT), DMAMUX_CHCFG_ENBL_SHIFT, DMAMUX_CHCFG_ENBL_WIDTH))
/*@}*/

/*
 * MKW40Z4 FGPIO
 *
 * General Purpose Input/Output
 *
 * Registers defined in this header file:
 * - FGPIO_PDOR - Port Data Output Register
 * - FGPIO_PSOR - Port Set Output Register
 * - FGPIO_PCOR - Port Clear Output Register
 * - FGPIO_PTOR - Port Toggle Output Register
 * - FGPIO_PDIR - Port Data Input Register
 * - FGPIO_PDDR - Port Data Direction Register
 */

#define FGPIO_INSTANCE_COUNT (3U) /*!< Number of instances of the FGPIO module. */
#define FGPIOA_IDX (0U) /*!< Instance number for FGPIOA. */
#define FGPIOB_IDX (1U) /*!< Instance number for FGPIOB. */
#define FGPIOC_IDX (2U) /*!< Instance number for FGPIOC. */

/*******************************************************************************
 * FGPIO_PDOR - Port Data Output Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PDOR - Port Data Output Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register configures the logic levels that are driven on each
 * general-purpose output pins.
 */
/*!
 * @name Constants and macros for entire FGPIO_PDOR register
 */
/*@{*/
#define FGPIO_RD_PDOR(base)      (FGPIO_PDOR_REG(base))
#define FGPIO_WR_PDOR(base, value) (FGPIO_PDOR_REG(base) = (value))
#define FGPIO_RMW_PDOR(base, mask, value) (FGPIO_WR_PDOR(base, (FGPIO_RD_PDOR(base) & ~(mask)) | (value)))
#define FGPIO_SET_PDOR(base, value) (FGPIO_WR_PDOR(base, FGPIO_RD_PDOR(base) |  (value)))
#define FGPIO_CLR_PDOR(base, value) (FGPIO_WR_PDOR(base, FGPIO_RD_PDOR(base) & ~(value)))
#define FGPIO_TOG_PDOR(base, value) (FGPIO_WR_PDOR(base, FGPIO_RD_PDOR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FGPIO_PSOR - Port Set Output Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PSOR - Port Set Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to set the fields of the PDOR.
 */
/*!
 * @name Constants and macros for entire FGPIO_PSOR register
 */
/*@{*/
#define FGPIO_RD_PSOR(base)      (FGPIO_PSOR_REG(base))
#define FGPIO_WR_PSOR(base, value) (FGPIO_PSOR_REG(base) = (value))
#define FGPIO_RMW_PSOR(base, mask, value) (FGPIO_WR_PSOR(base, (FGPIO_RD_PSOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * FGPIO_PCOR - Port Clear Output Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PCOR - Port Clear Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to clear the fields of PDOR.
 */
/*!
 * @name Constants and macros for entire FGPIO_PCOR register
 */
/*@{*/
#define FGPIO_RD_PCOR(base)      (FGPIO_PCOR_REG(base))
#define FGPIO_WR_PCOR(base, value) (FGPIO_PCOR_REG(base) = (value))
#define FGPIO_RMW_PCOR(base, mask, value) (FGPIO_WR_PCOR(base, (FGPIO_RD_PCOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * FGPIO_PTOR - Port Toggle Output Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PTOR - Port Toggle Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire FGPIO_PTOR register
 */
/*@{*/
#define FGPIO_RD_PTOR(base)      (FGPIO_PTOR_REG(base))
#define FGPIO_WR_PTOR(base, value) (FGPIO_PTOR_REG(base) = (value))
#define FGPIO_RMW_PTOR(base, mask, value) (FGPIO_WR_PTOR(base, (FGPIO_RD_PTOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * FGPIO_PDIR - Port Data Input Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PDIR - Port Data Input Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire FGPIO_PDIR register
 */
/*@{*/
#define FGPIO_RD_PDIR(base)      (FGPIO_PDIR_REG(base))
/*@}*/

/*******************************************************************************
 * FGPIO_PDDR - Port Data Direction Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PDDR - Port Data Direction Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The PDDR configures the individual port pins for input or output.
 */
/*!
 * @name Constants and macros for entire FGPIO_PDDR register
 */
/*@{*/
#define FGPIO_RD_PDDR(base)      (FGPIO_PDDR_REG(base))
#define FGPIO_WR_PDDR(base, value) (FGPIO_PDDR_REG(base) = (value))
#define FGPIO_RMW_PDDR(base, mask, value) (FGPIO_WR_PDDR(base, (FGPIO_RD_PDDR(base) & ~(mask)) | (value)))
#define FGPIO_SET_PDDR(base, value) (FGPIO_WR_PDDR(base, FGPIO_RD_PDDR(base) |  (value)))
#define FGPIO_CLR_PDDR(base, value) (FGPIO_WR_PDDR(base, FGPIO_RD_PDDR(base) & ~(value)))
#define FGPIO_TOG_PDDR(base, value) (FGPIO_WR_PDDR(base, FGPIO_RD_PDDR(base) ^  (value)))
/*@}*/

/*
 * MKW40Z4 FTFA
 *
 * Flash Memory Interface
 *
 * Registers defined in this header file:
 * - FTFA_FSTAT - Flash Status Register
 * - FTFA_FCNFG - Flash Configuration Register
 * - FTFA_FSEC - Flash Security Register
 * - FTFA_FOPT - Flash Option Register
 * - FTFA_FCCOB3 - Flash Common Command Object Registers
 * - FTFA_FCCOB2 - Flash Common Command Object Registers
 * - FTFA_FCCOB1 - Flash Common Command Object Registers
 * - FTFA_FCCOB0 - Flash Common Command Object Registers
 * - FTFA_FCCOB7 - Flash Common Command Object Registers
 * - FTFA_FCCOB6 - Flash Common Command Object Registers
 * - FTFA_FCCOB5 - Flash Common Command Object Registers
 * - FTFA_FCCOB4 - Flash Common Command Object Registers
 * - FTFA_FCCOBB - Flash Common Command Object Registers
 * - FTFA_FCCOBA - Flash Common Command Object Registers
 * - FTFA_FCCOB9 - Flash Common Command Object Registers
 * - FTFA_FCCOB8 - Flash Common Command Object Registers
 * - FTFA_FPROT3 - Program Flash Protection Registers
 * - FTFA_FPROT2 - Program Flash Protection Registers
 * - FTFA_FPROT1 - Program Flash Protection Registers
 * - FTFA_FPROT0 - Program Flash Protection Registers
 * - FTFA_XACCH3 - Execute-only Access Registers
 * - FTFA_XACCH2 - Execute-only Access Registers
 * - FTFA_XACCH1 - Execute-only Access Registers
 * - FTFA_XACCH0 - Execute-only Access Registers
 * - FTFA_XACCL3 - Execute-only Access Registers
 * - FTFA_XACCL2 - Execute-only Access Registers
 * - FTFA_XACCL1 - Execute-only Access Registers
 * - FTFA_XACCL0 - Execute-only Access Registers
 * - FTFA_SACCH3 - Supervisor-only Access Registers
 * - FTFA_SACCH2 - Supervisor-only Access Registers
 * - FTFA_SACCH1 - Supervisor-only Access Registers
 * - FTFA_SACCH0 - Supervisor-only Access Registers
 * - FTFA_SACCL3 - Supervisor-only Access Registers
 * - FTFA_SACCL2 - Supervisor-only Access Registers
 * - FTFA_SACCL1 - Supervisor-only Access Registers
 * - FTFA_SACCL0 - Supervisor-only Access Registers
 * - FTFA_FACSS - Flash Access Segment Size Register
 * - FTFA_FACSN - Flash Access Segment Number Register
 */

#define FTFA_INSTANCE_COUNT (1U) /*!< Number of instances of the FTFA module. */
#define FTFA_IDX (0U) /*!< Instance number for FTFA. */

/*******************************************************************************
 * FTFA_FSTAT - Flash Status Register
 ******************************************************************************/

/*!
 * @brief FTFA_FSTAT - Flash Status Register (RW)
 *
 * Reset value: 0x00U
 *
 * The FSTAT register reports the operational status of the flash memory module.
 * The CCIF, RDCOLERR, ACCERR, and FPVIOL bits are readable and writable. The
 * MGSTAT0 bit is read only. The unassigned bits read 0 and are not writable. When
 * set, the Access Error (ACCERR) and Flash Protection Violation (FPVIOL) bits in
 * this register prevent the launch of any more commands until the flag is
 * cleared (by writing a one to it).
 */
/*!
 * @name Constants and macros for entire FTFA_FSTAT register
 */
/*@{*/
#define FTFA_RD_FSTAT(base)      (FTFA_FSTAT_REG(base))
#define FTFA_WR_FSTAT(base, value) (FTFA_FSTAT_REG(base) = (value))
#define FTFA_RMW_FSTAT(base, mask, value) (FTFA_WR_FSTAT(base, (FTFA_RD_FSTAT(base) & ~(mask)) | (value)))
#define FTFA_SET_FSTAT(base, value) (BME_OR8(&FTFA_FSTAT_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FSTAT(base, value) (BME_AND8(&FTFA_FSTAT_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FSTAT(base, value) (BME_XOR8(&FTFA_FSTAT_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FSTAT bitfields
 */

/*!
 * @name Register FTFA_FSTAT, field MGSTAT0[0] (RO)
 *
 * The MGSTAT0 status flag is set if an error is detected during execution of a
 * flash command or during the flash reset sequence. As a status flag, this field
 * cannot (and need not) be cleared by the user like the other error flags in
 * this register. The value of the MGSTAT0 bit for "command-N" is valid only at the
 * end of the "command-N" execution when CCIF=1 and before the next command has
 * been launched. At some point during the execution of "command-N+1," the
 * previous result is discarded and any previous error is cleared.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_MGSTAT0 field. */
#define FTFA_RD_FSTAT_MGSTAT0(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_MGSTAT0_MASK) >> FTFA_FSTAT_MGSTAT0_SHIFT)
#define FTFA_BRD_FSTAT_MGSTAT0(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_MGSTAT0_SHIFT, FTFA_FSTAT_MGSTAT0_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field FPVIOL[4] (W1C)
 *
 * Indicates an attempt was made to program or erase an address in a protected
 * area of program flash memory during a command write sequence . While FPVIOL is
 * set, the CCIF flag cannot be cleared to launch a command. The FPVIOL bit is
 * cleared by writing a 1 to FPVIOL while CCIF is set. Writing a 0 to the FPVIOL
 * bit has no effect.
 *
 * Values:
 * - 0b0 - No protection violation detected
 * - 0b1 - Protection violation detected
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_FPVIOL field. */
#define FTFA_RD_FSTAT_FPVIOL(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_FPVIOL_MASK) >> FTFA_FSTAT_FPVIOL_SHIFT)
#define FTFA_BRD_FSTAT_FPVIOL(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_FPVIOL_SHIFT, FTFA_FSTAT_FPVIOL_WIDTH))

/*! @brief Set the FPVIOL field to a new value. */
#define FTFA_WR_FSTAT_FPVIOL(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_RDCOLERR_MASK | FTFA_FSTAT_CCIF_MASK), FTFA_FSTAT_FPVIOL(value)))
#define FTFA_BWR_FSTAT_FPVIOL(base, value) (BME_BFI8(&FTFA_FSTAT_REG(base), ((uint8_t)(value) << FTFA_FSTAT_FPVIOL_SHIFT), FTFA_FSTAT_FPVIOL_SHIFT, FTFA_FSTAT_FPVIOL_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field ACCERR[5] (W1C)
 *
 * Indicates an illegal access has occurred to a flash memory resource caused by
 * a violation of the command write sequence or issuing an illegal flash
 * command. While ACCERR is set, the CCIF flag cannot be cleared to launch a command.
 * The ACCERR bit is cleared by writing a 1 to ACCERR while CCIF is set. Writing a
 * 0 to the ACCERR bit has no effect.
 *
 * Values:
 * - 0b0 - No access error detected
 * - 0b1 - Access error detected
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_ACCERR field. */
#define FTFA_RD_FSTAT_ACCERR(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_ACCERR_MASK) >> FTFA_FSTAT_ACCERR_SHIFT)
#define FTFA_BRD_FSTAT_ACCERR(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_ACCERR_SHIFT, FTFA_FSTAT_ACCERR_WIDTH))

/*! @brief Set the ACCERR field to a new value. */
#define FTFA_WR_FSTAT_ACCERR(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_RDCOLERR_MASK | FTFA_FSTAT_CCIF_MASK), FTFA_FSTAT_ACCERR(value)))
#define FTFA_BWR_FSTAT_ACCERR(base, value) (BME_BFI8(&FTFA_FSTAT_REG(base), ((uint8_t)(value) << FTFA_FSTAT_ACCERR_SHIFT), FTFA_FSTAT_ACCERR_SHIFT, FTFA_FSTAT_ACCERR_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field RDCOLERR[6] (W1C)
 *
 * Indicates that the MCU attempted a read from a flash memory resource that was
 * being manipulated by a flash command (CCIF=0). Any simultaneous access is
 * detected as a collision error by the block arbitration logic. The read data in
 * this case cannot be guaranteed. The RDCOLERR bit is cleared by writing a 1 to
 * it. Writing a 0 to RDCOLERR has no effect.
 *
 * Values:
 * - 0b0 - No collision error detected
 * - 0b1 - Collision error detected
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_RDCOLERR field. */
#define FTFA_RD_FSTAT_RDCOLERR(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_RDCOLERR_MASK) >> FTFA_FSTAT_RDCOLERR_SHIFT)
#define FTFA_BRD_FSTAT_RDCOLERR(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_RDCOLERR_SHIFT, FTFA_FSTAT_RDCOLERR_WIDTH))

/*! @brief Set the RDCOLERR field to a new value. */
#define FTFA_WR_FSTAT_RDCOLERR(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_RDCOLERR_MASK | FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_CCIF_MASK), FTFA_FSTAT_RDCOLERR(value)))
#define FTFA_BWR_FSTAT_RDCOLERR(base, value) (BME_BFI8(&FTFA_FSTAT_REG(base), ((uint8_t)(value) << FTFA_FSTAT_RDCOLERR_SHIFT), FTFA_FSTAT_RDCOLERR_SHIFT, FTFA_FSTAT_RDCOLERR_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field CCIF[7] (W1C)
 *
 * Indicates that a flash command has completed. The CCIF flag is cleared by
 * writing a 1 to CCIF to launch a command, and CCIF stays low until command
 * completion or command violation. CCIF is reset to 0 but is set to 1 by the memory
 * controller at the end of the reset initialization sequence. Depending on how
 * quickly the read occurs after reset release, the user may or may not see the 0
 * hardware reset value.
 *
 * Values:
 * - 0b0 - Flash command in progress
 * - 0b1 - Flash command has completed
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_CCIF field. */
#define FTFA_RD_FSTAT_CCIF(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_CCIF_MASK) >> FTFA_FSTAT_CCIF_SHIFT)
#define FTFA_BRD_FSTAT_CCIF(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_CCIF_SHIFT, FTFA_FSTAT_CCIF_WIDTH))

/*! @brief Set the CCIF field to a new value. */
#define FTFA_WR_FSTAT_CCIF(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_CCIF_MASK | FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_RDCOLERR_MASK), FTFA_FSTAT_CCIF(value)))
#define FTFA_BWR_FSTAT_CCIF(base, value) (BME_BFI8(&FTFA_FSTAT_REG(base), ((uint8_t)(value) << FTFA_FSTAT_CCIF_SHIFT), FTFA_FSTAT_CCIF_SHIFT, FTFA_FSTAT_CCIF_WIDTH))
/*@}*/

/*******************************************************************************
 * FTFA_FCNFG - Flash Configuration Register
 ******************************************************************************/

/*!
 * @brief FTFA_FCNFG - Flash Configuration Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides information on the current functional state of the
 * flash memory module. The erase control bits (ERSAREQ and ERSSUSP) have write
 * restrictions. The unassigned bits read as noted and are not writable.
 */
/*!
 * @name Constants and macros for entire FTFA_FCNFG register
 */
/*@{*/
#define FTFA_RD_FCNFG(base)      (FTFA_FCNFG_REG(base))
#define FTFA_WR_FCNFG(base, value) (FTFA_FCNFG_REG(base) = (value))
#define FTFA_RMW_FCNFG(base, mask, value) (FTFA_WR_FCNFG(base, (FTFA_RD_FCNFG(base) & ~(mask)) | (value)))
#define FTFA_SET_FCNFG(base, value) (BME_OR8(&FTFA_FCNFG_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCNFG(base, value) (BME_AND8(&FTFA_FCNFG_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCNFG(base, value) (BME_XOR8(&FTFA_FCNFG_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FCNFG bitfields
 */

/*!
 * @name Register FTFA_FCNFG, field ERSSUSP[4] (RW)
 *
 * Allows the user to suspend (interrupt) the Erase Flash Sector command while
 * it is executing.
 *
 * Values:
 * - 0b0 - No suspend requested
 * - 0b1 - Suspend the current Erase Flash Sector command execution.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_ERSSUSP field. */
#define FTFA_RD_FCNFG_ERSSUSP(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_ERSSUSP_MASK) >> FTFA_FCNFG_ERSSUSP_SHIFT)
#define FTFA_BRD_FCNFG_ERSSUSP(base) (BME_UBFX8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_ERSSUSP_SHIFT, FTFA_FCNFG_ERSSUSP_WIDTH))

/*! @brief Set the ERSSUSP field to a new value. */
#define FTFA_WR_FCNFG_ERSSUSP(base, value) (FTFA_RMW_FCNFG(base, FTFA_FCNFG_ERSSUSP_MASK, FTFA_FCNFG_ERSSUSP(value)))
#define FTFA_BWR_FCNFG_ERSSUSP(base, value) (BME_BFI8(&FTFA_FCNFG_REG(base), ((uint8_t)(value) << FTFA_FCNFG_ERSSUSP_SHIFT), FTFA_FCNFG_ERSSUSP_SHIFT, FTFA_FCNFG_ERSSUSP_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FCNFG, field ERSAREQ[5] (RO)
 *
 * Issues a request to the memory controller to execute the Erase All Blocks
 * command and release security. ERSAREQ is not directly writable but is under
 * indirect user control. Refer to the device's Chip Configuration details on how to
 * request this command. ERSAREQ sets when and CCIF is set (no command is
 * currently being executed). ERSAREQ is cleared by the flash memory module when the
 * operation completes.
 *
 * Values:
 * - 0b0 - No request or request complete
 * - 0b1 - Request to: run the Erase All Blocks command, verify the erased
 *     state, program the security byte in the Flash Configuration Field to the
 *     unsecure state, and release MCU security by setting the FSEC[SEC] field to the
 *     unsecure state.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_ERSAREQ field. */
#define FTFA_RD_FCNFG_ERSAREQ(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_ERSAREQ_MASK) >> FTFA_FCNFG_ERSAREQ_SHIFT)
#define FTFA_BRD_FCNFG_ERSAREQ(base) (BME_UBFX8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_ERSAREQ_SHIFT, FTFA_FCNFG_ERSAREQ_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FCNFG, field RDCOLLIE[6] (RW)
 *
 * Controls interrupt generation when a flash memory read collision error occurs.
 *
 * Values:
 * - 0b0 - Read collision error interrupt disabled
 * - 0b1 - Read collision error interrupt enabled. An interrupt request is
 *     generated whenever a flash memory read collision error is detected (see the
 *     description of FSTAT[RDCOLERR]).
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_RDCOLLIE field. */
#define FTFA_RD_FCNFG_RDCOLLIE(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_RDCOLLIE_MASK) >> FTFA_FCNFG_RDCOLLIE_SHIFT)
#define FTFA_BRD_FCNFG_RDCOLLIE(base) (BME_UBFX8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_RDCOLLIE_SHIFT, FTFA_FCNFG_RDCOLLIE_WIDTH))

/*! @brief Set the RDCOLLIE field to a new value. */
#define FTFA_WR_FCNFG_RDCOLLIE(base, value) (FTFA_RMW_FCNFG(base, FTFA_FCNFG_RDCOLLIE_MASK, FTFA_FCNFG_RDCOLLIE(value)))
#define FTFA_BWR_FCNFG_RDCOLLIE(base, value) (BME_BFI8(&FTFA_FCNFG_REG(base), ((uint8_t)(value) << FTFA_FCNFG_RDCOLLIE_SHIFT), FTFA_FCNFG_RDCOLLIE_SHIFT, FTFA_FCNFG_RDCOLLIE_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FCNFG, field CCIE[7] (RW)
 *
 * Controls interrupt generation when a flash command completes.
 *
 * Values:
 * - 0b0 - Command complete interrupt disabled
 * - 0b1 - Command complete interrupt enabled. An interrupt request is generated
 *     whenever the FSTAT[CCIF] flag is set.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_CCIE field. */
#define FTFA_RD_FCNFG_CCIE(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_CCIE_MASK) >> FTFA_FCNFG_CCIE_SHIFT)
#define FTFA_BRD_FCNFG_CCIE(base) (BME_UBFX8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_CCIE_SHIFT, FTFA_FCNFG_CCIE_WIDTH))

/*! @brief Set the CCIE field to a new value. */
#define FTFA_WR_FCNFG_CCIE(base, value) (FTFA_RMW_FCNFG(base, FTFA_FCNFG_CCIE_MASK, FTFA_FCNFG_CCIE(value)))
#define FTFA_BWR_FCNFG_CCIE(base, value) (BME_BFI8(&FTFA_FCNFG_REG(base), ((uint8_t)(value) << FTFA_FCNFG_CCIE_SHIFT), FTFA_FCNFG_CCIE_SHIFT, FTFA_FCNFG_CCIE_WIDTH))
/*@}*/

/*******************************************************************************
 * FTFA_FSEC - Flash Security Register
 ******************************************************************************/

/*!
 * @brief FTFA_FSEC - Flash Security Register (RO)
 *
 * Reset value: 0x00U
 *
 * This read-only register holds all bits associated with the security of the
 * MCU and flash memory module. During the reset sequence, the register is loaded
 * with the contents of the flash security byte in the Flash Configuration Field
 * located in program flash memory. The flash basis for the values is signified by
 * X in the reset value.
 */
/*!
 * @name Constants and macros for entire FTFA_FSEC register
 */
/*@{*/
#define FTFA_RD_FSEC(base)       (FTFA_FSEC_REG(base))
/*@}*/

/*
 * Constants & macros for individual FTFA_FSEC bitfields
 */

/*!
 * @name Register FTFA_FSEC, field SEC[1:0] (RO)
 *
 * Defines the security state of the MCU. In the secure state, the MCU limits
 * access to flash memory module resources. The limitations are defined per device
 * and are detailed in the Chip Configuration details. If the flash memory module
 * is unsecured using backdoor key access, SEC is forced to 10b.
 *
 * Values:
 * - 0b00 - MCU security status is secure.
 * - 0b01 - MCU security status is secure.
 * - 0b10 - MCU security status is unsecure. (The standard shipping condition of
 *     the flash memory module is unsecure.)
 * - 0b11 - MCU security status is secure.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_SEC field. */
#define FTFA_RD_FSEC_SEC(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_SEC_MASK) >> FTFA_FSEC_SEC_SHIFT)
#define FTFA_BRD_FSEC_SEC(base) (BME_UBFX8(&FTFA_FSEC_REG(base), FTFA_FSEC_SEC_SHIFT, FTFA_FSEC_SEC_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSEC, field FSLACC[3:2] (RO)
 *
 * Enables or disables access to the flash memory contents during returned part
 * failure analysis at Freescale. When SEC is secure and FSLACC is denied, access
 * to the program flash contents is denied and any failure analysis performed by
 * Freescale factory test must begin with a full erase to unsecure the part.
 * When access is granted (SEC is unsecure, or SEC is secure and FSLACC is granted),
 * Freescale factory testing has visibility of the current flash contents. The
 * state of the FSLACC bits is only relevant when SEC is set to secure. When SEC
 * is set to unsecure, the FSLACC setting does not matter.
 *
 * Values:
 * - 0b00 - Freescale factory access granted
 * - 0b01 - Freescale factory access denied
 * - 0b10 - Freescale factory access denied
 * - 0b11 - Freescale factory access granted
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_FSLACC field. */
#define FTFA_RD_FSEC_FSLACC(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_FSLACC_MASK) >> FTFA_FSEC_FSLACC_SHIFT)
#define FTFA_BRD_FSEC_FSLACC(base) (BME_UBFX8(&FTFA_FSEC_REG(base), FTFA_FSEC_FSLACC_SHIFT, FTFA_FSEC_FSLACC_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSEC, field MEEN[5:4] (RO)
 *
 * Enables and disables mass erase capability of the flash memory module. When
 * SEC is set to unsecure, the MEEN setting does not matter.
 *
 * Values:
 * - 0b00 - Mass erase is enabled
 * - 0b01 - Mass erase is enabled
 * - 0b10 - Mass erase is disabled
 * - 0b11 - Mass erase is enabled
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_MEEN field. */
#define FTFA_RD_FSEC_MEEN(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_MEEN_MASK) >> FTFA_FSEC_MEEN_SHIFT)
#define FTFA_BRD_FSEC_MEEN(base) (BME_UBFX8(&FTFA_FSEC_REG(base), FTFA_FSEC_MEEN_SHIFT, FTFA_FSEC_MEEN_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSEC, field KEYEN[7:6] (RO)
 *
 * Enables or disables backdoor key access to the flash memory module.
 *
 * Values:
 * - 0b00 - Backdoor key access disabled
 * - 0b01 - Backdoor key access disabled (preferred KEYEN state to disable
 *     backdoor key access)
 * - 0b10 - Backdoor key access enabled
 * - 0b11 - Backdoor key access disabled
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_KEYEN field. */
#define FTFA_RD_FSEC_KEYEN(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_KEYEN_MASK) >> FTFA_FSEC_KEYEN_SHIFT)
#define FTFA_BRD_FSEC_KEYEN(base) (BME_UBFX8(&FTFA_FSEC_REG(base), FTFA_FSEC_KEYEN_SHIFT, FTFA_FSEC_KEYEN_WIDTH))
/*@}*/

/*******************************************************************************
 * FTFA_FOPT - Flash Option Register
 ******************************************************************************/

/*!
 * @brief FTFA_FOPT - Flash Option Register (RO)
 *
 * Reset value: 0x00U
 *
 * The flash option register allows the MCU to customize its operations by
 * examining the state of these read-only bits, which are loaded from NVM at reset.
 * The function of the bits is defined in the device's Chip Configuration details.
 * All bits in the register are read-only . During the reset sequence, the
 * register is loaded from the flash nonvolatile option byte in the Flash Configuration
 * Field located in program flash memory. The flash basis for the values is
 * signified by X in the reset value.
 */
/*!
 * @name Constants and macros for entire FTFA_FOPT register
 */
/*@{*/
#define FTFA_RD_FOPT(base)       (FTFA_FOPT_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB3 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB3 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB3 register
 */
/*@{*/
#define FTFA_RD_FCCOB3(base)     (FTFA_FCCOB3_REG(base))
#define FTFA_WR_FCCOB3(base, value) (FTFA_FCCOB3_REG(base) = (value))
#define FTFA_RMW_FCCOB3(base, mask, value) (FTFA_WR_FCCOB3(base, (FTFA_RD_FCCOB3(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB3(base, value) (BME_OR8(&FTFA_FCCOB3_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB3(base, value) (BME_AND8(&FTFA_FCCOB3_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB3(base, value) (BME_XOR8(&FTFA_FCCOB3_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB2 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB2 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB2 register
 */
/*@{*/
#define FTFA_RD_FCCOB2(base)     (FTFA_FCCOB2_REG(base))
#define FTFA_WR_FCCOB2(base, value) (FTFA_FCCOB2_REG(base) = (value))
#define FTFA_RMW_FCCOB2(base, mask, value) (FTFA_WR_FCCOB2(base, (FTFA_RD_FCCOB2(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB2(base, value) (BME_OR8(&FTFA_FCCOB2_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB2(base, value) (BME_AND8(&FTFA_FCCOB2_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB2(base, value) (BME_XOR8(&FTFA_FCCOB2_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB1 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB1 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB1 register
 */
/*@{*/
#define FTFA_RD_FCCOB1(base)     (FTFA_FCCOB1_REG(base))
#define FTFA_WR_FCCOB1(base, value) (FTFA_FCCOB1_REG(base) = (value))
#define FTFA_RMW_FCCOB1(base, mask, value) (FTFA_WR_FCCOB1(base, (FTFA_RD_FCCOB1(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB1(base, value) (BME_OR8(&FTFA_FCCOB1_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB1(base, value) (BME_AND8(&FTFA_FCCOB1_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB1(base, value) (BME_XOR8(&FTFA_FCCOB1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB0 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB0 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB0 register
 */
/*@{*/
#define FTFA_RD_FCCOB0(base)     (FTFA_FCCOB0_REG(base))
#define FTFA_WR_FCCOB0(base, value) (FTFA_FCCOB0_REG(base) = (value))
#define FTFA_RMW_FCCOB0(base, mask, value) (FTFA_WR_FCCOB0(base, (FTFA_RD_FCCOB0(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB0(base, value) (BME_OR8(&FTFA_FCCOB0_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB0(base, value) (BME_AND8(&FTFA_FCCOB0_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB0(base, value) (BME_XOR8(&FTFA_FCCOB0_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB7 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB7 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB7 register
 */
/*@{*/
#define FTFA_RD_FCCOB7(base)     (FTFA_FCCOB7_REG(base))
#define FTFA_WR_FCCOB7(base, value) (FTFA_FCCOB7_REG(base) = (value))
#define FTFA_RMW_FCCOB7(base, mask, value) (FTFA_WR_FCCOB7(base, (FTFA_RD_FCCOB7(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB7(base, value) (BME_OR8(&FTFA_FCCOB7_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB7(base, value) (BME_AND8(&FTFA_FCCOB7_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB7(base, value) (BME_XOR8(&FTFA_FCCOB7_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB6 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB6 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB6 register
 */
/*@{*/
#define FTFA_RD_FCCOB6(base)     (FTFA_FCCOB6_REG(base))
#define FTFA_WR_FCCOB6(base, value) (FTFA_FCCOB6_REG(base) = (value))
#define FTFA_RMW_FCCOB6(base, mask, value) (FTFA_WR_FCCOB6(base, (FTFA_RD_FCCOB6(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB6(base, value) (BME_OR8(&FTFA_FCCOB6_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB6(base, value) (BME_AND8(&FTFA_FCCOB6_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB6(base, value) (BME_XOR8(&FTFA_FCCOB6_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB5 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB5 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB5 register
 */
/*@{*/
#define FTFA_RD_FCCOB5(base)     (FTFA_FCCOB5_REG(base))
#define FTFA_WR_FCCOB5(base, value) (FTFA_FCCOB5_REG(base) = (value))
#define FTFA_RMW_FCCOB5(base, mask, value) (FTFA_WR_FCCOB5(base, (FTFA_RD_FCCOB5(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB5(base, value) (BME_OR8(&FTFA_FCCOB5_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB5(base, value) (BME_AND8(&FTFA_FCCOB5_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB5(base, value) (BME_XOR8(&FTFA_FCCOB5_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB4 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB4 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB4 register
 */
/*@{*/
#define FTFA_RD_FCCOB4(base)     (FTFA_FCCOB4_REG(base))
#define FTFA_WR_FCCOB4(base, value) (FTFA_FCCOB4_REG(base) = (value))
#define FTFA_RMW_FCCOB4(base, mask, value) (FTFA_WR_FCCOB4(base, (FTFA_RD_FCCOB4(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB4(base, value) (BME_OR8(&FTFA_FCCOB4_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB4(base, value) (BME_AND8(&FTFA_FCCOB4_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB4(base, value) (BME_XOR8(&FTFA_FCCOB4_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOBB - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOBB - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOBB register
 */
/*@{*/
#define FTFA_RD_FCCOBB(base)     (FTFA_FCCOBB_REG(base))
#define FTFA_WR_FCCOBB(base, value) (FTFA_FCCOBB_REG(base) = (value))
#define FTFA_RMW_FCCOBB(base, mask, value) (FTFA_WR_FCCOBB(base, (FTFA_RD_FCCOBB(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOBB(base, value) (BME_OR8(&FTFA_FCCOBB_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOBB(base, value) (BME_AND8(&FTFA_FCCOBB_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOBB(base, value) (BME_XOR8(&FTFA_FCCOBB_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOBA - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOBA - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOBA register
 */
/*@{*/
#define FTFA_RD_FCCOBA(base)     (FTFA_FCCOBA_REG(base))
#define FTFA_WR_FCCOBA(base, value) (FTFA_FCCOBA_REG(base) = (value))
#define FTFA_RMW_FCCOBA(base, mask, value) (FTFA_WR_FCCOBA(base, (FTFA_RD_FCCOBA(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOBA(base, value) (BME_OR8(&FTFA_FCCOBA_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOBA(base, value) (BME_AND8(&FTFA_FCCOBA_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOBA(base, value) (BME_XOR8(&FTFA_FCCOBA_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB9 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB9 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB9 register
 */
/*@{*/
#define FTFA_RD_FCCOB9(base)     (FTFA_FCCOB9_REG(base))
#define FTFA_WR_FCCOB9(base, value) (FTFA_FCCOB9_REG(base) = (value))
#define FTFA_RMW_FCCOB9(base, mask, value) (FTFA_WR_FCCOB9(base, (FTFA_RD_FCCOB9(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB9(base, value) (BME_OR8(&FTFA_FCCOB9_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB9(base, value) (BME_AND8(&FTFA_FCCOB9_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB9(base, value) (BME_XOR8(&FTFA_FCCOB9_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB8 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB8 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB8 register
 */
/*@{*/
#define FTFA_RD_FCCOB8(base)     (FTFA_FCCOB8_REG(base))
#define FTFA_WR_FCCOB8(base, value) (FTFA_FCCOB8_REG(base) = (value))
#define FTFA_RMW_FCCOB8(base, mask, value) (FTFA_WR_FCCOB8(base, (FTFA_RD_FCCOB8(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB8(base, value) (BME_OR8(&FTFA_FCCOB8_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB8(base, value) (BME_AND8(&FTFA_FCCOB8_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB8(base, value) (BME_XOR8(&FTFA_FCCOB8_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT3 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT3 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 32 KB of program flash where each assigned bit protects 1
 * KB . For configurations with 24 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory, FPROT2 is
 * not used. For configurations with 24 KB of program flash memory or less,
 * FPROT0 is not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory,
 * FPROT2 is not used. The bitfields are defined in each register as follows:
 * Program flash protection register Program flash protection bits FPROT0 PROT[31:24]
 * FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset
 * sequence, the FPROT registers are loaded with the contents of the program flash
 * protection bytes in the Flash Configuration Field as indicated in the following
 * table. Program flash protection register Flash Configuration Field offset address
 * FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program
 * flash protection that is loaded during the reset sequence, unprotect the
 * sector of program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT3 register
 */
/*@{*/
#define FTFA_RD_FPROT3(base)     (FTFA_FPROT3_REG(base))
#define FTFA_WR_FPROT3(base, value) (FTFA_FPROT3_REG(base) = (value))
#define FTFA_RMW_FPROT3(base, mask, value) (FTFA_WR_FPROT3(base, (FTFA_RD_FPROT3(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT3(base, value) (BME_OR8(&FTFA_FPROT3_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FPROT3(base, value) (BME_AND8(&FTFA_FPROT3_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FPROT3(base, value) (BME_XOR8(&FTFA_FPROT3_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT2 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT2 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 32 KB of program flash where each assigned bit protects 1
 * KB . For configurations with 24 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory, FPROT2 is
 * not used. For configurations with 24 KB of program flash memory or less,
 * FPROT0 is not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory,
 * FPROT2 is not used. The bitfields are defined in each register as follows:
 * Program flash protection register Program flash protection bits FPROT0 PROT[31:24]
 * FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset
 * sequence, the FPROT registers are loaded with the contents of the program flash
 * protection bytes in the Flash Configuration Field as indicated in the following
 * table. Program flash protection register Flash Configuration Field offset address
 * FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program
 * flash protection that is loaded during the reset sequence, unprotect the
 * sector of program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT2 register
 */
/*@{*/
#define FTFA_RD_FPROT2(base)     (FTFA_FPROT2_REG(base))
#define FTFA_WR_FPROT2(base, value) (FTFA_FPROT2_REG(base) = (value))
#define FTFA_RMW_FPROT2(base, mask, value) (FTFA_WR_FPROT2(base, (FTFA_RD_FPROT2(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT2(base, value) (BME_OR8(&FTFA_FPROT2_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FPROT2(base, value) (BME_AND8(&FTFA_FPROT2_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FPROT2(base, value) (BME_XOR8(&FTFA_FPROT2_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT1 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT1 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 32 KB of program flash where each assigned bit protects 1
 * KB . For configurations with 24 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory, FPROT2 is
 * not used. For configurations with 24 KB of program flash memory or less,
 * FPROT0 is not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory,
 * FPROT2 is not used. The bitfields are defined in each register as follows:
 * Program flash protection register Program flash protection bits FPROT0 PROT[31:24]
 * FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset
 * sequence, the FPROT registers are loaded with the contents of the program flash
 * protection bytes in the Flash Configuration Field as indicated in the following
 * table. Program flash protection register Flash Configuration Field offset address
 * FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program
 * flash protection that is loaded during the reset sequence, unprotect the
 * sector of program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT1 register
 */
/*@{*/
#define FTFA_RD_FPROT1(base)     (FTFA_FPROT1_REG(base))
#define FTFA_WR_FPROT1(base, value) (FTFA_FPROT1_REG(base) = (value))
#define FTFA_RMW_FPROT1(base, mask, value) (FTFA_WR_FPROT1(base, (FTFA_RD_FPROT1(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT1(base, value) (BME_OR8(&FTFA_FPROT1_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FPROT1(base, value) (BME_AND8(&FTFA_FPROT1_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FPROT1(base, value) (BME_XOR8(&FTFA_FPROT1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT0 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT0 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 32 KB of program flash where each assigned bit protects 1
 * KB . For configurations with 24 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory, FPROT2 is
 * not used. For configurations with 24 KB of program flash memory or less,
 * FPROT0 is not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory,
 * FPROT2 is not used. The bitfields are defined in each register as follows:
 * Program flash protection register Program flash protection bits FPROT0 PROT[31:24]
 * FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset
 * sequence, the FPROT registers are loaded with the contents of the program flash
 * protection bytes in the Flash Configuration Field as indicated in the following
 * table. Program flash protection register Flash Configuration Field offset address
 * FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program
 * flash protection that is loaded during the reset sequence, unprotect the
 * sector of program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT0 register
 */
/*@{*/
#define FTFA_RD_FPROT0(base)     (FTFA_FPROT0_REG(base))
#define FTFA_WR_FPROT0(base, value) (FTFA_FPROT0_REG(base) = (value))
#define FTFA_RMW_FPROT0(base, mask, value) (FTFA_WR_FPROT0(base, (FTFA_RD_FPROT0(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT0(base, value) (BME_OR8(&FTFA_FPROT0_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FPROT0(base, value) (BME_AND8(&FTFA_FPROT0_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FPROT0(base, value) (BME_XOR8(&FTFA_FPROT0_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_XACCH3 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCH3 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCH3 register
 */
/*@{*/
#define FTFA_RD_XACCH3(base)     (FTFA_XACCH3_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCH2 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCH2 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCH2 register
 */
/*@{*/
#define FTFA_RD_XACCH2(base)     (FTFA_XACCH2_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCH1 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCH1 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCH1 register
 */
/*@{*/
#define FTFA_RD_XACCH1(base)     (FTFA_XACCH1_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCH0 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCH0 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCH0 register
 */
/*@{*/
#define FTFA_RD_XACCH0(base)     (FTFA_XACCH0_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCL3 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCL3 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCL3 register
 */
/*@{*/
#define FTFA_RD_XACCL3(base)     (FTFA_XACCL3_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCL2 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCL2 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCL2 register
 */
/*@{*/
#define FTFA_RD_XACCL2(base)     (FTFA_XACCL2_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCL1 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCL1 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCL1 register
 */
/*@{*/
#define FTFA_RD_XACCL1(base)     (FTFA_XACCL1_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCL0 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCL0 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCL0 register
 */
/*@{*/
#define FTFA_RD_XACCL0(base)     (FTFA_XACCL0_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCH3 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCH3 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCH3 register
 */
/*@{*/
#define FTFA_RD_SACCH3(base)     (FTFA_SACCH3_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCH2 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCH2 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCH2 register
 */
/*@{*/
#define FTFA_RD_SACCH2(base)     (FTFA_SACCH2_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCH1 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCH1 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCH1 register
 */
/*@{*/
#define FTFA_RD_SACCH1(base)     (FTFA_SACCH1_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCH0 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCH0 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCH0 register
 */
/*@{*/
#define FTFA_RD_SACCH0(base)     (FTFA_SACCH0_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCL3 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCL3 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCL3 register
 */
/*@{*/
#define FTFA_RD_SACCL3(base)     (FTFA_SACCL3_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCL2 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCL2 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCL2 register
 */
/*@{*/
#define FTFA_RD_SACCL2(base)     (FTFA_SACCL2_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCL1 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCL1 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCL1 register
 */
/*@{*/
#define FTFA_RD_SACCL1(base)     (FTFA_SACCL1_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCL0 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCL0 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCL0 register
 */
/*@{*/
#define FTFA_RD_SACCL0(base)     (FTFA_SACCL0_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_FACSS - Flash Access Segment Size Register
 ******************************************************************************/

/*!
 * @brief FTFA_FACSS - Flash Access Segment Size Register (RO)
 *
 * Reset value: 0x00U
 *
 * The flash access segment size register determines which bits in the address
 * are used to index into the SACC and XACC bitmaps to get the appropriate
 * permission flags. All bits in the register are read-only. The contents of this
 * register are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_FACSS register
 */
/*@{*/
#define FTFA_RD_FACSS(base)      (FTFA_FACSS_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_FACSN - Flash Access Segment Number Register
 ******************************************************************************/

/*!
 * @brief FTFA_FACSN - Flash Access Segment Number Register (RO)
 *
 * Reset value: 0x00U
 *
 * The flash access segment number register provides the number of program flash
 * segments that are available for XACC and SACC permissions. All bits in the
 * register are read-only. The contents of this register are loaded during the
 * reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_FACSN register
 */
/*@{*/
#define FTFA_RD_FACSN(base)      (FTFA_FACSN_REG(base))
/*@}*/

/*
 * MKW40Z4 GPIO
 *
 * General Purpose Input/Output
 *
 * Registers defined in this header file:
 * - GPIO_PDOR - Port Data Output Register
 * - GPIO_PSOR - Port Set Output Register
 * - GPIO_PCOR - Port Clear Output Register
 * - GPIO_PTOR - Port Toggle Output Register
 * - GPIO_PDIR - Port Data Input Register
 * - GPIO_PDDR - Port Data Direction Register
 */

#define GPIO_INSTANCE_COUNT (3U) /*!< Number of instances of the GPIO module. */
#define GPIOA_IDX (0U) /*!< Instance number for GPIOA. */
#define GPIOB_IDX (1U) /*!< Instance number for GPIOB. */
#define GPIOC_IDX (2U) /*!< Instance number for GPIOC. */

/*******************************************************************************
 * GPIO_PDOR - Port Data Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDOR - Port Data Output Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register configures the logic levels that are driven on each
 * general-purpose output pins. Do not modify pin configuration registers associated with
 * pins not available in your selected package. All unbonded pins not available in
 * your package will default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire GPIO_PDOR register
 */
/*@{*/
#define GPIO_RD_PDOR(base)       (GPIO_PDOR_REG(base))
#define GPIO_WR_PDOR(base, value) (GPIO_PDOR_REG(base) = (value))
#define GPIO_RMW_PDOR(base, mask, value) (GPIO_WR_PDOR(base, (GPIO_RD_PDOR(base) & ~(mask)) | (value)))
#define GPIO_SET_PDOR(base, value) (BME_OR32(&GPIO_PDOR_REG(base), (uint32_t)(value)))
#define GPIO_CLR_PDOR(base, value) (BME_AND32(&GPIO_PDOR_REG(base), (uint32_t)(~(value))))
#define GPIO_TOG_PDOR(base, value) (BME_XOR32(&GPIO_PDOR_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * GPIO_PSOR - Port Set Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PSOR - Port Set Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to set the fields of the PDOR.
 */
/*!
 * @name Constants and macros for entire GPIO_PSOR register
 */
/*@{*/
#define GPIO_RD_PSOR(base)       (GPIO_PSOR_REG(base))
#define GPIO_WR_PSOR(base, value) (GPIO_PSOR_REG(base) = (value))
#define GPIO_RMW_PSOR(base, mask, value) (GPIO_WR_PSOR(base, (GPIO_RD_PSOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PCOR - Port Clear Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PCOR - Port Clear Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to clear the fields of PDOR.
 */
/*!
 * @name Constants and macros for entire GPIO_PCOR register
 */
/*@{*/
#define GPIO_RD_PCOR(base)       (GPIO_PCOR_REG(base))
#define GPIO_WR_PCOR(base, value) (GPIO_PCOR_REG(base) = (value))
#define GPIO_RMW_PCOR(base, mask, value) (GPIO_WR_PCOR(base, (GPIO_RD_PCOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PTOR - Port Toggle Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PTOR - Port Toggle Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire GPIO_PTOR register
 */
/*@{*/
#define GPIO_RD_PTOR(base)       (GPIO_PTOR_REG(base))
#define GPIO_WR_PTOR(base, value) (GPIO_PTOR_REG(base) = (value))
#define GPIO_RMW_PTOR(base, mask, value) (GPIO_WR_PTOR(base, (GPIO_RD_PTOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PDIR - Port Data Input Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDIR - Port Data Input Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Do not modify pin configuration registers associated with pins not available
 * in your selected package. All unbonded pins not available in your package will
 * default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire GPIO_PDIR register
 */
/*@{*/
#define GPIO_RD_PDIR(base)       (GPIO_PDIR_REG(base))
/*@}*/

/*******************************************************************************
 * GPIO_PDDR - Port Data Direction Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDDR - Port Data Direction Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The PDDR configures the individual port pins for input or output.
 */
/*!
 * @name Constants and macros for entire GPIO_PDDR register
 */
/*@{*/
#define GPIO_RD_PDDR(base)       (GPIO_PDDR_REG(base))
#define GPIO_WR_PDDR(base, value) (GPIO_PDDR_REG(base) = (value))
#define GPIO_RMW_PDDR(base, mask, value) (GPIO_WR_PDDR(base, (GPIO_RD_PDDR(base) & ~(mask)) | (value)))
#define GPIO_SET_PDDR(base, value) (BME_OR32(&GPIO_PDDR_REG(base), (uint32_t)(value)))
#define GPIO_CLR_PDDR(base, value) (BME_AND32(&GPIO_PDDR_REG(base), (uint32_t)(~(value))))
#define GPIO_TOG_PDDR(base, value) (BME_XOR32(&GPIO_PDDR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * MKW40Z4 I2C
 *
 * Inter-Integrated Circuit
 *
 * Registers defined in this header file:
 * - I2C_A1 - I2C Address Register 1
 * - I2C_F - I2C Frequency Divider register
 * - I2C_C1 - I2C Control Register 1
 * - I2C_S - I2C Status register
 * - I2C_D - I2C Data I/O register
 * - I2C_C2 - I2C Control Register 2
 * - I2C_FLT - I2C Programmable Input Glitch Filter Register
 * - I2C_RA - I2C Range Address register
 * - I2C_SMB - I2C SMBus Control and Status register
 * - I2C_A2 - I2C Address Register 2
 * - I2C_SLTH - I2C SCL Low Timeout Register High
 * - I2C_SLTL - I2C SCL Low Timeout Register Low
 * - I2C_S2 - I2C Status register 2
 */

#define I2C_INSTANCE_COUNT (2U) /*!< Number of instances of the I2C module. */
#define I2C0_IDX (0U) /*!< Instance number for I2C0. */
#define I2C1_IDX (1U) /*!< Instance number for I2C1. */

/*******************************************************************************
 * I2C_A1 - I2C Address Register 1
 ******************************************************************************/

/*!
 * @brief I2C_A1 - I2C Address Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains the slave address to be used by the I2C module.
 */
/*!
 * @name Constants and macros for entire I2C_A1 register
 */
/*@{*/
#define I2C_RD_A1(base)          (I2C_A1_REG(base))
#define I2C_WR_A1(base, value)   (I2C_A1_REG(base) = (value))
#define I2C_RMW_A1(base, mask, value) (I2C_WR_A1(base, (I2C_RD_A1(base) & ~(mask)) | (value)))
#define I2C_SET_A1(base, value)  (BME_OR8(&I2C_A1_REG(base), (uint8_t)(value)))
#define I2C_CLR_A1(base, value)  (BME_AND8(&I2C_A1_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_A1(base, value)  (BME_XOR8(&I2C_A1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_A1 bitfields
 */

/*!
 * @name Register I2C_A1, field AD[7:1] (RW)
 *
 * Contains the primary slave address used by the I2C module when it is
 * addressed as a slave. This field is used in the 7-bit address scheme and the lower
 * seven bits in the 10-bit address scheme.
 */
/*@{*/
/*! @brief Read current value of the I2C_A1_AD field. */
#define I2C_RD_A1_AD(base)   ((I2C_A1_REG(base) & I2C_A1_AD_MASK) >> I2C_A1_AD_SHIFT)
#define I2C_BRD_A1_AD(base)  (BME_UBFX8(&I2C_A1_REG(base), I2C_A1_AD_SHIFT, I2C_A1_AD_WIDTH))

/*! @brief Set the AD field to a new value. */
#define I2C_WR_A1_AD(base, value) (I2C_RMW_A1(base, I2C_A1_AD_MASK, I2C_A1_AD(value)))
#define I2C_BWR_A1_AD(base, value) (BME_BFI8(&I2C_A1_REG(base), ((uint8_t)(value) << I2C_A1_AD_SHIFT), I2C_A1_AD_SHIFT, I2C_A1_AD_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_F - I2C Frequency Divider register
 ******************************************************************************/

/*!
 * @brief I2C_F - I2C Frequency Divider register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_F register
 */
/*@{*/
#define I2C_RD_F(base)           (I2C_F_REG(base))
#define I2C_WR_F(base, value)    (I2C_F_REG(base) = (value))
#define I2C_RMW_F(base, mask, value) (I2C_WR_F(base, (I2C_RD_F(base) & ~(mask)) | (value)))
#define I2C_SET_F(base, value)   (BME_OR8(&I2C_F_REG(base), (uint8_t)(value)))
#define I2C_CLR_F(base, value)   (BME_AND8(&I2C_F_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_F(base, value)   (BME_XOR8(&I2C_F_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_F bitfields
 */

/*!
 * @name Register I2C_F, field ICR[5:0] (RW)
 *
 * Prescales the I2C module clock for bit rate selection. This field and the
 * MULT field determine the I2C baud rate, the SDA hold time, the SCL start hold
 * time, and the SCL stop hold time. For a list of values corresponding to each ICR
 * setting, see I2C divider and hold values. The SCL divider multiplied by
 * multiplier factor (mul) determines the I2C baud rate. I2C baud rate = I2C module
 * clock speed (Hz)/(mul * SCL divider) The SDA hold time is the delay from the
 * falling edge of SCL (I2C clock) to the changing of SDA (I2C data). SDA hold time =
 * I2C module clock period (s) * mul * SDA hold value The SCL start hold time is
 * the delay from the falling edge of SDA (I2C data) while SCL is high (start
 * condition) to the falling edge of SCL (I2C clock). SCL start hold time = I2C
 * module clock period (s) * mul * SCL start hold value The SCL stop hold time is
 * the delay from the rising edge of SCL (I2C clock) to the rising edge of SDA (I2C
 * data) while SCL is high (stop condition). SCL stop hold time = I2C module
 * clock period (s) * mul * SCL stop hold value For example, if the I2C module clock
 * speed is 8 MHz, the following table shows the possible hold time values with
 * different ICR and MULT selections to achieve an I2C baud rate of 100 kbit/s.
 * MULT ICR Hold times (us) SDA SCL Start SCL Stop 2h 00h 3.500 3.000 5.500 1h 07h
 * 2.500 4.000 5.250 1h 0Bh 2.250 4.000 5.250 0h 14h 2.125 4.250 5.125 0h 18h
 * 1.125 4.750 5.125
 */
/*@{*/
/*! @brief Read current value of the I2C_F_ICR field. */
#define I2C_RD_F_ICR(base)   ((I2C_F_REG(base) & I2C_F_ICR_MASK) >> I2C_F_ICR_SHIFT)
#define I2C_BRD_F_ICR(base)  (BME_UBFX8(&I2C_F_REG(base), I2C_F_ICR_SHIFT, I2C_F_ICR_WIDTH))

/*! @brief Set the ICR field to a new value. */
#define I2C_WR_F_ICR(base, value) (I2C_RMW_F(base, I2C_F_ICR_MASK, I2C_F_ICR(value)))
#define I2C_BWR_F_ICR(base, value) (BME_BFI8(&I2C_F_REG(base), ((uint8_t)(value) << I2C_F_ICR_SHIFT), I2C_F_ICR_SHIFT, I2C_F_ICR_WIDTH))
/*@}*/

/*!
 * @name Register I2C_F, field MULT[7:6] (RW)
 *
 * Defines the multiplier factor (mul). This factor is used along with the SCL
 * divider to generate the I2C baud rate.
 *
 * Values:
 * - 0b00 - mul = 1
 * - 0b01 - mul = 2
 * - 0b10 - mul = 4
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the I2C_F_MULT field. */
#define I2C_RD_F_MULT(base)  ((I2C_F_REG(base) & I2C_F_MULT_MASK) >> I2C_F_MULT_SHIFT)
#define I2C_BRD_F_MULT(base) (BME_UBFX8(&I2C_F_REG(base), I2C_F_MULT_SHIFT, I2C_F_MULT_WIDTH))

/*! @brief Set the MULT field to a new value. */
#define I2C_WR_F_MULT(base, value) (I2C_RMW_F(base, I2C_F_MULT_MASK, I2C_F_MULT(value)))
#define I2C_BWR_F_MULT(base, value) (BME_BFI8(&I2C_F_REG(base), ((uint8_t)(value) << I2C_F_MULT_SHIFT), I2C_F_MULT_SHIFT, I2C_F_MULT_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_C1 - I2C Control Register 1
 ******************************************************************************/

/*!
 * @brief I2C_C1 - I2C Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_C1 register
 */
/*@{*/
#define I2C_RD_C1(base)          (I2C_C1_REG(base))
#define I2C_WR_C1(base, value)   (I2C_C1_REG(base) = (value))
#define I2C_RMW_C1(base, mask, value) (I2C_WR_C1(base, (I2C_RD_C1(base) & ~(mask)) | (value)))
#define I2C_SET_C1(base, value)  (BME_OR8(&I2C_C1_REG(base), (uint8_t)(value)))
#define I2C_CLR_C1(base, value)  (BME_AND8(&I2C_C1_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_C1(base, value)  (BME_XOR8(&I2C_C1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_C1 bitfields
 */

/*!
 * @name Register I2C_C1, field DMAEN[0] (RW)
 *
 * Enables or disables the DMA function.
 *
 * Values:
 * - 0b0 - All DMA signalling disabled.
 * - 0b1 - DMA transfer is enabled. While SMB[FACK] = 0, the following
 *     conditions trigger the DMA request: a data byte is received, and either address or
 *     data is transmitted. (ACK/NACK is automatic) the first byte received
 *     matches the A1 register or is a general call address. If any address matching
 *     occurs, S[IAAS] and S[TCF] are set. If the direction of transfer is known
 *     from master to slave, then it is not required to check S[SRW]. With this
 *     assumption, DMA can also be used in this case. In other cases, if the master
 *     reads data from the slave, then it is required to rewrite the C1 register
 *     operation. With this assumption, DMA cannot be used. When FACK = 1, an
 *     address or a data byte is transmitted.
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_DMAEN field. */
#define I2C_RD_C1_DMAEN(base) ((I2C_C1_REG(base) & I2C_C1_DMAEN_MASK) >> I2C_C1_DMAEN_SHIFT)
#define I2C_BRD_C1_DMAEN(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_DMAEN_SHIFT, I2C_C1_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define I2C_WR_C1_DMAEN(base, value) (I2C_RMW_C1(base, I2C_C1_DMAEN_MASK, I2C_C1_DMAEN(value)))
#define I2C_BWR_C1_DMAEN(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_DMAEN_SHIFT), I2C_C1_DMAEN_SHIFT, I2C_C1_DMAEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field WUEN[1] (RW)
 *
 * The I2C module can wake the MCU from low power mode with no peripheral bus
 * running when slave address matching occurs.
 *
 * Values:
 * - 0b0 - Normal operation. No interrupt generated when address matching in low
 *     power mode.
 * - 0b1 - Enables the wakeup function in low power mode.
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_WUEN field. */
#define I2C_RD_C1_WUEN(base) ((I2C_C1_REG(base) & I2C_C1_WUEN_MASK) >> I2C_C1_WUEN_SHIFT)
#define I2C_BRD_C1_WUEN(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_WUEN_SHIFT, I2C_C1_WUEN_WIDTH))

/*! @brief Set the WUEN field to a new value. */
#define I2C_WR_C1_WUEN(base, value) (I2C_RMW_C1(base, I2C_C1_WUEN_MASK, I2C_C1_WUEN(value)))
#define I2C_BWR_C1_WUEN(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_WUEN_SHIFT), I2C_C1_WUEN_SHIFT, I2C_C1_WUEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field RSTA[2] (WORZ)
 *
 * Writing 1 to this bit generates a repeated START condition provided it is the
 * current master. This bit will always be read as 0. Attempting a repeat at the
 * wrong time results in loss of arbitration.
 */
/*@{*/
/*! @brief Set the RSTA field to a new value. */
#define I2C_WR_C1_RSTA(base, value) (I2C_RMW_C1(base, I2C_C1_RSTA_MASK, I2C_C1_RSTA(value)))
#define I2C_BWR_C1_RSTA(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_RSTA_SHIFT), I2C_C1_RSTA_SHIFT, I2C_C1_RSTA_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field TXAK[3] (RW)
 *
 * Specifies the value driven onto the SDA during data acknowledge cycles for
 * both master and slave receivers. The value of SMB[FACK] affects NACK/ACK
 * generation. SCL is held low until TXAK is written.
 *
 * Values:
 * - 0b0 - An acknowledge signal is sent to the bus on the following receiving
 *     byte (if FACK is cleared) or the current receiving byte (if FACK is set).
 * - 0b1 - No acknowledge signal is sent to the bus on the following receiving
 *     data byte (if FACK is cleared) or the current receiving data byte (if FACK
 *     is set).
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_TXAK field. */
#define I2C_RD_C1_TXAK(base) ((I2C_C1_REG(base) & I2C_C1_TXAK_MASK) >> I2C_C1_TXAK_SHIFT)
#define I2C_BRD_C1_TXAK(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_TXAK_SHIFT, I2C_C1_TXAK_WIDTH))

/*! @brief Set the TXAK field to a new value. */
#define I2C_WR_C1_TXAK(base, value) (I2C_RMW_C1(base, I2C_C1_TXAK_MASK, I2C_C1_TXAK(value)))
#define I2C_BWR_C1_TXAK(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_TXAK_SHIFT), I2C_C1_TXAK_SHIFT, I2C_C1_TXAK_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field TX[4] (RW)
 *
 * Selects the direction of master and slave transfers. In master mode this bit
 * must be set according to the type of transfer required. Therefore, for address
 * cycles, this bit is always set. When addressed as a slave this bit must be
 * set by software according to the SRW bit in the status register.
 *
 * Values:
 * - 0b0 - Receive
 * - 0b1 - Transmit
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_TX field. */
#define I2C_RD_C1_TX(base)   ((I2C_C1_REG(base) & I2C_C1_TX_MASK) >> I2C_C1_TX_SHIFT)
#define I2C_BRD_C1_TX(base)  (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_TX_SHIFT, I2C_C1_TX_WIDTH))

/*! @brief Set the TX field to a new value. */
#define I2C_WR_C1_TX(base, value) (I2C_RMW_C1(base, I2C_C1_TX_MASK, I2C_C1_TX(value)))
#define I2C_BWR_C1_TX(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_TX_SHIFT), I2C_C1_TX_SHIFT, I2C_C1_TX_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field MST[5] (RW)
 *
 * When MST is changed from 0 to 1, a START signal is generated on the bus and
 * master mode is selected. When this bit changes from 1 to 0, a STOP signal is
 * generated and the mode of operation changes from master to slave.
 *
 * Values:
 * - 0b0 - Slave mode
 * - 0b1 - Master mode
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_MST field. */
#define I2C_RD_C1_MST(base)  ((I2C_C1_REG(base) & I2C_C1_MST_MASK) >> I2C_C1_MST_SHIFT)
#define I2C_BRD_C1_MST(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_MST_SHIFT, I2C_C1_MST_WIDTH))

/*! @brief Set the MST field to a new value. */
#define I2C_WR_C1_MST(base, value) (I2C_RMW_C1(base, I2C_C1_MST_MASK, I2C_C1_MST(value)))
#define I2C_BWR_C1_MST(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_MST_SHIFT), I2C_C1_MST_SHIFT, I2C_C1_MST_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field IICIE[6] (RW)
 *
 * Enables I2C interrupt requests.
 *
 * Values:
 * - 0b0 - Disabled
 * - 0b1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_IICIE field. */
#define I2C_RD_C1_IICIE(base) ((I2C_C1_REG(base) & I2C_C1_IICIE_MASK) >> I2C_C1_IICIE_SHIFT)
#define I2C_BRD_C1_IICIE(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_IICIE_SHIFT, I2C_C1_IICIE_WIDTH))

/*! @brief Set the IICIE field to a new value. */
#define I2C_WR_C1_IICIE(base, value) (I2C_RMW_C1(base, I2C_C1_IICIE_MASK, I2C_C1_IICIE(value)))
#define I2C_BWR_C1_IICIE(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_IICIE_SHIFT), I2C_C1_IICIE_SHIFT, I2C_C1_IICIE_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field IICEN[7] (RW)
 *
 * Enables I2C module operation.
 *
 * Values:
 * - 0b0 - Disabled
 * - 0b1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_IICEN field. */
#define I2C_RD_C1_IICEN(base) ((I2C_C1_REG(base) & I2C_C1_IICEN_MASK) >> I2C_C1_IICEN_SHIFT)
#define I2C_BRD_C1_IICEN(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_IICEN_SHIFT, I2C_C1_IICEN_WIDTH))

/*! @brief Set the IICEN field to a new value. */
#define I2C_WR_C1_IICEN(base, value) (I2C_RMW_C1(base, I2C_C1_IICEN_MASK, I2C_C1_IICEN(value)))
#define I2C_BWR_C1_IICEN(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_IICEN_SHIFT), I2C_C1_IICEN_SHIFT, I2C_C1_IICEN_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_S - I2C Status register
 ******************************************************************************/

/*!
 * @brief I2C_S - I2C Status register (RW)
 *
 * Reset value: 0x80U
 */
/*!
 * @name Constants and macros for entire I2C_S register
 */
/*@{*/
#define I2C_RD_S(base)           (I2C_S_REG(base))
#define I2C_WR_S(base, value)    (I2C_S_REG(base) = (value))
#define I2C_RMW_S(base, mask, value) (I2C_WR_S(base, (I2C_RD_S(base) & ~(mask)) | (value)))
#define I2C_SET_S(base, value)   (BME_OR8(&I2C_S_REG(base), (uint8_t)(value)))
#define I2C_CLR_S(base, value)   (BME_AND8(&I2C_S_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_S(base, value)   (BME_XOR8(&I2C_S_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_S bitfields
 */

/*!
 * @name Register I2C_S, field RXAK[0] (RO)
 *
 * Values:
 * - 0b0 - Acknowledge signal was received after the completion of one byte of
 *     data transmission on the bus
 * - 0b1 - No acknowledge signal detected
 */
/*@{*/
/*! @brief Read current value of the I2C_S_RXAK field. */
#define I2C_RD_S_RXAK(base)  ((I2C_S_REG(base) & I2C_S_RXAK_MASK) >> I2C_S_RXAK_SHIFT)
#define I2C_BRD_S_RXAK(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_RXAK_SHIFT, I2C_S_RXAK_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field IICIF[1] (W1C)
 *
 * This bit sets when an interrupt is pending. This bit must be cleared by
 * software by writing 1 to it, such as in the interrupt routine. One of the following
 * events can set this bit: One byte transfer, including ACK/NACK bit, completes
 * if FACK is 0. An ACK or NACK is sent on the bus by writing 0 or 1 to TXAK
 * after this bit is set in receive mode. One byte transfer, excluding ACK/NACK bit,
 * completes if FACK is 1. Match of slave address to calling address including
 * primary slave address, range slave address , alert response address, second
 * slave address, or general call address. Arbitration lost In SMBus mode, any
 * timeouts except SCL and SDA high timeouts I2C bus stop or start detection if the
 * STOPIE SSIE bit in the Input Glitch Filter register is 1 To clear the I2C bus
 * stop or start detection interrupt: In the interrupt service routine, first clear
 * the STOPF or STARTF bit in the Input Glitch Filter register by writing 1 to
 * it, and then clear the IICIF bit. If this sequence is reversed, the IICIF bit
 * is asserted again.
 *
 * Values:
 * - 0b0 - No interrupt pending
 * - 0b1 - Interrupt pending
 */
/*@{*/
/*! @brief Read current value of the I2C_S_IICIF field. */
#define I2C_RD_S_IICIF(base) ((I2C_S_REG(base) & I2C_S_IICIF_MASK) >> I2C_S_IICIF_SHIFT)
#define I2C_BRD_S_IICIF(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_IICIF_SHIFT, I2C_S_IICIF_WIDTH))

/*! @brief Set the IICIF field to a new value. */
#define I2C_WR_S_IICIF(base, value) (I2C_RMW_S(base, (I2C_S_IICIF_MASK | I2C_S_ARBL_MASK), I2C_S_IICIF(value)))
#define I2C_BWR_S_IICIF(base, value) (BME_BFI8(&I2C_S_REG(base), ((uint8_t)(value) << I2C_S_IICIF_SHIFT), I2C_S_IICIF_SHIFT, I2C_S_IICIF_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field SRW[2] (RO)
 *
 * When addressed as a slave, SRW indicates the value of the R/W command bit of
 * the calling address sent to the master.
 *
 * Values:
 * - 0b0 - Slave receive, master writing to slave
 * - 0b1 - Slave transmit, master reading from slave
 */
/*@{*/
/*! @brief Read current value of the I2C_S_SRW field. */
#define I2C_RD_S_SRW(base)   ((I2C_S_REG(base) & I2C_S_SRW_MASK) >> I2C_S_SRW_SHIFT)
#define I2C_BRD_S_SRW(base)  (BME_UBFX8(&I2C_S_REG(base), I2C_S_SRW_SHIFT, I2C_S_SRW_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field RAM[3] (RW)
 *
 * This bit is set to 1 by any of the following conditions, if I2C_C2[RMEN] = 1:
 * Any nonzero calling address is received that matches the address in the RA
 * register. The calling address is within the range of values of the A1 and RA
 * registers. For the RAM bit to be set to 1 correctly, C1[IICIE] must be set to 1.
 * Writing the C1 register with any value clears this bit to 0.
 *
 * Values:
 * - 0b0 - Not addressed
 * - 0b1 - Addressed as a slave
 */
/*@{*/
/*! @brief Read current value of the I2C_S_RAM field. */
#define I2C_RD_S_RAM(base)   ((I2C_S_REG(base) & I2C_S_RAM_MASK) >> I2C_S_RAM_SHIFT)
#define I2C_BRD_S_RAM(base)  (BME_UBFX8(&I2C_S_REG(base), I2C_S_RAM_SHIFT, I2C_S_RAM_WIDTH))

/*! @brief Set the RAM field to a new value. */
#define I2C_WR_S_RAM(base, value) (I2C_RMW_S(base, (I2C_S_RAM_MASK | I2C_S_IICIF_MASK | I2C_S_ARBL_MASK), I2C_S_RAM(value)))
#define I2C_BWR_S_RAM(base, value) (BME_BFI8(&I2C_S_REG(base), ((uint8_t)(value) << I2C_S_RAM_SHIFT), I2C_S_RAM_SHIFT, I2C_S_RAM_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field ARBL[4] (W1C)
 *
 * This bit is set by hardware when the arbitration procedure is lost. The ARBL
 * bit must be cleared by software, by writing 1 to it.
 *
 * Values:
 * - 0b0 - Standard bus operation.
 * - 0b1 - Loss of arbitration.
 */
/*@{*/
/*! @brief Read current value of the I2C_S_ARBL field. */
#define I2C_RD_S_ARBL(base)  ((I2C_S_REG(base) & I2C_S_ARBL_MASK) >> I2C_S_ARBL_SHIFT)
#define I2C_BRD_S_ARBL(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_ARBL_SHIFT, I2C_S_ARBL_WIDTH))

/*! @brief Set the ARBL field to a new value. */
#define I2C_WR_S_ARBL(base, value) (I2C_RMW_S(base, (I2C_S_ARBL_MASK | I2C_S_IICIF_MASK), I2C_S_ARBL(value)))
#define I2C_BWR_S_ARBL(base, value) (BME_BFI8(&I2C_S_REG(base), ((uint8_t)(value) << I2C_S_ARBL_SHIFT), I2C_S_ARBL_SHIFT, I2C_S_ARBL_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field BUSY[5] (RO)
 *
 * Indicates the status of the bus regardless of slave or master mode. This bit
 * is set when a START signal is detected and cleared when a STOP signal is
 * detected.
 *
 * Values:
 * - 0b0 - Bus is idle
 * - 0b1 - Bus is busy
 */
/*@{*/
/*! @brief Read current value of the I2C_S_BUSY field. */
#define I2C_RD_S_BUSY(base)  ((I2C_S_REG(base) & I2C_S_BUSY_MASK) >> I2C_S_BUSY_SHIFT)
#define I2C_BRD_S_BUSY(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_BUSY_SHIFT, I2C_S_BUSY_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field IAAS[6] (RW)
 *
 * This bit is set by one of the following conditions: The calling address
 * matches the programmed primary slave address in the A1 register, or matches the
 * range address in the RA register (which must be set to a nonzero value and under
 * the condition I2C_C2[RMEN] = 1). C2[GCAEN] is set and a general call is
 * received. SMB[SIICAEN] is set and the calling address matches the second programmed
 * slave address. ALERTEN is set and an SMBus alert response address is received
 * RMEN is set and an address is received that is within the range between the
 * values of the A1 and RA registers. IAAS sets before the ACK bit. The CPU must
 * check the SRW bit and set TX/RX accordingly. Writing the C1 register with any
 * value clears this bit.
 *
 * Values:
 * - 0b0 - Not addressed
 * - 0b1 - Addressed as a slave
 */
/*@{*/
/*! @brief Read current value of the I2C_S_IAAS field. */
#define I2C_RD_S_IAAS(base)  ((I2C_S_REG(base) & I2C_S_IAAS_MASK) >> I2C_S_IAAS_SHIFT)
#define I2C_BRD_S_IAAS(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_IAAS_SHIFT, I2C_S_IAAS_WIDTH))

/*! @brief Set the IAAS field to a new value. */
#define I2C_WR_S_IAAS(base, value) (I2C_RMW_S(base, (I2C_S_IAAS_MASK | I2C_S_IICIF_MASK | I2C_S_ARBL_MASK), I2C_S_IAAS(value)))
#define I2C_BWR_S_IAAS(base, value) (BME_BFI8(&I2C_S_REG(base), ((uint8_t)(value) << I2C_S_IAAS_SHIFT), I2C_S_IAAS_SHIFT, I2C_S_IAAS_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field TCF[7] (RO)
 *
 * Acknowledges a byte transfer; TCF is set on the completion of a byte
 * transfer. This bit is valid only during or immediately following a transfer to or from
 * the I2C module. TCF is cleared by reading the I2C data register in receive
 * mode or by writing to the I2C data register in transmit mode.In the buffer mode,
 * TCF is cleared automatically by internal reading or writing the data register
 * I2C_D, with no need waiting for manually reading/writing the I2C data
 * register in Rx/Tx mode.
 *
 * Values:
 * - 0b0 - Transfer in progress
 * - 0b1 - Transfer complete
 */
/*@{*/
/*! @brief Read current value of the I2C_S_TCF field. */
#define I2C_RD_S_TCF(base)   ((I2C_S_REG(base) & I2C_S_TCF_MASK) >> I2C_S_TCF_SHIFT)
#define I2C_BRD_S_TCF(base)  (BME_UBFX8(&I2C_S_REG(base), I2C_S_TCF_SHIFT, I2C_S_TCF_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_D - I2C Data I/O register
 ******************************************************************************/

/*!
 * @brief I2C_D - I2C Data I/O register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_D register
 */
/*@{*/
#define I2C_RD_D(base)           (I2C_D_REG(base))
#define I2C_WR_D(base, value)    (I2C_D_REG(base) = (value))
#define I2C_RMW_D(base, mask, value) (I2C_WR_D(base, (I2C_RD_D(base) & ~(mask)) | (value)))
#define I2C_SET_D(base, value)   (BME_OR8(&I2C_D_REG(base), (uint8_t)(value)))
#define I2C_CLR_D(base, value)   (BME_AND8(&I2C_D_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_D(base, value)   (BME_XOR8(&I2C_D_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * I2C_C2 - I2C Control Register 2
 ******************************************************************************/

/*!
 * @brief I2C_C2 - I2C Control Register 2 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_C2 register
 */
/*@{*/
#define I2C_RD_C2(base)          (I2C_C2_REG(base))
#define I2C_WR_C2(base, value)   (I2C_C2_REG(base) = (value))
#define I2C_RMW_C2(base, mask, value) (I2C_WR_C2(base, (I2C_RD_C2(base) & ~(mask)) | (value)))
#define I2C_SET_C2(base, value)  (BME_OR8(&I2C_C2_REG(base), (uint8_t)(value)))
#define I2C_CLR_C2(base, value)  (BME_AND8(&I2C_C2_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_C2(base, value)  (BME_XOR8(&I2C_C2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_C2 bitfields
 */

/*!
 * @name Register I2C_C2, field AD[2:0] (RW)
 *
 * Contains the upper three bits of the slave address in the 10-bit address
 * scheme. This field is valid only while the ADEXT bit is set.
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_AD field. */
#define I2C_RD_C2_AD(base)   ((I2C_C2_REG(base) & I2C_C2_AD_MASK) >> I2C_C2_AD_SHIFT)
#define I2C_BRD_C2_AD(base)  (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_AD_SHIFT, I2C_C2_AD_WIDTH))

/*! @brief Set the AD field to a new value. */
#define I2C_WR_C2_AD(base, value) (I2C_RMW_C2(base, I2C_C2_AD_MASK, I2C_C2_AD(value)))
#define I2C_BWR_C2_AD(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_AD_SHIFT), I2C_C2_AD_SHIFT, I2C_C2_AD_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field RMEN[3] (RW)
 *
 * This bit controls the slave address matching for addresses between the values
 * of the A1 and RA registers. When this bit is set, a slave address matching
 * occurs for any address greater than the value of the A1 register and less than
 * or equal to the value of the RA register.
 *
 * Values:
 * - 0b0 - Range mode disabled. No address matching occurs for an address within
 *     the range of values of the A1 and RA registers.
 * - 0b1 - Range mode enabled. Address matching occurs when a slave receives an
 *     address within the range of values of the A1 and RA registers.
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_RMEN field. */
#define I2C_RD_C2_RMEN(base) ((I2C_C2_REG(base) & I2C_C2_RMEN_MASK) >> I2C_C2_RMEN_SHIFT)
#define I2C_BRD_C2_RMEN(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_RMEN_SHIFT, I2C_C2_RMEN_WIDTH))

/*! @brief Set the RMEN field to a new value. */
#define I2C_WR_C2_RMEN(base, value) (I2C_RMW_C2(base, I2C_C2_RMEN_MASK, I2C_C2_RMEN(value)))
#define I2C_BWR_C2_RMEN(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_RMEN_SHIFT), I2C_C2_RMEN_SHIFT, I2C_C2_RMEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field SBRC[4] (RW)
 *
 * Enables independent slave mode baud rate at maximum frequency, which forces
 * clock stretching on SCL in very fast I2C modes. To a slave, an example of a
 * "very fast" mode is when the master transfers at 40 kbit/s but the slave can
 * capture the master's data at only 10 kbit/s.
 *
 * Values:
 * - 0b0 - The slave baud rate follows the master baud rate and clock stretching
 *     may occur
 * - 0b1 - Slave baud rate is independent of the master baud rate
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_SBRC field. */
#define I2C_RD_C2_SBRC(base) ((I2C_C2_REG(base) & I2C_C2_SBRC_MASK) >> I2C_C2_SBRC_SHIFT)
#define I2C_BRD_C2_SBRC(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_SBRC_SHIFT, I2C_C2_SBRC_WIDTH))

/*! @brief Set the SBRC field to a new value. */
#define I2C_WR_C2_SBRC(base, value) (I2C_RMW_C2(base, I2C_C2_SBRC_MASK, I2C_C2_SBRC(value)))
#define I2C_BWR_C2_SBRC(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_SBRC_SHIFT), I2C_C2_SBRC_SHIFT, I2C_C2_SBRC_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field HDRS[5] (RW)
 *
 * Controls the drive capability of the I2C pads.
 *
 * Values:
 * - 0b0 - Normal drive mode
 * - 0b1 - High drive mode
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_HDRS field. */
#define I2C_RD_C2_HDRS(base) ((I2C_C2_REG(base) & I2C_C2_HDRS_MASK) >> I2C_C2_HDRS_SHIFT)
#define I2C_BRD_C2_HDRS(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_HDRS_SHIFT, I2C_C2_HDRS_WIDTH))

/*! @brief Set the HDRS field to a new value. */
#define I2C_WR_C2_HDRS(base, value) (I2C_RMW_C2(base, I2C_C2_HDRS_MASK, I2C_C2_HDRS(value)))
#define I2C_BWR_C2_HDRS(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_HDRS_SHIFT), I2C_C2_HDRS_SHIFT, I2C_C2_HDRS_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field ADEXT[6] (RW)
 *
 * Controls the number of bits used for the slave address.
 *
 * Values:
 * - 0b0 - 7-bit address scheme
 * - 0b1 - 10-bit address scheme
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_ADEXT field. */
#define I2C_RD_C2_ADEXT(base) ((I2C_C2_REG(base) & I2C_C2_ADEXT_MASK) >> I2C_C2_ADEXT_SHIFT)
#define I2C_BRD_C2_ADEXT(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_ADEXT_SHIFT, I2C_C2_ADEXT_WIDTH))

/*! @brief Set the ADEXT field to a new value. */
#define I2C_WR_C2_ADEXT(base, value) (I2C_RMW_C2(base, I2C_C2_ADEXT_MASK, I2C_C2_ADEXT(value)))
#define I2C_BWR_C2_ADEXT(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_ADEXT_SHIFT), I2C_C2_ADEXT_SHIFT, I2C_C2_ADEXT_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field GCAEN[7] (RW)
 *
 * Enables general call address.
 *
 * Values:
 * - 0b0 - Disabled
 * - 0b1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_GCAEN field. */
#define I2C_RD_C2_GCAEN(base) ((I2C_C2_REG(base) & I2C_C2_GCAEN_MASK) >> I2C_C2_GCAEN_SHIFT)
#define I2C_BRD_C2_GCAEN(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_GCAEN_SHIFT, I2C_C2_GCAEN_WIDTH))

/*! @brief Set the GCAEN field to a new value. */
#define I2C_WR_C2_GCAEN(base, value) (I2C_RMW_C2(base, I2C_C2_GCAEN_MASK, I2C_C2_GCAEN(value)))
#define I2C_BWR_C2_GCAEN(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_GCAEN_SHIFT), I2C_C2_GCAEN_SHIFT, I2C_C2_GCAEN_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_FLT - I2C Programmable Input Glitch Filter Register
 ******************************************************************************/

/*!
 * @brief I2C_FLT - I2C Programmable Input Glitch Filter Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_FLT register
 */
/*@{*/
#define I2C_RD_FLT(base)         (I2C_FLT_REG(base))
#define I2C_WR_FLT(base, value)  (I2C_FLT_REG(base) = (value))
#define I2C_RMW_FLT(base, mask, value) (I2C_WR_FLT(base, (I2C_RD_FLT(base) & ~(mask)) | (value)))
#define I2C_SET_FLT(base, value) (BME_OR8(&I2C_FLT_REG(base), (uint8_t)(value)))
#define I2C_CLR_FLT(base, value) (BME_AND8(&I2C_FLT_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_FLT(base, value) (BME_XOR8(&I2C_FLT_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_FLT bitfields
 */

/*!
 * @name Register I2C_FLT, field FLT[3:0] (RW)
 *
 * Controls the width of the glitch, in terms of I2C module clock cycles, that
 * the filter must absorb. For any glitch whose size is less than or equal to this
 * width setting, the filter does not allow the glitch to pass. The width of the
 * FLT is an integration option that can be changed in different SoCs. Also the
 * clock source used is an integration/configuration option: it could be the 2*
 * IPBus clock or the IPBus clock -- which must be identified at architectural
 * definition. For the sample 4-bit definitions, the description of "half" IPBUS
 * clock cycles does not apply when the IPBUS clock is used for filtering logic.
 *
 * Values:
 * - 0b0000 - No filter/bypass
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_FLT field. */
#define I2C_RD_FLT_FLT(base) ((I2C_FLT_REG(base) & I2C_FLT_FLT_MASK) >> I2C_FLT_FLT_SHIFT)
#define I2C_BRD_FLT_FLT(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_FLT_SHIFT, I2C_FLT_FLT_WIDTH))

/*! @brief Set the FLT field to a new value. */
#define I2C_WR_FLT_FLT(base, value) (I2C_RMW_FLT(base, (I2C_FLT_FLT_MASK | I2C_FLT_STARTF_MASK | I2C_FLT_STOPF_MASK), I2C_FLT_FLT(value)))
#define I2C_BWR_FLT_FLT(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_FLT_SHIFT), I2C_FLT_FLT_SHIFT, I2C_FLT_FLT_WIDTH))
/*@}*/

/*!
 * @name Register I2C_FLT, field STARTF[4] (W1C)
 *
 * Hardware sets this bit when the I2C bus's start status is detected. The
 * STARTF bit must be cleared by writing 1 to it.
 *
 * Values:
 * - 0b0 - No start happens on I2C bus
 * - 0b1 - Start detected on I2C bus
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_STARTF field. */
#define I2C_RD_FLT_STARTF(base) ((I2C_FLT_REG(base) & I2C_FLT_STARTF_MASK) >> I2C_FLT_STARTF_SHIFT)
#define I2C_BRD_FLT_STARTF(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_STARTF_SHIFT, I2C_FLT_STARTF_WIDTH))

/*! @brief Set the STARTF field to a new value. */
#define I2C_WR_FLT_STARTF(base, value) (I2C_RMW_FLT(base, (I2C_FLT_STARTF_MASK | I2C_FLT_STOPF_MASK), I2C_FLT_STARTF(value)))
#define I2C_BWR_FLT_STARTF(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_STARTF_SHIFT), I2C_FLT_STARTF_SHIFT, I2C_FLT_STARTF_WIDTH))
/*@}*/

/*!
 * @name Register I2C_FLT, field SSIE[5] (RW)
 *
 * This bit enables the interrupt for I2C bus stop or start detection. To clear
 * the I2C bus stop or start detection interrupt: In the interrupt service
 * routine, first clear the STOPF or STARTF bit by writing 1 to it, and then clear the
 * IICIF bit in the status register. If this sequence is reversed, the IICIF bit
 * is asserted again.
 *
 * Values:
 * - 0b0 - Stop or start detection interrupt is disabled
 * - 0b1 - Stop or start detection interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_SSIE field. */
#define I2C_RD_FLT_SSIE(base) ((I2C_FLT_REG(base) & I2C_FLT_SSIE_MASK) >> I2C_FLT_SSIE_SHIFT)
#define I2C_BRD_FLT_SSIE(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_SSIE_SHIFT, I2C_FLT_SSIE_WIDTH))

/*! @brief Set the SSIE field to a new value. */
#define I2C_WR_FLT_SSIE(base, value) (I2C_RMW_FLT(base, (I2C_FLT_SSIE_MASK | I2C_FLT_STARTF_MASK | I2C_FLT_STOPF_MASK), I2C_FLT_SSIE(value)))
#define I2C_BWR_FLT_SSIE(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_SSIE_SHIFT), I2C_FLT_SSIE_SHIFT, I2C_FLT_SSIE_WIDTH))
/*@}*/

/*!
 * @name Register I2C_FLT, field STOPF[6] (W1C)
 *
 * Hardware sets this bit when the I2C bus's stop status is detected. The STOPF
 * bit must be cleared by writing 1 to it.
 *
 * Values:
 * - 0b0 - No stop happens on I2C bus
 * - 0b1 - Stop detected on I2C bus
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_STOPF field. */
#define I2C_RD_FLT_STOPF(base) ((I2C_FLT_REG(base) & I2C_FLT_STOPF_MASK) >> I2C_FLT_STOPF_SHIFT)
#define I2C_BRD_FLT_STOPF(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_STOPF_SHIFT, I2C_FLT_STOPF_WIDTH))

/*! @brief Set the STOPF field to a new value. */
#define I2C_WR_FLT_STOPF(base, value) (I2C_RMW_FLT(base, (I2C_FLT_STOPF_MASK | I2C_FLT_STARTF_MASK), I2C_FLT_STOPF(value)))
#define I2C_BWR_FLT_STOPF(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_STOPF_SHIFT), I2C_FLT_STOPF_SHIFT, I2C_FLT_STOPF_WIDTH))
/*@}*/

/*!
 * @name Register I2C_FLT, field SHEN[7] (RW)
 *
 * Set this bit to hold off entry to stop mode when any data transmission or
 * reception is occurring. The following scenario explains the holdoff
 * functionality: The I2C module is configured for a basic transfer, and the SHEN bit is set
 * to 1. A transfer begins. The MCU signals the I2C module to enter stop mode. The
 * byte currently being transferred, including both address and data, completes
 * its transfer. The I2C slave or master acknowledges that the in-transfer byte
 * completed its transfer and acknowledges the request to enter stop mode. After
 * receiving the I2C module's acknowledgment of the request to enter stop mode,
 * the MCU determines whether to shut off the I2C module's clock. If the SHEN bit
 * is set to 1 and the I2C module is in an idle or disabled state when the MCU
 * signals to enter stop mode, the module immediately acknowledges the request to
 * enter stop mode. If SHEN is cleared to 0 and the overall data transmission or
 * reception that was suspended by stop mode entry was incomplete: To resume the
 * overall transmission or reception after the MCU exits stop mode, software must
 * reinitialize the transfer by resending the address of the slave. If the I2C
 * Control Register 1's IICIE bit was set to 1 before the MCU entered stop mode,
 * system software will receive the interrupt triggered by the I2C Status Register's
 * TCF bit after the MCU wakes from the stop mode.
 *
 * Values:
 * - 0b0 - Stop holdoff is disabled. The MCU's entry to stop mode is not gated.
 *     Clocks to peripherals are gated when the core stop occurs.
 * - 0b1 - Stop holdoff is enabled. Stop mode entry is gated until the current
 *     transaction phase is complete, and the IP enters stop mode (clocks are
 *     gated) after the current phase's completion. That is to say: If the system
 *     stop request occurs between the address or data phase, the stop acknowledge
 *     is asserted after the current byte and IIC ack completion (after the
 *     acknowledge in the ninth cycle).
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_SHEN field. */
#define I2C_RD_FLT_SHEN(base) ((I2C_FLT_REG(base) & I2C_FLT_SHEN_MASK) >> I2C_FLT_SHEN_SHIFT)
#define I2C_BRD_FLT_SHEN(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_SHEN_SHIFT, I2C_FLT_SHEN_WIDTH))

/*! @brief Set the SHEN field to a new value. */
#define I2C_WR_FLT_SHEN(base, value) (I2C_RMW_FLT(base, (I2C_FLT_SHEN_MASK | I2C_FLT_STARTF_MASK | I2C_FLT_STOPF_MASK), I2C_FLT_SHEN(value)))
#define I2C_BWR_FLT_SHEN(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_SHEN_SHIFT), I2C_FLT_SHEN_SHIFT, I2C_FLT_SHEN_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_RA - I2C Range Address register
 ******************************************************************************/

/*!
 * @brief I2C_RA - I2C Range Address register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_RA register
 */
/*@{*/
#define I2C_RD_RA(base)          (I2C_RA_REG(base))
#define I2C_WR_RA(base, value)   (I2C_RA_REG(base) = (value))
#define I2C_RMW_RA(base, mask, value) (I2C_WR_RA(base, (I2C_RD_RA(base) & ~(mask)) | (value)))
#define I2C_SET_RA(base, value)  (BME_OR8(&I2C_RA_REG(base), (uint8_t)(value)))
#define I2C_CLR_RA(base, value)  (BME_AND8(&I2C_RA_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_RA(base, value)  (BME_XOR8(&I2C_RA_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_RA bitfields
 */

/*!
 * @name Register I2C_RA, field RAD[7:1] (RW)
 *
 * This field contains the slave address to be used by the I2C module. The field
 * is used in the 7-bit address scheme. If I2C_C2[RMEN] is set to 1, any nonzero
 * value write enables this register. This register value can be considered as a
 * maximum boundary in the range matching mode.
 */
/*@{*/
/*! @brief Read current value of the I2C_RA_RAD field. */
#define I2C_RD_RA_RAD(base)  ((I2C_RA_REG(base) & I2C_RA_RAD_MASK) >> I2C_RA_RAD_SHIFT)
#define I2C_BRD_RA_RAD(base) (BME_UBFX8(&I2C_RA_REG(base), I2C_RA_RAD_SHIFT, I2C_RA_RAD_WIDTH))

/*! @brief Set the RAD field to a new value. */
#define I2C_WR_RA_RAD(base, value) (I2C_RMW_RA(base, I2C_RA_RAD_MASK, I2C_RA_RAD(value)))
#define I2C_BWR_RA_RAD(base, value) (BME_BFI8(&I2C_RA_REG(base), ((uint8_t)(value) << I2C_RA_RAD_SHIFT), I2C_RA_RAD_SHIFT, I2C_RA_RAD_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_SMB - I2C SMBus Control and Status register
 ******************************************************************************/

/*!
 * @brief I2C_SMB - I2C SMBus Control and Status register (RW)
 *
 * Reset value: 0x00U
 *
 * When the SCL and SDA signals are held high for a length of time greater than
 * the high timeout period, the SHTF1 flag sets. Before reaching this threshold,
 * while the system is detecting how long these signals are being held high, a
 * master assumes that the bus is free. However, the SHTF1 bit is set to 1 in the
 * bus transmission process with the idle bus state. When the TCKSEL bit is set,
 * there is no need to monitor the SHTF1 bit because the bus speed is too high to
 * match the protocol of SMBus.
 */
/*!
 * @name Constants and macros for entire I2C_SMB register
 */
/*@{*/
#define I2C_RD_SMB(base)         (I2C_SMB_REG(base))
#define I2C_WR_SMB(base, value)  (I2C_SMB_REG(base) = (value))
#define I2C_RMW_SMB(base, mask, value) (I2C_WR_SMB(base, (I2C_RD_SMB(base) & ~(mask)) | (value)))
#define I2C_SET_SMB(base, value) (BME_OR8(&I2C_SMB_REG(base), (uint8_t)(value)))
#define I2C_CLR_SMB(base, value) (BME_AND8(&I2C_SMB_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_SMB(base, value) (BME_XOR8(&I2C_SMB_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_SMB bitfields
 */

/*!
 * @name Register I2C_SMB, field SHTF2IE[0] (RW)
 *
 * Enables SCL high and SDA low timeout interrupt.
 *
 * Values:
 * - 0b0 - SHTF2 interrupt is disabled
 * - 0b1 - SHTF2 interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SHTF2IE field. */
#define I2C_RD_SMB_SHTF2IE(base) ((I2C_SMB_REG(base) & I2C_SMB_SHTF2IE_MASK) >> I2C_SMB_SHTF2IE_SHIFT)
#define I2C_BRD_SMB_SHTF2IE(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SHTF2IE_SHIFT, I2C_SMB_SHTF2IE_WIDTH))

/*! @brief Set the SHTF2IE field to a new value. */
#define I2C_WR_SMB_SHTF2IE(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SHTF2IE_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_SHTF2IE(value)))
#define I2C_BWR_SMB_SHTF2IE(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_SHTF2IE_SHIFT), I2C_SMB_SHTF2IE_SHIFT, I2C_SMB_SHTF2IE_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field SHTF2[1] (W1C)
 *
 * This bit sets when SCL is held high and SDA is held low more than clock *
 * LoValue / 512. Software clears this bit by writing 1 to it.
 *
 * Values:
 * - 0b0 - No SCL high and SDA low timeout occurs
 * - 0b1 - SCL high and SDA low timeout occurs
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SHTF2 field. */
#define I2C_RD_SMB_SHTF2(base) ((I2C_SMB_REG(base) & I2C_SMB_SHTF2_MASK) >> I2C_SMB_SHTF2_SHIFT)
#define I2C_BRD_SMB_SHTF2(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SHTF2_SHIFT, I2C_SMB_SHTF2_WIDTH))

/*! @brief Set the SHTF2 field to a new value. */
#define I2C_WR_SMB_SHTF2(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_SHTF2(value)))
#define I2C_BWR_SMB_SHTF2(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_SHTF2_SHIFT), I2C_SMB_SHTF2_SHIFT, I2C_SMB_SHTF2_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field SHTF1[2] (RO)
 *
 * This read-only bit sets when SCL and SDA are held high more than clock *
 * LoValue / 512, which indicates the bus is free. This bit is cleared automatically.
 *
 * Values:
 * - 0b0 - No SCL high and SDA high timeout occurs
 * - 0b1 - SCL high and SDA high timeout occurs
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SHTF1 field. */
#define I2C_RD_SMB_SHTF1(base) ((I2C_SMB_REG(base) & I2C_SMB_SHTF1_MASK) >> I2C_SMB_SHTF1_SHIFT)
#define I2C_BRD_SMB_SHTF1(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SHTF1_SHIFT, I2C_SMB_SHTF1_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field SLTF[3] (W1C)
 *
 * This bit is set when the SLT register (consisting of the SLTH and SLTL
 * registers) is loaded with a non-zero value (LoValue) and an SCL low timeout occurs.
 * Software clears this bit by writing a logic 1 to it. The low timeout function
 * is disabled when the SLT register's value is 0.
 *
 * Values:
 * - 0b0 - No low timeout occurs
 * - 0b1 - Low timeout occurs
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SLTF field. */
#define I2C_RD_SMB_SLTF(base) ((I2C_SMB_REG(base) & I2C_SMB_SLTF_MASK) >> I2C_SMB_SLTF_SHIFT)
#define I2C_BRD_SMB_SLTF(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SLTF_SHIFT, I2C_SMB_SLTF_WIDTH))

/*! @brief Set the SLTF field to a new value. */
#define I2C_WR_SMB_SLTF(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SLTF_MASK | I2C_SMB_SHTF2_MASK), I2C_SMB_SLTF(value)))
#define I2C_BWR_SMB_SLTF(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_SLTF_SHIFT), I2C_SMB_SLTF_SHIFT, I2C_SMB_SLTF_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field TCKSEL[4] (RW)
 *
 * Selects the clock source of the timeout counter.
 *
 * Values:
 * - 0b0 - Timeout counter counts at the frequency of the I2C module clock / 64
 * - 0b1 - Timeout counter counts at the frequency of the I2C module clock
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_TCKSEL field. */
#define I2C_RD_SMB_TCKSEL(base) ((I2C_SMB_REG(base) & I2C_SMB_TCKSEL_MASK) >> I2C_SMB_TCKSEL_SHIFT)
#define I2C_BRD_SMB_TCKSEL(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_TCKSEL_SHIFT, I2C_SMB_TCKSEL_WIDTH))

/*! @brief Set the TCKSEL field to a new value. */
#define I2C_WR_SMB_TCKSEL(base, value) (I2C_RMW_SMB(base, (I2C_SMB_TCKSEL_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_TCKSEL(value)))
#define I2C_BWR_SMB_TCKSEL(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_TCKSEL_SHIFT), I2C_SMB_TCKSEL_SHIFT, I2C_SMB_TCKSEL_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field SIICAEN[5] (RW)
 *
 * Enables or disables SMBus device default address.
 *
 * Values:
 * - 0b0 - I2C address register 2 matching is disabled
 * - 0b1 - I2C address register 2 matching is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SIICAEN field. */
#define I2C_RD_SMB_SIICAEN(base) ((I2C_SMB_REG(base) & I2C_SMB_SIICAEN_MASK) >> I2C_SMB_SIICAEN_SHIFT)
#define I2C_BRD_SMB_SIICAEN(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SIICAEN_SHIFT, I2C_SMB_SIICAEN_WIDTH))

/*! @brief Set the SIICAEN field to a new value. */
#define I2C_WR_SMB_SIICAEN(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SIICAEN_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_SIICAEN(value)))
#define I2C_BWR_SMB_SIICAEN(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_SIICAEN_SHIFT), I2C_SMB_SIICAEN_SHIFT, I2C_SMB_SIICAEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field ALERTEN[6] (RW)
 *
 * Enables or disables SMBus alert response address matching. After the host
 * responds to a device that used the alert response address, you must use software
 * to put the device's address on the bus. The alert protocol is described in the
 * SMBus specification.
 *
 * Values:
 * - 0b0 - SMBus alert response address matching is disabled
 * - 0b1 - SMBus alert response address matching is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_ALERTEN field. */
#define I2C_RD_SMB_ALERTEN(base) ((I2C_SMB_REG(base) & I2C_SMB_ALERTEN_MASK) >> I2C_SMB_ALERTEN_SHIFT)
#define I2C_BRD_SMB_ALERTEN(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_ALERTEN_SHIFT, I2C_SMB_ALERTEN_WIDTH))

/*! @brief Set the ALERTEN field to a new value. */
#define I2C_WR_SMB_ALERTEN(base, value) (I2C_RMW_SMB(base, (I2C_SMB_ALERTEN_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_ALERTEN(value)))
#define I2C_BWR_SMB_ALERTEN(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_ALERTEN_SHIFT), I2C_SMB_ALERTEN_SHIFT, I2C_SMB_ALERTEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field FACK[7] (RW)
 *
 * For SMBus packet error checking, the CPU must be able to issue an ACK or NACK
 * according to the result of receiving data byte.
 *
 * Values:
 * - 0b0 - An ACK or NACK is sent on the following receiving data byte
 * - 0b1 - Writing 0 to TXAK after receiving a data byte generates an ACK.
 *     Writing 1 to TXAK after receiving a data byte generates a NACK.
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_FACK field. */
#define I2C_RD_SMB_FACK(base) ((I2C_SMB_REG(base) & I2C_SMB_FACK_MASK) >> I2C_SMB_FACK_SHIFT)
#define I2C_BRD_SMB_FACK(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_FACK_SHIFT, I2C_SMB_FACK_WIDTH))

/*! @brief Set the FACK field to a new value. */
#define I2C_WR_SMB_FACK(base, value) (I2C_RMW_SMB(base, (I2C_SMB_FACK_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_FACK(value)))
#define I2C_BWR_SMB_FACK(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_FACK_SHIFT), I2C_SMB_FACK_SHIFT, I2C_SMB_FACK_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_A2 - I2C Address Register 2
 ******************************************************************************/

/*!
 * @brief I2C_A2 - I2C Address Register 2 (RW)
 *
 * Reset value: 0xC2U
 */
/*!
 * @name Constants and macros for entire I2C_A2 register
 */
/*@{*/
#define I2C_RD_A2(base)          (I2C_A2_REG(base))
#define I2C_WR_A2(base, value)   (I2C_A2_REG(base) = (value))
#define I2C_RMW_A2(base, mask, value) (I2C_WR_A2(base, (I2C_RD_A2(base) & ~(mask)) | (value)))
#define I2C_SET_A2(base, value)  (BME_OR8(&I2C_A2_REG(base), (uint8_t)(value)))
#define I2C_CLR_A2(base, value)  (BME_AND8(&I2C_A2_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_A2(base, value)  (BME_XOR8(&I2C_A2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_A2 bitfields
 */

/*!
 * @name Register I2C_A2, field SAD[7:1] (RW)
 *
 * Contains the slave address used by the SMBus. This field is used on the
 * device default address or other related addresses.
 */
/*@{*/
/*! @brief Read current value of the I2C_A2_SAD field. */
#define I2C_RD_A2_SAD(base)  ((I2C_A2_REG(base) & I2C_A2_SAD_MASK) >> I2C_A2_SAD_SHIFT)
#define I2C_BRD_A2_SAD(base) (BME_UBFX8(&I2C_A2_REG(base), I2C_A2_SAD_SHIFT, I2C_A2_SAD_WIDTH))

/*! @brief Set the SAD field to a new value. */
#define I2C_WR_A2_SAD(base, value) (I2C_RMW_A2(base, I2C_A2_SAD_MASK, I2C_A2_SAD(value)))
#define I2C_BWR_A2_SAD(base, value) (BME_BFI8(&I2C_A2_REG(base), ((uint8_t)(value) << I2C_A2_SAD_SHIFT), I2C_A2_SAD_SHIFT, I2C_A2_SAD_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_SLTH - I2C SCL Low Timeout Register High
 ******************************************************************************/

/*!
 * @brief I2C_SLTH - I2C SCL Low Timeout Register High (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_SLTH register
 */
/*@{*/
#define I2C_RD_SLTH(base)        (I2C_SLTH_REG(base))
#define I2C_WR_SLTH(base, value) (I2C_SLTH_REG(base) = (value))
#define I2C_RMW_SLTH(base, mask, value) (I2C_WR_SLTH(base, (I2C_RD_SLTH(base) & ~(mask)) | (value)))
#define I2C_SET_SLTH(base, value) (BME_OR8(&I2C_SLTH_REG(base), (uint8_t)(value)))
#define I2C_CLR_SLTH(base, value) (BME_AND8(&I2C_SLTH_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_SLTH(base, value) (BME_XOR8(&I2C_SLTH_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * I2C_SLTL - I2C SCL Low Timeout Register Low
 ******************************************************************************/

/*!
 * @brief I2C_SLTL - I2C SCL Low Timeout Register Low (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_SLTL register
 */
/*@{*/
#define I2C_RD_SLTL(base)        (I2C_SLTL_REG(base))
#define I2C_WR_SLTL(base, value) (I2C_SLTL_REG(base) = (value))
#define I2C_RMW_SLTL(base, mask, value) (I2C_WR_SLTL(base, (I2C_RD_SLTL(base) & ~(mask)) | (value)))
#define I2C_SET_SLTL(base, value) (BME_OR8(&I2C_SLTL_REG(base), (uint8_t)(value)))
#define I2C_CLR_SLTL(base, value) (BME_AND8(&I2C_SLTL_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_SLTL(base, value) (BME_XOR8(&I2C_SLTL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * I2C_S2 - I2C Status register 2
 ******************************************************************************/

/*!
 * @brief I2C_S2 - I2C Status register 2 (RW)
 *
 * Reset value: 0x01U
 */
/*!
 * @name Constants and macros for entire I2C_S2 register
 */
/*@{*/
#define I2C_RD_S2(base)          (I2C_S2_REG(base))
#define I2C_WR_S2(base, value)   (I2C_S2_REG(base) = (value))
#define I2C_RMW_S2(base, mask, value) (I2C_WR_S2(base, (I2C_RD_S2(base) & ~(mask)) | (value)))
#define I2C_SET_S2(base, value)  (BME_OR8(&I2C_S2_REG(base), (uint8_t)(value)))
#define I2C_CLR_S2(base, value)  (BME_AND8(&I2C_S2_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_S2(base, value)  (BME_XOR8(&I2C_S2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_S2 bitfields
 */

/*!
 * @name Register I2C_S2, field EMPTY[0] (RO)
 *
 * Indicates if the Tx or Rx buffer is empty.
 *
 * Values:
 * - 0b0 - Tx or Rx buffer is not empty and cannot be written to, that is new
 *     data cannot be loaded into the buffer.
 * - 0b1 - Tx or Rx buffer is empty and can be written to, that is new data can
 *     be loaded into the buffer. Write 1 to reset this flag (to the default
 *     value 1, which means that the Tx or Rx buffer is empty).
 */
/*@{*/
/*! @brief Read current value of the I2C_S2_EMPTY field. */
#define I2C_RD_S2_EMPTY(base) ((I2C_S2_REG(base) & I2C_S2_EMPTY_MASK) >> I2C_S2_EMPTY_SHIFT)
#define I2C_BRD_S2_EMPTY(base) (BME_UBFX8(&I2C_S2_REG(base), I2C_S2_EMPTY_SHIFT, I2C_S2_EMPTY_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S2, field ERROR[1] (W1C)
 *
 * Indicates if there are read or write errors with the Tx and Rx buffers.
 *
 * Values:
 * - 0b0 - The buffer is not full and all write/read operations have no errors.
 * - 0b1 - There are 3 or more write/read errors during the data transfer phase
 *     (when the Empty flag is not set and the buffer is busy).
 */
/*@{*/
/*! @brief Read current value of the I2C_S2_ERROR field. */
#define I2C_RD_S2_ERROR(base) ((I2C_S2_REG(base) & I2C_S2_ERROR_MASK) >> I2C_S2_ERROR_SHIFT)
#define I2C_BRD_S2_ERROR(base) (BME_UBFX8(&I2C_S2_REG(base), I2C_S2_ERROR_SHIFT, I2C_S2_ERROR_WIDTH))

/*! @brief Set the ERROR field to a new value. */
#define I2C_WR_S2_ERROR(base, value) (I2C_RMW_S2(base, I2C_S2_ERROR_MASK, I2C_S2_ERROR(value)))
#define I2C_BWR_S2_ERROR(base, value) (BME_BFI8(&I2C_S2_REG(base), ((uint8_t)(value) << I2C_S2_ERROR_SHIFT), I2C_S2_ERROR_SHIFT, I2C_S2_ERROR_WIDTH))
/*@}*/

/*
 * MKW40Z4 LLWU
 *
 * Low leakage wakeup unit
 *
 * Registers defined in this header file:
 * - LLWU_PE1 - LLWU Pin Enable 1 register
 * - LLWU_PE2 - LLWU Pin Enable 2 register
 * - LLWU_PE3 - LLWU Pin Enable 3 register
 * - LLWU_PE4 - LLWU Pin Enable 4 register
 * - LLWU_ME - LLWU Module Enable register
 * - LLWU_F1 - LLWU Flag 1 register
 * - LLWU_F2 - LLWU Flag 2 register
 * - LLWU_F3 - LLWU Flag 3 register
 * - LLWU_FILT1 - LLWU Pin Filter 1 register
 * - LLWU_FILT2 - LLWU Pin Filter 2 register
 */

#define LLWU_INSTANCE_COUNT (1U) /*!< Number of instances of the LLWU module. */
#define LLWU_IDX (0U) /*!< Instance number for LLWU. */

/*******************************************************************************
 * LLWU_PE1 - LLWU Pin Enable 1 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE1 - LLWU Pin Enable 1 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE1 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P3-LLWU_P0. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE1 register
 */
/*@{*/
#define LLWU_RD_PE1(base)        (LLWU_PE1_REG(base))
#define LLWU_WR_PE1(base, value) (LLWU_PE1_REG(base) = (value))
#define LLWU_RMW_PE1(base, mask, value) (LLWU_WR_PE1(base, (LLWU_RD_PE1(base) & ~(mask)) | (value)))
#define LLWU_SET_PE1(base, value) (BME_OR8(&LLWU_PE1_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE1(base, value) (BME_AND8(&LLWU_PE1_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE1(base, value) (BME_XOR8(&LLWU_PE1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE1 bitfields
 */

/*!
 * @name Register LLWU_PE1, field WUPE0[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE0 field. */
#define LLWU_RD_PE1_WUPE0(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE0_MASK) >> LLWU_PE1_WUPE0_SHIFT)
#define LLWU_BRD_PE1_WUPE0(base) (BME_UBFX8(&LLWU_PE1_REG(base), LLWU_PE1_WUPE0_SHIFT, LLWU_PE1_WUPE0_WIDTH))

/*! @brief Set the WUPE0 field to a new value. */
#define LLWU_WR_PE1_WUPE0(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE0_MASK, LLWU_PE1_WUPE0(value)))
#define LLWU_BWR_PE1_WUPE0(base, value) (BME_BFI8(&LLWU_PE1_REG(base), ((uint8_t)(value) << LLWU_PE1_WUPE0_SHIFT), LLWU_PE1_WUPE0_SHIFT, LLWU_PE1_WUPE0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE1[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE1 field. */
#define LLWU_RD_PE1_WUPE1(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE1_MASK) >> LLWU_PE1_WUPE1_SHIFT)
#define LLWU_BRD_PE1_WUPE1(base) (BME_UBFX8(&LLWU_PE1_REG(base), LLWU_PE1_WUPE1_SHIFT, LLWU_PE1_WUPE1_WIDTH))

/*! @brief Set the WUPE1 field to a new value. */
#define LLWU_WR_PE1_WUPE1(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE1_MASK, LLWU_PE1_WUPE1(value)))
#define LLWU_BWR_PE1_WUPE1(base, value) (BME_BFI8(&LLWU_PE1_REG(base), ((uint8_t)(value) << LLWU_PE1_WUPE1_SHIFT), LLWU_PE1_WUPE1_SHIFT, LLWU_PE1_WUPE1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE2[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE2 field. */
#define LLWU_RD_PE1_WUPE2(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE2_MASK) >> LLWU_PE1_WUPE2_SHIFT)
#define LLWU_BRD_PE1_WUPE2(base) (BME_UBFX8(&LLWU_PE1_REG(base), LLWU_PE1_WUPE2_SHIFT, LLWU_PE1_WUPE2_WIDTH))

/*! @brief Set the WUPE2 field to a new value. */
#define LLWU_WR_PE1_WUPE2(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE2_MASK, LLWU_PE1_WUPE2(value)))
#define LLWU_BWR_PE1_WUPE2(base, value) (BME_BFI8(&LLWU_PE1_REG(base), ((uint8_t)(value) << LLWU_PE1_WUPE2_SHIFT), LLWU_PE1_WUPE2_SHIFT, LLWU_PE1_WUPE2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE3[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE3 field. */
#define LLWU_RD_PE1_WUPE3(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE3_MASK) >> LLWU_PE1_WUPE3_SHIFT)
#define LLWU_BRD_PE1_WUPE3(base) (BME_UBFX8(&LLWU_PE1_REG(base), LLWU_PE1_WUPE3_SHIFT, LLWU_PE1_WUPE3_WIDTH))

/*! @brief Set the WUPE3 field to a new value. */
#define LLWU_WR_PE1_WUPE3(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE3_MASK, LLWU_PE1_WUPE3(value)))
#define LLWU_BWR_PE1_WUPE3(base, value) (BME_BFI8(&LLWU_PE1_REG(base), ((uint8_t)(value) << LLWU_PE1_WUPE3_SHIFT), LLWU_PE1_WUPE3_SHIFT, LLWU_PE1_WUPE3_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE2 - LLWU Pin Enable 2 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE2 - LLWU Pin Enable 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE2 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P7-LLWU_P4. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE2 register
 */
/*@{*/
#define LLWU_RD_PE2(base)        (LLWU_PE2_REG(base))
#define LLWU_WR_PE2(base, value) (LLWU_PE2_REG(base) = (value))
#define LLWU_RMW_PE2(base, mask, value) (LLWU_WR_PE2(base, (LLWU_RD_PE2(base) & ~(mask)) | (value)))
#define LLWU_SET_PE2(base, value) (BME_OR8(&LLWU_PE2_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE2(base, value) (BME_AND8(&LLWU_PE2_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE2(base, value) (BME_XOR8(&LLWU_PE2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE2 bitfields
 */

/*!
 * @name Register LLWU_PE2, field WUPE4[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE4 field. */
#define LLWU_RD_PE2_WUPE4(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE4_MASK) >> LLWU_PE2_WUPE4_SHIFT)
#define LLWU_BRD_PE2_WUPE4(base) (BME_UBFX8(&LLWU_PE2_REG(base), LLWU_PE2_WUPE4_SHIFT, LLWU_PE2_WUPE4_WIDTH))

/*! @brief Set the WUPE4 field to a new value. */
#define LLWU_WR_PE2_WUPE4(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE4_MASK, LLWU_PE2_WUPE4(value)))
#define LLWU_BWR_PE2_WUPE4(base, value) (BME_BFI8(&LLWU_PE2_REG(base), ((uint8_t)(value) << LLWU_PE2_WUPE4_SHIFT), LLWU_PE2_WUPE4_SHIFT, LLWU_PE2_WUPE4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE5[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE5 field. */
#define LLWU_RD_PE2_WUPE5(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE5_MASK) >> LLWU_PE2_WUPE5_SHIFT)
#define LLWU_BRD_PE2_WUPE5(base) (BME_UBFX8(&LLWU_PE2_REG(base), LLWU_PE2_WUPE5_SHIFT, LLWU_PE2_WUPE5_WIDTH))

/*! @brief Set the WUPE5 field to a new value. */
#define LLWU_WR_PE2_WUPE5(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE5_MASK, LLWU_PE2_WUPE5(value)))
#define LLWU_BWR_PE2_WUPE5(base, value) (BME_BFI8(&LLWU_PE2_REG(base), ((uint8_t)(value) << LLWU_PE2_WUPE5_SHIFT), LLWU_PE2_WUPE5_SHIFT, LLWU_PE2_WUPE5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE6[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE6 field. */
#define LLWU_RD_PE2_WUPE6(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE6_MASK) >> LLWU_PE2_WUPE6_SHIFT)
#define LLWU_BRD_PE2_WUPE6(base) (BME_UBFX8(&LLWU_PE2_REG(base), LLWU_PE2_WUPE6_SHIFT, LLWU_PE2_WUPE6_WIDTH))

/*! @brief Set the WUPE6 field to a new value. */
#define LLWU_WR_PE2_WUPE6(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE6_MASK, LLWU_PE2_WUPE6(value)))
#define LLWU_BWR_PE2_WUPE6(base, value) (BME_BFI8(&LLWU_PE2_REG(base), ((uint8_t)(value) << LLWU_PE2_WUPE6_SHIFT), LLWU_PE2_WUPE6_SHIFT, LLWU_PE2_WUPE6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE7[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE7 field. */
#define LLWU_RD_PE2_WUPE7(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE7_MASK) >> LLWU_PE2_WUPE7_SHIFT)
#define LLWU_BRD_PE2_WUPE7(base) (BME_UBFX8(&LLWU_PE2_REG(base), LLWU_PE2_WUPE7_SHIFT, LLWU_PE2_WUPE7_WIDTH))

/*! @brief Set the WUPE7 field to a new value. */
#define LLWU_WR_PE2_WUPE7(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE7_MASK, LLWU_PE2_WUPE7(value)))
#define LLWU_BWR_PE2_WUPE7(base, value) (BME_BFI8(&LLWU_PE2_REG(base), ((uint8_t)(value) << LLWU_PE2_WUPE7_SHIFT), LLWU_PE2_WUPE7_SHIFT, LLWU_PE2_WUPE7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE3 - LLWU Pin Enable 3 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE3 - LLWU Pin Enable 3 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE3 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P11-LLWU_P8. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE3 register
 */
/*@{*/
#define LLWU_RD_PE3(base)        (LLWU_PE3_REG(base))
#define LLWU_WR_PE3(base, value) (LLWU_PE3_REG(base) = (value))
#define LLWU_RMW_PE3(base, mask, value) (LLWU_WR_PE3(base, (LLWU_RD_PE3(base) & ~(mask)) | (value)))
#define LLWU_SET_PE3(base, value) (BME_OR8(&LLWU_PE3_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE3(base, value) (BME_AND8(&LLWU_PE3_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE3(base, value) (BME_XOR8(&LLWU_PE3_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE3 bitfields
 */

/*!
 * @name Register LLWU_PE3, field WUPE8[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE8 field. */
#define LLWU_RD_PE3_WUPE8(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE8_MASK) >> LLWU_PE3_WUPE8_SHIFT)
#define LLWU_BRD_PE3_WUPE8(base) (BME_UBFX8(&LLWU_PE3_REG(base), LLWU_PE3_WUPE8_SHIFT, LLWU_PE3_WUPE8_WIDTH))

/*! @brief Set the WUPE8 field to a new value. */
#define LLWU_WR_PE3_WUPE8(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE8_MASK, LLWU_PE3_WUPE8(value)))
#define LLWU_BWR_PE3_WUPE8(base, value) (BME_BFI8(&LLWU_PE3_REG(base), ((uint8_t)(value) << LLWU_PE3_WUPE8_SHIFT), LLWU_PE3_WUPE8_SHIFT, LLWU_PE3_WUPE8_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE9[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE9 field. */
#define LLWU_RD_PE3_WUPE9(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE9_MASK) >> LLWU_PE3_WUPE9_SHIFT)
#define LLWU_BRD_PE3_WUPE9(base) (BME_UBFX8(&LLWU_PE3_REG(base), LLWU_PE3_WUPE9_SHIFT, LLWU_PE3_WUPE9_WIDTH))

/*! @brief Set the WUPE9 field to a new value. */
#define LLWU_WR_PE3_WUPE9(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE9_MASK, LLWU_PE3_WUPE9(value)))
#define LLWU_BWR_PE3_WUPE9(base, value) (BME_BFI8(&LLWU_PE3_REG(base), ((uint8_t)(value) << LLWU_PE3_WUPE9_SHIFT), LLWU_PE3_WUPE9_SHIFT, LLWU_PE3_WUPE9_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE10[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE10 field. */
#define LLWU_RD_PE3_WUPE10(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE10_MASK) >> LLWU_PE3_WUPE10_SHIFT)
#define LLWU_BRD_PE3_WUPE10(base) (BME_UBFX8(&LLWU_PE3_REG(base), LLWU_PE3_WUPE10_SHIFT, LLWU_PE3_WUPE10_WIDTH))

/*! @brief Set the WUPE10 field to a new value. */
#define LLWU_WR_PE3_WUPE10(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE10_MASK, LLWU_PE3_WUPE10(value)))
#define LLWU_BWR_PE3_WUPE10(base, value) (BME_BFI8(&LLWU_PE3_REG(base), ((uint8_t)(value) << LLWU_PE3_WUPE10_SHIFT), LLWU_PE3_WUPE10_SHIFT, LLWU_PE3_WUPE10_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE11[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE11 field. */
#define LLWU_RD_PE3_WUPE11(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE11_MASK) >> LLWU_PE3_WUPE11_SHIFT)
#define LLWU_BRD_PE3_WUPE11(base) (BME_UBFX8(&LLWU_PE3_REG(base), LLWU_PE3_WUPE11_SHIFT, LLWU_PE3_WUPE11_WIDTH))

/*! @brief Set the WUPE11 field to a new value. */
#define LLWU_WR_PE3_WUPE11(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE11_MASK, LLWU_PE3_WUPE11(value)))
#define LLWU_BWR_PE3_WUPE11(base, value) (BME_BFI8(&LLWU_PE3_REG(base), ((uint8_t)(value) << LLWU_PE3_WUPE11_SHIFT), LLWU_PE3_WUPE11_SHIFT, LLWU_PE3_WUPE11_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE4 - LLWU Pin Enable 4 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE4 - LLWU Pin Enable 4 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE4 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P15-LLWU_P12. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE4 register
 */
/*@{*/
#define LLWU_RD_PE4(base)        (LLWU_PE4_REG(base))
#define LLWU_WR_PE4(base, value) (LLWU_PE4_REG(base) = (value))
#define LLWU_RMW_PE4(base, mask, value) (LLWU_WR_PE4(base, (LLWU_RD_PE4(base) & ~(mask)) | (value)))
#define LLWU_SET_PE4(base, value) (BME_OR8(&LLWU_PE4_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE4(base, value) (BME_AND8(&LLWU_PE4_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE4(base, value) (BME_XOR8(&LLWU_PE4_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE4 bitfields
 */

/*!
 * @name Register LLWU_PE4, field WUPE12[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE12 field. */
#define LLWU_RD_PE4_WUPE12(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE12_MASK) >> LLWU_PE4_WUPE12_SHIFT)
#define LLWU_BRD_PE4_WUPE12(base) (BME_UBFX8(&LLWU_PE4_REG(base), LLWU_PE4_WUPE12_SHIFT, LLWU_PE4_WUPE12_WIDTH))

/*! @brief Set the WUPE12 field to a new value. */
#define LLWU_WR_PE4_WUPE12(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE12_MASK, LLWU_PE4_WUPE12(value)))
#define LLWU_BWR_PE4_WUPE12(base, value) (BME_BFI8(&LLWU_PE4_REG(base), ((uint8_t)(value) << LLWU_PE4_WUPE12_SHIFT), LLWU_PE4_WUPE12_SHIFT, LLWU_PE4_WUPE12_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE13[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE13 field. */
#define LLWU_RD_PE4_WUPE13(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE13_MASK) >> LLWU_PE4_WUPE13_SHIFT)
#define LLWU_BRD_PE4_WUPE13(base) (BME_UBFX8(&LLWU_PE4_REG(base), LLWU_PE4_WUPE13_SHIFT, LLWU_PE4_WUPE13_WIDTH))

/*! @brief Set the WUPE13 field to a new value. */
#define LLWU_WR_PE4_WUPE13(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE13_MASK, LLWU_PE4_WUPE13(value)))
#define LLWU_BWR_PE4_WUPE13(base, value) (BME_BFI8(&LLWU_PE4_REG(base), ((uint8_t)(value) << LLWU_PE4_WUPE13_SHIFT), LLWU_PE4_WUPE13_SHIFT, LLWU_PE4_WUPE13_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE14[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE14 field. */
#define LLWU_RD_PE4_WUPE14(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE14_MASK) >> LLWU_PE4_WUPE14_SHIFT)
#define LLWU_BRD_PE4_WUPE14(base) (BME_UBFX8(&LLWU_PE4_REG(base), LLWU_PE4_WUPE14_SHIFT, LLWU_PE4_WUPE14_WIDTH))

/*! @brief Set the WUPE14 field to a new value. */
#define LLWU_WR_PE4_WUPE14(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE14_MASK, LLWU_PE4_WUPE14(value)))
#define LLWU_BWR_PE4_WUPE14(base, value) (BME_BFI8(&LLWU_PE4_REG(base), ((uint8_t)(value) << LLWU_PE4_WUPE14_SHIFT), LLWU_PE4_WUPE14_SHIFT, LLWU_PE4_WUPE14_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE15[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE15 field. */
#define LLWU_RD_PE4_WUPE15(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE15_MASK) >> LLWU_PE4_WUPE15_SHIFT)
#define LLWU_BRD_PE4_WUPE15(base) (BME_UBFX8(&LLWU_PE4_REG(base), LLWU_PE4_WUPE15_SHIFT, LLWU_PE4_WUPE15_WIDTH))

/*! @brief Set the WUPE15 field to a new value. */
#define LLWU_WR_PE4_WUPE15(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE15_MASK, LLWU_PE4_WUPE15(value)))
#define LLWU_BWR_PE4_WUPE15(base, value) (BME_BFI8(&LLWU_PE4_REG(base), ((uint8_t)(value) << LLWU_PE4_WUPE15_SHIFT), LLWU_PE4_WUPE15_SHIFT, LLWU_PE4_WUPE15_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_ME - LLWU Module Enable register
 ******************************************************************************/

/*!
 * @brief LLWU_ME - LLWU Module Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_ME contains the bits to enable the internal module flag as a wakeup
 * input source for inputs MWUF7-MWUF0. This register is reset on Chip Reset not VLLS
 * and by reset types that trigger Chip Reset not VLLS. It is unaffected by
 * reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module (RCM). The
 * RCM implements many of the reset functions for the chip. See the chip's reset
 * chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_ME register
 */
/*@{*/
#define LLWU_RD_ME(base)         (LLWU_ME_REG(base))
#define LLWU_WR_ME(base, value)  (LLWU_ME_REG(base) = (value))
#define LLWU_RMW_ME(base, mask, value) (LLWU_WR_ME(base, (LLWU_RD_ME(base) & ~(mask)) | (value)))
#define LLWU_SET_ME(base, value) (BME_OR8(&LLWU_ME_REG(base), (uint8_t)(value)))
#define LLWU_CLR_ME(base, value) (BME_AND8(&LLWU_ME_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_ME(base, value) (BME_XOR8(&LLWU_ME_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_ME bitfields
 */

/*!
 * @name Register LLWU_ME, field WUME0[0] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME0 field. */
#define LLWU_RD_ME_WUME0(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME0_MASK) >> LLWU_ME_WUME0_SHIFT)
#define LLWU_BRD_ME_WUME0(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME0_SHIFT, LLWU_ME_WUME0_WIDTH))

/*! @brief Set the WUME0 field to a new value. */
#define LLWU_WR_ME_WUME0(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME0_MASK, LLWU_ME_WUME0(value)))
#define LLWU_BWR_ME_WUME0(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME0_SHIFT), LLWU_ME_WUME0_SHIFT, LLWU_ME_WUME0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME1[1] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME1 field. */
#define LLWU_RD_ME_WUME1(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME1_MASK) >> LLWU_ME_WUME1_SHIFT)
#define LLWU_BRD_ME_WUME1(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME1_SHIFT, LLWU_ME_WUME1_WIDTH))

/*! @brief Set the WUME1 field to a new value. */
#define LLWU_WR_ME_WUME1(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME1_MASK, LLWU_ME_WUME1(value)))
#define LLWU_BWR_ME_WUME1(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME1_SHIFT), LLWU_ME_WUME1_SHIFT, LLWU_ME_WUME1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME2[2] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME2 field. */
#define LLWU_RD_ME_WUME2(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME2_MASK) >> LLWU_ME_WUME2_SHIFT)
#define LLWU_BRD_ME_WUME2(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME2_SHIFT, LLWU_ME_WUME2_WIDTH))

/*! @brief Set the WUME2 field to a new value. */
#define LLWU_WR_ME_WUME2(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME2_MASK, LLWU_ME_WUME2(value)))
#define LLWU_BWR_ME_WUME2(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME2_SHIFT), LLWU_ME_WUME2_SHIFT, LLWU_ME_WUME2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME3[3] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME3 field. */
#define LLWU_RD_ME_WUME3(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME3_MASK) >> LLWU_ME_WUME3_SHIFT)
#define LLWU_BRD_ME_WUME3(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME3_SHIFT, LLWU_ME_WUME3_WIDTH))

/*! @brief Set the WUME3 field to a new value. */
#define LLWU_WR_ME_WUME3(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME3_MASK, LLWU_ME_WUME3(value)))
#define LLWU_BWR_ME_WUME3(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME3_SHIFT), LLWU_ME_WUME3_SHIFT, LLWU_ME_WUME3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME4[4] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME4 field. */
#define LLWU_RD_ME_WUME4(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME4_MASK) >> LLWU_ME_WUME4_SHIFT)
#define LLWU_BRD_ME_WUME4(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME4_SHIFT, LLWU_ME_WUME4_WIDTH))

/*! @brief Set the WUME4 field to a new value. */
#define LLWU_WR_ME_WUME4(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME4_MASK, LLWU_ME_WUME4(value)))
#define LLWU_BWR_ME_WUME4(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME4_SHIFT), LLWU_ME_WUME4_SHIFT, LLWU_ME_WUME4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME5[5] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME5 field. */
#define LLWU_RD_ME_WUME5(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME5_MASK) >> LLWU_ME_WUME5_SHIFT)
#define LLWU_BRD_ME_WUME5(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME5_SHIFT, LLWU_ME_WUME5_WIDTH))

/*! @brief Set the WUME5 field to a new value. */
#define LLWU_WR_ME_WUME5(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME5_MASK, LLWU_ME_WUME5(value)))
#define LLWU_BWR_ME_WUME5(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME5_SHIFT), LLWU_ME_WUME5_SHIFT, LLWU_ME_WUME5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME6[6] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME6 field. */
#define LLWU_RD_ME_WUME6(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME6_MASK) >> LLWU_ME_WUME6_SHIFT)
#define LLWU_BRD_ME_WUME6(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME6_SHIFT, LLWU_ME_WUME6_WIDTH))

/*! @brief Set the WUME6 field to a new value. */
#define LLWU_WR_ME_WUME6(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME6_MASK, LLWU_ME_WUME6(value)))
#define LLWU_BWR_ME_WUME6(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME6_SHIFT), LLWU_ME_WUME6_SHIFT, LLWU_ME_WUME6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME7[7] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME7 field. */
#define LLWU_RD_ME_WUME7(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME7_MASK) >> LLWU_ME_WUME7_SHIFT)
#define LLWU_BRD_ME_WUME7(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME7_SHIFT, LLWU_ME_WUME7_WIDTH))

/*! @brief Set the WUME7 field to a new value. */
#define LLWU_WR_ME_WUME7(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME7_MASK, LLWU_ME_WUME7(value)))
#define LLWU_BWR_ME_WUME7(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME7_SHIFT), LLWU_ME_WUME7_SHIFT, LLWU_ME_WUME7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_F1 - LLWU Flag 1 register
 ******************************************************************************/

/*!
 * @brief LLWU_F1 - LLWU Flag 1 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_F1 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit LLS or VLLS mode. For LLS, this is the source causing the CPU
 * interrupt flow. For VLLS, this is the source causing the MCU reset flow. The
 * external wakeup flags are read-only and clearing a flag is accomplished by a write
 * of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if set, will
 * remain set if the associated WUPEx bit is cleared. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_F1 register
 */
/*@{*/
#define LLWU_RD_F1(base)         (LLWU_F1_REG(base))
#define LLWU_WR_F1(base, value)  (LLWU_F1_REG(base) = (value))
#define LLWU_RMW_F1(base, mask, value) (LLWU_WR_F1(base, (LLWU_RD_F1(base) & ~(mask)) | (value)))
#define LLWU_SET_F1(base, value) (BME_OR8(&LLWU_F1_REG(base), (uint8_t)(value)))
#define LLWU_CLR_F1(base, value) (BME_AND8(&LLWU_F1_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_F1(base, value) (BME_XOR8(&LLWU_F1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_F1 bitfields
 */

/*!
 * @name Register LLWU_F1, field WUF0[0] (W1C)
 *
 * Indicates that an enabled external wake-up pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF0.
 *
 * Values:
 * - 0b0 - LLWU_P0 input was not a wakeup source
 * - 0b1 - LLWU_P0 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF0 field. */
#define LLWU_RD_F1_WUF0(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF0_MASK) >> LLWU_F1_WUF0_SHIFT)
#define LLWU_BRD_F1_WUF0(base) (BME_UBFX8(&LLWU_F1_REG(base), LLWU_F1_WUF0_SHIFT, LLWU_F1_WUF0_WIDTH))

/*! @brief Set the WUF0 field to a new value. */
#define LLWU_WR_F1_WUF0(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF6_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF0(value)))
#define LLWU_BWR_F1_WUF0(base, value) (BME_BFI8(&LLWU_F1_REG(base), ((uint8_t)(value) << LLWU_F1_WUF0_SHIFT), LLWU_F1_WUF0_SHIFT, LLWU_F1_WUF0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF1[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF1.
 *
 * Values:
 * - 0b0 - LLWU_P1 input was not a wakeup source
 * - 0b1 - LLWU_P1 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF1 field. */
#define LLWU_RD_F1_WUF1(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF1_MASK) >> LLWU_F1_WUF1_SHIFT)
#define LLWU_BRD_F1_WUF1(base) (BME_UBFX8(&LLWU_F1_REG(base), LLWU_F1_WUF1_SHIFT, LLWU_F1_WUF1_WIDTH))

/*! @brief Set the WUF1 field to a new value. */
#define LLWU_WR_F1_WUF1(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF1_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF6_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF1(value)))
#define LLWU_BWR_F1_WUF1(base, value) (BME_BFI8(&LLWU_F1_REG(base), ((uint8_t)(value) << LLWU_F1_WUF1_SHIFT), LLWU_F1_WUF1_SHIFT, LLWU_F1_WUF1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF2[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF2.
 *
 * Values:
 * - 0b0 - LLWU_P2 input was not a wakeup source
 * - 0b1 - LLWU_P2 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF2 field. */
#define LLWU_RD_F1_WUF2(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF2_MASK) >> LLWU_F1_WUF2_SHIFT)
#define LLWU_BRD_F1_WUF2(base) (BME_UBFX8(&LLWU_F1_REG(base), LLWU_F1_WUF2_SHIFT, LLWU_F1_WUF2_WIDTH))

/*! @brief Set the WUF2 field to a new value. */
#define LLWU_WR_F1_WUF2(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF2_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF6_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF2(value)))
#define LLWU_BWR_F1_WUF2(base, value) (BME_BFI8(&LLWU_F1_REG(base), ((uint8_t)(value) << LLWU_F1_WUF2_SHIFT), LLWU_F1_WUF2_SHIFT, LLWU_F1_WUF2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF3[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF3.
 *
 * Values:
 * - 0b0 - LLWU_P3 input was not a wake-up source
 * - 0b1 - LLWU_P3 input was a wake-up source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF3 field. */
#define LLWU_RD_F1_WUF3(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF3_MASK) >> LLWU_F1_WUF3_SHIFT)
#define LLWU_BRD_F1_WUF3(base) (BME_UBFX8(&LLWU_F1_REG(base), LLWU_F1_WUF3_SHIFT, LLWU_F1_WUF3_WIDTH))

/*! @brief Set the WUF3 field to a new value. */
#define LLWU_WR_F1_WUF3(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF3_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF6_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF3(value)))
#define LLWU_BWR_F1_WUF3(base, value) (BME_BFI8(&LLWU_F1_REG(base), ((uint8_t)(value) << LLWU_F1_WUF3_SHIFT), LLWU_F1_WUF3_SHIFT, LLWU_F1_WUF3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF4[4] (W1C)
 *
 * Indicates that an enabled external wake-up pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF4.
 *
 * Values:
 * - 0b0 - LLWU_P4 input was not a wakeup source
 * - 0b1 - LLWU_P4 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF4 field. */
#define LLWU_RD_F1_WUF4(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF4_MASK) >> LLWU_F1_WUF4_SHIFT)
#define LLWU_BRD_F1_WUF4(base) (BME_UBFX8(&LLWU_F1_REG(base), LLWU_F1_WUF4_SHIFT, LLWU_F1_WUF4_WIDTH))

/*! @brief Set the WUF4 field to a new value. */
#define LLWU_WR_F1_WUF4(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF4_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF6_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF4(value)))
#define LLWU_BWR_F1_WUF4(base, value) (BME_BFI8(&LLWU_F1_REG(base), ((uint8_t)(value) << LLWU_F1_WUF4_SHIFT), LLWU_F1_WUF4_SHIFT, LLWU_F1_WUF4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF5[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF5.
 *
 * Values:
 * - 0b0 - LLWU_P5 input was not a wakeup source
 * - 0b1 - LLWU_P5 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF5 field. */
#define LLWU_RD_F1_WUF5(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF5_MASK) >> LLWU_F1_WUF5_SHIFT)
#define LLWU_BRD_F1_WUF5(base) (BME_UBFX8(&LLWU_F1_REG(base), LLWU_F1_WUF5_SHIFT, LLWU_F1_WUF5_WIDTH))

/*! @brief Set the WUF5 field to a new value. */
#define LLWU_WR_F1_WUF5(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF5_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF6_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF5(value)))
#define LLWU_BWR_F1_WUF5(base, value) (BME_BFI8(&LLWU_F1_REG(base), ((uint8_t)(value) << LLWU_F1_WUF5_SHIFT), LLWU_F1_WUF5_SHIFT, LLWU_F1_WUF5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF6[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF6.
 *
 * Values:
 * - 0b0 - LLWU_P6 input was not a wakeup source
 * - 0b1 - LLWU_P6 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF6 field. */
#define LLWU_RD_F1_WUF6(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF6_MASK) >> LLWU_F1_WUF6_SHIFT)
#define LLWU_BRD_F1_WUF6(base) (BME_UBFX8(&LLWU_F1_REG(base), LLWU_F1_WUF6_SHIFT, LLWU_F1_WUF6_WIDTH))

/*! @brief Set the WUF6 field to a new value. */
#define LLWU_WR_F1_WUF6(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF6_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF6(value)))
#define LLWU_BWR_F1_WUF6(base, value) (BME_BFI8(&LLWU_F1_REG(base), ((uint8_t)(value) << LLWU_F1_WUF6_SHIFT), LLWU_F1_WUF6_SHIFT, LLWU_F1_WUF6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF7[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF7.
 *
 * Values:
 * - 0b0 - LLWU_P7 input was not a wakeup source
 * - 0b1 - LLWU_P7 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF7 field. */
#define LLWU_RD_F1_WUF7(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF7_MASK) >> LLWU_F1_WUF7_SHIFT)
#define LLWU_BRD_F1_WUF7(base) (BME_UBFX8(&LLWU_F1_REG(base), LLWU_F1_WUF7_SHIFT, LLWU_F1_WUF7_WIDTH))

/*! @brief Set the WUF7 field to a new value. */
#define LLWU_WR_F1_WUF7(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF7_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF6_MASK), LLWU_F1_WUF7(value)))
#define LLWU_BWR_F1_WUF7(base, value) (BME_BFI8(&LLWU_F1_REG(base), ((uint8_t)(value) << LLWU_F1_WUF7_SHIFT), LLWU_F1_WUF7_SHIFT, LLWU_F1_WUF7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_F2 - LLWU Flag 2 register
 ******************************************************************************/

/*!
 * @brief LLWU_F2 - LLWU Flag 2 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_F2 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit LLS or VLLS mode. For LLS, this is the source causing the CPU
 * interrupt flow. For VLLS, this is the source causing the MCU reset flow. The
 * external wakeup flags are read-only and clearing a flag is accomplished by a write
 * of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if set, will
 * remain set if the associated WUPEx bit is cleared. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_F2 register
 */
/*@{*/
#define LLWU_RD_F2(base)         (LLWU_F2_REG(base))
#define LLWU_WR_F2(base, value)  (LLWU_F2_REG(base) = (value))
#define LLWU_RMW_F2(base, mask, value) (LLWU_WR_F2(base, (LLWU_RD_F2(base) & ~(mask)) | (value)))
#define LLWU_SET_F2(base, value) (BME_OR8(&LLWU_F2_REG(base), (uint8_t)(value)))
#define LLWU_CLR_F2(base, value) (BME_AND8(&LLWU_F2_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_F2(base, value) (BME_XOR8(&LLWU_F2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_F2 bitfields
 */

/*!
 * @name Register LLWU_F2, field WUF8[0] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF8.
 *
 * Values:
 * - 0b0 - LLWU_P8 input was not a wakeup source
 * - 0b1 - LLWU_P8 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF8 field. */
#define LLWU_RD_F2_WUF8(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF8_MASK) >> LLWU_F2_WUF8_SHIFT)
#define LLWU_BRD_F2_WUF8(base) (BME_UBFX8(&LLWU_F2_REG(base), LLWU_F2_WUF8_SHIFT, LLWU_F2_WUF8_WIDTH))

/*! @brief Set the WUF8 field to a new value. */
#define LLWU_WR_F2_WUF8(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF14_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF8(value)))
#define LLWU_BWR_F2_WUF8(base, value) (BME_BFI8(&LLWU_F2_REG(base), ((uint8_t)(value) << LLWU_F2_WUF8_SHIFT), LLWU_F2_WUF8_SHIFT, LLWU_F2_WUF8_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF9[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF9.
 *
 * Values:
 * - 0b0 - LLWU_P9 input was not a wakeup source
 * - 0b1 - LLWU_P9 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF9 field. */
#define LLWU_RD_F2_WUF9(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF9_MASK) >> LLWU_F2_WUF9_SHIFT)
#define LLWU_BRD_F2_WUF9(base) (BME_UBFX8(&LLWU_F2_REG(base), LLWU_F2_WUF9_SHIFT, LLWU_F2_WUF9_WIDTH))

/*! @brief Set the WUF9 field to a new value. */
#define LLWU_WR_F2_WUF9(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF9_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF14_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF9(value)))
#define LLWU_BWR_F2_WUF9(base, value) (BME_BFI8(&LLWU_F2_REG(base), ((uint8_t)(value) << LLWU_F2_WUF9_SHIFT), LLWU_F2_WUF9_SHIFT, LLWU_F2_WUF9_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF10[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF10.
 *
 * Values:
 * - 0b0 - LLWU_P10 input was not a wakeup source
 * - 0b1 - LLWU_P10 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF10 field. */
#define LLWU_RD_F2_WUF10(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF10_MASK) >> LLWU_F2_WUF10_SHIFT)
#define LLWU_BRD_F2_WUF10(base) (BME_UBFX8(&LLWU_F2_REG(base), LLWU_F2_WUF10_SHIFT, LLWU_F2_WUF10_WIDTH))

/*! @brief Set the WUF10 field to a new value. */
#define LLWU_WR_F2_WUF10(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF10_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF14_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF10(value)))
#define LLWU_BWR_F2_WUF10(base, value) (BME_BFI8(&LLWU_F2_REG(base), ((uint8_t)(value) << LLWU_F2_WUF10_SHIFT), LLWU_F2_WUF10_SHIFT, LLWU_F2_WUF10_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF11[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF11.
 *
 * Values:
 * - 0b0 - LLWU_P11 input was not a wakeup source
 * - 0b1 - LLWU_P11 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF11 field. */
#define LLWU_RD_F2_WUF11(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF11_MASK) >> LLWU_F2_WUF11_SHIFT)
#define LLWU_BRD_F2_WUF11(base) (BME_UBFX8(&LLWU_F2_REG(base), LLWU_F2_WUF11_SHIFT, LLWU_F2_WUF11_WIDTH))

/*! @brief Set the WUF11 field to a new value. */
#define LLWU_WR_F2_WUF11(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF11_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF14_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF11(value)))
#define LLWU_BWR_F2_WUF11(base, value) (BME_BFI8(&LLWU_F2_REG(base), ((uint8_t)(value) << LLWU_F2_WUF11_SHIFT), LLWU_F2_WUF11_SHIFT, LLWU_F2_WUF11_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF12[4] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF12.
 *
 * Values:
 * - 0b0 - LLWU_P12 input was not a wakeup source
 * - 0b1 - LLWU_P12 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF12 field. */
#define LLWU_RD_F2_WUF12(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF12_MASK) >> LLWU_F2_WUF12_SHIFT)
#define LLWU_BRD_F2_WUF12(base) (BME_UBFX8(&LLWU_F2_REG(base), LLWU_F2_WUF12_SHIFT, LLWU_F2_WUF12_WIDTH))

/*! @brief Set the WUF12 field to a new value. */
#define LLWU_WR_F2_WUF12(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF12_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF14_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF12(value)))
#define LLWU_BWR_F2_WUF12(base, value) (BME_BFI8(&LLWU_F2_REG(base), ((uint8_t)(value) << LLWU_F2_WUF12_SHIFT), LLWU_F2_WUF12_SHIFT, LLWU_F2_WUF12_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF13[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF13.
 *
 * Values:
 * - 0b0 - LLWU_P13 input was not a wakeup source
 * - 0b1 - LLWU_P13 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF13 field. */
#define LLWU_RD_F2_WUF13(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF13_MASK) >> LLWU_F2_WUF13_SHIFT)
#define LLWU_BRD_F2_WUF13(base) (BME_UBFX8(&LLWU_F2_REG(base), LLWU_F2_WUF13_SHIFT, LLWU_F2_WUF13_WIDTH))

/*! @brief Set the WUF13 field to a new value. */
#define LLWU_WR_F2_WUF13(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF13_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF14_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF13(value)))
#define LLWU_BWR_F2_WUF13(base, value) (BME_BFI8(&LLWU_F2_REG(base), ((uint8_t)(value) << LLWU_F2_WUF13_SHIFT), LLWU_F2_WUF13_SHIFT, LLWU_F2_WUF13_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF14[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF14.
 *
 * Values:
 * - 0b0 - LLWU_P14 input was not a wakeup source
 * - 0b1 - LLWU_P14 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF14 field. */
#define LLWU_RD_F2_WUF14(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF14_MASK) >> LLWU_F2_WUF14_SHIFT)
#define LLWU_BRD_F2_WUF14(base) (BME_UBFX8(&LLWU_F2_REG(base), LLWU_F2_WUF14_SHIFT, LLWU_F2_WUF14_WIDTH))

/*! @brief Set the WUF14 field to a new value. */
#define LLWU_WR_F2_WUF14(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF14_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF14(value)))
#define LLWU_BWR_F2_WUF14(base, value) (BME_BFI8(&LLWU_F2_REG(base), ((uint8_t)(value) << LLWU_F2_WUF14_SHIFT), LLWU_F2_WUF14_SHIFT, LLWU_F2_WUF14_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF15[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF15.
 *
 * Values:
 * - 0b0 - LLWU_P15 input was not a wakeup source
 * - 0b1 - LLWU_P15 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF15 field. */
#define LLWU_RD_F2_WUF15(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF15_MASK) >> LLWU_F2_WUF15_SHIFT)
#define LLWU_BRD_F2_WUF15(base) (BME_UBFX8(&LLWU_F2_REG(base), LLWU_F2_WUF15_SHIFT, LLWU_F2_WUF15_WIDTH))

/*! @brief Set the WUF15 field to a new value. */
#define LLWU_WR_F2_WUF15(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF15_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF14_MASK), LLWU_F2_WUF15(value)))
#define LLWU_BWR_F2_WUF15(base, value) (BME_BFI8(&LLWU_F2_REG(base), ((uint8_t)(value) << LLWU_F2_WUF15_SHIFT), LLWU_F2_WUF15_SHIFT, LLWU_F2_WUF15_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_F3 - LLWU Flag 3 register
 ******************************************************************************/

/*!
 * @brief LLWU_F3 - LLWU Flag 3 register (RO)
 *
 * Reset value: 0x00U
 *
 * LLWU_F3 contains the wakeup flags indicating which internal wakeup source
 * caused the MCU to exit LLS or VLLS mode. For LLS, this is the source causing the
 * CPU interrupt flow. For VLLS, this is the source causing the MCU reset flow.
 * For internal peripherals that are capable of running in a low-leakage power
 * mode, such as a real time clock module or CMP module, the flag from the
 * associated peripheral is accessible as the MWUFx bit. The flag will need to be cleared
 * in the peripheral instead of writing a 1 to the MWUFx bit. This register is
 * reset on Chip Reset not VLLS and by reset types that trigger Chip Reset not
 * VLLS. It is unaffected by reset types that do not trigger Chip Reset not VLLS. See
 * the IntroductionInformation found here describes the registers of the Reset
 * Control Module (RCM). The RCM implements many of the reset functions for the
 * chip. See the chip's reset chapter for more information. details for more
 * information.
 */
/*!
 * @name Constants and macros for entire LLWU_F3 register
 */
/*@{*/
#define LLWU_RD_F3(base)         (LLWU_F3_REG(base))
/*@}*/

/*
 * Constants & macros for individual LLWU_F3 bitfields
 */

/*!
 * @name Register LLWU_F3, field MWUF0[0] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 0 input was not a wakeup source
 * - 0b1 - Module 0 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF0 field. */
#define LLWU_RD_F3_MWUF0(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF0_MASK) >> LLWU_F3_MWUF0_SHIFT)
#define LLWU_BRD_F3_MWUF0(base) (BME_UBFX8(&LLWU_F3_REG(base), LLWU_F3_MWUF0_SHIFT, LLWU_F3_MWUF0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF1[1] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 1 input was not a wakeup source
 * - 0b1 - Module 1 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF1 field. */
#define LLWU_RD_F3_MWUF1(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF1_MASK) >> LLWU_F3_MWUF1_SHIFT)
#define LLWU_BRD_F3_MWUF1(base) (BME_UBFX8(&LLWU_F3_REG(base), LLWU_F3_MWUF1_SHIFT, LLWU_F3_MWUF1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF2[2] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 2 input was not a wakeup source
 * - 0b1 - Module 2 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF2 field. */
#define LLWU_RD_F3_MWUF2(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF2_MASK) >> LLWU_F3_MWUF2_SHIFT)
#define LLWU_BRD_F3_MWUF2(base) (BME_UBFX8(&LLWU_F3_REG(base), LLWU_F3_MWUF2_SHIFT, LLWU_F3_MWUF2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF3[3] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 3 input was not a wakeup source
 * - 0b1 - Module 3 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF3 field. */
#define LLWU_RD_F3_MWUF3(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF3_MASK) >> LLWU_F3_MWUF3_SHIFT)
#define LLWU_BRD_F3_MWUF3(base) (BME_UBFX8(&LLWU_F3_REG(base), LLWU_F3_MWUF3_SHIFT, LLWU_F3_MWUF3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF4[4] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 4 input was not a wakeup source
 * - 0b1 - Module 4 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF4 field. */
#define LLWU_RD_F3_MWUF4(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF4_MASK) >> LLWU_F3_MWUF4_SHIFT)
#define LLWU_BRD_F3_MWUF4(base) (BME_UBFX8(&LLWU_F3_REG(base), LLWU_F3_MWUF4_SHIFT, LLWU_F3_MWUF4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF5[5] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 5 input was not a wakeup source
 * - 0b1 - Module 5 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF5 field. */
#define LLWU_RD_F3_MWUF5(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF5_MASK) >> LLWU_F3_MWUF5_SHIFT)
#define LLWU_BRD_F3_MWUF5(base) (BME_UBFX8(&LLWU_F3_REG(base), LLWU_F3_MWUF5_SHIFT, LLWU_F3_MWUF5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF6[6] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 6 input was not a wakeup source
 * - 0b1 - Module 6 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF6 field. */
#define LLWU_RD_F3_MWUF6(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF6_MASK) >> LLWU_F3_MWUF6_SHIFT)
#define LLWU_BRD_F3_MWUF6(base) (BME_UBFX8(&LLWU_F3_REG(base), LLWU_F3_MWUF6_SHIFT, LLWU_F3_MWUF6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF7[7] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 7 input was not a wakeup source
 * - 0b1 - Module 7 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF7 field. */
#define LLWU_RD_F3_MWUF7(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF7_MASK) >> LLWU_F3_MWUF7_SHIFT)
#define LLWU_BRD_F3_MWUF7(base) (BME_UBFX8(&LLWU_F3_REG(base), LLWU_F3_MWUF7_SHIFT, LLWU_F3_MWUF7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_FILT1 - LLWU Pin Filter 1 register
 ******************************************************************************/

/*!
 * @brief LLWU_FILT1 - LLWU Pin Filter 1 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_FILT1 is a control and status register that is used to enable/disable
 * the digital filter 1 features for an external pin. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See
 * the chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_FILT1 register
 */
/*@{*/
#define LLWU_RD_FILT1(base)      (LLWU_FILT1_REG(base))
#define LLWU_WR_FILT1(base, value) (LLWU_FILT1_REG(base) = (value))
#define LLWU_RMW_FILT1(base, mask, value) (LLWU_WR_FILT1(base, (LLWU_RD_FILT1(base) & ~(mask)) | (value)))
#define LLWU_SET_FILT1(base, value) (BME_OR8(&LLWU_FILT1_REG(base), (uint8_t)(value)))
#define LLWU_CLR_FILT1(base, value) (BME_AND8(&LLWU_FILT1_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_FILT1(base, value) (BME_XOR8(&LLWU_FILT1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_FILT1 bitfields
 */

/*!
 * @name Register LLWU_FILT1, field FILTSEL[3:0] (RW)
 *
 * Selects 1 out of the 16 wakeup pins to be muxed into the filter.
 *
 * Values:
 * - 0b0000 - Select LLWU_P0 for filter
 * - 0b1111 - Select LLWU_P15 for filter
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT1_FILTSEL field. */
#define LLWU_RD_FILT1_FILTSEL(base) ((LLWU_FILT1_REG(base) & LLWU_FILT1_FILTSEL_MASK) >> LLWU_FILT1_FILTSEL_SHIFT)
#define LLWU_BRD_FILT1_FILTSEL(base) (BME_UBFX8(&LLWU_FILT1_REG(base), LLWU_FILT1_FILTSEL_SHIFT, LLWU_FILT1_FILTSEL_WIDTH))

/*! @brief Set the FILTSEL field to a new value. */
#define LLWU_WR_FILT1_FILTSEL(base, value) (LLWU_RMW_FILT1(base, (LLWU_FILT1_FILTSEL_MASK | LLWU_FILT1_FILTF_MASK), LLWU_FILT1_FILTSEL(value)))
#define LLWU_BWR_FILT1_FILTSEL(base, value) (BME_BFI8(&LLWU_FILT1_REG(base), ((uint8_t)(value) << LLWU_FILT1_FILTSEL_SHIFT), LLWU_FILT1_FILTSEL_SHIFT, LLWU_FILT1_FILTSEL_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT1, field FILTE[6:5] (RW)
 *
 * Controls the digital filter options for the external pin detect.
 *
 * Values:
 * - 0b00 - Filter disabled
 * - 0b01 - Filter posedge detect enabled
 * - 0b10 - Filter negedge detect enabled
 * - 0b11 - Filter any edge detect enabled
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT1_FILTE field. */
#define LLWU_RD_FILT1_FILTE(base) ((LLWU_FILT1_REG(base) & LLWU_FILT1_FILTE_MASK) >> LLWU_FILT1_FILTE_SHIFT)
#define LLWU_BRD_FILT1_FILTE(base) (BME_UBFX8(&LLWU_FILT1_REG(base), LLWU_FILT1_FILTE_SHIFT, LLWU_FILT1_FILTE_WIDTH))

/*! @brief Set the FILTE field to a new value. */
#define LLWU_WR_FILT1_FILTE(base, value) (LLWU_RMW_FILT1(base, (LLWU_FILT1_FILTE_MASK | LLWU_FILT1_FILTF_MASK), LLWU_FILT1_FILTE(value)))
#define LLWU_BWR_FILT1_FILTE(base, value) (BME_BFI8(&LLWU_FILT1_REG(base), ((uint8_t)(value) << LLWU_FILT1_FILTE_SHIFT), LLWU_FILT1_FILTE_SHIFT, LLWU_FILT1_FILTE_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT1, field FILTF[7] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0b0 - Pin Filter 1 was not a wakeup source
 * - 0b1 - Pin Filter 1 was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT1_FILTF field. */
#define LLWU_RD_FILT1_FILTF(base) ((LLWU_FILT1_REG(base) & LLWU_FILT1_FILTF_MASK) >> LLWU_FILT1_FILTF_SHIFT)
#define LLWU_BRD_FILT1_FILTF(base) (BME_UBFX8(&LLWU_FILT1_REG(base), LLWU_FILT1_FILTF_SHIFT, LLWU_FILT1_FILTF_WIDTH))

/*! @brief Set the FILTF field to a new value. */
#define LLWU_WR_FILT1_FILTF(base, value) (LLWU_RMW_FILT1(base, LLWU_FILT1_FILTF_MASK, LLWU_FILT1_FILTF(value)))
#define LLWU_BWR_FILT1_FILTF(base, value) (BME_BFI8(&LLWU_FILT1_REG(base), ((uint8_t)(value) << LLWU_FILT1_FILTF_SHIFT), LLWU_FILT1_FILTF_SHIFT, LLWU_FILT1_FILTF_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_FILT2 - LLWU Pin Filter 2 register
 ******************************************************************************/

/*!
 * @brief LLWU_FILT2 - LLWU Pin Filter 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_FILT2 is a control and status register that is used to enable/disable
 * the digital filter 2 features for an external pin. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See
 * the chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_FILT2 register
 */
/*@{*/
#define LLWU_RD_FILT2(base)      (LLWU_FILT2_REG(base))
#define LLWU_WR_FILT2(base, value) (LLWU_FILT2_REG(base) = (value))
#define LLWU_RMW_FILT2(base, mask, value) (LLWU_WR_FILT2(base, (LLWU_RD_FILT2(base) & ~(mask)) | (value)))
#define LLWU_SET_FILT2(base, value) (BME_OR8(&LLWU_FILT2_REG(base), (uint8_t)(value)))
#define LLWU_CLR_FILT2(base, value) (BME_AND8(&LLWU_FILT2_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_FILT2(base, value) (BME_XOR8(&LLWU_FILT2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_FILT2 bitfields
 */

/*!
 * @name Register LLWU_FILT2, field FILTSEL[3:0] (RW)
 *
 * Selects 1 out of the 16 wakeup pins to be muxed into the filter.
 *
 * Values:
 * - 0b0000 - Select LLWU_P0 for filter
 * - 0b1111 - Select LLWU_P15 for filter
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT2_FILTSEL field. */
#define LLWU_RD_FILT2_FILTSEL(base) ((LLWU_FILT2_REG(base) & LLWU_FILT2_FILTSEL_MASK) >> LLWU_FILT2_FILTSEL_SHIFT)
#define LLWU_BRD_FILT2_FILTSEL(base) (BME_UBFX8(&LLWU_FILT2_REG(base), LLWU_FILT2_FILTSEL_SHIFT, LLWU_FILT2_FILTSEL_WIDTH))

/*! @brief Set the FILTSEL field to a new value. */
#define LLWU_WR_FILT2_FILTSEL(base, value) (LLWU_RMW_FILT2(base, (LLWU_FILT2_FILTSEL_MASK | LLWU_FILT2_FILTF_MASK), LLWU_FILT2_FILTSEL(value)))
#define LLWU_BWR_FILT2_FILTSEL(base, value) (BME_BFI8(&LLWU_FILT2_REG(base), ((uint8_t)(value) << LLWU_FILT2_FILTSEL_SHIFT), LLWU_FILT2_FILTSEL_SHIFT, LLWU_FILT2_FILTSEL_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT2, field FILTE[6:5] (RW)
 *
 * Controls the digital filter options for the external pin detect.
 *
 * Values:
 * - 0b00 - Filter disabled
 * - 0b01 - Filter posedge detect enabled
 * - 0b10 - Filter negedge detect enabled
 * - 0b11 - Filter any edge detect enabled
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT2_FILTE field. */
#define LLWU_RD_FILT2_FILTE(base) ((LLWU_FILT2_REG(base) & LLWU_FILT2_FILTE_MASK) >> LLWU_FILT2_FILTE_SHIFT)
#define LLWU_BRD_FILT2_FILTE(base) (BME_UBFX8(&LLWU_FILT2_REG(base), LLWU_FILT2_FILTE_SHIFT, LLWU_FILT2_FILTE_WIDTH))

/*! @brief Set the FILTE field to a new value. */
#define LLWU_WR_FILT2_FILTE(base, value) (LLWU_RMW_FILT2(base, (LLWU_FILT2_FILTE_MASK | LLWU_FILT2_FILTF_MASK), LLWU_FILT2_FILTE(value)))
#define LLWU_BWR_FILT2_FILTE(base, value) (BME_BFI8(&LLWU_FILT2_REG(base), ((uint8_t)(value) << LLWU_FILT2_FILTE_SHIFT), LLWU_FILT2_FILTE_SHIFT, LLWU_FILT2_FILTE_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT2, field FILTF[7] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0b0 - Pin Filter 2 was not a wakeup source
 * - 0b1 - Pin Filter 2 was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT2_FILTF field. */
#define LLWU_RD_FILT2_FILTF(base) ((LLWU_FILT2_REG(base) & LLWU_FILT2_FILTF_MASK) >> LLWU_FILT2_FILTF_SHIFT)
#define LLWU_BRD_FILT2_FILTF(base) (BME_UBFX8(&LLWU_FILT2_REG(base), LLWU_FILT2_FILTF_SHIFT, LLWU_FILT2_FILTF_WIDTH))

/*! @brief Set the FILTF field to a new value. */
#define LLWU_WR_FILT2_FILTF(base, value) (LLWU_RMW_FILT2(base, LLWU_FILT2_FILTF_MASK, LLWU_FILT2_FILTF(value)))
#define LLWU_BWR_FILT2_FILTF(base, value) (BME_BFI8(&LLWU_FILT2_REG(base), ((uint8_t)(value) << LLWU_FILT2_FILTF_SHIFT), LLWU_FILT2_FILTF_SHIFT, LLWU_FILT2_FILTF_WIDTH))
/*@}*/

/*
 * MKW40Z4 LPTMR
 *
 * Low Power Timer
 *
 * Registers defined in this header file:
 * - LPTMR_CSR - Low Power Timer Control Status Register
 * - LPTMR_PSR - Low Power Timer Prescale Register
 * - LPTMR_CMR - Low Power Timer Compare Register
 * - LPTMR_CNR - Low Power Timer Counter Register
 */

#define LPTMR_INSTANCE_COUNT (1U) /*!< Number of instances of the LPTMR module. */
#define LPTMR0_IDX (0U) /*!< Instance number for LPTMR0. */

/*******************************************************************************
 * LPTMR_CSR - Low Power Timer Control Status Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CSR - Low Power Timer Control Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CSR register
 */
/*@{*/
#define LPTMR_RD_CSR(base)       (LPTMR_CSR_REG(base))
#define LPTMR_WR_CSR(base, value) (LPTMR_CSR_REG(base) = (value))
#define LPTMR_RMW_CSR(base, mask, value) (LPTMR_WR_CSR(base, (LPTMR_RD_CSR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CSR(base, value) (BME_OR32(&LPTMR_CSR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_CSR(base, value) (BME_AND32(&LPTMR_CSR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_CSR(base, value) (BME_XOR32(&LPTMR_CSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CSR bitfields
 */

/*!
 * @name Register LPTMR_CSR, field TEN[0] (RW)
 *
 * When TEN is clear, it resets the LPTMR internal logic, including the CNR and
 * TCF. When TEN is set, the LPTMR is enabled. While writing 1 to this field,
 * CSR[5:1] must not be altered.
 *
 * Values:
 * - 0b0 - LPTMR is disabled and internal logic is reset.
 * - 0b1 - LPTMR is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TEN field. */
#define LPTMR_RD_CSR_TEN(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TEN_MASK) >> LPTMR_CSR_TEN_SHIFT)
#define LPTMR_BRD_CSR_TEN(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TEN_SHIFT, LPTMR_CSR_TEN_WIDTH))

/*! @brief Set the TEN field to a new value. */
#define LPTMR_WR_CSR_TEN(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TEN_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TEN(value)))
#define LPTMR_BWR_CSR_TEN(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TEN_SHIFT), LPTMR_CSR_TEN_SHIFT, LPTMR_CSR_TEN_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TMS[1] (RW)
 *
 * Configures the mode of the LPTMR. TMS must be altered only when the LPTMR is
 * disabled.
 *
 * Values:
 * - 0b0 - Time Counter mode.
 * - 0b1 - Pulse Counter mode.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TMS field. */
#define LPTMR_RD_CSR_TMS(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TMS_MASK) >> LPTMR_CSR_TMS_SHIFT)
#define LPTMR_BRD_CSR_TMS(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TMS_SHIFT, LPTMR_CSR_TMS_WIDTH))

/*! @brief Set the TMS field to a new value. */
#define LPTMR_WR_CSR_TMS(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TMS_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TMS(value)))
#define LPTMR_BWR_CSR_TMS(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TMS_SHIFT), LPTMR_CSR_TMS_SHIFT, LPTMR_CSR_TMS_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TFC[2] (RW)
 *
 * When clear, TFC configures the CNR to reset whenever TCF is set. When set,
 * TFC configures the CNR to reset on overflow. TFC must be altered only when the
 * LPTMR is disabled.
 *
 * Values:
 * - 0b0 - CNR is reset whenever TCF is set.
 * - 0b1 - CNR is reset on overflow.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TFC field. */
#define LPTMR_RD_CSR_TFC(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TFC_MASK) >> LPTMR_CSR_TFC_SHIFT)
#define LPTMR_BRD_CSR_TFC(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TFC_SHIFT, LPTMR_CSR_TFC_WIDTH))

/*! @brief Set the TFC field to a new value. */
#define LPTMR_WR_CSR_TFC(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TFC_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TFC(value)))
#define LPTMR_BWR_CSR_TFC(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TFC_SHIFT), LPTMR_CSR_TFC_SHIFT, LPTMR_CSR_TFC_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPP[3] (RW)
 *
 * Configures the polarity of the input source in Pulse Counter mode. TPP must
 * be changed only when the LPTMR is disabled.
 *
 * Values:
 * - 0b0 - Pulse Counter input source is active-high, and the CNR will increment
 *     on the rising-edge.
 * - 0b1 - Pulse Counter input source is active-low, and the CNR will increment
 *     on the falling-edge.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TPP field. */
#define LPTMR_RD_CSR_TPP(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TPP_MASK) >> LPTMR_CSR_TPP_SHIFT)
#define LPTMR_BRD_CSR_TPP(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TPP_SHIFT, LPTMR_CSR_TPP_WIDTH))

/*! @brief Set the TPP field to a new value. */
#define LPTMR_WR_CSR_TPP(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TPP_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TPP(value)))
#define LPTMR_BWR_CSR_TPP(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TPP_SHIFT), LPTMR_CSR_TPP_SHIFT, LPTMR_CSR_TPP_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPS[5:4] (RW)
 *
 * Configures the input source to be used in Pulse Counter mode. TPS must be
 * altered only when the LPTMR is disabled. The input connections vary by device.
 * See the chip configuration details for information on the connections to these
 * inputs.
 *
 * Values:
 * - 0b00 - Pulse counter input 0 is selected.
 * - 0b01 - Pulse counter input 1 is selected.
 * - 0b10 - Pulse counter input 2 is selected.
 * - 0b11 - Pulse counter input 3 is selected.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TPS field. */
#define LPTMR_RD_CSR_TPS(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TPS_MASK) >> LPTMR_CSR_TPS_SHIFT)
#define LPTMR_BRD_CSR_TPS(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TPS_SHIFT, LPTMR_CSR_TPS_WIDTH))

/*! @brief Set the TPS field to a new value. */
#define LPTMR_WR_CSR_TPS(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TPS_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TPS(value)))
#define LPTMR_BWR_CSR_TPS(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TPS_SHIFT), LPTMR_CSR_TPS_SHIFT, LPTMR_CSR_TPS_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TIE[6] (RW)
 *
 * When TIE is set, the LPTMR Interrupt is generated whenever TCF is also set.
 *
 * Values:
 * - 0b0 - Timer interrupt disabled.
 * - 0b1 - Timer interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TIE field. */
#define LPTMR_RD_CSR_TIE(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TIE_MASK) >> LPTMR_CSR_TIE_SHIFT)
#define LPTMR_BRD_CSR_TIE(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TIE_SHIFT, LPTMR_CSR_TIE_WIDTH))

/*! @brief Set the TIE field to a new value. */
#define LPTMR_WR_CSR_TIE(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TIE_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TIE(value)))
#define LPTMR_BWR_CSR_TIE(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TIE_SHIFT), LPTMR_CSR_TIE_SHIFT, LPTMR_CSR_TIE_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TCF[7] (W1C)
 *
 * TCF is set when the LPTMR is enabled and the CNR equals the CMR and
 * increments. TCF is cleared when the LPTMR is disabled or a logic 1 is written to it.
 *
 * Values:
 * - 0b0 - The value of CNR is not equal to CMR and increments.
 * - 0b1 - The value of CNR is equal to CMR and increments.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TCF field. */
#define LPTMR_RD_CSR_TCF(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TCF_MASK) >> LPTMR_CSR_TCF_SHIFT)
#define LPTMR_BRD_CSR_TCF(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TCF_SHIFT, LPTMR_CSR_TCF_WIDTH))

/*! @brief Set the TCF field to a new value. */
#define LPTMR_WR_CSR_TCF(base, value) (LPTMR_RMW_CSR(base, LPTMR_CSR_TCF_MASK, LPTMR_CSR_TCF(value)))
#define LPTMR_BWR_CSR_TCF(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TCF_SHIFT), LPTMR_CSR_TCF_SHIFT, LPTMR_CSR_TCF_WIDTH))
/*@}*/

/*******************************************************************************
 * LPTMR_PSR - Low Power Timer Prescale Register
 ******************************************************************************/

/*!
 * @brief LPTMR_PSR - Low Power Timer Prescale Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_PSR register
 */
/*@{*/
#define LPTMR_RD_PSR(base)       (LPTMR_PSR_REG(base))
#define LPTMR_WR_PSR(base, value) (LPTMR_PSR_REG(base) = (value))
#define LPTMR_RMW_PSR(base, mask, value) (LPTMR_WR_PSR(base, (LPTMR_RD_PSR(base) & ~(mask)) | (value)))
#define LPTMR_SET_PSR(base, value) (BME_OR32(&LPTMR_PSR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_PSR(base, value) (BME_AND32(&LPTMR_PSR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_PSR(base, value) (BME_XOR32(&LPTMR_PSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_PSR bitfields
 */

/*!
 * @name Register LPTMR_PSR, field PCS[1:0] (RW)
 *
 * Selects the clock to be used by the LPTMR prescaler/glitch filter. PCS must
 * be altered only when the LPTMR is disabled. The clock connections vary by
 * device. See the chip configuration details for information on the connections to
 * these inputs.
 *
 * Values:
 * - 0b00 - Prescaler/glitch filter clock 0 selected.
 * - 0b01 - Prescaler/glitch filter clock 1 selected.
 * - 0b10 - Prescaler/glitch filter clock 2 selected.
 * - 0b11 - Prescaler/glitch filter clock 3 selected.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PCS field. */
#define LPTMR_RD_PSR_PCS(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PCS_MASK) >> LPTMR_PSR_PCS_SHIFT)
#define LPTMR_BRD_PSR_PCS(base) (BME_UBFX32(&LPTMR_PSR_REG(base), LPTMR_PSR_PCS_SHIFT, LPTMR_PSR_PCS_WIDTH))

/*! @brief Set the PCS field to a new value. */
#define LPTMR_WR_PSR_PCS(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PCS_MASK, LPTMR_PSR_PCS(value)))
#define LPTMR_BWR_PSR_PCS(base, value) (BME_BFI32(&LPTMR_PSR_REG(base), ((uint32_t)(value) << LPTMR_PSR_PCS_SHIFT), LPTMR_PSR_PCS_SHIFT, LPTMR_PSR_PCS_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PBYP[2] (RW)
 *
 * When PBYP is set, the selected prescaler clock in Time Counter mode or
 * selected input source in Pulse Counter mode directly clocks the CNR. When PBYP is
 * clear, the CNR is clocked by the output of the prescaler/glitch filter. PBYP
 * must be altered only when the LPTMR is disabled.
 *
 * Values:
 * - 0b0 - Prescaler/glitch filter is enabled.
 * - 0b1 - Prescaler/glitch filter is bypassed.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PBYP field. */
#define LPTMR_RD_PSR_PBYP(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PBYP_MASK) >> LPTMR_PSR_PBYP_SHIFT)
#define LPTMR_BRD_PSR_PBYP(base) (BME_UBFX32(&LPTMR_PSR_REG(base), LPTMR_PSR_PBYP_SHIFT, LPTMR_PSR_PBYP_WIDTH))

/*! @brief Set the PBYP field to a new value. */
#define LPTMR_WR_PSR_PBYP(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PBYP_MASK, LPTMR_PSR_PBYP(value)))
#define LPTMR_BWR_PSR_PBYP(base, value) (BME_BFI32(&LPTMR_PSR_REG(base), ((uint32_t)(value) << LPTMR_PSR_PBYP_SHIFT), LPTMR_PSR_PBYP_SHIFT, LPTMR_PSR_PBYP_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PRESCALE[6:3] (RW)
 *
 * Configures the size of the Prescaler in Time Counter mode or width of the
 * glitch filter in Pulse Counter mode. PRESCALE must be altered only when the LPTMR
 * is disabled.
 *
 * Values:
 * - 0b0000 - Prescaler divides the prescaler clock by 2; glitch filter does not
 *     support this configuration.
 * - 0b0001 - Prescaler divides the prescaler clock by 4; glitch filter
 *     recognizes change on input pin after 2 rising clock edges.
 * - 0b0010 - Prescaler divides the prescaler clock by 8; glitch filter
 *     recognizes change on input pin after 4 rising clock edges.
 * - 0b0011 - Prescaler divides the prescaler clock by 16; glitch filter
 *     recognizes change on input pin after 8 rising clock edges.
 * - 0b0100 - Prescaler divides the prescaler clock by 32; glitch filter
 *     recognizes change on input pin after 16 rising clock edges.
 * - 0b0101 - Prescaler divides the prescaler clock by 64; glitch filter
 *     recognizes change on input pin after 32 rising clock edges.
 * - 0b0110 - Prescaler divides the prescaler clock by 128; glitch filter
 *     recognizes change on input pin after 64 rising clock edges.
 * - 0b0111 - Prescaler divides the prescaler clock by 256; glitch filter
 *     recognizes change on input pin after 128 rising clock edges.
 * - 0b1000 - Prescaler divides the prescaler clock by 512; glitch filter
 *     recognizes change on input pin after 256 rising clock edges.
 * - 0b1001 - Prescaler divides the prescaler clock by 1024; glitch filter
 *     recognizes change on input pin after 512 rising clock edges.
 * - 0b1010 - Prescaler divides the prescaler clock by 2048; glitch filter
 *     recognizes change on input pin after 1024 rising clock edges.
 * - 0b1011 - Prescaler divides the prescaler clock by 4096; glitch filter
 *     recognizes change on input pin after 2048 rising clock edges.
 * - 0b1100 - Prescaler divides the prescaler clock by 8192; glitch filter
 *     recognizes change on input pin after 4096 rising clock edges.
 * - 0b1101 - Prescaler divides the prescaler clock by 16,384; glitch filter
 *     recognizes change on input pin after 8192 rising clock edges.
 * - 0b1110 - Prescaler divides the prescaler clock by 32,768; glitch filter
 *     recognizes change on input pin after 16,384 rising clock edges.
 * - 0b1111 - Prescaler divides the prescaler clock by 65,536; glitch filter
 *     recognizes change on input pin after 32,768 rising clock edges.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PRESCALE field. */
#define LPTMR_RD_PSR_PRESCALE(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PRESCALE_MASK) >> LPTMR_PSR_PRESCALE_SHIFT)
#define LPTMR_BRD_PSR_PRESCALE(base) (BME_UBFX32(&LPTMR_PSR_REG(base), LPTMR_PSR_PRESCALE_SHIFT, LPTMR_PSR_PRESCALE_WIDTH))

/*! @brief Set the PRESCALE field to a new value. */
#define LPTMR_WR_PSR_PRESCALE(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PRESCALE_MASK, LPTMR_PSR_PRESCALE(value)))
#define LPTMR_BWR_PSR_PRESCALE(base, value) (BME_BFI32(&LPTMR_PSR_REG(base), ((uint32_t)(value) << LPTMR_PSR_PRESCALE_SHIFT), LPTMR_PSR_PRESCALE_SHIFT, LPTMR_PSR_PRESCALE_WIDTH))
/*@}*/

/*******************************************************************************
 * LPTMR_CMR - Low Power Timer Compare Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CMR - Low Power Timer Compare Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CMR register
 */
/*@{*/
#define LPTMR_RD_CMR(base)       (LPTMR_CMR_REG(base))
#define LPTMR_WR_CMR(base, value) (LPTMR_CMR_REG(base) = (value))
#define LPTMR_RMW_CMR(base, mask, value) (LPTMR_WR_CMR(base, (LPTMR_RD_CMR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CMR(base, value) (BME_OR32(&LPTMR_CMR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_CMR(base, value) (BME_AND32(&LPTMR_CMR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_CMR(base, value) (BME_XOR32(&LPTMR_CMR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CMR bitfields
 */

/*!
 * @name Register LPTMR_CMR, field COMPARE[15:0] (RW)
 *
 * When the LPTMR is enabled and the CNR equals the value in the CMR and
 * increments, TCF is set and the hardware trigger asserts until the next time the CNR
 * increments. If the CMR is 0, the hardware trigger will remain asserted until
 * the LPTMR is disabled. If the LPTMR is enabled, the CMR must be altered only
 * when TCF is set.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CMR_COMPARE field. */
#define LPTMR_RD_CMR_COMPARE(base) ((LPTMR_CMR_REG(base) & LPTMR_CMR_COMPARE_MASK) >> LPTMR_CMR_COMPARE_SHIFT)
#define LPTMR_BRD_CMR_COMPARE(base) (BME_UBFX32(&LPTMR_CMR_REG(base), LPTMR_CMR_COMPARE_SHIFT, LPTMR_CMR_COMPARE_WIDTH))

/*! @brief Set the COMPARE field to a new value. */
#define LPTMR_WR_CMR_COMPARE(base, value) (LPTMR_RMW_CMR(base, LPTMR_CMR_COMPARE_MASK, LPTMR_CMR_COMPARE(value)))
#define LPTMR_BWR_CMR_COMPARE(base, value) (BME_BFI32(&LPTMR_CMR_REG(base), ((uint32_t)(value) << LPTMR_CMR_COMPARE_SHIFT), LPTMR_CMR_COMPARE_SHIFT, LPTMR_CMR_COMPARE_WIDTH))
/*@}*/

/*******************************************************************************
 * LPTMR_CNR - Low Power Timer Counter Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CNR - Low Power Timer Counter Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CNR register
 */
/*@{*/
#define LPTMR_RD_CNR(base)       (LPTMR_CNR_REG(base))
#define LPTMR_WR_CNR(base, value) (LPTMR_CNR_REG(base) = (value))
#define LPTMR_RMW_CNR(base, mask, value) (LPTMR_WR_CNR(base, (LPTMR_RD_CNR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CNR(base, value) (BME_OR32(&LPTMR_CNR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_CNR(base, value) (BME_AND32(&LPTMR_CNR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_CNR(base, value) (BME_XOR32(&LPTMR_CNR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CNR bitfields
 */

/*!
 * @name Register LPTMR_CNR, field COUNTER[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CNR_COUNTER field. */
#define LPTMR_RD_CNR_COUNTER(base) ((LPTMR_CNR_REG(base) & LPTMR_CNR_COUNTER_MASK) >> LPTMR_CNR_COUNTER_SHIFT)
#define LPTMR_BRD_CNR_COUNTER(base) (BME_UBFX32(&LPTMR_CNR_REG(base), LPTMR_CNR_COUNTER_SHIFT, LPTMR_CNR_COUNTER_WIDTH))

/*! @brief Set the COUNTER field to a new value. */
#define LPTMR_WR_CNR_COUNTER(base, value) (LPTMR_RMW_CNR(base, LPTMR_CNR_COUNTER_MASK, LPTMR_CNR_COUNTER(value)))
#define LPTMR_BWR_CNR_COUNTER(base, value) (BME_BFI32(&LPTMR_CNR_REG(base), ((uint32_t)(value) << LPTMR_CNR_COUNTER_SHIFT), LPTMR_CNR_COUNTER_SHIFT, LPTMR_CNR_COUNTER_WIDTH))
/*@}*/

/*
 * MKW40Z4 LPUART
 *
 * Universal Asynchronous Receiver/Transmitter
 *
 * Registers defined in this header file:
 * - LPUART_BAUD - LPUART Baud Rate Register
 * - LPUART_STAT - LPUART Status Register
 * - LPUART_CTRL - LPUART Control Register
 * - LPUART_DATA - LPUART Data Register
 * - LPUART_MATCH - LPUART Match Address Register
 * - LPUART_MODIR - LPUART Modem IrDA Register
 */

#define LPUART_INSTANCE_COUNT (1U) /*!< Number of instances of the LPUART module. */
#define LPUART0_IDX (0U) /*!< Instance number for LPUART0. */

/*******************************************************************************
 * LPUART_BAUD - LPUART Baud Rate Register
 ******************************************************************************/

/*!
 * @brief LPUART_BAUD - LPUART Baud Rate Register (RW)
 *
 * Reset value: 0x0F000004U
 */
/*!
 * @name Constants and macros for entire LPUART_BAUD register
 */
/*@{*/
#define LPUART_RD_BAUD(base)     (LPUART_BAUD_REG(base))
#define LPUART_WR_BAUD(base, value) (LPUART_BAUD_REG(base) = (value))
#define LPUART_RMW_BAUD(base, mask, value) (LPUART_WR_BAUD(base, (LPUART_RD_BAUD(base) & ~(mask)) | (value)))
#define LPUART_SET_BAUD(base, value) (BME_OR32(&LPUART_BAUD_REG(base), (uint32_t)(value)))
#define LPUART_CLR_BAUD(base, value) (BME_AND32(&LPUART_BAUD_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_BAUD(base, value) (BME_XOR32(&LPUART_BAUD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_BAUD bitfields
 */

/*!
 * @name Register LPUART_BAUD, field SBR[12:0] (RW)
 *
 * The 13 bits in SBR[12:0] set the modulo divide rate for the baud rate
 * generator. When SBR is 1 - 8191, the baud rate equals "baud clock / ((OSR+1) * SBR)".
 * The 13-bit baud rate setting [SBR12:SBR0] must only be updated when the
 * transmitter and receiver are both disabled (LPUART_CTRL[RE] and LPUART_CTRL[TE] are
 * both 0).
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_SBR field. */
#define LPUART_RD_BAUD_SBR(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_SBR_MASK) >> LPUART_BAUD_SBR_SHIFT)
#define LPUART_BRD_BAUD_SBR(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_SBR_SHIFT, LPUART_BAUD_SBR_WIDTH))

/*! @brief Set the SBR field to a new value. */
#define LPUART_WR_BAUD_SBR(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_SBR_MASK, LPUART_BAUD_SBR(value)))
#define LPUART_BWR_BAUD_SBR(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_SBR_SHIFT), LPUART_BAUD_SBR_SHIFT, LPUART_BAUD_SBR_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field SBNS[13] (RW)
 *
 * SBNS determines whether data characters are one or two stop bits. This bit
 * should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0b0 - One stop bit.
 * - 0b1 - Two stop bits.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_SBNS field. */
#define LPUART_RD_BAUD_SBNS(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_SBNS_MASK) >> LPUART_BAUD_SBNS_SHIFT)
#define LPUART_BRD_BAUD_SBNS(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_SBNS_SHIFT, LPUART_BAUD_SBNS_WIDTH))

/*! @brief Set the SBNS field to a new value. */
#define LPUART_WR_BAUD_SBNS(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_SBNS_MASK, LPUART_BAUD_SBNS(value)))
#define LPUART_BWR_BAUD_SBNS(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_SBNS_SHIFT), LPUART_BAUD_SBNS_SHIFT, LPUART_BAUD_SBNS_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field RXEDGIE[14] (RW)
 *
 * Enables the receive input active edge, RXEDGIF, to generate interrupt
 * requests. Changing CTRL[LOOP] or CTRL[RSRC] when RXEDGIE is set can cause the RXEDGIF
 * to set.
 *
 * Values:
 * - 0b0 - Hardware interrupts from LPUART_STAT[RXEDGIF] disabled (use polling).
 * - 0b1 - Hardware interrupt requested when LPUART_STAT[RXEDGIF] flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_RXEDGIE field. */
#define LPUART_RD_BAUD_RXEDGIE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_RXEDGIE_MASK) >> LPUART_BAUD_RXEDGIE_SHIFT)
#define LPUART_BRD_BAUD_RXEDGIE(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_RXEDGIE_SHIFT, LPUART_BAUD_RXEDGIE_WIDTH))

/*! @brief Set the RXEDGIE field to a new value. */
#define LPUART_WR_BAUD_RXEDGIE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_RXEDGIE_MASK, LPUART_BAUD_RXEDGIE(value)))
#define LPUART_BWR_BAUD_RXEDGIE(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_RXEDGIE_SHIFT), LPUART_BAUD_RXEDGIE_SHIFT, LPUART_BAUD_RXEDGIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field LBKDIE[15] (RW)
 *
 * LBKDIE enables the LIN break detect flag, LBKDIF, to generate interrupt
 * requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from LPUART_STAT[LBKDIF] disabled (use polling).
 * - 0b1 - Hardware interrupt requested when LPUART_STAT[LBKDIF] flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_LBKDIE field. */
#define LPUART_RD_BAUD_LBKDIE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_LBKDIE_MASK) >> LPUART_BAUD_LBKDIE_SHIFT)
#define LPUART_BRD_BAUD_LBKDIE(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_LBKDIE_SHIFT, LPUART_BAUD_LBKDIE_WIDTH))

/*! @brief Set the LBKDIE field to a new value. */
#define LPUART_WR_BAUD_LBKDIE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_LBKDIE_MASK, LPUART_BAUD_LBKDIE(value)))
#define LPUART_BWR_BAUD_LBKDIE(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_LBKDIE_SHIFT), LPUART_BAUD_LBKDIE_SHIFT, LPUART_BAUD_LBKDIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field RESYNCDIS[16] (RW)
 *
 * When set, disables the resynchronization of the received data word when a
 * data one followed by data zero transition is detected. This bit should only be
 * changed when the receiver is disabled.
 *
 * Values:
 * - 0b0 - Resynchronization during received data word is supported
 * - 0b1 - Resynchronization during received data word is disabled
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_RESYNCDIS field. */
#define LPUART_RD_BAUD_RESYNCDIS(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_RESYNCDIS_MASK) >> LPUART_BAUD_RESYNCDIS_SHIFT)
#define LPUART_BRD_BAUD_RESYNCDIS(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_RESYNCDIS_SHIFT, LPUART_BAUD_RESYNCDIS_WIDTH))

/*! @brief Set the RESYNCDIS field to a new value. */
#define LPUART_WR_BAUD_RESYNCDIS(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_RESYNCDIS_MASK, LPUART_BAUD_RESYNCDIS(value)))
#define LPUART_BWR_BAUD_RESYNCDIS(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_RESYNCDIS_SHIFT), LPUART_BAUD_RESYNCDIS_SHIFT, LPUART_BAUD_RESYNCDIS_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field BOTHEDGE[17] (RW)
 *
 * Enables sampling of the received data on both edges of the baud rate clock,
 * effectively doubling the number of times the receiver samples the input data
 * for a given oversampling ratio. This bit must be set for oversampling ratios
 * between x4 and x7 and is optional for higher oversampling ratios. This bit should
 * only be changed when the receiver is disabled.
 *
 * Values:
 * - 0b0 - Receiver samples input data using the rising edge of the baud rate
 *     clock.
 * - 0b1 - Receiver samples input data using the rising and falling edge of the
 *     baud rate clock.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_BOTHEDGE field. */
#define LPUART_RD_BAUD_BOTHEDGE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_BOTHEDGE_MASK) >> LPUART_BAUD_BOTHEDGE_SHIFT)
#define LPUART_BRD_BAUD_BOTHEDGE(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_BOTHEDGE_SHIFT, LPUART_BAUD_BOTHEDGE_WIDTH))

/*! @brief Set the BOTHEDGE field to a new value. */
#define LPUART_WR_BAUD_BOTHEDGE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_BOTHEDGE_MASK, LPUART_BAUD_BOTHEDGE(value)))
#define LPUART_BWR_BAUD_BOTHEDGE(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_BOTHEDGE_SHIFT), LPUART_BAUD_BOTHEDGE_SHIFT, LPUART_BAUD_BOTHEDGE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field MATCFG[19:18] (RW)
 *
 * Configures the match addressing mode used.
 *
 * Values:
 * - 0b00 - Address Match Wakeup
 * - 0b01 - Idle Match Wakeup
 * - 0b10 - Match On and Match Off
 * - 0b11 - Enables RWU on Data Match and Match On/Off for transmitter CTS input
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_MATCFG field. */
#define LPUART_RD_BAUD_MATCFG(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_MATCFG_MASK) >> LPUART_BAUD_MATCFG_SHIFT)
#define LPUART_BRD_BAUD_MATCFG(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_MATCFG_SHIFT, LPUART_BAUD_MATCFG_WIDTH))

/*! @brief Set the MATCFG field to a new value. */
#define LPUART_WR_BAUD_MATCFG(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_MATCFG_MASK, LPUART_BAUD_MATCFG(value)))
#define LPUART_BWR_BAUD_MATCFG(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_MATCFG_SHIFT), LPUART_BAUD_MATCFG_SHIFT, LPUART_BAUD_MATCFG_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field RDMAE[21] (RW)
 *
 * RDMAE configures the receiver data register full flag, LPUART_STAT[RDRF], to
 * generate a DMA request.
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_RDMAE field. */
#define LPUART_RD_BAUD_RDMAE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_RDMAE_MASK) >> LPUART_BAUD_RDMAE_SHIFT)
#define LPUART_BRD_BAUD_RDMAE(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_RDMAE_SHIFT, LPUART_BAUD_RDMAE_WIDTH))

/*! @brief Set the RDMAE field to a new value. */
#define LPUART_WR_BAUD_RDMAE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_RDMAE_MASK, LPUART_BAUD_RDMAE(value)))
#define LPUART_BWR_BAUD_RDMAE(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_RDMAE_SHIFT), LPUART_BAUD_RDMAE_SHIFT, LPUART_BAUD_RDMAE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field TDMAE[23] (RW)
 *
 * TDMAE configures the transmit data register empty flag, LPUART_STAT[TDRE], to
 * generate a DMA request.
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_TDMAE field. */
#define LPUART_RD_BAUD_TDMAE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_TDMAE_MASK) >> LPUART_BAUD_TDMAE_SHIFT)
#define LPUART_BRD_BAUD_TDMAE(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_TDMAE_SHIFT, LPUART_BAUD_TDMAE_WIDTH))

/*! @brief Set the TDMAE field to a new value. */
#define LPUART_WR_BAUD_TDMAE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_TDMAE_MASK, LPUART_BAUD_TDMAE(value)))
#define LPUART_BWR_BAUD_TDMAE(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_TDMAE_SHIFT), LPUART_BAUD_TDMAE_SHIFT, LPUART_BAUD_TDMAE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field OSR[28:24] (RW)
 *
 * This field configures the oversampling ratio for the receiver between 4x
 * (00011) and 32x (11111). Writing an invalid oversampling ratio will default to an
 * oversampling ratio of 16 (01111). This field should only be changed when the
 * transmitter and receiver are both disabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_OSR field. */
#define LPUART_RD_BAUD_OSR(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_OSR_MASK) >> LPUART_BAUD_OSR_SHIFT)
#define LPUART_BRD_BAUD_OSR(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_OSR_SHIFT, LPUART_BAUD_OSR_WIDTH))

/*! @brief Set the OSR field to a new value. */
#define LPUART_WR_BAUD_OSR(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_OSR_MASK, LPUART_BAUD_OSR(value)))
#define LPUART_BWR_BAUD_OSR(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_OSR_SHIFT), LPUART_BAUD_OSR_SHIFT, LPUART_BAUD_OSR_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field M10[29] (RW)
 *
 * The M10 bit causes a tenth bit to be part of the serial transmission. This
 * bit should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0b0 - Receiver and transmitter use 8-bit or 9-bit data characters.
 * - 0b1 - Receiver and transmitter use 10-bit data characters.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_M10 field. */
#define LPUART_RD_BAUD_M10(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_M10_MASK) >> LPUART_BAUD_M10_SHIFT)
#define LPUART_BRD_BAUD_M10(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_M10_SHIFT, LPUART_BAUD_M10_WIDTH))

/*! @brief Set the M10 field to a new value. */
#define LPUART_WR_BAUD_M10(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_M10_MASK, LPUART_BAUD_M10(value)))
#define LPUART_BWR_BAUD_M10(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_M10_SHIFT), LPUART_BAUD_M10_SHIFT, LPUART_BAUD_M10_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field MAEN2[30] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Enables automatic address matching or data matching mode for
 *     MATCH[MA2].
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_MAEN2 field. */
#define LPUART_RD_BAUD_MAEN2(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_MAEN2_MASK) >> LPUART_BAUD_MAEN2_SHIFT)
#define LPUART_BRD_BAUD_MAEN2(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_MAEN2_SHIFT, LPUART_BAUD_MAEN2_WIDTH))

/*! @brief Set the MAEN2 field to a new value. */
#define LPUART_WR_BAUD_MAEN2(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_MAEN2_MASK, LPUART_BAUD_MAEN2(value)))
#define LPUART_BWR_BAUD_MAEN2(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_MAEN2_SHIFT), LPUART_BAUD_MAEN2_SHIFT, LPUART_BAUD_MAEN2_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field MAEN1[31] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Enables automatic address matching or data matching mode for
 *     MATCH[MA1].
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_MAEN1 field. */
#define LPUART_RD_BAUD_MAEN1(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_MAEN1_MASK) >> LPUART_BAUD_MAEN1_SHIFT)
#define LPUART_BRD_BAUD_MAEN1(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_MAEN1_SHIFT, LPUART_BAUD_MAEN1_WIDTH))

/*! @brief Set the MAEN1 field to a new value. */
#define LPUART_WR_BAUD_MAEN1(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_MAEN1_MASK, LPUART_BAUD_MAEN1(value)))
#define LPUART_BWR_BAUD_MAEN1(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_MAEN1_SHIFT), LPUART_BAUD_MAEN1_SHIFT, LPUART_BAUD_MAEN1_WIDTH))
/*@}*/

/*******************************************************************************
 * LPUART_STAT - LPUART Status Register
 ******************************************************************************/

/*!
 * @brief LPUART_STAT - LPUART Status Register (RW)
 *
 * Reset value: 0x00C00000U
 */
/*!
 * @name Constants and macros for entire LPUART_STAT register
 */
/*@{*/
#define LPUART_RD_STAT(base)     (LPUART_STAT_REG(base))
#define LPUART_WR_STAT(base, value) (LPUART_STAT_REG(base) = (value))
#define LPUART_RMW_STAT(base, mask, value) (LPUART_WR_STAT(base, (LPUART_RD_STAT(base) & ~(mask)) | (value)))
#define LPUART_SET_STAT(base, value) (BME_OR32(&LPUART_STAT_REG(base), (uint32_t)(value)))
#define LPUART_CLR_STAT(base, value) (BME_AND32(&LPUART_STAT_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_STAT(base, value) (BME_XOR32(&LPUART_STAT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_STAT bitfields
 */

/*!
 * @name Register LPUART_STAT, field MA2F[14] (W1C)
 *
 * MA2F is set whenever the next character to be read from LPUART_DATA matches
 * MA2. To clear MA2F, write a logic one to the MA2F.
 *
 * Values:
 * - 0b0 - Received data is not equal to MA2
 * - 0b1 - Received data is equal to MA2
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_MA2F field. */
#define LPUART_RD_STAT_MA2F(base) ((LPUART_STAT_REG(base) & LPUART_STAT_MA2F_MASK) >> LPUART_STAT_MA2F_SHIFT)
#define LPUART_BRD_STAT_MA2F(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_MA2F_SHIFT, LPUART_STAT_MA2F_WIDTH))

/*! @brief Set the MA2F field to a new value. */
#define LPUART_WR_STAT_MA2F(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_MA2F(value)))
#define LPUART_BWR_STAT_MA2F(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_MA2F_SHIFT), LPUART_STAT_MA2F_SHIFT, LPUART_STAT_MA2F_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field MA1F[15] (W1C)
 *
 * MA1F is set whenever the next character to be read from LPUART_DATA matches
 * MA1. To clear MA1F, write a logic one to the MA1F.
 *
 * Values:
 * - 0b0 - Received data is not equal to MA1
 * - 0b1 - Received data is equal to MA1
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_MA1F field. */
#define LPUART_RD_STAT_MA1F(base) ((LPUART_STAT_REG(base) & LPUART_STAT_MA1F_MASK) >> LPUART_STAT_MA1F_SHIFT)
#define LPUART_BRD_STAT_MA1F(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_MA1F_SHIFT, LPUART_STAT_MA1F_WIDTH))

/*! @brief Set the MA1F field to a new value. */
#define LPUART_WR_STAT_MA1F(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_MA1F_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_MA1F(value)))
#define LPUART_BWR_STAT_MA1F(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_MA1F_SHIFT), LPUART_STAT_MA1F_SHIFT, LPUART_STAT_MA1F_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field PF[16] (W1C)
 *
 * PF is set whenever the next character to be read from LPUART_DATA was
 * received when parity is enabled (PE = 1) and the parity bit in the received character
 * does not agree with the expected parity value. To clear PF, write a logic one
 * to the PF.
 *
 * Values:
 * - 0b0 - No parity error.
 * - 0b1 - Parity error.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_PF field. */
#define LPUART_RD_STAT_PF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_PF_MASK) >> LPUART_STAT_PF_SHIFT)
#define LPUART_BRD_STAT_PF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_PF_SHIFT, LPUART_STAT_PF_WIDTH))

/*! @brief Set the PF field to a new value. */
#define LPUART_WR_STAT_PF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_PF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_PF(value)))
#define LPUART_BWR_STAT_PF(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_PF_SHIFT), LPUART_STAT_PF_SHIFT, LPUART_STAT_PF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field FE[17] (W1C)
 *
 * FE is set whenever the next character to be read from LPUART_DATA was
 * received with logic 0 detected where a stop bit was expected. To clear NF, write
 * logic one to the NF.
 *
 * Values:
 * - 0b0 - No framing error detected. This does not guarantee the framing is
 *     correct.
 * - 0b1 - Framing error.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_FE field. */
#define LPUART_RD_STAT_FE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_FE_MASK) >> LPUART_STAT_FE_SHIFT)
#define LPUART_BRD_STAT_FE(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_FE_SHIFT, LPUART_STAT_FE_WIDTH))

/*! @brief Set the FE field to a new value. */
#define LPUART_WR_STAT_FE(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_FE_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_FE(value)))
#define LPUART_BWR_STAT_FE(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_FE_SHIFT), LPUART_STAT_FE_SHIFT, LPUART_STAT_FE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field NF[18] (W1C)
 *
 * The advanced sampling technique used in the receiver takes three samples in
 * each of the received bits. If any of these samples disagrees with the rest of
 * the samples within any bit time in the frame then noise is detected for that
 * character. NF is set whenever the next character to be read from LPUART_DATA was
 * received with noise detected within the character. To clear NF, write logic
 * one to the NF.
 *
 * Values:
 * - 0b0 - No noise detected.
 * - 0b1 - Noise detected in the received character in LPUART_DATA.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_NF field. */
#define LPUART_RD_STAT_NF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_NF_MASK) >> LPUART_STAT_NF_SHIFT)
#define LPUART_BRD_STAT_NF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_NF_SHIFT, LPUART_STAT_NF_WIDTH))

/*! @brief Set the NF field to a new value. */
#define LPUART_WR_STAT_NF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_NF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_NF(value)))
#define LPUART_BWR_STAT_NF(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_NF_SHIFT), LPUART_STAT_NF_SHIFT, LPUART_STAT_NF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field OR[19] (W1C)
 *
 * OR is set when software fails to prevent the receive data register from
 * overflowing with data. The OR bit is set immediately after the stop bit has been
 * completely received for the dataword that overflows the buffer and all the other
 * error flags (FE, NF, and PF) are prevented from setting. The data in the
 * shift register is lost, but the data already in the LPUART data registers is not
 * affected. If LBKDE is enabled and a LIN Break is detected, the OR field asserts
 * if LBKDIF is not cleared before the next data character is received. While
 * the OR flag is set, no additional data is stored in the data buffer even if
 * sufficient room exists. To clear OR, write logic 1 to the OR flag.
 *
 * Values:
 * - 0b0 - No overrun.
 * - 0b1 - Receive overrun (new LPUART data lost).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_OR field. */
#define LPUART_RD_STAT_OR(base) ((LPUART_STAT_REG(base) & LPUART_STAT_OR_MASK) >> LPUART_STAT_OR_SHIFT)
#define LPUART_BRD_STAT_OR(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_OR_SHIFT, LPUART_STAT_OR_WIDTH))

/*! @brief Set the OR field to a new value. */
#define LPUART_WR_STAT_OR(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_OR_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_OR(value)))
#define LPUART_BWR_STAT_OR(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_OR_SHIFT), LPUART_STAT_OR_SHIFT, LPUART_STAT_OR_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field IDLE[20] (W1C)
 *
 * IDLE is set when the LPUART receive line becomes idle for a full character
 * time after a period of activity. When ILT is cleared, the receiver starts
 * counting idle bit times after the start bit. If the receive character is all 1s,
 * these bit times and the stop bits time count toward the full character time of
 * logic high, 10 to 13 bit times, needed for the receiver to detect an idle line.
 * When ILT is set, the receiver doesn't start counting idle bit times until
 * after the stop bits. The stop bits and any logic high bit times at the end of the
 * previous character do not count toward the full character time of logic high
 * needed for the receiver to detect an idle line. To clear IDLE, write logic 1 to
 * the IDLE flag. After IDLE has been cleared, it cannot become set again until
 * after a new character has been stored in the receive buffer or a LIN break
 * character has set the LBKDIF flag . IDLE is set only once even if the receive
 * line remains idle for an extended period.
 *
 * Values:
 * - 0b0 - No idle line detected.
 * - 0b1 - Idle line was detected.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_IDLE field. */
#define LPUART_RD_STAT_IDLE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_IDLE_MASK) >> LPUART_STAT_IDLE_SHIFT)
#define LPUART_BRD_STAT_IDLE(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_IDLE_SHIFT, LPUART_STAT_IDLE_WIDTH))

/*! @brief Set the IDLE field to a new value. */
#define LPUART_WR_STAT_IDLE(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_IDLE_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_IDLE(value)))
#define LPUART_BWR_STAT_IDLE(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_IDLE_SHIFT), LPUART_STAT_IDLE_SHIFT, LPUART_STAT_IDLE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RDRF[21] (RO)
 *
 * When the receive FIFO is enabled, RDRF is set when the number of datawords in
 * the receive buffer is equal to or more than the number indicated by
 * LPUART_WATER[RXWATER]. To clear RDRF, read LPUART_DATA until the number of datawords in
 * the receive data buffer is less than the number indicated by
 * LPUART_WATER[RXWATER]. When the receive FIFO is disabled,RDRF is set when the receive buffer
 * (LPUART_DATA) is full. To clear RDRF, read the LPUART_DATA register. A
 * character that is in the process of being received does not cause a change in RDRF
 * until the entire character is received. Even if RDRF is set, the character will
 * continue to be received until an overrun condition occurs once the entire
 * character is received.
 *
 * Values:
 * - 0b0 - Receive data buffer empty.
 * - 0b1 - Receive data buffer full.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RDRF field. */
#define LPUART_RD_STAT_RDRF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RDRF_MASK) >> LPUART_STAT_RDRF_SHIFT)
#define LPUART_BRD_STAT_RDRF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_RDRF_SHIFT, LPUART_STAT_RDRF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field TC[22] (RO)
 *
 * TC is cleared when there is a transmission in progress or when a preamble or
 * break character is loaded. TC is set when the transmit buffer is empty and no
 * data, preamble, or break character is being transmitted. When TC is set, the
 * transmit data output signal becomes idle (logic 1). TC is cleared by writing to
 * LPUART_DATA to transmit new data, queuing a preamble by clearing and then
 * setting LPUART_CTRL[TE], queuing a break character by writing 1 to
 * LPUART_CTRL[SBK].
 *
 * Values:
 * - 0b0 - Transmitter active (sending data, a preamble, or a break).
 * - 0b1 - Transmitter idle (transmission activity complete).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_TC field. */
#define LPUART_RD_STAT_TC(base) ((LPUART_STAT_REG(base) & LPUART_STAT_TC_MASK) >> LPUART_STAT_TC_SHIFT)
#define LPUART_BRD_STAT_TC(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_TC_SHIFT, LPUART_STAT_TC_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field TDRE[23] (RO)
 *
 * When the transmit FIFO is enabled, TDRE will set when the number of datawords
 * in the transmit FIFO (LPUART_DATA) is equal to or less than the number
 * indicated by LPUART_WATER[TXWATER]). To clear TDRE, write to the LPUART data
 * register (LPUART_DATA) until the number of words in the transmit FIFO is greater than
 * the number indicated by LPUART_WATER[TXWATER]. When the transmit FIFO is
 * disabled,TDRE will set when the transmit data register (LPUART_DATA) is empty. To
 * clear TDRE, write to the LPUART data register (LPUART_DATA). TDRE is not
 * affected by a character that is in the process of being transmitted, it is updated
 * at the start of each transmitted character.
 *
 * Values:
 * - 0b0 - Transmit data buffer full.
 * - 0b1 - Transmit data buffer empty.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_TDRE field. */
#define LPUART_RD_STAT_TDRE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_TDRE_MASK) >> LPUART_STAT_TDRE_SHIFT)
#define LPUART_BRD_STAT_TDRE(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_TDRE_SHIFT, LPUART_STAT_TDRE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RAF[24] (RO)
 *
 * RAF is set when the receiver detects the beginning of a valid start bit, and
 * RAF is cleared automatically when the receiver detects an idle line.
 *
 * Values:
 * - 0b0 - LPUART receiver idle waiting for a start bit.
 * - 0b1 - LPUART receiver active (LPUART_RX input not idle).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RAF field. */
#define LPUART_RD_STAT_RAF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RAF_MASK) >> LPUART_STAT_RAF_SHIFT)
#define LPUART_BRD_STAT_RAF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_RAF_SHIFT, LPUART_STAT_RAF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field LBKDE[25] (RW)
 *
 * LBKDE selects a longer break character detection length. While LBKDE is set,
 * receive data is not stored in the receive data buffer.
 *
 * Values:
 * - 0b0 - Break character is detected at length 10 bit times (if M = 0, SBNS =
 *     0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1, SBNS = 1
 *     or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
 * - 0b1 - Break character is detected at length of 11 bit times (if M = 0, SBNS
 *     = 0) or 12 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 14 (if M = 1, SBNS
 *     = 1 or M10 = 1, SNBS = 0) or 15 (if M10 = 1, SNBS = 1).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_LBKDE field. */
#define LPUART_RD_STAT_LBKDE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_LBKDE_MASK) >> LPUART_STAT_LBKDE_SHIFT)
#define LPUART_BRD_STAT_LBKDE(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_LBKDE_SHIFT, LPUART_STAT_LBKDE_WIDTH))

/*! @brief Set the LBKDE field to a new value. */
#define LPUART_WR_STAT_LBKDE(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_LBKDE_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_LBKDE(value)))
#define LPUART_BWR_STAT_LBKDE(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_LBKDE_SHIFT), LPUART_STAT_LBKDE_SHIFT, LPUART_STAT_LBKDE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field BRK13[26] (RW)
 *
 * BRK13 selects a longer transmitted break character length. Detection of a
 * framing error is not affected by the state of this bit. This bit should only be
 * changed when the transmitter is disabled.
 *
 * Values:
 * - 0b0 - Break character is transmitted with length of 10 bit times (if M = 0,
 *     SBNS = 0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1,
 *     SBNS = 1 or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
 * - 0b1 - Break character is transmitted with length of 13 bit times (if M = 0,
 *     SBNS = 0) or 14 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 15 (if M = 1,
 *     SBNS = 1 or M10 = 1, SNBS = 0) or 16 (if M10 = 1, SNBS = 1).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_BRK13 field. */
#define LPUART_RD_STAT_BRK13(base) ((LPUART_STAT_REG(base) & LPUART_STAT_BRK13_MASK) >> LPUART_STAT_BRK13_SHIFT)
#define LPUART_BRD_STAT_BRK13(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_BRK13_SHIFT, LPUART_STAT_BRK13_WIDTH))

/*! @brief Set the BRK13 field to a new value. */
#define LPUART_WR_STAT_BRK13(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_BRK13_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_BRK13(value)))
#define LPUART_BWR_STAT_BRK13(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_BRK13_SHIFT), LPUART_STAT_BRK13_SHIFT, LPUART_STAT_BRK13_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RWUID[27] (RW)
 *
 * For RWU on idle character, RWUID controls whether the idle character that
 * wakes up the receiver sets the IDLE bit. For address match wakeup, RWUID controls
 * if the IDLE bit is set when the address does not match. This bit should only
 * be changed when the receiver is disabled.
 *
 * Values:
 * - 0b0 - During receive standby state (RWU = 1), the IDLE bit does not get set
 *     upon detection of an idle character. During address match wakeup, the
 *     IDLE bit does not get set when an address does not match.
 * - 0b1 - During receive standby state (RWU = 1), the IDLE bit gets set upon
 *     detection of an idle character. During address match wakeup, the IDLE bit
 *     does get set when an address does not match.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RWUID field. */
#define LPUART_RD_STAT_RWUID(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RWUID_MASK) >> LPUART_STAT_RWUID_SHIFT)
#define LPUART_BRD_STAT_RWUID(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_RWUID_SHIFT, LPUART_STAT_RWUID_WIDTH))

/*! @brief Set the RWUID field to a new value. */
#define LPUART_WR_STAT_RWUID(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_RWUID_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_RWUID(value)))
#define LPUART_BWR_STAT_RWUID(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_RWUID_SHIFT), LPUART_STAT_RWUID_SHIFT, LPUART_STAT_RWUID_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RXINV[28] (RW)
 *
 * Setting this bit reverses the polarity of the received data input. Setting
 * RXINV inverts the LPUART_RX input for all cases: data bits, start and stop bits,
 * break, and idle.
 *
 * Values:
 * - 0b0 - Receive data not inverted.
 * - 0b1 - Receive data inverted.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RXINV field. */
#define LPUART_RD_STAT_RXINV(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RXINV_MASK) >> LPUART_STAT_RXINV_SHIFT)
#define LPUART_BRD_STAT_RXINV(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_RXINV_SHIFT, LPUART_STAT_RXINV_WIDTH))

/*! @brief Set the RXINV field to a new value. */
#define LPUART_WR_STAT_RXINV(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_RXINV_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_RXINV(value)))
#define LPUART_BWR_STAT_RXINV(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_RXINV_SHIFT), LPUART_STAT_RXINV_SHIFT, LPUART_STAT_RXINV_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field MSBF[29] (RW)
 *
 * Setting this bit reverses the order of the bits that are transmitted and
 * received on the wire. This bit does not affect the polarity of the bits, the
 * location of the parity bit or the location of the start or stop bits. This bit
 * should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0b0 - LSB (bit0) is the first bit that is transmitted following the start
 *     bit. Further, the first bit received after the start bit is identified as
 *     bit0.
 * - 0b1 - MSB (bit9, bit8, bit7 or bit6) is the first bit that is transmitted
 *     following the start bit depending on the setting of CTRL[M], CTRL[PE] and
 *     BAUD[M10]. Further, the first bit received after the start bit is
 *     identified as bit9, bit8, bit7 or bit6 depending on the setting of CTRL[M] and
 *     CTRL[PE].
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_MSBF field. */
#define LPUART_RD_STAT_MSBF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_MSBF_MASK) >> LPUART_STAT_MSBF_SHIFT)
#define LPUART_BRD_STAT_MSBF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_MSBF_SHIFT, LPUART_STAT_MSBF_WIDTH))

/*! @brief Set the MSBF field to a new value. */
#define LPUART_WR_STAT_MSBF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_MSBF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_MSBF(value)))
#define LPUART_BWR_STAT_MSBF(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_MSBF_SHIFT), LPUART_STAT_MSBF_SHIFT, LPUART_STAT_MSBF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RXEDGIF[30] (W1C)
 *
 * RXEDGIF is set when an active edge, falling if RXINV = 0, rising if RXINV=1,
 * on the LPUART_RX pin occurs. RXEDGIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0b0 - No active edge on the receive pin has occurred.
 * - 0b1 - An active edge on the receive pin has occurred.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RXEDGIF field. */
#define LPUART_RD_STAT_RXEDGIF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RXEDGIF_MASK) >> LPUART_STAT_RXEDGIF_SHIFT)
#define LPUART_BRD_STAT_RXEDGIF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_RXEDGIF_SHIFT, LPUART_STAT_RXEDGIF_WIDTH))

/*! @brief Set the RXEDGIF field to a new value. */
#define LPUART_WR_STAT_RXEDGIF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_RXEDGIF(value)))
#define LPUART_BWR_STAT_RXEDGIF(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_RXEDGIF_SHIFT), LPUART_STAT_RXEDGIF_SHIFT, LPUART_STAT_RXEDGIF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field LBKDIF[31] (W1C)
 *
 * LBKDIF is set when the LIN break detect circuitry is enabled and a LIN break
 * character is detected. LBKDIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0b0 - No LIN break character has been detected.
 * - 0b1 - LIN break character has been detected.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_LBKDIF field. */
#define LPUART_RD_STAT_LBKDIF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_LBKDIF_MASK) >> LPUART_STAT_LBKDIF_SHIFT)
#define LPUART_BRD_STAT_LBKDIF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_LBKDIF_SHIFT, LPUART_STAT_LBKDIF_WIDTH))

/*! @brief Set the LBKDIF field to a new value. */
#define LPUART_WR_STAT_LBKDIF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_LBKDIF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK), LPUART_STAT_LBKDIF(value)))
#define LPUART_BWR_STAT_LBKDIF(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_LBKDIF_SHIFT), LPUART_STAT_LBKDIF_SHIFT, LPUART_STAT_LBKDIF_WIDTH))
/*@}*/

/*******************************************************************************
 * LPUART_CTRL - LPUART Control Register
 ******************************************************************************/

/*!
 * @brief LPUART_CTRL - LPUART Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This read/write register controls various optional features of the LPUART
 * system. This register should only be altered when the transmitter and receiver
 * are both disabled.
 */
/*!
 * @name Constants and macros for entire LPUART_CTRL register
 */
/*@{*/
#define LPUART_RD_CTRL(base)     (LPUART_CTRL_REG(base))
#define LPUART_WR_CTRL(base, value) (LPUART_CTRL_REG(base) = (value))
#define LPUART_RMW_CTRL(base, mask, value) (LPUART_WR_CTRL(base, (LPUART_RD_CTRL(base) & ~(mask)) | (value)))
#define LPUART_SET_CTRL(base, value) (BME_OR32(&LPUART_CTRL_REG(base), (uint32_t)(value)))
#define LPUART_CLR_CTRL(base, value) (BME_AND32(&LPUART_CTRL_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_CTRL(base, value) (BME_XOR32(&LPUART_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_CTRL bitfields
 */

/*!
 * @name Register LPUART_CTRL, field PT[0] (RW)
 *
 * Provided parity is enabled (PE = 1), this bit selects even or odd parity. Odd
 * parity means the total number of 1s in the data character, including the
 * parity bit, is odd. Even parity means the total number of 1s in the data
 * character, including the parity bit, is even.
 *
 * Values:
 * - 0b0 - Even parity.
 * - 0b1 - Odd parity.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_PT field. */
#define LPUART_RD_CTRL_PT(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_PT_MASK) >> LPUART_CTRL_PT_SHIFT)
#define LPUART_BRD_CTRL_PT(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_PT_SHIFT, LPUART_CTRL_PT_WIDTH))

/*! @brief Set the PT field to a new value. */
#define LPUART_WR_CTRL_PT(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_PT_MASK, LPUART_CTRL_PT(value)))
#define LPUART_BWR_CTRL_PT(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_PT_SHIFT), LPUART_CTRL_PT_SHIFT, LPUART_CTRL_PT_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field PE[1] (RW)
 *
 * Enables hardware parity generation and checking. When parity is enabled, the
 * bit immediately before the stop bit is treated as the parity bit.
 *
 * Values:
 * - 0b0 - No hardware parity generation or checking.
 * - 0b1 - Parity enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_PE field. */
#define LPUART_RD_CTRL_PE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_PE_MASK) >> LPUART_CTRL_PE_SHIFT)
#define LPUART_BRD_CTRL_PE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_PE_SHIFT, LPUART_CTRL_PE_WIDTH))

/*! @brief Set the PE field to a new value. */
#define LPUART_WR_CTRL_PE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_PE_MASK, LPUART_CTRL_PE(value)))
#define LPUART_BWR_CTRL_PE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_PE_SHIFT), LPUART_CTRL_PE_SHIFT, LPUART_CTRL_PE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field ILT[2] (RW)
 *
 * Determines when the receiver starts counting logic 1s as idle character bits.
 * The count begins either after a valid start bit or after the stop bit. If the
 * count begins after the start bit, then a string of logic 1s preceding the
 * stop bit can cause false recognition of an idle character. Beginning the count
 * after the stop bit avoids false idle character recognition, but requires
 * properly synchronized transmissions. In case the LPUART is programmed with ILT = 1, a
 * logic 0 is automatically shifted after a received stop bit, therefore
 * resetting the idle count.
 *
 * Values:
 * - 0b0 - Idle character bit count starts after start bit.
 * - 0b1 - Idle character bit count starts after stop bit.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_ILT field. */
#define LPUART_RD_CTRL_ILT(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_ILT_MASK) >> LPUART_CTRL_ILT_SHIFT)
#define LPUART_BRD_CTRL_ILT(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_ILT_SHIFT, LPUART_CTRL_ILT_WIDTH))

/*! @brief Set the ILT field to a new value. */
#define LPUART_WR_CTRL_ILT(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_ILT_MASK, LPUART_CTRL_ILT(value)))
#define LPUART_BWR_CTRL_ILT(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_ILT_SHIFT), LPUART_CTRL_ILT_SHIFT, LPUART_CTRL_ILT_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field WAKE[3] (RW)
 *
 * Determines which condition wakes the LPUART when RWU=1: Address mark in the
 * most significant bit position of a received data character, or An idle
 * condition on the receive pin input signal.
 *
 * Values:
 * - 0b0 - Configures RWU for idle-line wakeup.
 * - 0b1 - Configures RWU with address-mark wakeup.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_WAKE field. */
#define LPUART_RD_CTRL_WAKE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_WAKE_MASK) >> LPUART_CTRL_WAKE_SHIFT)
#define LPUART_BRD_CTRL_WAKE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_WAKE_SHIFT, LPUART_CTRL_WAKE_WIDTH))

/*! @brief Set the WAKE field to a new value. */
#define LPUART_WR_CTRL_WAKE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_WAKE_MASK, LPUART_CTRL_WAKE(value)))
#define LPUART_BWR_CTRL_WAKE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_WAKE_SHIFT), LPUART_CTRL_WAKE_SHIFT, LPUART_CTRL_WAKE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field M[4] (RW)
 *
 * Values:
 * - 0b0 - Receiver and transmitter use 8-bit data characters.
 * - 0b1 - Receiver and transmitter use 9-bit data characters.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_M field. */
#define LPUART_RD_CTRL_M(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_M_MASK) >> LPUART_CTRL_M_SHIFT)
#define LPUART_BRD_CTRL_M(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_M_SHIFT, LPUART_CTRL_M_WIDTH))

/*! @brief Set the M field to a new value. */
#define LPUART_WR_CTRL_M(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_M_MASK, LPUART_CTRL_M(value)))
#define LPUART_BWR_CTRL_M(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_M_SHIFT), LPUART_CTRL_M_SHIFT, LPUART_CTRL_M_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RSRC[5] (RW)
 *
 * This field has no meaning or effect unless the LOOPS field is set. When LOOPS
 * is set, the RSRC field determines the source for the receiver shift register
 * input.
 *
 * Values:
 * - 0b0 - Provided LOOPS is set, RSRC is cleared, selects internal loop back
 *     mode and the LPUART does not use the LPUART_RX pin.
 * - 0b1 - Single-wire LPUART mode where the LPUART_TX pin is connected to the
 *     transmitter output and receiver input.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RSRC field. */
#define LPUART_RD_CTRL_RSRC(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RSRC_MASK) >> LPUART_CTRL_RSRC_SHIFT)
#define LPUART_BRD_CTRL_RSRC(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_RSRC_SHIFT, LPUART_CTRL_RSRC_WIDTH))

/*! @brief Set the RSRC field to a new value. */
#define LPUART_WR_CTRL_RSRC(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RSRC_MASK, LPUART_CTRL_RSRC(value)))
#define LPUART_BWR_CTRL_RSRC(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_RSRC_SHIFT), LPUART_CTRL_RSRC_SHIFT, LPUART_CTRL_RSRC_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field DOZEEN[6] (RW)
 *
 * Values:
 * - 0b0 - LPUART is enabled in Doze mode.
 * - 0b1 - LPUART is disabled in Doze mode.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_DOZEEN field. */
#define LPUART_RD_CTRL_DOZEEN(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_DOZEEN_MASK) >> LPUART_CTRL_DOZEEN_SHIFT)
#define LPUART_BRD_CTRL_DOZEEN(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_DOZEEN_SHIFT, LPUART_CTRL_DOZEEN_WIDTH))

/*! @brief Set the DOZEEN field to a new value. */
#define LPUART_WR_CTRL_DOZEEN(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_DOZEEN_MASK, LPUART_CTRL_DOZEEN(value)))
#define LPUART_BWR_CTRL_DOZEEN(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_DOZEEN_SHIFT), LPUART_CTRL_DOZEEN_SHIFT, LPUART_CTRL_DOZEEN_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field LOOPS[7] (RW)
 *
 * When LOOPS is set, the LPUART_RX pin is disconnected from the LPUART and the
 * transmitter output is internally connected to the receiver input. The
 * transmitter and the receiver must be enabled to use the loop function.
 *
 * Values:
 * - 0b0 - Normal operation - LPUART_RX and LPUART_TX use separate pins.
 * - 0b1 - Loop mode or single-wire mode where transmitter outputs are
 *     internally connected to receiver input (see RSRC bit).
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_LOOPS field. */
#define LPUART_RD_CTRL_LOOPS(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_LOOPS_MASK) >> LPUART_CTRL_LOOPS_SHIFT)
#define LPUART_BRD_CTRL_LOOPS(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_LOOPS_SHIFT, LPUART_CTRL_LOOPS_WIDTH))

/*! @brief Set the LOOPS field to a new value. */
#define LPUART_WR_CTRL_LOOPS(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_LOOPS_MASK, LPUART_CTRL_LOOPS(value)))
#define LPUART_BWR_CTRL_LOOPS(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_LOOPS_SHIFT), LPUART_CTRL_LOOPS_SHIFT, LPUART_CTRL_LOOPS_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field IDLECFG[10:8] (RW)
 *
 * Configures the number of idle characters that must be received before the
 * IDLE flag is set.
 *
 * Values:
 * - 0b000 - 1 idle character
 * - 0b001 - 2 idle characters
 * - 0b010 - 4 idle characters
 * - 0b011 - 8 idle characters
 * - 0b100 - 16 idle characters
 * - 0b101 - 32 idle characters
 * - 0b110 - 64 idle characters
 * - 0b111 - 128 idle characters
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_IDLECFG field. */
#define LPUART_RD_CTRL_IDLECFG(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_IDLECFG_MASK) >> LPUART_CTRL_IDLECFG_SHIFT)
#define LPUART_BRD_CTRL_IDLECFG(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_IDLECFG_SHIFT, LPUART_CTRL_IDLECFG_WIDTH))

/*! @brief Set the IDLECFG field to a new value. */
#define LPUART_WR_CTRL_IDLECFG(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_IDLECFG_MASK, LPUART_CTRL_IDLECFG(value)))
#define LPUART_BWR_CTRL_IDLECFG(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_IDLECFG_SHIFT), LPUART_CTRL_IDLECFG_SHIFT, LPUART_CTRL_IDLECFG_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field MA2IE[14] (RW)
 *
 * Values:
 * - 0b0 - MA2F interrupt disabled
 * - 0b1 - MA2F interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_MA2IE field. */
#define LPUART_RD_CTRL_MA2IE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_MA2IE_MASK) >> LPUART_CTRL_MA2IE_SHIFT)
#define LPUART_BRD_CTRL_MA2IE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_MA2IE_SHIFT, LPUART_CTRL_MA2IE_WIDTH))

/*! @brief Set the MA2IE field to a new value. */
#define LPUART_WR_CTRL_MA2IE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_MA2IE_MASK, LPUART_CTRL_MA2IE(value)))
#define LPUART_BWR_CTRL_MA2IE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_MA2IE_SHIFT), LPUART_CTRL_MA2IE_SHIFT, LPUART_CTRL_MA2IE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field MA1IE[15] (RW)
 *
 * Values:
 * - 0b0 - MA1F interrupt disabled
 * - 0b1 - MA1F interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_MA1IE field. */
#define LPUART_RD_CTRL_MA1IE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_MA1IE_MASK) >> LPUART_CTRL_MA1IE_SHIFT)
#define LPUART_BRD_CTRL_MA1IE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_MA1IE_SHIFT, LPUART_CTRL_MA1IE_WIDTH))

/*! @brief Set the MA1IE field to a new value. */
#define LPUART_WR_CTRL_MA1IE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_MA1IE_MASK, LPUART_CTRL_MA1IE(value)))
#define LPUART_BWR_CTRL_MA1IE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_MA1IE_SHIFT), LPUART_CTRL_MA1IE_SHIFT, LPUART_CTRL_MA1IE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field SBK[16] (RW)
 *
 * Writing a 1 and then a 0 to SBK queues a break character in the transmit data
 * stream. Additional break characters of 10 to 13, or 13 to 16 if
 * LPUART_STATBRK13] is set, bit times of logic 0 are queued as long as SBK is set. Depending
 * on the timing of the set and clear of SBK relative to the information
 * currently being transmitted, a second break character may be queued before software
 * clears SBK.
 *
 * Values:
 * - 0b0 - Normal transmitter operation.
 * - 0b1 - Queue break character(s) to be sent.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_SBK field. */
#define LPUART_RD_CTRL_SBK(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_SBK_MASK) >> LPUART_CTRL_SBK_SHIFT)
#define LPUART_BRD_CTRL_SBK(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_SBK_SHIFT, LPUART_CTRL_SBK_WIDTH))

/*! @brief Set the SBK field to a new value. */
#define LPUART_WR_CTRL_SBK(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_SBK_MASK, LPUART_CTRL_SBK(value)))
#define LPUART_BWR_CTRL_SBK(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_SBK_SHIFT), LPUART_CTRL_SBK_SHIFT, LPUART_CTRL_SBK_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RWU[17] (RW)
 *
 * This field can be set to place the LPUART receiver in a standby state. RWU
 * automatically clears when an RWU event occurs, that is, an IDLE event when
 * CTRL[WAKE] is clear or an address match when CTRL[WAKE] is set with STAT[RWUID] is
 * clear. RWU must be set only with CTRL[WAKE] = 0 (wakeup on idle) if the
 * channel is currently not idle. This can be determined by STAT[RAF]. If the flag is
 * set to wake up an IDLE event and the channel is already idle, it is possible
 * that the LPUART will discard data. This is because the data must be received or
 * a LIN break detected after an IDLE is detected before IDLE is allowed to be
 * reasserted.
 *
 * Values:
 * - 0b0 - Normal receiver operation.
 * - 0b1 - LPUART receiver in standby waiting for wakeup condition.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RWU field. */
#define LPUART_RD_CTRL_RWU(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RWU_MASK) >> LPUART_CTRL_RWU_SHIFT)
#define LPUART_BRD_CTRL_RWU(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_RWU_SHIFT, LPUART_CTRL_RWU_WIDTH))

/*! @brief Set the RWU field to a new value. */
#define LPUART_WR_CTRL_RWU(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RWU_MASK, LPUART_CTRL_RWU(value)))
#define LPUART_BWR_CTRL_RWU(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_RWU_SHIFT), LPUART_CTRL_RWU_SHIFT, LPUART_CTRL_RWU_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RE[18] (RW)
 *
 * Enables the LPUART receiver. When RE is written to 0, this register bit will
 * read as 1 until the receiver finishes receiving the current character (if any).
 *
 * Values:
 * - 0b0 - Receiver disabled.
 * - 0b1 - Receiver enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RE field. */
#define LPUART_RD_CTRL_RE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RE_MASK) >> LPUART_CTRL_RE_SHIFT)
#define LPUART_BRD_CTRL_RE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_RE_SHIFT, LPUART_CTRL_RE_WIDTH))

/*! @brief Set the RE field to a new value. */
#define LPUART_WR_CTRL_RE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RE_MASK, LPUART_CTRL_RE(value)))
#define LPUART_BWR_CTRL_RE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_RE_SHIFT), LPUART_CTRL_RE_SHIFT, LPUART_CTRL_RE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TE[19] (RW)
 *
 * Enables the LPUART transmitter. TE can also be used to queue an idle preamble
 * by clearing and then setting TE. When TE is cleared, this register bit will
 * read as 1 until the transmitter has completed the current character and the
 * LPUART_TX pin is tristated.
 *
 * Values:
 * - 0b0 - Transmitter disabled.
 * - 0b1 - Transmitter enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TE field. */
#define LPUART_RD_CTRL_TE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TE_MASK) >> LPUART_CTRL_TE_SHIFT)
#define LPUART_BRD_CTRL_TE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_TE_SHIFT, LPUART_CTRL_TE_WIDTH))

/*! @brief Set the TE field to a new value. */
#define LPUART_WR_CTRL_TE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TE_MASK, LPUART_CTRL_TE(value)))
#define LPUART_BWR_CTRL_TE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_TE_SHIFT), LPUART_CTRL_TE_SHIFT, LPUART_CTRL_TE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field ILIE[20] (RW)
 *
 * ILIE enables the idle line flag, STAT[IDLE], to generate interrupt requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from IDLE disabled; use polling.
 * - 0b1 - Hardware interrupt requested when IDLE flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_ILIE field. */
#define LPUART_RD_CTRL_ILIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_ILIE_MASK) >> LPUART_CTRL_ILIE_SHIFT)
#define LPUART_BRD_CTRL_ILIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_ILIE_SHIFT, LPUART_CTRL_ILIE_WIDTH))

/*! @brief Set the ILIE field to a new value. */
#define LPUART_WR_CTRL_ILIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_ILIE_MASK, LPUART_CTRL_ILIE(value)))
#define LPUART_BWR_CTRL_ILIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_ILIE_SHIFT), LPUART_CTRL_ILIE_SHIFT, LPUART_CTRL_ILIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RIE[21] (RW)
 *
 * Enables STAT[RDRF] to generate interrupt requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from RDRF disabled; use polling.
 * - 0b1 - Hardware interrupt requested when RDRF flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RIE field. */
#define LPUART_RD_CTRL_RIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RIE_MASK) >> LPUART_CTRL_RIE_SHIFT)
#define LPUART_BRD_CTRL_RIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_RIE_SHIFT, LPUART_CTRL_RIE_WIDTH))

/*! @brief Set the RIE field to a new value. */
#define LPUART_WR_CTRL_RIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RIE_MASK, LPUART_CTRL_RIE(value)))
#define LPUART_BWR_CTRL_RIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_RIE_SHIFT), LPUART_CTRL_RIE_SHIFT, LPUART_CTRL_RIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TCIE[22] (RW)
 *
 * TCIE enables the transmission complete flag, TC, to generate interrupt
 * requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from TC disabled; use polling.
 * - 0b1 - Hardware interrupt requested when TC flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TCIE field. */
#define LPUART_RD_CTRL_TCIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TCIE_MASK) >> LPUART_CTRL_TCIE_SHIFT)
#define LPUART_BRD_CTRL_TCIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_TCIE_SHIFT, LPUART_CTRL_TCIE_WIDTH))

/*! @brief Set the TCIE field to a new value. */
#define LPUART_WR_CTRL_TCIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TCIE_MASK, LPUART_CTRL_TCIE(value)))
#define LPUART_BWR_CTRL_TCIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_TCIE_SHIFT), LPUART_CTRL_TCIE_SHIFT, LPUART_CTRL_TCIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TIE[23] (RW)
 *
 * Enables STAT[TDRE] to generate interrupt requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from TDRE disabled; use polling.
 * - 0b1 - Hardware interrupt requested when TDRE flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TIE field. */
#define LPUART_RD_CTRL_TIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TIE_MASK) >> LPUART_CTRL_TIE_SHIFT)
#define LPUART_BRD_CTRL_TIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_TIE_SHIFT, LPUART_CTRL_TIE_WIDTH))

/*! @brief Set the TIE field to a new value. */
#define LPUART_WR_CTRL_TIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TIE_MASK, LPUART_CTRL_TIE(value)))
#define LPUART_BWR_CTRL_TIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_TIE_SHIFT), LPUART_CTRL_TIE_SHIFT, LPUART_CTRL_TIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field PEIE[24] (RW)
 *
 * This bit enables the parity error flag (PF) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0b0 - PF interrupts disabled; use polling).
 * - 0b1 - Hardware interrupt requested when PF is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_PEIE field. */
#define LPUART_RD_CTRL_PEIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_PEIE_MASK) >> LPUART_CTRL_PEIE_SHIFT)
#define LPUART_BRD_CTRL_PEIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_PEIE_SHIFT, LPUART_CTRL_PEIE_WIDTH))

/*! @brief Set the PEIE field to a new value. */
#define LPUART_WR_CTRL_PEIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_PEIE_MASK, LPUART_CTRL_PEIE(value)))
#define LPUART_BWR_CTRL_PEIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_PEIE_SHIFT), LPUART_CTRL_PEIE_SHIFT, LPUART_CTRL_PEIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field FEIE[25] (RW)
 *
 * This bit enables the framing error flag (FE) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0b0 - FE interrupts disabled; use polling.
 * - 0b1 - Hardware interrupt requested when FE is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_FEIE field. */
#define LPUART_RD_CTRL_FEIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_FEIE_MASK) >> LPUART_CTRL_FEIE_SHIFT)
#define LPUART_BRD_CTRL_FEIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_FEIE_SHIFT, LPUART_CTRL_FEIE_WIDTH))

/*! @brief Set the FEIE field to a new value. */
#define LPUART_WR_CTRL_FEIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_FEIE_MASK, LPUART_CTRL_FEIE(value)))
#define LPUART_BWR_CTRL_FEIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_FEIE_SHIFT), LPUART_CTRL_FEIE_SHIFT, LPUART_CTRL_FEIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field NEIE[26] (RW)
 *
 * This bit enables the noise flag (NF) to generate hardware interrupt requests.
 *
 * Values:
 * - 0b0 - NF interrupts disabled; use polling.
 * - 0b1 - Hardware interrupt requested when NF is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_NEIE field. */
#define LPUART_RD_CTRL_NEIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_NEIE_MASK) >> LPUART_CTRL_NEIE_SHIFT)
#define LPUART_BRD_CTRL_NEIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_NEIE_SHIFT, LPUART_CTRL_NEIE_WIDTH))

/*! @brief Set the NEIE field to a new value. */
#define LPUART_WR_CTRL_NEIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_NEIE_MASK, LPUART_CTRL_NEIE(value)))
#define LPUART_BWR_CTRL_NEIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_NEIE_SHIFT), LPUART_CTRL_NEIE_SHIFT, LPUART_CTRL_NEIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field ORIE[27] (RW)
 *
 * This bit enables the overrun flag (OR) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0b0 - OR interrupts disabled; use polling.
 * - 0b1 - Hardware interrupt requested when OR is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_ORIE field. */
#define LPUART_RD_CTRL_ORIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_ORIE_MASK) >> LPUART_CTRL_ORIE_SHIFT)
#define LPUART_BRD_CTRL_ORIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_ORIE_SHIFT, LPUART_CTRL_ORIE_WIDTH))

/*! @brief Set the ORIE field to a new value. */
#define LPUART_WR_CTRL_ORIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_ORIE_MASK, LPUART_CTRL_ORIE(value)))
#define LPUART_BWR_CTRL_ORIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_ORIE_SHIFT), LPUART_CTRL_ORIE_SHIFT, LPUART_CTRL_ORIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TXINV[28] (RW)
 *
 * Setting this bit reverses the polarity of the transmitted data output.
 * Setting TXINV inverts the LPUART_TX output for all cases: data bits, start and stop
 * bits, break, and idle.
 *
 * Values:
 * - 0b0 - Transmit data not inverted.
 * - 0b1 - Transmit data inverted.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TXINV field. */
#define LPUART_RD_CTRL_TXINV(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TXINV_MASK) >> LPUART_CTRL_TXINV_SHIFT)
#define LPUART_BRD_CTRL_TXINV(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_TXINV_SHIFT, LPUART_CTRL_TXINV_WIDTH))

/*! @brief Set the TXINV field to a new value. */
#define LPUART_WR_CTRL_TXINV(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TXINV_MASK, LPUART_CTRL_TXINV(value)))
#define LPUART_BWR_CTRL_TXINV(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_TXINV_SHIFT), LPUART_CTRL_TXINV_SHIFT, LPUART_CTRL_TXINV_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TXDIR[29] (RW)
 *
 * When the LPUART is configured for single-wire half-duplex operation (LOOPS =
 * RSRC = 1), this bit determines the direction of data at the LPUART_TX pin.
 * When clearing TXDIR, the transmitter will finish receiving the current character
 * (if any) before the receiver starts receiving data from the LPUART_TX pin.
 *
 * Values:
 * - 0b0 - LPUART_TX pin is an input in single-wire mode.
 * - 0b1 - LPUART_TX pin is an output in single-wire mode.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TXDIR field. */
#define LPUART_RD_CTRL_TXDIR(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TXDIR_MASK) >> LPUART_CTRL_TXDIR_SHIFT)
#define LPUART_BRD_CTRL_TXDIR(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_TXDIR_SHIFT, LPUART_CTRL_TXDIR_WIDTH))

/*! @brief Set the TXDIR field to a new value. */
#define LPUART_WR_CTRL_TXDIR(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TXDIR_MASK, LPUART_CTRL_TXDIR(value)))
#define LPUART_BWR_CTRL_TXDIR(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_TXDIR_SHIFT), LPUART_CTRL_TXDIR_SHIFT, LPUART_CTRL_TXDIR_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field R9T8[30] (RW)
 *
 * R9 is the tenth data bit received when the LPUART is configured for 10-bit
 * data formats. When reading 10-bit data, read R9 before reading LPUART_DATA T8 is
 * the ninth data bit received when the LPUART is configured for 9-bit or 10-bit
 * data formats. When writing 9-bit or 10-bit data, write T8 before writing
 * LPUART_DATA. If T8 does not need to change from its previous value, such as when
 * it is used to generate address mark or parity, they it need not be written each
 * time LPUART_DATA is written.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_R9T8 field. */
#define LPUART_RD_CTRL_R9T8(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_R9T8_MASK) >> LPUART_CTRL_R9T8_SHIFT)
#define LPUART_BRD_CTRL_R9T8(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_R9T8_SHIFT, LPUART_CTRL_R9T8_WIDTH))

/*! @brief Set the R9T8 field to a new value. */
#define LPUART_WR_CTRL_R9T8(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_R9T8_MASK, LPUART_CTRL_R9T8(value)))
#define LPUART_BWR_CTRL_R9T8(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_R9T8_SHIFT), LPUART_CTRL_R9T8_SHIFT, LPUART_CTRL_R9T8_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field R8T9[31] (RW)
 *
 * R8 is the ninth data bit received when the LPUART is configured for 9-bit or
 * 10-bit data formats. When reading 9-bit or 10-bit data, read R8 before reading
 * LPUART_DATA. T9 is the tenth data bit received when the LPUART is configured
 * for 10-bit data formats. When writing 10-bit data, write T9 before writing
 * LPUART_DATA. If T9 does not need to change from its previous value, such as when
 * it is used to generate address mark or parity, they it need not be written
 * each time LPUART_DATA is written.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_R8T9 field. */
#define LPUART_RD_CTRL_R8T9(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_R8T9_MASK) >> LPUART_CTRL_R8T9_SHIFT)
#define LPUART_BRD_CTRL_R8T9(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_R8T9_SHIFT, LPUART_CTRL_R8T9_WIDTH))

/*! @brief Set the R8T9 field to a new value. */
#define LPUART_WR_CTRL_R8T9(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_R8T9_MASK, LPUART_CTRL_R8T9(value)))
#define LPUART_BWR_CTRL_R8T9(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_R8T9_SHIFT), LPUART_CTRL_R8T9_SHIFT, LPUART_CTRL_R8T9_WIDTH))
/*@}*/

/*******************************************************************************
 * LPUART_DATA - LPUART Data Register
 ******************************************************************************/

/*!
 * @brief LPUART_DATA - LPUART Data Register (RW)
 *
 * Reset value: 0x00001000U
 *
 * This register is actually two separate registers. Reads return the contents
 * of the read-only receive data buffer and writes go to the write-only transmit
 * data buffer. Reads and writes of this register are also involved in the
 * automatic flag clearing mechanisms for some of the LPUART status flags.
 */
/*!
 * @name Constants and macros for entire LPUART_DATA register
 */
/*@{*/
#define LPUART_RD_DATA(base)     (LPUART_DATA_REG(base))
#define LPUART_WR_DATA(base, value) (LPUART_DATA_REG(base) = (value))
#define LPUART_RMW_DATA(base, mask, value) (LPUART_WR_DATA(base, (LPUART_RD_DATA(base) & ~(mask)) | (value)))
#define LPUART_SET_DATA(base, value) (BME_OR32(&LPUART_DATA_REG(base), (uint32_t)(value)))
#define LPUART_CLR_DATA(base, value) (BME_AND32(&LPUART_DATA_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_DATA(base, value) (BME_XOR32(&LPUART_DATA_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_DATA bitfields
 */

/*!
 * @name Register LPUART_DATA, field R0T0[0] (RW)
 *
 * Read receive data buffer 0 or write transmit data buffer 0.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R0T0 field. */
#define LPUART_RD_DATA_R0T0(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R0T0_MASK) >> LPUART_DATA_R0T0_SHIFT)
#define LPUART_BRD_DATA_R0T0(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R0T0_SHIFT, LPUART_DATA_R0T0_WIDTH))

/*! @brief Set the R0T0 field to a new value. */
#define LPUART_WR_DATA_R0T0(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R0T0_MASK, LPUART_DATA_R0T0(value)))
#define LPUART_BWR_DATA_R0T0(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R0T0_SHIFT), LPUART_DATA_R0T0_SHIFT, LPUART_DATA_R0T0_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R1T1[1] (RW)
 *
 * Read receive data buffer 1 or write transmit data buffer 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R1T1 field. */
#define LPUART_RD_DATA_R1T1(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R1T1_MASK) >> LPUART_DATA_R1T1_SHIFT)
#define LPUART_BRD_DATA_R1T1(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R1T1_SHIFT, LPUART_DATA_R1T1_WIDTH))

/*! @brief Set the R1T1 field to a new value. */
#define LPUART_WR_DATA_R1T1(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R1T1_MASK, LPUART_DATA_R1T1(value)))
#define LPUART_BWR_DATA_R1T1(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R1T1_SHIFT), LPUART_DATA_R1T1_SHIFT, LPUART_DATA_R1T1_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R2T2[2] (RW)
 *
 * Read receive data buffer 2 or write transmit data buffer 2.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R2T2 field. */
#define LPUART_RD_DATA_R2T2(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R2T2_MASK) >> LPUART_DATA_R2T2_SHIFT)
#define LPUART_BRD_DATA_R2T2(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R2T2_SHIFT, LPUART_DATA_R2T2_WIDTH))

/*! @brief Set the R2T2 field to a new value. */
#define LPUART_WR_DATA_R2T2(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R2T2_MASK, LPUART_DATA_R2T2(value)))
#define LPUART_BWR_DATA_R2T2(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R2T2_SHIFT), LPUART_DATA_R2T2_SHIFT, LPUART_DATA_R2T2_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R3T3[3] (RW)
 *
 * Read receive data buffer 3 or write transmit data buffer 3.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R3T3 field. */
#define LPUART_RD_DATA_R3T3(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R3T3_MASK) >> LPUART_DATA_R3T3_SHIFT)
#define LPUART_BRD_DATA_R3T3(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R3T3_SHIFT, LPUART_DATA_R3T3_WIDTH))

/*! @brief Set the R3T3 field to a new value. */
#define LPUART_WR_DATA_R3T3(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R3T3_MASK, LPUART_DATA_R3T3(value)))
#define LPUART_BWR_DATA_R3T3(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R3T3_SHIFT), LPUART_DATA_R3T3_SHIFT, LPUART_DATA_R3T3_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R4T4[4] (RW)
 *
 * Read receive data buffer 4 or write transmit data buffer 4.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R4T4 field. */
#define LPUART_RD_DATA_R4T4(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R4T4_MASK) >> LPUART_DATA_R4T4_SHIFT)
#define LPUART_BRD_DATA_R4T4(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R4T4_SHIFT, LPUART_DATA_R4T4_WIDTH))

/*! @brief Set the R4T4 field to a new value. */
#define LPUART_WR_DATA_R4T4(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R4T4_MASK, LPUART_DATA_R4T4(value)))
#define LPUART_BWR_DATA_R4T4(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R4T4_SHIFT), LPUART_DATA_R4T4_SHIFT, LPUART_DATA_R4T4_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R5T5[5] (RW)
 *
 * Read receive data buffer 5 or write transmit data buffer 5.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R5T5 field. */
#define LPUART_RD_DATA_R5T5(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R5T5_MASK) >> LPUART_DATA_R5T5_SHIFT)
#define LPUART_BRD_DATA_R5T5(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R5T5_SHIFT, LPUART_DATA_R5T5_WIDTH))

/*! @brief Set the R5T5 field to a new value. */
#define LPUART_WR_DATA_R5T5(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R5T5_MASK, LPUART_DATA_R5T5(value)))
#define LPUART_BWR_DATA_R5T5(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R5T5_SHIFT), LPUART_DATA_R5T5_SHIFT, LPUART_DATA_R5T5_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R6T6[6] (RW)
 *
 * Read receive data buffer 6 or write transmit data buffer 6.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R6T6 field. */
#define LPUART_RD_DATA_R6T6(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R6T6_MASK) >> LPUART_DATA_R6T6_SHIFT)
#define LPUART_BRD_DATA_R6T6(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R6T6_SHIFT, LPUART_DATA_R6T6_WIDTH))

/*! @brief Set the R6T6 field to a new value. */
#define LPUART_WR_DATA_R6T6(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R6T6_MASK, LPUART_DATA_R6T6(value)))
#define LPUART_BWR_DATA_R6T6(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R6T6_SHIFT), LPUART_DATA_R6T6_SHIFT, LPUART_DATA_R6T6_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R7T7[7] (RW)
 *
 * Read receive data buffer 7 or write transmit data buffer 7.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R7T7 field. */
#define LPUART_RD_DATA_R7T7(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R7T7_MASK) >> LPUART_DATA_R7T7_SHIFT)
#define LPUART_BRD_DATA_R7T7(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R7T7_SHIFT, LPUART_DATA_R7T7_WIDTH))

/*! @brief Set the R7T7 field to a new value. */
#define LPUART_WR_DATA_R7T7(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R7T7_MASK, LPUART_DATA_R7T7(value)))
#define LPUART_BWR_DATA_R7T7(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R7T7_SHIFT), LPUART_DATA_R7T7_SHIFT, LPUART_DATA_R7T7_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R8T8[8] (RW)
 *
 * Read receive data buffer 8 or write transmit data buffer 8.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R8T8 field. */
#define LPUART_RD_DATA_R8T8(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R8T8_MASK) >> LPUART_DATA_R8T8_SHIFT)
#define LPUART_BRD_DATA_R8T8(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R8T8_SHIFT, LPUART_DATA_R8T8_WIDTH))

/*! @brief Set the R8T8 field to a new value. */
#define LPUART_WR_DATA_R8T8(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R8T8_MASK, LPUART_DATA_R8T8(value)))
#define LPUART_BWR_DATA_R8T8(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R8T8_SHIFT), LPUART_DATA_R8T8_SHIFT, LPUART_DATA_R8T8_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R9T9[9] (RW)
 *
 * Read receive data buffer 9 or write transmit data buffer 9.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R9T9 field. */
#define LPUART_RD_DATA_R9T9(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R9T9_MASK) >> LPUART_DATA_R9T9_SHIFT)
#define LPUART_BRD_DATA_R9T9(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R9T9_SHIFT, LPUART_DATA_R9T9_WIDTH))

/*! @brief Set the R9T9 field to a new value. */
#define LPUART_WR_DATA_R9T9(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R9T9_MASK, LPUART_DATA_R9T9(value)))
#define LPUART_BWR_DATA_R9T9(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R9T9_SHIFT), LPUART_DATA_R9T9_SHIFT, LPUART_DATA_R9T9_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field IDLINE[11] (RO)
 *
 * Indicates the receiver line was idle before receiving the character in
 * DATA[9:0]. Unlike the IDLE flag, this bit can set for the first character received
 * when the receiver is first enabled.
 *
 * Values:
 * - 0b0 - Receiver was not idle before receiving this character.
 * - 0b1 - Receiver was idle before receiving this character.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_IDLINE field. */
#define LPUART_RD_DATA_IDLINE(base) ((LPUART_DATA_REG(base) & LPUART_DATA_IDLINE_MASK) >> LPUART_DATA_IDLINE_SHIFT)
#define LPUART_BRD_DATA_IDLINE(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_IDLINE_SHIFT, LPUART_DATA_IDLINE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field RXEMPT[12] (RO)
 *
 * Asserts when there is no data in the receive buffer. This field does not take
 * into account data that is in the receive shift register.
 *
 * Values:
 * - 0b0 - Receive buffer contains valid data.
 * - 0b1 - Receive buffer is empty, data returned on read is not valid.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_RXEMPT field. */
#define LPUART_RD_DATA_RXEMPT(base) ((LPUART_DATA_REG(base) & LPUART_DATA_RXEMPT_MASK) >> LPUART_DATA_RXEMPT_SHIFT)
#define LPUART_BRD_DATA_RXEMPT(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_RXEMPT_SHIFT, LPUART_DATA_RXEMPT_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field FRETSC[13] (RW)
 *
 * For reads, indicates the current received dataword contained in DATA[R9:R0]
 * was received with a frame error. For writes, indicates a break or idle
 * character is to be transmitted instead of the contents in DATA[T9:T0]. T9 is used to
 * indicate a break character when 0 and a idle character when 1, he contents of
 * DATA[T8:T0] should be zero.
 *
 * Values:
 * - 0b0 - The dataword was received without a frame error on read, transmit a
 *     normal character on write.
 * - 0b1 - The dataword was received with a frame error, transmit an idle or
 *     break character on transmit.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_FRETSC field. */
#define LPUART_RD_DATA_FRETSC(base) ((LPUART_DATA_REG(base) & LPUART_DATA_FRETSC_MASK) >> LPUART_DATA_FRETSC_SHIFT)
#define LPUART_BRD_DATA_FRETSC(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_FRETSC_SHIFT, LPUART_DATA_FRETSC_WIDTH))

/*! @brief Set the FRETSC field to a new value. */
#define LPUART_WR_DATA_FRETSC(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_FRETSC_MASK, LPUART_DATA_FRETSC(value)))
#define LPUART_BWR_DATA_FRETSC(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_FRETSC_SHIFT), LPUART_DATA_FRETSC_SHIFT, LPUART_DATA_FRETSC_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field PARITYE[14] (RO)
 *
 * The current received dataword contained in DATA[R9:R0] was received with a
 * parity error.
 *
 * Values:
 * - 0b0 - The dataword was received without a parity error.
 * - 0b1 - The dataword was received with a parity error.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_PARITYE field. */
#define LPUART_RD_DATA_PARITYE(base) ((LPUART_DATA_REG(base) & LPUART_DATA_PARITYE_MASK) >> LPUART_DATA_PARITYE_SHIFT)
#define LPUART_BRD_DATA_PARITYE(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_PARITYE_SHIFT, LPUART_DATA_PARITYE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field NOISY[15] (RO)
 *
 * The current received dataword contained in DATA[R9:R0] was received with
 * noise.
 *
 * Values:
 * - 0b0 - The dataword was received without noise.
 * - 0b1 - The data was received with noise.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_NOISY field. */
#define LPUART_RD_DATA_NOISY(base) ((LPUART_DATA_REG(base) & LPUART_DATA_NOISY_MASK) >> LPUART_DATA_NOISY_SHIFT)
#define LPUART_BRD_DATA_NOISY(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_NOISY_SHIFT, LPUART_DATA_NOISY_WIDTH))
/*@}*/

/*******************************************************************************
 * LPUART_MATCH - LPUART Match Address Register
 ******************************************************************************/

/*!
 * @brief LPUART_MATCH - LPUART Match Address Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPUART_MATCH register
 */
/*@{*/
#define LPUART_RD_MATCH(base)    (LPUART_MATCH_REG(base))
#define LPUART_WR_MATCH(base, value) (LPUART_MATCH_REG(base) = (value))
#define LPUART_RMW_MATCH(base, mask, value) (LPUART_WR_MATCH(base, (LPUART_RD_MATCH(base) & ~(mask)) | (value)))
#define LPUART_SET_MATCH(base, value) (BME_OR32(&LPUART_MATCH_REG(base), (uint32_t)(value)))
#define LPUART_CLR_MATCH(base, value) (BME_AND32(&LPUART_MATCH_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_MATCH(base, value) (BME_XOR32(&LPUART_MATCH_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_MATCH bitfields
 */

/*!
 * @name Register LPUART_MATCH, field MA1[9:0] (RW)
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated BAUD[MAEN] bit is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. Software should only write a MA register
 * when the associated BAUD[MAEN] bit is clear.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MATCH_MA1 field. */
#define LPUART_RD_MATCH_MA1(base) ((LPUART_MATCH_REG(base) & LPUART_MATCH_MA1_MASK) >> LPUART_MATCH_MA1_SHIFT)
#define LPUART_BRD_MATCH_MA1(base) (BME_UBFX32(&LPUART_MATCH_REG(base), LPUART_MATCH_MA1_SHIFT, LPUART_MATCH_MA1_WIDTH))

/*! @brief Set the MA1 field to a new value. */
#define LPUART_WR_MATCH_MA1(base, value) (LPUART_RMW_MATCH(base, LPUART_MATCH_MA1_MASK, LPUART_MATCH_MA1(value)))
#define LPUART_BWR_MATCH_MA1(base, value) (BME_BFI32(&LPUART_MATCH_REG(base), ((uint32_t)(value) << LPUART_MATCH_MA1_SHIFT), LPUART_MATCH_MA1_SHIFT, LPUART_MATCH_MA1_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MATCH, field MA2[25:16] (RW)
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated BAUD[MAEN] bit is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. Software should only write a MA register
 * when the associated BAUD[MAEN] bit is clear.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MATCH_MA2 field. */
#define LPUART_RD_MATCH_MA2(base) ((LPUART_MATCH_REG(base) & LPUART_MATCH_MA2_MASK) >> LPUART_MATCH_MA2_SHIFT)
#define LPUART_BRD_MATCH_MA2(base) (BME_UBFX32(&LPUART_MATCH_REG(base), LPUART_MATCH_MA2_SHIFT, LPUART_MATCH_MA2_WIDTH))

/*! @brief Set the MA2 field to a new value. */
#define LPUART_WR_MATCH_MA2(base, value) (LPUART_RMW_MATCH(base, LPUART_MATCH_MA2_MASK, LPUART_MATCH_MA2(value)))
#define LPUART_BWR_MATCH_MA2(base, value) (BME_BFI32(&LPUART_MATCH_REG(base), ((uint32_t)(value) << LPUART_MATCH_MA2_SHIFT), LPUART_MATCH_MA2_SHIFT, LPUART_MATCH_MA2_WIDTH))
/*@}*/

/*******************************************************************************
 * LPUART_MODIR - LPUART Modem IrDA Register
 ******************************************************************************/

/*!
 * @brief LPUART_MODIR - LPUART Modem IrDA Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MODEM register controls options for setting the modem configuration.
 */
/*!
 * @name Constants and macros for entire LPUART_MODIR register
 */
/*@{*/
#define LPUART_RD_MODIR(base)    (LPUART_MODIR_REG(base))
#define LPUART_WR_MODIR(base, value) (LPUART_MODIR_REG(base) = (value))
#define LPUART_RMW_MODIR(base, mask, value) (LPUART_WR_MODIR(base, (LPUART_RD_MODIR(base) & ~(mask)) | (value)))
#define LPUART_SET_MODIR(base, value) (BME_OR32(&LPUART_MODIR_REG(base), (uint32_t)(value)))
#define LPUART_CLR_MODIR(base, value) (BME_AND32(&LPUART_MODIR_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_MODIR(base, value) (BME_XOR32(&LPUART_MODIR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_MODIR bitfields
 */

/*!
 * @name Register LPUART_MODIR, field TXCTSE[0] (RW)
 *
 * TXCTSE controls the operation of the transmitter. TXCTSE can be set
 * independently from the state of TXRTSE and RXRTSE.
 *
 * Values:
 * - 0b0 - CTS has no effect on the transmitter.
 * - 0b1 - Enables clear-to-send operation. The transmitter checks the state of
 *     CTS each time it is ready to send a character. If CTS is asserted, the
 *     character is sent. If CTS is deasserted, the signal TXD remains in the mark
 *     state and transmission is delayed until CTS is asserted. Changes in CTS as
 *     a character is being sent do not affect its transmission.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXCTSE field. */
#define LPUART_RD_MODIR_TXCTSE(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXCTSE_MASK) >> LPUART_MODIR_TXCTSE_SHIFT)
#define LPUART_BRD_MODIR_TXCTSE(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSE_SHIFT, LPUART_MODIR_TXCTSE_WIDTH))

/*! @brief Set the TXCTSE field to a new value. */
#define LPUART_WR_MODIR_TXCTSE(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXCTSE_MASK, LPUART_MODIR_TXCTSE(value)))
#define LPUART_BWR_MODIR_TXCTSE(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_TXCTSE_SHIFT), LPUART_MODIR_TXCTSE_SHIFT, LPUART_MODIR_TXCTSE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXRTSE[1] (RW)
 *
 * Controls RTS before and after a transmission.
 *
 * Values:
 * - 0b0 - The transmitter has no effect on RTS.
 * - 0b1 - When a character is placed into an empty transmitter data buffer ,
 *     RTS asserts one bit time before the start bit is transmitted. RTS deasserts
 *     one bit time after all characters in the transmitter data buffer and shift
 *     register are completely sent, including the last stop bit.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXRTSE field. */
#define LPUART_RD_MODIR_TXRTSE(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXRTSE_MASK) >> LPUART_MODIR_TXRTSE_SHIFT)
#define LPUART_BRD_MODIR_TXRTSE(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXRTSE_SHIFT, LPUART_MODIR_TXRTSE_WIDTH))

/*! @brief Set the TXRTSE field to a new value. */
#define LPUART_WR_MODIR_TXRTSE(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXRTSE_MASK, LPUART_MODIR_TXRTSE(value)))
#define LPUART_BWR_MODIR_TXRTSE(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_TXRTSE_SHIFT), LPUART_MODIR_TXRTSE_SHIFT, LPUART_MODIR_TXRTSE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXRTSPOL[2] (RW)
 *
 * Controls the polarity of the transmitter RTS. TXRTSPOL does not affect the
 * polarity of the receiver RTS. RTS will remain negated in the active low state
 * unless TXRTSE is set.
 *
 * Values:
 * - 0b0 - Transmitter RTS is active low.
 * - 0b1 - Transmitter RTS is active high.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXRTSPOL field. */
#define LPUART_RD_MODIR_TXRTSPOL(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXRTSPOL_MASK) >> LPUART_MODIR_TXRTSPOL_SHIFT)
#define LPUART_BRD_MODIR_TXRTSPOL(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXRTSPOL_SHIFT, LPUART_MODIR_TXRTSPOL_WIDTH))

/*! @brief Set the TXRTSPOL field to a new value. */
#define LPUART_WR_MODIR_TXRTSPOL(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXRTSPOL_MASK, LPUART_MODIR_TXRTSPOL(value)))
#define LPUART_BWR_MODIR_TXRTSPOL(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_TXRTSPOL_SHIFT), LPUART_MODIR_TXRTSPOL_SHIFT, LPUART_MODIR_TXRTSPOL_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field RXRTSE[3] (RW)
 *
 * Allows the RTS output to control the CTS input of the transmitting device to
 * prevent receiver overrun. Do not set both RXRTSE and TXRTSE.
 *
 * Values:
 * - 0b0 - The receiver has no effect on RTS.
 * - 0b1 - RTS assertion is configured by the RTSWATER field
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_RXRTSE field. */
#define LPUART_RD_MODIR_RXRTSE(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_RXRTSE_MASK) >> LPUART_MODIR_RXRTSE_SHIFT)
#define LPUART_BRD_MODIR_RXRTSE(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_RXRTSE_SHIFT, LPUART_MODIR_RXRTSE_WIDTH))

/*! @brief Set the RXRTSE field to a new value. */
#define LPUART_WR_MODIR_RXRTSE(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_RXRTSE_MASK, LPUART_MODIR_RXRTSE(value)))
#define LPUART_BWR_MODIR_RXRTSE(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_RXRTSE_SHIFT), LPUART_MODIR_RXRTSE_SHIFT, LPUART_MODIR_RXRTSE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXCTSC[4] (RW)
 *
 * Configures if the CTS state is checked at the start of each character or only
 * when the transmitter is idle.
 *
 * Values:
 * - 0b0 - CTS input is sampled at the start of each character.
 * - 0b1 - CTS input is sampled when the transmitter is idle.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXCTSC field. */
#define LPUART_RD_MODIR_TXCTSC(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXCTSC_MASK) >> LPUART_MODIR_TXCTSC_SHIFT)
#define LPUART_BRD_MODIR_TXCTSC(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSC_SHIFT, LPUART_MODIR_TXCTSC_WIDTH))

/*! @brief Set the TXCTSC field to a new value. */
#define LPUART_WR_MODIR_TXCTSC(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXCTSC_MASK, LPUART_MODIR_TXCTSC(value)))
#define LPUART_BWR_MODIR_TXCTSC(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_TXCTSC_SHIFT), LPUART_MODIR_TXCTSC_SHIFT, LPUART_MODIR_TXCTSC_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXCTSSRC[5] (RW)
 *
 * Configures the source of the CTS input.
 *
 * Values:
 * - 0b0 - CTS input is the LPUART_CTS pin.
 * - 0b1 - CTS input is the inverted Receiver Match result.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXCTSSRC field. */
#define LPUART_RD_MODIR_TXCTSSRC(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXCTSSRC_MASK) >> LPUART_MODIR_TXCTSSRC_SHIFT)
#define LPUART_BRD_MODIR_TXCTSSRC(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSSRC_SHIFT, LPUART_MODIR_TXCTSSRC_WIDTH))

/*! @brief Set the TXCTSSRC field to a new value. */
#define LPUART_WR_MODIR_TXCTSSRC(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXCTSSRC_MASK, LPUART_MODIR_TXCTSSRC(value)))
#define LPUART_BWR_MODIR_TXCTSSRC(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_TXCTSSRC_SHIFT), LPUART_MODIR_TXCTSSRC_SHIFT, LPUART_MODIR_TXCTSSRC_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TNP[17:16] (RW)
 *
 * Enables whether the LPUART transmits a 1/OSR, 2/OSR, 3/OSR or 4/OSR narrow
 * pulse.
 *
 * Values:
 * - 0b00 - 1/OSR.
 * - 0b01 - 2/OSR.
 * - 0b10 - 3/OSR.
 * - 0b11 - 4/OSR.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TNP field. */
#define LPUART_RD_MODIR_TNP(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TNP_MASK) >> LPUART_MODIR_TNP_SHIFT)
#define LPUART_BRD_MODIR_TNP(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_TNP_SHIFT, LPUART_MODIR_TNP_WIDTH))

/*! @brief Set the TNP field to a new value. */
#define LPUART_WR_MODIR_TNP(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TNP_MASK, LPUART_MODIR_TNP(value)))
#define LPUART_BWR_MODIR_TNP(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_TNP_SHIFT), LPUART_MODIR_TNP_SHIFT, LPUART_MODIR_TNP_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field IREN[18] (RW)
 *
 * Enables/disables the infrared modulation/demodulation.
 *
 * Values:
 * - 0b0 - IR disabled.
 * - 0b1 - IR enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_IREN field. */
#define LPUART_RD_MODIR_IREN(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_IREN_MASK) >> LPUART_MODIR_IREN_SHIFT)
#define LPUART_BRD_MODIR_IREN(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_IREN_SHIFT, LPUART_MODIR_IREN_WIDTH))

/*! @brief Set the IREN field to a new value. */
#define LPUART_WR_MODIR_IREN(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_IREN_MASK, LPUART_MODIR_IREN(value)))
#define LPUART_BWR_MODIR_IREN(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_IREN_SHIFT), LPUART_MODIR_IREN_SHIFT, LPUART_MODIR_IREN_WIDTH))
/*@}*/

/*
 * MKW40Z4 LTC
 *
 * LTC
 *
 * Registers defined in this header file:
 * - LTC_MD - LTC Mode Register (non-PKHA/non-RNG use)
 * - LTC_KS - LTC Key Size Register
 * - LTC_DS - LTC Data Size Register
 * - LTC_ICVS - LTC ICV Size Register
 * - LTC_COM - LTC Command Register
 * - LTC_CTL - LTC Control Register
 * - LTC_CW - LTC Clear Written Register
 * - LTC_STA - LTC Status Register
 * - LTC_ESTA - LTC Error Status Register
 * - LTC_AADSZ - LTC AAD Size Register
 * - LTC_CTX - LTC Context Register
 * - LTC_KEY - LTC Key Registers
 * - LTC_FIFOSTA - LTC FIFO Status Register
 * - LTC_IFIFO - LTC Input Data FIFO
 * - LTC_OFIFO - LTC Output Data FIFO
 * - LTC_VID1 - LTC Version ID Register
 * - LTC_CHAVID - LTC CHA Version ID Register
 */

#define LTC_INSTANCE_COUNT (1U) /*!< Number of instances of the LTC module. */
#define LTC0_IDX (0U) /*!< Instance number for LTC0. */

/*******************************************************************************
 * LTC_MD - LTC Mode Register (non-PKHA/non-RNG use)
 ******************************************************************************/

/*!
 * @brief LTC_MD - LTC Mode Register (non-PKHA/non-RNG use) (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Mode Register is used to tell the cryptographic engines which operation
 * is being requested. The interpretation of this register will be unique for each
 * CHA. This section defines the format of the Mode Register when used with
 * non-public-key algorithms and non-RNG operations.
 */
/*!
 * @name Constants and macros for entire LTC_MD register
 */
/*@{*/
#define LTC_RD_MD(base)          (LTC_MD_REG(base))
#define LTC_WR_MD(base, value)   (LTC_MD_REG(base) = (value))
#define LTC_RMW_MD(base, mask, value) (LTC_WR_MD(base, (LTC_RD_MD(base) & ~(mask)) | (value)))
#define LTC_SET_MD(base, value)  (BME_OR32(&LTC_MD_REG(base), (uint32_t)(value)))
#define LTC_CLR_MD(base, value)  (BME_AND32(&LTC_MD_REG(base), (uint32_t)(~(value))))
#define LTC_TOG_MD(base, value)  (BME_XOR32(&LTC_MD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LTC_MD bitfields
 */

/*!
 * @name Register LTC_MD, field ENC[0] (RW)
 *
 * Encrypt/Decrypt. This bit selects encryption or decryption.
 *
 * Values:
 * - 0b0 - Decrypt.
 * - 0b1 - Encrypt.
 */
/*@{*/
#define LTC_MD_ENC_DECRYPT             (0U)          /*!< Bit field value for LTC_MD_ENC: Decrypt. */
#define LTC_MD_ENC_ENCRYPT             (0x1U)        /*!< Bit field value for LTC_MD_ENC: Encrypt. */
/*! @brief Read current value of the LTC_MD_ENC field. */
#define LTC_RD_MD_ENC(base)  ((LTC_MD_REG(base) & LTC_MD_ENC_MASK) >> LTC_MD_ENC_SHIFT)
#define LTC_BRD_MD_ENC(base) (BME_UBFX32(&LTC_MD_REG(base), LTC_MD_ENC_SHIFT, LTC_MD_ENC_WIDTH))

/*! @brief Set the ENC field to a new value. */
#define LTC_WR_MD_ENC(base, value) (LTC_RMW_MD(base, LTC_MD_ENC_MASK, LTC_MD_ENC(value)))
#define LTC_BWR_MD_ENC(base, value) (BME_BFI32(&LTC_MD_REG(base), ((uint32_t)(value) << LTC_MD_ENC_SHIFT), LTC_MD_ENC_SHIFT, LTC_MD_ENC_WIDTH))
/*@}*/

/*!
 * @name Register LTC_MD, field ICV_TEST[1] (RW)
 *
 * ICV Checking / Test AES fault detection. For algorithms other than AES ECB
 * mode: ICV CheckingThis bit selects whether the current algorithm should compare
 * the known ICV versus the calculated ICV. This bit will be ignored by
 * algorithms that do not support ICV checking.0 - Don't compare1 - CompareFor AES ECB
 * mode: Test AES fault detectionIn AES ECB mode, this bit activates fault detection
 * testing by injecting bit level errors into AES core logic as defined in the
 * first 128 bits of the context.0 - Don't inject bit errors1 - Inject bit errors
 */
/*@{*/
/*! @brief Read current value of the LTC_MD_ICV_TEST field. */
#define LTC_RD_MD_ICV_TEST(base) ((LTC_MD_REG(base) & LTC_MD_ICV_TEST_MASK) >> LTC_MD_ICV_TEST_SHIFT)
#define LTC_BRD_MD_ICV_TEST(base) (BME_UBFX32(&LTC_MD_REG(base), LTC_MD_ICV_TEST_SHIFT, LTC_MD_ICV_TEST_WIDTH))

/*! @brief Set the ICV_TEST field to a new value. */
#define LTC_WR_MD_ICV_TEST(base, value) (LTC_RMW_MD(base, LTC_MD_ICV_TEST_MASK, LTC_MD_ICV_TEST(value)))
#define LTC_BWR_MD_ICV_TEST(base, value) (BME_BFI32(&LTC_MD_REG(base), ((uint32_t)(value) << LTC_MD_ICV_TEST_SHIFT), LTC_MD_ICV_TEST_SHIFT, LTC_MD_ICV_TEST_WIDTH))
/*@}*/

/*!
 * @name Register LTC_MD, field AS[3:2] (RW)
 *
 * Algorithm State. This field defines the state of the algorithm that is being
 * executed. This may not be used by every algorithm.
 *
 * Values:
 * - 0b00 - Update
 * - 0b01 - Initialize
 * - 0b10 - Finalize
 * - 0b11 - Initialize/Finalize
 */
/*@{*/
#define LTC_MD_AS_UPDATE               (0U)          /*!< Bit field value for LTC_MD_AS: Update */
#define LTC_MD_AS_INITIALIZE           (0x1U)        /*!< Bit field value for LTC_MD_AS: Initialize */
#define LTC_MD_AS_FINALIZE             (0x2U)        /*!< Bit field value for LTC_MD_AS: Finalize */
#define LTC_MD_AS_INIT_FINAL           (0x3U)        /*!< Bit field value for LTC_MD_AS: Initialize/Finalize */
/*! @brief Read current value of the LTC_MD_AS field. */
#define LTC_RD_MD_AS(base)   ((LTC_MD_REG(base) & LTC_MD_AS_MASK) >> LTC_MD_AS_SHIFT)
#define LTC_BRD_MD_AS(base)  (BME_UBFX32(&LTC_MD_REG(base), LTC_MD_AS_SHIFT, LTC_MD_AS_WIDTH))

/*! @brief Set the AS field to a new value. */
#define LTC_WR_MD_AS(base, value) (LTC_RMW_MD(base, LTC_MD_AS_MASK, LTC_MD_AS(value)))
#define LTC_BWR_MD_AS(base, value) (BME_BFI32(&LTC_MD_REG(base), ((uint32_t)(value) << LTC_MD_AS_SHIFT), LTC_MD_AS_SHIFT, LTC_MD_AS_WIDTH))
/*@}*/

/*!
 * @name Register LTC_MD, field AAI[12:4] (RW)
 *
 * Additional Algorithm information. This field contains additional mode
 * information that is associated with the algorithm that is being executed. See also
 * the section describing the appropriate CHA. Some algorithms do not require
 * additional algorithm information and in those cases this field should be all 0s.AAI
 * Interpretation for AES Modes[For AES the MSB of AAI is the DK (Decrypt Key)
 * bit.] CodeThe codes are mutually exclusive (i.e. they cannot be ORed with each
 * other).InterpretationCodeInterpretation00h CTR (mod 2128) 80hCCM, CCM*
 * 10hCBC90hReserved20hECBA0hCBC_XCBC_MAC30hreservedB0hCTR_XCBC_MAC40hreservedC0hReserved50hReservedD0hReserved60hCMACE0hReserved70hXCBC-MACSetting
 * the DK bit (i.e. ORing 100h with any AES code above) causes Key Register to
 * be loaded with the AES Dcrypt key, rather than the AES Encrypt key.
 */
/*@{*/
/*! @brief Read current value of the LTC_MD_AAI field. */
#define LTC_RD_MD_AAI(base)  ((LTC_MD_REG(base) & LTC_MD_AAI_MASK) >> LTC_MD_AAI_SHIFT)
#define LTC_BRD_MD_AAI(base) (BME_UBFX32(&LTC_MD_REG(base), LTC_MD_AAI_SHIFT, LTC_MD_AAI_WIDTH))

/*! @brief Set the AAI field to a new value. */
#define LTC_WR_MD_AAI(base, value) (LTC_RMW_MD(base, LTC_MD_AAI_MASK, LTC_MD_AAI(value)))
#define LTC_BWR_MD_AAI(base, value) (BME_BFI32(&LTC_MD_REG(base), ((uint32_t)(value) << LTC_MD_AAI_SHIFT), LTC_MD_AAI_SHIFT, LTC_MD_AAI_WIDTH))
/*@}*/

/*!
 * @name Register LTC_MD, field ALG[23:16] (RW)
 *
 * Algorithm. This field specifies which algorithm is being selected.
 *
 * Values:
 * - 0b00010000 - AES
 */
/*@{*/
#define LTC_MD_ALG_AES                 (0x10U)       /*!< Bit field value for LTC_MD_ALG: AES */
/*! @brief Read current value of the LTC_MD_ALG field. */
#define LTC_RD_MD_ALG(base)  ((LTC_MD_REG(base) & LTC_MD_ALG_MASK) >> LTC_MD_ALG_SHIFT)
#define LTC_BRD_MD_ALG(base) (BME_UBFX32(&LTC_MD_REG(base), LTC_MD_ALG_SHIFT, LTC_MD_ALG_WIDTH))

/*! @brief Set the ALG field to a new value. */
#define LTC_WR_MD_ALG(base, value) (LTC_RMW_MD(base, LTC_MD_ALG_MASK, LTC_MD_ALG(value)))
#define LTC_BWR_MD_ALG(base, value) (BME_BFI32(&LTC_MD_REG(base), ((uint32_t)(value) << LTC_MD_ALG_SHIFT), LTC_MD_ALG_SHIFT, LTC_MD_ALG_WIDTH))
/*@}*/

/*******************************************************************************
 * LTC_KS - LTC Key Size Register
 ******************************************************************************/

/*!
 * @brief LTC_KS - LTC Key Size Register (RW)
 *
 * Reset value: 0x00000010U
 *
 * The Key Size Register is used to tell the crypto engine(AES) the size of the
 * key that was loaded into the Key Register. The Key Size Register must be
 * written after the key is written into the Key Register. Writing to the Key Size
 * Register will prevent the user from modifying the Key Register. Only 16 byte keys
 * are supported so this register will always read 16 bytes. This register is
 * still required to be written to indicate to the AES engine that the key was
 * loaded.
 */
/*!
 * @name Constants and macros for entire LTC_KS register
 */
/*@{*/
#define LTC_RD_KS(base)          (LTC_KS_REG(base))
#define LTC_WR_KS(base, value)   (LTC_KS_REG(base) = (value))
#define LTC_RMW_KS(base, mask, value) (LTC_WR_KS(base, (LTC_RD_KS(base) & ~(mask)) | (value)))
#define LTC_SET_KS(base, value)  (BME_OR32(&LTC_KS_REG(base), (uint32_t)(value)))
#define LTC_CLR_KS(base, value)  (BME_AND32(&LTC_KS_REG(base), (uint32_t)(~(value))))
#define LTC_TOG_KS(base, value)  (BME_XOR32(&LTC_KS_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * LTC_DS - LTC Data Size Register
 ******************************************************************************/

/*!
 * @brief LTC_DS - LTC Data Size Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Data Size Register is used to tell the AES the amount of data that will
 * be loaded into the Input Data FIFO. This register should only be written to
 * once during a single operation. Note that writing to the , will cause this
 * register to also update. When this register is then written directory to then the
 * new value will be added to the previous value in the register. That is, if the
 * DS field currently has the value 16, writing 2 to the least-significant half of
 * the Data Size register (i.e. the DS field) will result in a value of 18 in
 * the DS field. Note that AES decrements this register, so reading the register
 * may return a value less than sum of the values that were written into it. This
 * register is cleared whenever a key is decrypted or encrypted.
 */
/*!
 * @name Constants and macros for entire LTC_DS register
 */
/*@{*/
#define LTC_RD_DS(base)          (LTC_DS_REG(base))
#define LTC_WR_DS(base, value)   (LTC_DS_REG(base) = (value))
#define LTC_RMW_DS(base, mask, value) (LTC_WR_DS(base, (LTC_RD_DS(base) & ~(mask)) | (value)))
#define LTC_SET_DS(base, value)  (BME_OR32(&LTC_DS_REG(base), (uint32_t)(value)))
#define LTC_CLR_DS(base, value)  (BME_AND32(&LTC_DS_REG(base), (uint32_t)(~(value))))
#define LTC_TOG_DS(base, value)  (BME_XOR32(&LTC_DS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LTC_DS bitfields
 */

/*!
 * @name Register LTC_DS, field DS[11:0] (RW)
 *
 * Data Size. This is the number of whole bytes of data that will be consumed by
 * the CHA. Note that writing the AAD Size Register will result in this register
 * also being written to.
 */
/*@{*/
/*! @brief Read current value of the LTC_DS_DS field. */
#define LTC_RD_DS_DS(base)   ((LTC_DS_REG(base) & LTC_DS_DS_MASK) >> LTC_DS_DS_SHIFT)
#define LTC_BRD_DS_DS(base)  (BME_UBFX32(&LTC_DS_REG(base), LTC_DS_DS_SHIFT, LTC_DS_DS_WIDTH))

/*! @brief Set the DS field to a new value. */
#define LTC_WR_DS_DS(base, value) (LTC_RMW_DS(base, LTC_DS_DS_MASK, LTC_DS_DS(value)))
#define LTC_BWR_DS_DS(base, value) (BME_BFI32(&LTC_DS_REG(base), ((uint32_t)(value) << LTC_DS_DS_SHIFT), LTC_DS_DS_SHIFT, LTC_DS_DS_WIDTH))
/*@}*/

/*******************************************************************************
 * LTC_ICVS - LTC ICV Size Register
 ******************************************************************************/

/*!
 * @brief LTC_ICVS - LTC ICV Size Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The ICV Size Register indicates how much of the last block of ICV is valid
 * when performing AES integrity check modes (e.g. AES-CMAC, AES-XCBC-MAC). This
 * register must be written prior to the corresponding word of data being consumed
 * by AES. In practical terms, this means the register must be written prior to
 * the corresponding data being written to the Input Data FIFO.
 */
/*!
 * @name Constants and macros for entire LTC_ICVS register
 */
/*@{*/
#define LTC_RD_ICVS(base)        (LTC_ICVS_REG(base))
#define LTC_WR_ICVS(base, value) (LTC_ICVS_REG(base) = (value))
#define LTC_RMW_ICVS(base, mask, value) (LTC_WR_ICVS(base, (LTC_RD_ICVS(base) & ~(mask)) | (value)))
#define LTC_SET_ICVS(base, value) (BME_OR32(&LTC_ICVS_REG(base), (uint32_t)(value)))
#define LTC_CLR_ICVS(base, value) (BME_AND32(&LTC_ICVS_REG(base), (uint32_t)(~(value))))
#define LTC_TOG_ICVS(base, value) (BME_XOR32(&LTC_ICVS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LTC_ICVS bitfields
 */

/*!
 * @name Register LTC_ICVS, field ICVS[4:0] (RW)
 *
 * ICV Size, in Bytes.
 */
/*@{*/
/*! @brief Read current value of the LTC_ICVS_ICVS field. */
#define LTC_RD_ICVS_ICVS(base) ((LTC_ICVS_REG(base) & LTC_ICVS_ICVS_MASK) >> LTC_ICVS_ICVS_SHIFT)
#define LTC_BRD_ICVS_ICVS(base) (BME_UBFX32(&LTC_ICVS_REG(base), LTC_ICVS_ICVS_SHIFT, LTC_ICVS_ICVS_WIDTH))

/*! @brief Set the ICVS field to a new value. */
#define LTC_WR_ICVS_ICVS(base, value) (LTC_RMW_ICVS(base, LTC_ICVS_ICVS_MASK, LTC_ICVS_ICVS(value)))
#define LTC_BWR_ICVS_ICVS(base, value) (BME_BFI32(&LTC_ICVS_REG(base), ((uint32_t)(value) << LTC_ICVS_ICVS_SHIFT), LTC_ICVS_ICVS_SHIFT, LTC_ICVS_ICVS_WIDTH))
/*@}*/

/*******************************************************************************
 * LTC_COM - LTC Command Register
 ******************************************************************************/

/*!
 * @brief LTC_COM - LTC Command Register (WO)
 *
 * Reset value: 0x00000000U
 *
 * The LTC Command Register is used to send control signals to the Crypto
 * Engines.
 */
/*!
 * @name Constants and macros for entire LTC_COM register
 */
/*@{*/
#define LTC_WR_COM(base, value)  (LTC_COM_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual LTC_COM bitfields
 */

/*!
 * @name Register LTC_COM, field ALL[0] (WO)
 *
 * Reset All Internal Logic. Writing to this bit will reset all accelerator
 * engines and as well as all the internal registers.
 *
 * Values:
 * - 0b0 - Do Not Reset
 * - 0b1 - Reset all CHAs in use by this CCB.
 */
/*@{*/
#define LTC_COM_ALL_NO_RESET           (0U)          /*!< Bit field value for LTC_COM_ALL: Do Not Reset */
#define LTC_COM_ALL_RESET_ALL          (0x1U)        /*!< Bit field value for LTC_COM_ALL: Reset all CHAs in use by this CCB. */
/*! @brief Set the ALL field to a new value. */
#define LTC_WR_COM_ALL(base, value) (LTC_WR_COM(base, LTC_COM_ALL(value)))
#define LTC_BWR_COM_ALL(base, value) (LTC_WR_COM_ALL(base, value))
/*@}*/

/*!
 * @name Register LTC_COM, field AES[1] (WO)
 *
 * Reset AESA. Writing a 1 to this bit resets the AES Accelerator core engine.
 *
 * Values:
 * - 0b0 - Do Not Reset
 * - 0b1 - Reset AES Accelerator
 */
/*@{*/
#define LTC_COM_AES_NO_RESET           (0U)          /*!< Bit field value for LTC_COM_AES: Do Not Reset */
#define LTC_COM_AES_RESET_AESA         (0x1U)        /*!< Bit field value for LTC_COM_AES: Reset AES Accelerator */
/*! @brief Set the AES field to a new value. */
#define LTC_WR_COM_AES(base, value) (LTC_WR_COM(base, LTC_COM_AES(value)))
#define LTC_BWR_COM_AES(base, value) (LTC_WR_COM_AES(base, value))
/*@}*/

/*******************************************************************************
 * LTC_CTL - LTC Control Register
 ******************************************************************************/

/*!
 * @brief LTC_CTL - LTC Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is used for some of the internal controls of the LTC block.
 */
/*!
 * @name Constants and macros for entire LTC_CTL register
 */
/*@{*/
#define LTC_RD_CTL(base)         (LTC_CTL_REG(base))
#define LTC_WR_CTL(base, value)  (LTC_CTL_REG(base) = (value))
#define LTC_RMW_CTL(base, mask, value) (LTC_WR_CTL(base, (LTC_RD_CTL(base) & ~(mask)) | (value)))
#define LTC_SET_CTL(base, value) (BME_OR32(&LTC_CTL_REG(base), (uint32_t)(value)))
#define LTC_CLR_CTL(base, value) (BME_AND32(&LTC_CTL_REG(base), (uint32_t)(~(value))))
#define LTC_TOG_CTL(base, value) (BME_XOR32(&LTC_CTL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LTC_CTL bitfields
 */

/*!
 * @name Register LTC_CTL, field IM[0] (RW)
 *
 * Interrupt Mask. Once this bit is set, it can only be cleared by hard reset.
 *
 * Values:
 * - 0b0 - Interrupt not masked.
 * - 0b1 - Interrupt masked
 */
/*@{*/
#define LTC_CTL_IM_INT_NOT_MASKED      (0U)          /*!< Bit field value for LTC_CTL_IM: Interrupt not masked. */
#define LTC_CTL_IM_INT_MASKED          (0x1U)        /*!< Bit field value for LTC_CTL_IM: Interrupt masked */
/*! @brief Read current value of the LTC_CTL_IM field. */
#define LTC_RD_CTL_IM(base)  ((LTC_CTL_REG(base) & LTC_CTL_IM_MASK) >> LTC_CTL_IM_SHIFT)
#define LTC_BRD_CTL_IM(base) (BME_UBFX32(&LTC_CTL_REG(base), LTC_CTL_IM_SHIFT, LTC_CTL_IM_WIDTH))

/*! @brief Set the IM field to a new value. */
#define LTC_WR_CTL_IM(base, value) (LTC_RMW_CTL(base, LTC_CTL_IM_MASK, LTC_CTL_IM(value)))
#define LTC_BWR_CTL_IM(base, value) (BME_BFI32(&LTC_CTL_REG(base), ((uint32_t)(value) << LTC_CTL_IM_SHIFT), LTC_CTL_IM_SHIFT, LTC_CTL_IM_WIDTH))
/*@}*/

/*!
 * @name Register LTC_CTL, field IFE[8] (RW)
 *
 * Input FIFO DMA Enable.
 *
 * Values:
 * - 0b0 - DMA Request and Done signals disabled for the Input FIFO.
 * - 0b1 - DMA Request and Done signals enabled for the Input FIFO.
 */
/*@{*/
#define LTC_CTL_IFE_IFE_DISABLED       (0U)          /*!< Bit field value for LTC_CTL_IFE: DMA Request and Done signals disabled for the Input FIFO. */
#define LTC_CTL_IFE_IFE_ENABLED        (0x1U)        /*!< Bit field value for LTC_CTL_IFE: DMA Request and Done signals enabled for the Input FIFO. */
/*! @brief Read current value of the LTC_CTL_IFE field. */
#define LTC_RD_CTL_IFE(base) ((LTC_CTL_REG(base) & LTC_CTL_IFE_MASK) >> LTC_CTL_IFE_SHIFT)
#define LTC_BRD_CTL_IFE(base) (BME_UBFX32(&LTC_CTL_REG(base), LTC_CTL_IFE_SHIFT, LTC_CTL_IFE_WIDTH))

/*! @brief Set the IFE field to a new value. */
#define LTC_WR_CTL_IFE(base, value) (LTC_RMW_CTL(base, LTC_CTL_IFE_MASK, LTC_CTL_IFE(value)))
#define LTC_BWR_CTL_IFE(base, value) (BME_BFI32(&LTC_CTL_REG(base), ((uint32_t)(value) << LTC_CTL_IFE_SHIFT), LTC_CTL_IFE_SHIFT, LTC_CTL_IFE_WIDTH))
/*@}*/

/*!
 * @name Register LTC_CTL, field IFR[9] (RW)
 *
 * Input FIFO DMA Request Size. The DMA request logic will only request data if
 * the INPUT FIFO has enough space for the request size.
 *
 * Values:
 * - 0b0 - DMA request size is 1 entry.
 * - 0b1 - DMA request size is 4 entries.
 */
/*@{*/
#define LTC_CTL_IFR_IFR_1              (0U)          /*!< Bit field value for LTC_CTL_IFR: DMA request size is 1 entry. */
#define LTC_CTL_IFR_IFR_4              (0x1U)        /*!< Bit field value for LTC_CTL_IFR: DMA request size is 4 entries. */
/*! @brief Read current value of the LTC_CTL_IFR field. */
#define LTC_RD_CTL_IFR(base) ((LTC_CTL_REG(base) & LTC_CTL_IFR_MASK) >> LTC_CTL_IFR_SHIFT)
#define LTC_BRD_CTL_IFR(base) (BME_UBFX32(&LTC_CTL_REG(base), LTC_CTL_IFR_SHIFT, LTC_CTL_IFR_WIDTH))

/*! @brief Set the IFR field to a new value. */
#define LTC_WR_CTL_IFR(base, value) (LTC_RMW_CTL(base, LTC_CTL_IFR_MASK, LTC_CTL_IFR(value)))
#define LTC_BWR_CTL_IFR(base, value) (BME_BFI32(&LTC_CTL_REG(base), ((uint32_t)(value) << LTC_CTL_IFR_SHIFT), LTC_CTL_IFR_SHIFT, LTC_CTL_IFR_WIDTH))
/*@}*/

/*!
 * @name Register LTC_CTL, field OFE[12] (RW)
 *
 * Output FIFO DMA Enable.
 *
 * Values:
 * - 0b0 - DMA Request and Done signals disabled for the Output FIFO.
 * - 0b1 - DMA Request and Done signals enabled for the Output FIFO.
 */
/*@{*/
#define LTC_CTL_OFE_OFE_DISABLED       (0U)          /*!< Bit field value for LTC_CTL_OFE: DMA Request and Done signals disabled for the Output FIFO. */
#define LTC_CTL_OFE_OFE_ENABLED        (0x1U)        /*!< Bit field value for LTC_CTL_OFE: DMA Request and Done signals enabled for the Output FIFO. */
/*! @brief Read current value of the LTC_CTL_OFE field. */
#define LTC_RD_CTL_OFE(base) ((LTC_CTL_REG(base) & LTC_CTL_OFE_MASK) >> LTC_CTL_OFE_SHIFT)
#define LTC_BRD_CTL_OFE(base) (BME_UBFX32(&LTC_CTL_REG(base), LTC_CTL_OFE_SHIFT, LTC_CTL_OFE_WIDTH))

/*! @brief Set the OFE field to a new value. */
#define LTC_WR_CTL_OFE(base, value) (LTC_RMW_CTL(base, LTC_CTL_OFE_MASK, LTC_CTL_OFE(value)))
#define LTC_BWR_CTL_OFE(base, value) (BME_BFI32(&LTC_CTL_REG(base), ((uint32_t)(value) << LTC_CTL_OFE_SHIFT), LTC_CTL_OFE_SHIFT, LTC_CTL_OFE_WIDTH))
/*@}*/

/*!
 * @name Register LTC_CTL, field OFR[13] (RW)
 *
 * Output FIFO DMA Request Size. The DMA request logic will only request data if
 * the OUTPUT FIFO has enough data to satisfy the request.
 *
 * Values:
 * - 0b0 - DMA request size is 1 entry.
 * - 0b1 - DMA request size is 4 entries.
 */
/*@{*/
#define LTC_CTL_OFR_OFR_1              (0U)          /*!< Bit field value for LTC_CTL_OFR: DMA request size is 1 entry. */
#define LTC_CTL_OFR_OFR_4              (0x1U)        /*!< Bit field value for LTC_CTL_OFR: DMA request size is 4 entries. */
/*! @brief Read current value of the LTC_CTL_OFR field. */
#define LTC_RD_CTL_OFR(base) ((LTC_CTL_REG(base) & LTC_CTL_OFR_MASK) >> LTC_CTL_OFR_SHIFT)
#define LTC_BRD_CTL_OFR(base) (BME_UBFX32(&LTC_CTL_REG(base), LTC_CTL_OFR_SHIFT, LTC_CTL_OFR_WIDTH))

/*! @brief Set the OFR field to a new value. */
#define LTC_WR_CTL_OFR(base, value) (LTC_RMW_CTL(base, LTC_CTL_OFR_MASK, LTC_CTL_OFR(value)))
#define LTC_BWR_CTL_OFR(base, value) (BME_BFI32(&LTC_CTL_REG(base), ((uint32_t)(value) << LTC_CTL_OFR_SHIFT), LTC_CTL_OFR_SHIFT, LTC_CTL_OFR_WIDTH))
/*@}*/

/*!
 * @name Register LTC_CTL, field IFS[16] (RW)
 *
 * Input FIFO Byte Swap. Byte swap all data that is written to the Input FIFO.
 *
 * Values:
 * - 0b0 - Do Not Byte Swap Data.
 * - 0b1 - Byte Swap Data.
 */
/*@{*/
#define LTC_CTL_IFS_IFS_NO_SWAP        (0U)          /*!< Bit field value for LTC_CTL_IFS: Do Not Byte Swap Data. */
#define LTC_CTL_IFS_IFS_SWAP           (0x1U)        /*!< Bit field value for LTC_CTL_IFS: Byte Swap Data. */
/*! @brief Read current value of the LTC_CTL_IFS field. */
#define LTC_RD_CTL_IFS(base) ((LTC_CTL_REG(base) & LTC_CTL_IFS_MASK) >> LTC_CTL_IFS_SHIFT)
#define LTC_BRD_CTL_IFS(base) (BME_UBFX32(&LTC_CTL_REG(base), LTC_CTL_IFS_SHIFT, LTC_CTL_IFS_WIDTH))

/*! @brief Set the IFS field to a new value. */
#define LTC_WR_CTL_IFS(base, value) (LTC_RMW_CTL(base, LTC_CTL_IFS_MASK, LTC_CTL_IFS(value)))
#define LTC_BWR_CTL_IFS(base, value) (BME_BFI32(&LTC_CTL_REG(base), ((uint32_t)(value) << LTC_CTL_IFS_SHIFT), LTC_CTL_IFS_SHIFT, LTC_CTL_IFS_WIDTH))
/*@}*/

/*!
 * @name Register LTC_CTL, field OFS[17] (RW)
 *
 * Output FIFO Byte Swap. Byte swap all data that is read from the Onput FIFO.
 *
 * Values:
 * - 0b0 - Do Not Byte Swap Data.
 * - 0b1 - Byte Swap Data.
 */
/*@{*/
#define LTC_CTL_OFS_OFS_NO_SWAP        (0U)          /*!< Bit field value for LTC_CTL_OFS: Do Not Byte Swap Data. */
#define LTC_CTL_OFS_OFS_SWAP           (0x1U)        /*!< Bit field value for LTC_CTL_OFS: Byte Swap Data. */
/*! @brief Read current value of the LTC_CTL_OFS field. */
#define LTC_RD_CTL_OFS(base) ((LTC_CTL_REG(base) & LTC_CTL_OFS_MASK) >> LTC_CTL_OFS_SHIFT)
#define LTC_BRD_CTL_OFS(base) (BME_UBFX32(&LTC_CTL_REG(base), LTC_CTL_OFS_SHIFT, LTC_CTL_OFS_WIDTH))

/*! @brief Set the OFS field to a new value. */
#define LTC_WR_CTL_OFS(base, value) (LTC_RMW_CTL(base, LTC_CTL_OFS_MASK, LTC_CTL_OFS(value)))
#define LTC_BWR_CTL_OFS(base, value) (BME_BFI32(&LTC_CTL_REG(base), ((uint32_t)(value) << LTC_CTL_OFS_SHIFT), LTC_CTL_OFS_SHIFT, LTC_CTL_OFS_WIDTH))
/*@}*/

/*!
 * @name Register LTC_CTL, field KIS[20] (RW)
 *
 * Key Register Input Byte Swap. Byte swap all data that is written to the key
 * register. Data is byte swapped only within a single word.
 *
 * Values:
 * - 0b0 - Do Not Byte Swap Data.
 * - 0b1 - Byte Swap Data.
 */
/*@{*/
#define LTC_CTL_KIS_KIS_NO_SWAP        (0U)          /*!< Bit field value for LTC_CTL_KIS: Do Not Byte Swap Data. */
#define LTC_CTL_KIS_KIS_SWAP           (0x1U)        /*!< Bit field value for LTC_CTL_KIS: Byte Swap Data. */
/*! @brief Read current value of the LTC_CTL_KIS field. */
#define LTC_RD_CTL_KIS(base) ((LTC_CTL_REG(base) & LTC_CTL_KIS_MASK) >> LTC_CTL_KIS_SHIFT)
#define LTC_BRD_CTL_KIS(base) (BME_UBFX32(&LTC_CTL_REG(base), LTC_CTL_KIS_SHIFT, LTC_CTL_KIS_WIDTH))

/*! @brief Set the KIS field to a new value. */
#define LTC_WR_CTL_KIS(base, value) (LTC_RMW_CTL(base, LTC_CTL_KIS_MASK, LTC_CTL_KIS(value)))
#define LTC_BWR_CTL_KIS(base, value) (BME_BFI32(&LTC_CTL_REG(base), ((uint32_t)(value) << LTC_CTL_KIS_SHIFT), LTC_CTL_KIS_SHIFT, LTC_CTL_KIS_WIDTH))
/*@}*/

/*!
 * @name Register LTC_CTL, field KOS[21] (RW)
 *
 * Key Register Output Byte Swap. Byte swap all data that is read from the key
 * register. Data is byte swapped only within a single word.
 *
 * Values:
 * - 0b0 - Do Not Byte Swap Data.
 * - 0b1 - Byte Swap Data.
 */
/*@{*/
#define LTC_CTL_KOS_KOS_NO_SWAP        (0U)          /*!< Bit field value for LTC_CTL_KOS: Do Not Byte Swap Data. */
#define LTC_CTL_KOS_KOS_SWAP           (0x1U)        /*!< Bit field value for LTC_CTL_KOS: Byte Swap Data. */
/*! @brief Read current value of the LTC_CTL_KOS field. */
#define LTC_RD_CTL_KOS(base) ((LTC_CTL_REG(base) & LTC_CTL_KOS_MASK) >> LTC_CTL_KOS_SHIFT)
#define LTC_BRD_CTL_KOS(base) (BME_UBFX32(&LTC_CTL_REG(base), LTC_CTL_KOS_SHIFT, LTC_CTL_KOS_WIDTH))

/*! @brief Set the KOS field to a new value. */
#define LTC_WR_CTL_KOS(base, value) (LTC_RMW_CTL(base, LTC_CTL_KOS_MASK, LTC_CTL_KOS(value)))
#define LTC_BWR_CTL_KOS(base, value) (BME_BFI32(&LTC_CTL_REG(base), ((uint32_t)(value) << LTC_CTL_KOS_SHIFT), LTC_CTL_KOS_SHIFT, LTC_CTL_KOS_WIDTH))
/*@}*/

/*!
 * @name Register LTC_CTL, field CIS[22] (RW)
 *
 * Context Register Input Byte Swap. Byte swap all data that is written to the
 * context register. Data is byte swapped only within a single word.
 *
 * Values:
 * - 0b0 - Do Not Byte Swap Data.
 * - 0b1 - Byte Swap Data.
 */
/*@{*/
#define LTC_CTL_CIS_CIS_NO_SWAP        (0U)          /*!< Bit field value for LTC_CTL_CIS: Do Not Byte Swap Data. */
#define LTC_CTL_CIS_CIS_SWAP           (0x1U)        /*!< Bit field value for LTC_CTL_CIS: Byte Swap Data. */
/*! @brief Read current value of the LTC_CTL_CIS field. */
#define LTC_RD_CTL_CIS(base) ((LTC_CTL_REG(base) & LTC_CTL_CIS_MASK) >> LTC_CTL_CIS_SHIFT)
#define LTC_BRD_CTL_CIS(base) (BME_UBFX32(&LTC_CTL_REG(base), LTC_CTL_CIS_SHIFT, LTC_CTL_CIS_WIDTH))

/*! @brief Set the CIS field to a new value. */
#define LTC_WR_CTL_CIS(base, value) (LTC_RMW_CTL(base, LTC_CTL_CIS_MASK, LTC_CTL_CIS(value)))
#define LTC_BWR_CTL_CIS(base, value) (BME_BFI32(&LTC_CTL_REG(base), ((uint32_t)(value) << LTC_CTL_CIS_SHIFT), LTC_CTL_CIS_SHIFT, LTC_CTL_CIS_WIDTH))
/*@}*/

/*!
 * @name Register LTC_CTL, field COS[23] (RW)
 *
 * Context Register Output Byte Swap. Byte swap all data that is read from the
 * context register. Data is byte swapped only within a single word.
 *
 * Values:
 * - 0b0 - Do Not Byte Swap Data.
 * - 0b1 - Byte Swap Data.
 */
/*@{*/
#define LTC_CTL_COS_COS_NO_SWAP        (0U)          /*!< Bit field value for LTC_CTL_COS: Do Not Byte Swap Data. */
#define LTC_CTL_COS_COS_SWAP           (0x1U)        /*!< Bit field value for LTC_CTL_COS: Byte Swap Data. */
/*! @brief Read current value of the LTC_CTL_COS field. */
#define LTC_RD_CTL_COS(base) ((LTC_CTL_REG(base) & LTC_CTL_COS_MASK) >> LTC_CTL_COS_SHIFT)
#define LTC_BRD_CTL_COS(base) (BME_UBFX32(&LTC_CTL_REG(base), LTC_CTL_COS_SHIFT, LTC_CTL_COS_WIDTH))

/*! @brief Set the COS field to a new value. */
#define LTC_WR_CTL_COS(base, value) (LTC_RMW_CTL(base, LTC_CTL_COS_MASK, LTC_CTL_COS(value)))
#define LTC_BWR_CTL_COS(base, value) (BME_BFI32(&LTC_CTL_REG(base), ((uint32_t)(value) << LTC_CTL_COS_SHIFT), LTC_CTL_COS_SHIFT, LTC_CTL_COS_WIDTH))
/*@}*/

/*!
 * @name Register LTC_CTL, field KAL[31] (RW)
 *
 * Key Register Access Lock. Read access to the key register is blocked. Any
 * reads of the key register will only return zero. Once this bit is set, it can
 * only be cleared by hard reset.
 *
 * Values:
 * - 0b0 - Key Register is readable.
 * - 0b1 - Key Register is not readable.
 */
/*@{*/
#define LTC_CTL_KAL_KAL_READABLE       (0U)          /*!< Bit field value for LTC_CTL_KAL: Key Register is readable. */
#define LTC_CTL_KAL_KAL_NOT_READABLE   (0x1U)        /*!< Bit field value for LTC_CTL_KAL: Key Register is not readable. */
/*! @brief Read current value of the LTC_CTL_KAL field. */
#define LTC_RD_CTL_KAL(base) ((LTC_CTL_REG(base) & LTC_CTL_KAL_MASK) >> LTC_CTL_KAL_SHIFT)
#define LTC_BRD_CTL_KAL(base) (BME_UBFX32(&LTC_CTL_REG(base), LTC_CTL_KAL_SHIFT, LTC_CTL_KAL_WIDTH))

/*! @brief Set the KAL field to a new value. */
#define LTC_WR_CTL_KAL(base, value) (LTC_RMW_CTL(base, LTC_CTL_KAL_MASK, LTC_CTL_KAL(value)))
#define LTC_BWR_CTL_KAL(base, value) (BME_BFI32(&LTC_CTL_REG(base), ((uint32_t)(value) << LTC_CTL_KAL_SHIFT), LTC_CTL_KAL_SHIFT, LTC_CTL_KAL_WIDTH))
/*@}*/

/*******************************************************************************
 * LTC_CW - LTC Clear Written Register
 ******************************************************************************/

/*!
 * @brief LTC_CW - LTC Clear Written Register (WO)
 *
 * Reset value: 0x00000000U
 *
 * The Clear Written Register is used to clear many of the internal registers.
 * All fields of this register are self-clearing.
 */
/*!
 * @name Constants and macros for entire LTC_CW register
 */
/*@{*/
#define LTC_WR_CW(base, value)   (LTC_CW_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual LTC_CW bitfields
 */

/*!
 * @name Register LTC_CW, field CM[0] (WO)
 *
 * Clear the Mode Register. Writing a one to this bit causes the Mode Register
 * to be cleared.
 */
/*@{*/
/*! @brief Set the CM field to a new value. */
#define LTC_WR_CW_CM(base, value) (LTC_WR_CW(base, LTC_CW_CM(value)))
#define LTC_BWR_CW_CM(base, value) (LTC_WR_CW_CM(base, value))
/*@}*/

/*!
 * @name Register LTC_CW, field CDS[2] (WO)
 *
 * Clear the Data Size Register. Writing a one to this bit causes the Data Size
 * Register to be cleared. This clears AAD Size as well.
 */
/*@{*/
/*! @brief Set the CDS field to a new value. */
#define LTC_WR_CW_CDS(base, value) (LTC_WR_CW(base, LTC_CW_CDS(value)))
#define LTC_BWR_CW_CDS(base, value) (LTC_WR_CW_CDS(base, value))
/*@}*/

/*!
 * @name Register LTC_CW, field CICV[3] (WO)
 *
 * Clear the ICV Size Register. Writing a one to this bit causes the ICV Size
 * Register to be cleared.
 */
/*@{*/
/*! @brief Set the CICV field to a new value. */
#define LTC_WR_CW_CICV(base, value) (LTC_WR_CW(base, LTC_CW_CICV(value)))
#define LTC_BWR_CW_CICV(base, value) (LTC_WR_CW_CICV(base, value))
/*@}*/

/*!
 * @name Register LTC_CW, field CCR[5] (WO)
 *
 * Clear the Context Register. Writing a one to this bit causes the Context
 * Register to be cleared.
 */
/*@{*/
/*! @brief Set the CCR field to a new value. */
#define LTC_WR_CW_CCR(base, value) (LTC_WR_CW(base, LTC_CW_CCR(value)))
#define LTC_BWR_CW_CCR(base, value) (LTC_WR_CW_CCR(base, value))
/*@}*/

/*!
 * @name Register LTC_CW, field CKR[6] (WO)
 *
 * Clear the Key Register. Writing a one to this bit causes the Key and Key Size
 * Registers to be cleared.
 */
/*@{*/
/*! @brief Set the CKR field to a new value. */
#define LTC_WR_CW_CKR(base, value) (LTC_WR_CW(base, LTC_CW_CKR(value)))
#define LTC_BWR_CW_CKR(base, value) (LTC_WR_CW_CKR(base, value))
/*@}*/

/*!
 * @name Register LTC_CW, field COF[30] (WO)
 *
 * Clear Output FIFO. Writing a 1 to this bit causes the Output FIFO to be
 * cleared.
 */
/*@{*/
/*! @brief Set the COF field to a new value. */
#define LTC_WR_CW_COF(base, value) (LTC_WR_CW(base, LTC_CW_COF(value)))
#define LTC_BWR_CW_COF(base, value) (LTC_WR_CW_COF(base, value))
/*@}*/

/*!
 * @name Register LTC_CW, field CIF[31] (WO)
 *
 * Clear Input FIFO. Writing a 1 to this bit causes the Input Data FIFO.
 */
/*@{*/
/*! @brief Set the CIF field to a new value. */
#define LTC_WR_CW_CIF(base, value) (LTC_WR_CW(base, LTC_CW_CIF(value)))
#define LTC_BWR_CW_CIF(base, value) (LTC_WR_CW_CIF(base, value))
/*@}*/

/*******************************************************************************
 * LTC_STA - LTC Status Register
 ******************************************************************************/

/*!
 * @brief LTC_STA - LTC Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The LTC Status Register shows the status of the internal Crypto engine and
 * its internal registers.
 */
/*!
 * @name Constants and macros for entire LTC_STA register
 */
/*@{*/
#define LTC_RD_STA(base)         (LTC_STA_REG(base))
#define LTC_WR_STA(base, value)  (LTC_STA_REG(base) = (value))
#define LTC_RMW_STA(base, mask, value) (LTC_WR_STA(base, (LTC_RD_STA(base) & ~(mask)) | (value)))
#define LTC_SET_STA(base, value) (BME_OR32(&LTC_STA_REG(base), (uint32_t)(value)))
#define LTC_CLR_STA(base, value) (BME_AND32(&LTC_STA_REG(base), (uint32_t)(~(value))))
#define LTC_TOG_STA(base, value) (BME_XOR32(&LTC_STA_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LTC_STA bitfields
 */

/*!
 * @name Register LTC_STA, field AB[1] (RO)
 *
 * AESA Busy. This bit indicates that the AES Accelertor is busy. The CHA can
 * either be busy processing data or resetting.
 *
 * Values:
 * - 0b0 - AESA Idle
 * - 0b1 - AESA Busy.
 */
/*@{*/
#define LTC_STA_AB_AESA_IDLE           (0U)          /*!< Bit field value for LTC_STA_AB: AESA Idle */
#define LTC_STA_AB_AESA_BUSY           (0x1U)        /*!< Bit field value for LTC_STA_AB: AESA Busy. */
/*! @brief Read current value of the LTC_STA_AB field. */
#define LTC_RD_STA_AB(base)  ((LTC_STA_REG(base) & LTC_STA_AB_MASK) >> LTC_STA_AB_SHIFT)
#define LTC_BRD_STA_AB(base) (BME_UBFX32(&LTC_STA_REG(base), LTC_STA_AB_SHIFT, LTC_STA_AB_WIDTH))
/*@}*/

/*!
 * @name Register LTC_STA, field DI[16] (W1C)
 *
 * Done Interrupt. The Done Interrupt has been asserted. ValueReadWrite0No Done
 * InterruptNo change1Done Interrupt assertedClear the Done Interrupt
 */
/*@{*/
/*! @brief Read current value of the LTC_STA_DI field. */
#define LTC_RD_STA_DI(base)  ((LTC_STA_REG(base) & LTC_STA_DI_MASK) >> LTC_STA_DI_SHIFT)
#define LTC_BRD_STA_DI(base) (BME_UBFX32(&LTC_STA_REG(base), LTC_STA_DI_SHIFT, LTC_STA_DI_WIDTH))

/*! @brief Set the DI field to a new value. */
#define LTC_WR_STA_DI(base, value) (LTC_RMW_STA(base, LTC_STA_DI_MASK, LTC_STA_DI(value)))
#define LTC_BWR_STA_DI(base, value) (BME_BFI32(&LTC_STA_REG(base), ((uint32_t)(value) << LTC_STA_DI_SHIFT), LTC_STA_DI_SHIFT, LTC_STA_DI_WIDTH))
/*@}*/

/*!
 * @name Register LTC_STA, field EI[20] (RO)
 *
 * Error Interrupt. The Error Interrupt has been asserted. This error can only
 * be cleared by resetting LTC.
 *
 * Values:
 * - 0b0 - Not Error.
 * - 0b1 - Error Interrupt.
 */
/*@{*/
#define LTC_STA_EI_NOT_ERROR_INT       (0U)          /*!< Bit field value for LTC_STA_EI: Not Error. */
#define LTC_STA_EI_ERROR_INT           (0x1U)        /*!< Bit field value for LTC_STA_EI: Error Interrupt. */
/*! @brief Read current value of the LTC_STA_EI field. */
#define LTC_RD_STA_EI(base)  ((LTC_STA_REG(base) & LTC_STA_EI_MASK) >> LTC_STA_EI_SHIFT)
#define LTC_BRD_STA_EI(base) (BME_UBFX32(&LTC_STA_REG(base), LTC_STA_EI_SHIFT, LTC_STA_EI_WIDTH))
/*@}*/

/*******************************************************************************
 * LTC_ESTA - LTC Error Status Register
 ******************************************************************************/

/*!
 * @brief LTC_ESTA - LTC Error Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The LTC Error Register shows the status of the internal Crypto Engine and its
 * internal registers.
 */
/*!
 * @name Constants and macros for entire LTC_ESTA register
 */
/*@{*/
#define LTC_RD_ESTA(base)        (LTC_ESTA_REG(base))
/*@}*/

/*
 * Constants & macros for individual LTC_ESTA bitfields
 */

/*!
 * @name Register LTC_ESTA, field ERRID1[3:0] (RO)
 *
 * Error ID 1. These bits indicate the type of error that was found while
 * processing the Descriptor. The Algorithm that is associated with the error can be
 * found in the CL1 field.Others reserved.
 *
 * Values:
 * - 0b0001 - Mode Error
 * - 0b0010 - Data Size Error
 * - 0b0011 - Key Size Error
 * - 0b0110 - Data Arrived out of Sequence Error
 * - 0b1010 - ICV Check Failed
 * - 0b1011 - Internal Hardware Failure
 * - 0b1100 - CCM AAD Size Error (either 1. AAD flag in B0 =1 and no AAD type
 *     provided, 2. AAD flag in B0 = 0 and AAD povided, or 3. AAD flag in B0 =1 and
 *     not enough AAD provided - expecting more based on AAD size.)
 * - 0b1111 - Invalid Crypto Engine Selected
 */
/*@{*/
#define LTC_ESTA_ERRID1_MODE_ERROR     (0x1U)        /*!< Bit field value for LTC_ESTA_ERRID1: Mode Error */
#define LTC_ESTA_ERRID1_DATA_SIZE_ERROR (0x2U)       /*!< Bit field value for LTC_ESTA_ERRID1: Data Size Error */
#define LTC_ESTA_ERRID1_KEY_SIZE_ERROR (0x3U)        /*!< Bit field value for LTC_ESTA_ERRID1: Key Size Error */
#define LTC_ESTA_ERRID1_DATA_OUT_OF_SEQ_ERROR (0x6U) /*!< Bit field value for LTC_ESTA_ERRID1: Data Arrived out of Sequence Error */
#define LTC_ESTA_ERRID1_ICV_CHECK_FAIL (0xAU)        /*!< Bit field value for LTC_ESTA_ERRID1: ICV Check Failed */
#define LTC_ESTA_ERRID1_INTERNAL_HARD_FAIL (0xBU)    /*!< Bit field value for LTC_ESTA_ERRID1: Internal Hardware Failure */
#define LTC_ESTA_ERRID1_CCM_AAD_SIZE_ERROR (0xCU)    /*!< Bit field value for LTC_ESTA_ERRID1: CCM AAD Size Error (either 1. AAD flag in B0 =1 and no AAD type provided, 2. AAD flag in B0 = 0 and AAD povided, or 3. AAD flag in B0 =1 and not enough AAD provided - expecting more based on AAD size.) */
#define LTC_ESTA_ERRID1_INVALID_ENGINE_SEL_ERROR (0xFU) /*!< Bit field value for LTC_ESTA_ERRID1: Invalid Crypto Engine Selected */
/*! @brief Read current value of the LTC_ESTA_ERRID1 field. */
#define LTC_RD_ESTA_ERRID1(base) ((LTC_ESTA_REG(base) & LTC_ESTA_ERRID1_MASK) >> LTC_ESTA_ERRID1_SHIFT)
#define LTC_BRD_ESTA_ERRID1(base) (BME_UBFX32(&LTC_ESTA_REG(base), LTC_ESTA_ERRID1_SHIFT, LTC_ESTA_ERRID1_WIDTH))
/*@}*/

/*!
 * @name Register LTC_ESTA, field CL1[11:8] (RO)
 *
 * algorithms. The algorithms field indicates which algorithm is asserting an
 * error.Others reserved
 *
 * Values:
 * - 0b0000 - LTC General Error
 * - 0b0001 - AES
 */
/*@{*/
#define LTC_ESTA_CL1_GEN_ERROR         (0U)          /*!< Bit field value for LTC_ESTA_CL1: LTC General Error */
#define LTC_ESTA_CL1_AES_ERROR         (0x1U)        /*!< Bit field value for LTC_ESTA_CL1: AES */
/*! @brief Read current value of the LTC_ESTA_CL1 field. */
#define LTC_RD_ESTA_CL1(base) ((LTC_ESTA_REG(base) & LTC_ESTA_CL1_MASK) >> LTC_ESTA_CL1_SHIFT)
#define LTC_BRD_ESTA_CL1(base) (BME_UBFX32(&LTC_ESTA_REG(base), LTC_ESTA_CL1_SHIFT, LTC_ESTA_CL1_WIDTH))
/*@}*/

/*******************************************************************************
 * LTC_AADSZ - LTC AAD Size Register
 ******************************************************************************/

/*!
 * @brief LTC_AADSZ - LTC AAD Size Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The AAD Size Register is used by AESA to determine how much of the last block
 * of AAD is valid. The write to this register should be the entire size of the
 * AAD as it is also added directly to the Data Size Register. The size added to
 * the Data Size Register is the AAD size rounded up to the next 16 byte
 * boundary. For instance a size of 20 bytes written to the AAD size register will cause
 * 32 bytes to be added to the Data Size Register. The size stored in the AADSZ
 * field represents the number of bytes valid in the final block of AAD. However
 * the entire size of AAD should be written to the Register address location. When
 * authentication only is being done then the AL bit needs to be written to tell
 * the AES engine that this is the last of the data.
 */
/*!
 * @name Constants and macros for entire LTC_AADSZ register
 */
/*@{*/
#define LTC_RD_AADSZ(base)       (LTC_AADSZ_REG(base))
#define LTC_WR_AADSZ(base, value) (LTC_AADSZ_REG(base) = (value))
#define LTC_RMW_AADSZ(base, mask, value) (LTC_WR_AADSZ(base, (LTC_RD_AADSZ(base) & ~(mask)) | (value)))
#define LTC_SET_AADSZ(base, value) (BME_OR32(&LTC_AADSZ_REG(base), (uint32_t)(value)))
#define LTC_CLR_AADSZ(base, value) (BME_AND32(&LTC_AADSZ_REG(base), (uint32_t)(~(value))))
#define LTC_TOG_AADSZ(base, value) (BME_XOR32(&LTC_AADSZ_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LTC_AADSZ bitfields
 */

/*!
 * @name Register LTC_AADSZ, field AADSZ[3:0] (RW)
 *
 * AAD size in Bytes, mod 16.
 */
/*@{*/
/*! @brief Read current value of the LTC_AADSZ_AADSZ field. */
#define LTC_RD_AADSZ_AADSZ(base) ((LTC_AADSZ_REG(base) & LTC_AADSZ_AADSZ_MASK) >> LTC_AADSZ_AADSZ_SHIFT)
#define LTC_BRD_AADSZ_AADSZ(base) (BME_UBFX32(&LTC_AADSZ_REG(base), LTC_AADSZ_AADSZ_SHIFT, LTC_AADSZ_AADSZ_WIDTH))

/*! @brief Set the AADSZ field to a new value. */
#define LTC_WR_AADSZ_AADSZ(base, value) (LTC_RMW_AADSZ(base, LTC_AADSZ_AADSZ_MASK, LTC_AADSZ_AADSZ(value)))
#define LTC_BWR_AADSZ_AADSZ(base, value) (BME_BFI32(&LTC_AADSZ_REG(base), ((uint32_t)(value) << LTC_AADSZ_AADSZ_SHIFT), LTC_AADSZ_AADSZ_SHIFT, LTC_AADSZ_AADSZ_WIDTH))
/*@}*/

/*!
 * @name Register LTC_AADSZ, field AL[31] (RW)
 *
 * AAD Last. Only AAD data will be written into the Input FIFO.
 */
/*@{*/
/*! @brief Read current value of the LTC_AADSZ_AL field. */
#define LTC_RD_AADSZ_AL(base) ((LTC_AADSZ_REG(base) & LTC_AADSZ_AL_MASK) >> LTC_AADSZ_AL_SHIFT)
#define LTC_BRD_AADSZ_AL(base) (BME_UBFX32(&LTC_AADSZ_REG(base), LTC_AADSZ_AL_SHIFT, LTC_AADSZ_AL_WIDTH))

/*! @brief Set the AL field to a new value. */
#define LTC_WR_AADSZ_AL(base, value) (LTC_RMW_AADSZ(base, LTC_AADSZ_AL_MASK, LTC_AADSZ_AL(value)))
#define LTC_BWR_AADSZ_AL(base, value) (BME_BFI32(&LTC_AADSZ_REG(base), ((uint32_t)(value) << LTC_AADSZ_AL_SHIFT), LTC_AADSZ_AL_SHIFT, LTC_AADSZ_AL_WIDTH))
/*@}*/

/*******************************************************************************
 * LTC_CTX - LTC Context Register
 ******************************************************************************/

/*!
 * @brief LTC_CTX - LTC Context Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Context Register holds the context for the internal crypto engine. This
 * register is 512 bits in length. The IP bus write to the Context Register is
 * accessible only as full-word reads or writes to sixteen 32-bit registers. The MSB
 * is located at offset 0100h with respect to the register page. The bit
 * assignments of this register are dependent on the algorithm, and in some cases the
 * mode of that algorithm. See the appropriate section for the Context Register
 * format used for that algorithm: AES ECB: Section AES CBC: Section AES CTR:
 * Section AES CCM: Section
 */
/*!
 * @name Constants and macros for entire LTC_CTX register
 */
/*@{*/
#define LTC_RD_CTX(base, index)  (LTC_CTX_REG(base, index))
#define LTC_WR_CTX(base, index, value) (LTC_CTX_REG(base, index) = (value))
#define LTC_RMW_CTX(base, index, mask, value) (LTC_WR_CTX(base, index, (LTC_RD_CTX(base, index) & ~(mask)) | (value)))
#define LTC_SET_CTX(base, index, value) (BME_OR32(&LTC_CTX_REG(base, index), (uint32_t)(value)))
#define LTC_CLR_CTX(base, index, value) (BME_AND32(&LTC_CTX_REG(base, index), (uint32_t)(~(value))))
#define LTC_TOG_CTX(base, index, value) (BME_XOR32(&LTC_CTX_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * LTC_KEY - LTC Key Registers
 ******************************************************************************/

/*!
 * @brief LTC_KEY - LTC Key Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Key Register normally holds the left-aligned key for the internal crypto
 * engine. The MSB is in offset 200h. The Key Register is 128 bits in length. The
 * IP bus write to the Context Register is accessible only as full-word reads or
 * writes to four 32-bit registers. Before the value in the Key Register can be
 * used in a cryptographic operation, the size of the key must be written into
 * the Key Size Register. Once the Key Size Register has been written, the Key
 * Register cannot be written again until the Key Size Register has been cleared.
 */
/*!
 * @name Constants and macros for entire LTC_KEY register
 */
/*@{*/
#define LTC_RD_KEY(base, index)  (LTC_KEY_REG(base, index))
#define LTC_WR_KEY(base, index, value) (LTC_KEY_REG(base, index) = (value))
#define LTC_RMW_KEY(base, index, mask, value) (LTC_WR_KEY(base, index, (LTC_RD_KEY(base, index) & ~(mask)) | (value)))
#define LTC_SET_KEY(base, index, value) (BME_OR32(&LTC_KEY_REG(base, index), (uint32_t)(value)))
#define LTC_CLR_KEY(base, index, value) (BME_AND32(&LTC_KEY_REG(base, index), (uint32_t)(~(value))))
#define LTC_TOG_KEY(base, index, value) (BME_XOR32(&LTC_KEY_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * LTC_FIFOSTA - LTC FIFO Status Register
 ******************************************************************************/

/*!
 * @brief LTC_FIFOSTA - LTC FIFO Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The LTC FIFO Status shows the current levels of the Input and Output FIFO.
 */
/*!
 * @name Constants and macros for entire LTC_FIFOSTA register
 */
/*@{*/
#define LTC_RD_FIFOSTA(base)     (LTC_FIFOSTA_REG(base))
/*@}*/

/*
 * Constants & macros for individual LTC_FIFOSTA bitfields
 */

/*!
 * @name Register LTC_FIFOSTA, field IFL[6:0] (RO)
 *
 * Input FIFO Level. These bits indicate the current number of entries in the
 * Input FIFO.
 */
/*@{*/
/*! @brief Read current value of the LTC_FIFOSTA_IFL field. */
#define LTC_RD_FIFOSTA_IFL(base) ((LTC_FIFOSTA_REG(base) & LTC_FIFOSTA_IFL_MASK) >> LTC_FIFOSTA_IFL_SHIFT)
#define LTC_BRD_FIFOSTA_IFL(base) (BME_UBFX32(&LTC_FIFOSTA_REG(base), LTC_FIFOSTA_IFL_SHIFT, LTC_FIFOSTA_IFL_WIDTH))
/*@}*/

/*!
 * @name Register LTC_FIFOSTA, field IFF[15] (RO)
 *
 * Input FIFO Full. The Input FIFO is full and should not be written to.
 */
/*@{*/
/*! @brief Read current value of the LTC_FIFOSTA_IFF field. */
#define LTC_RD_FIFOSTA_IFF(base) ((LTC_FIFOSTA_REG(base) & LTC_FIFOSTA_IFF_MASK) >> LTC_FIFOSTA_IFF_SHIFT)
#define LTC_BRD_FIFOSTA_IFF(base) (BME_UBFX32(&LTC_FIFOSTA_REG(base), LTC_FIFOSTA_IFF_SHIFT, LTC_FIFOSTA_IFF_WIDTH))
/*@}*/

/*!
 * @name Register LTC_FIFOSTA, field OFL[22:16] (RO)
 *
 * Output FIFO Level. These bits indicate the current number of entries in the
 * Output FIFO.
 */
/*@{*/
/*! @brief Read current value of the LTC_FIFOSTA_OFL field. */
#define LTC_RD_FIFOSTA_OFL(base) ((LTC_FIFOSTA_REG(base) & LTC_FIFOSTA_OFL_MASK) >> LTC_FIFOSTA_OFL_SHIFT)
#define LTC_BRD_FIFOSTA_OFL(base) (BME_UBFX32(&LTC_FIFOSTA_REG(base), LTC_FIFOSTA_OFL_SHIFT, LTC_FIFOSTA_OFL_WIDTH))
/*@}*/

/*!
 * @name Register LTC_FIFOSTA, field OFF[31] (RO)
 *
 * Output FIFO Full. The Output FIFO is full and should not be written to.
 */
/*@{*/
/*! @brief Read current value of the LTC_FIFOSTA_OFF field. */
#define LTC_RD_FIFOSTA_OFF(base) ((LTC_FIFOSTA_REG(base) & LTC_FIFOSTA_OFF_MASK) >> LTC_FIFOSTA_OFF_SHIFT)
#define LTC_BRD_FIFOSTA_OFF(base) (BME_UBFX32(&LTC_FIFOSTA_REG(base), LTC_FIFOSTA_OFF_SHIFT, LTC_FIFOSTA_OFF_WIDTH))
/*@}*/

/*******************************************************************************
 * LTC_IFIFO - LTC Input Data FIFO
 ******************************************************************************/

/*!
 * @brief LTC_IFIFO - LTC Input Data FIFO (WO)
 *
 * Reset value: 0x00000000U
 *
 * Data to be processed by the various crypto engines is first pushed into the
 * Input Data FIFO. The Input Data FIFO supports byte enables, allowing one to
 * four bytes to be written to the IFIFO from the IP bus. The IFIFO is four entries
 * deep, and each entry is four bytes. Care must be used to not overflow the
 * Input Data FIFO. Reads from this address will always return 0x0.
 */
/*!
 * @name Constants and macros for entire LTC_IFIFO register
 */
/*@{*/
#define LTC_WR_IFIFO(base, value) (LTC_IFIFO_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * LTC_OFIFO - LTC Output Data FIFO
 ******************************************************************************/

/*!
 * @brief LTC_OFIFO - LTC Output Data FIFO (RO)
 *
 * Reset value: 0x00000000U
 *
 * Data that is output from the AES is pushed into the Output Data FIFO. The
 * OFIFO is four entries deep, and each entry is four bytes. During normal
 * operation, the AES will never overflow the Output Data FIFO. Writes to this register
 * are ignored.
 */
/*!
 * @name Constants and macros for entire LTC_OFIFO register
 */
/*@{*/
#define LTC_RD_OFIFO(base)       (LTC_OFIFO_REG(base))
/*@}*/

/*******************************************************************************
 * LTC_VID1 - LTC Version ID Register
 ******************************************************************************/

/*!
 * @brief LTC_VID1 - LTC Version ID Register (RO)
 *
 * Reset value: 0x00340100U
 *
 * This register contains the ID for LTC and major and minor revision numbers.
 */
/*!
 * @name Constants and macros for entire LTC_VID1 register
 */
/*@{*/
#define LTC_RD_VID1(base)        (LTC_VID1_REG(base))
/*@}*/

/*
 * Constants & macros for individual LTC_VID1 bitfields
 */

/*!
 * @name Register LTC_VID1, field MIN_REV[7:0] (RO)
 *
 * Minor revision number(0x00).
 */
/*@{*/
/*! @brief Read current value of the LTC_VID1_MIN_REV field. */
#define LTC_RD_VID1_MIN_REV(base) ((LTC_VID1_REG(base) & LTC_VID1_MIN_REV_MASK) >> LTC_VID1_MIN_REV_SHIFT)
#define LTC_BRD_VID1_MIN_REV(base) (BME_UBFX32(&LTC_VID1_REG(base), LTC_VID1_MIN_REV_SHIFT, LTC_VID1_MIN_REV_WIDTH))
/*@}*/

/*!
 * @name Register LTC_VID1, field MAJ_REV[15:8] (RO)
 *
 * Major revision number(0x01).
 */
/*@{*/
/*! @brief Read current value of the LTC_VID1_MAJ_REV field. */
#define LTC_RD_VID1_MAJ_REV(base) ((LTC_VID1_REG(base) & LTC_VID1_MAJ_REV_MASK) >> LTC_VID1_MAJ_REV_SHIFT)
#define LTC_BRD_VID1_MAJ_REV(base) (BME_UBFX32(&LTC_VID1_REG(base), LTC_VID1_MAJ_REV_SHIFT, LTC_VID1_MAJ_REV_WIDTH))
/*@}*/

/*!
 * @name Register LTC_VID1, field IP_ID[31:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the LTC_VID1_IP_ID field. */
#define LTC_RD_VID1_IP_ID(base) ((LTC_VID1_REG(base) & LTC_VID1_IP_ID_MASK) >> LTC_VID1_IP_ID_SHIFT)
#define LTC_BRD_VID1_IP_ID(base) (BME_UBFX32(&LTC_VID1_REG(base), LTC_VID1_IP_ID_SHIFT, LTC_VID1_IP_ID_WIDTH))
/*@}*/

/*******************************************************************************
 * LTC_CHAVID - LTC CHA Version ID Register
 ******************************************************************************/

/*!
 * @brief LTC_CHAVID - LTC CHA Version ID Register (RO)
 *
 * Reset value: 0x00000050U
 *
 * This register contains the Version ID and Revision Number for the CHAs
 * contained within LTC.
 */
/*!
 * @name Constants and macros for entire LTC_CHAVID register
 */
/*@{*/
#define LTC_RD_CHAVID(base)      (LTC_CHAVID_REG(base))
/*@}*/

/*
 * Constants & macros for individual LTC_CHAVID bitfields
 */

/*!
 * @name Register LTC_CHAVID, field AESREV[3:0] (RO)
 *
 * AES Revision Number(0x0).
 */
/*@{*/
/*! @brief Read current value of the LTC_CHAVID_AESREV field. */
#define LTC_RD_CHAVID_AESREV(base) ((LTC_CHAVID_REG(base) & LTC_CHAVID_AESREV_MASK) >> LTC_CHAVID_AESREV_SHIFT)
#define LTC_BRD_CHAVID_AESREV(base) (BME_UBFX32(&LTC_CHAVID_REG(base), LTC_CHAVID_AESREV_SHIFT, LTC_CHAVID_AESREV_WIDTH))
/*@}*/

/*!
 * @name Register LTC_CHAVID, field AESVID[7:4] (RO)
 *
 * AES Version ID(0x5).
 */
/*@{*/
/*! @brief Read current value of the LTC_CHAVID_AESVID field. */
#define LTC_RD_CHAVID_AESVID(base) ((LTC_CHAVID_REG(base) & LTC_CHAVID_AESVID_MASK) >> LTC_CHAVID_AESVID_SHIFT)
#define LTC_BRD_CHAVID_AESVID(base) (BME_UBFX32(&LTC_CHAVID_REG(base), LTC_CHAVID_AESVID_SHIFT, LTC_CHAVID_AESVID_WIDTH))
/*@}*/

/*
 * MKW40Z4 MCG
 *
 * Multipurpose Clock Generator module
 *
 * Registers defined in this header file:
 * - MCG_C1 - MCG Control 1 Register
 * - MCG_C2 - MCG Control 2 Register
 * - MCG_C3 - MCG Control 3 Register
 * - MCG_C4 - MCG Control 4 Register
 * - MCG_C5 - MCG Control 5 Register
 * - MCG_C6 - MCG Control 6 Register
 * - MCG_S - MCG Status Register
 * - MCG_SC - MCG Status and Control Register
 * - MCG_ATCVH - MCG Auto Trim Compare Value High Register
 * - MCG_ATCVL - MCG Auto Trim Compare Value Low Register
 * - MCG_C7 - MCG Control 7 Register
 * - MCG_C8 - MCG Control 8 Register
 */

#define MCG_INSTANCE_COUNT (1U) /*!< Number of instances of the MCG module. */
#define MCG_IDX (0U) /*!< Instance number for MCG. */

/*******************************************************************************
 * MCG_C1 - MCG Control 1 Register
 ******************************************************************************/

/*!
 * @brief MCG_C1 - MCG Control 1 Register (RW)
 *
 * Reset value: 0x04U
 */
/*!
 * @name Constants and macros for entire MCG_C1 register
 */
/*@{*/
#define MCG_RD_C1(base)          (MCG_C1_REG(base))
#define MCG_WR_C1(base, value)   (MCG_C1_REG(base) = (value))
#define MCG_RMW_C1(base, mask, value) (MCG_WR_C1(base, (MCG_RD_C1(base) & ~(mask)) | (value)))
#define MCG_SET_C1(base, value)  (BME_OR8(&MCG_C1_REG(base), (uint8_t)(value)))
#define MCG_CLR_C1(base, value)  (BME_AND8(&MCG_C1_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C1(base, value)  (BME_XOR8(&MCG_C1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C1 bitfields
 */

/*!
 * @name Register MCG_C1, field IREFSTEN[0] (RW)
 *
 * Controls whether or not the internal reference clock remains enabled when the
 * MCG enters Stop mode.
 *
 * Values:
 * - 0b0 - Internal reference clock is disabled in Stop mode.
 * - 0b1 - Internal reference clock is enabled in Stop mode if IRCLKEN is set or
 *     if MCG is in FEI, FBI, or BLPI modes before entering Stop mode.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_IREFSTEN field. */
#define MCG_RD_C1_IREFSTEN(base) ((MCG_C1_REG(base) & MCG_C1_IREFSTEN_MASK) >> MCG_C1_IREFSTEN_SHIFT)
#define MCG_BRD_C1_IREFSTEN(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_IREFSTEN_SHIFT, MCG_C1_IREFSTEN_WIDTH))

/*! @brief Set the IREFSTEN field to a new value. */
#define MCG_WR_C1_IREFSTEN(base, value) (MCG_RMW_C1(base, MCG_C1_IREFSTEN_MASK, MCG_C1_IREFSTEN(value)))
#define MCG_BWR_C1_IREFSTEN(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_IREFSTEN_SHIFT), MCG_C1_IREFSTEN_SHIFT, MCG_C1_IREFSTEN_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C1, field IRCLKEN[1] (RW)
 *
 * Enables the internal reference clock for use as MCGIRCLK.
 *
 * Values:
 * - 0b0 - MCGIRCLK inactive.
 * - 0b1 - MCGIRCLK active.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_IRCLKEN field. */
#define MCG_RD_C1_IRCLKEN(base) ((MCG_C1_REG(base) & MCG_C1_IRCLKEN_MASK) >> MCG_C1_IRCLKEN_SHIFT)
#define MCG_BRD_C1_IRCLKEN(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_IRCLKEN_SHIFT, MCG_C1_IRCLKEN_WIDTH))

/*! @brief Set the IRCLKEN field to a new value. */
#define MCG_WR_C1_IRCLKEN(base, value) (MCG_RMW_C1(base, MCG_C1_IRCLKEN_MASK, MCG_C1_IRCLKEN(value)))
#define MCG_BWR_C1_IRCLKEN(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_IRCLKEN_SHIFT), MCG_C1_IRCLKEN_SHIFT, MCG_C1_IRCLKEN_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C1, field IREFS[2] (RW)
 *
 * Selects the reference clock source for the FLL. IREFS also controls the MCG
 * clock mode configuration. See "MCG Modes of Operation" table and "MCG Mode
 * Switching" for further details regarding MCG clock mode selection and MCG mode
 * switching.
 *
 * Values:
 * - 0b0 - External reference clock is selected.
 * - 0b1 - The slow internal reference clock is selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_IREFS field. */
#define MCG_RD_C1_IREFS(base) ((MCG_C1_REG(base) & MCG_C1_IREFS_MASK) >> MCG_C1_IREFS_SHIFT)
#define MCG_BRD_C1_IREFS(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_IREFS_SHIFT, MCG_C1_IREFS_WIDTH))

/*! @brief Set the IREFS field to a new value. */
#define MCG_WR_C1_IREFS(base, value) (MCG_RMW_C1(base, MCG_C1_IREFS_MASK, MCG_C1_IREFS(value)))
#define MCG_BWR_C1_IREFS(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_IREFS_SHIFT), MCG_C1_IREFS_SHIFT, MCG_C1_IREFS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C1, field FRDIV[5:3] (RW)
 *
 * Selects the amount to divide down the external reference clock for the FLL.
 * The resulting frequency must be in the range 31.25 kHz to 39.0625 kHz (This is
 * required when FLL/DCO is the clock source for MCGOUTCLK "mcg_out_clk". In FBE
 * mode, it is not required to meet this range, but it is recommended in the
 * cases when trying to enter a FLL mode from FBE).
 *
 * Values:
 * - 0b000 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 1; for all other RANGE
 *     values, Divide Factor is 32.
 * - 0b001 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 2; for all other RANGE
 *     values, Divide Factor is 64.
 * - 0b010 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 4; for all other RANGE
 *     values, Divide Factor is 128.
 * - 0b011 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 8; for all other RANGE
 *     values, Divide Factor is 256.
 * - 0b100 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 16; for all other RANGE
 *     values, Divide Factor is 512.
 * - 0b101 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 32; for all other RANGE
 *     values, Divide Factor is 1024.
 * - 0b110 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 64; for all other RANGE
 *     values, Divide Factor is 1280 .
 * - 0b111 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 128; for all other
 *     RANGE values, Divide Factor is 1536 .
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_FRDIV field. */
#define MCG_RD_C1_FRDIV(base) ((MCG_C1_REG(base) & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)
#define MCG_BRD_C1_FRDIV(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_FRDIV_SHIFT, MCG_C1_FRDIV_WIDTH))

/*! @brief Set the FRDIV field to a new value. */
#define MCG_WR_C1_FRDIV(base, value) (MCG_RMW_C1(base, MCG_C1_FRDIV_MASK, MCG_C1_FRDIV(value)))
#define MCG_BWR_C1_FRDIV(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_FRDIV_SHIFT), MCG_C1_FRDIV_SHIFT, MCG_C1_FRDIV_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C1, field CLKS[7:6] (RW)
 *
 * Selects the clock source for MCGOUTCLK "mcg_out_clk". For more details
 * regarding MCG clock source selection and MCG mode switching, see "MCG Modes of
 * Operation" table and "MCG Mode Switching"
 *
 * Values:
 * - 0b00 - Encoding 0 - Output of FLL is selected.
 * - 0b01 - Encoding 1 - Internal reference clock is selected.
 * - 0b10 - Encoding 2 - External reference clock is selected.
 * - 0b11 - Encoding 3 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_CLKS field. */
#define MCG_RD_C1_CLKS(base) ((MCG_C1_REG(base) & MCG_C1_CLKS_MASK) >> MCG_C1_CLKS_SHIFT)
#define MCG_BRD_C1_CLKS(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_CLKS_SHIFT, MCG_C1_CLKS_WIDTH))

/*! @brief Set the CLKS field to a new value. */
#define MCG_WR_C1_CLKS(base, value) (MCG_RMW_C1(base, MCG_C1_CLKS_MASK, MCG_C1_CLKS(value)))
#define MCG_BWR_C1_CLKS(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_CLKS_SHIFT), MCG_C1_CLKS_SHIFT, MCG_C1_CLKS_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_C2 - MCG Control 2 Register
 ******************************************************************************/

/*!
 * @brief MCG_C2 - MCG Control 2 Register (RW)
 *
 * Reset value: 0xC0U
 */
/*!
 * @name Constants and macros for entire MCG_C2 register
 */
/*@{*/
#define MCG_RD_C2(base)          (MCG_C2_REG(base))
#define MCG_WR_C2(base, value)   (MCG_C2_REG(base) = (value))
#define MCG_RMW_C2(base, mask, value) (MCG_WR_C2(base, (MCG_RD_C2(base) & ~(mask)) | (value)))
#define MCG_SET_C2(base, value)  (BME_OR8(&MCG_C2_REG(base), (uint8_t)(value)))
#define MCG_CLR_C2(base, value)  (BME_AND8(&MCG_C2_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C2(base, value)  (BME_XOR8(&MCG_C2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C2 bitfields
 */

/*!
 * @name Register MCG_C2, field IRCS[0] (RW)
 *
 * Selects between the fast or slow internal reference clock source.
 *
 * Values:
 * - 0b0 - Slow internal reference clock selected. (32 kHz Internal Reference
 *     Clock (32 kHz IRC)).
 * - 0b1 - Fast internal reference clock selected. (4 MHz Internal Reference
 *     Clock (4 MHz IRC)).
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_IRCS field. */
#define MCG_RD_C2_IRCS(base) ((MCG_C2_REG(base) & MCG_C2_IRCS_MASK) >> MCG_C2_IRCS_SHIFT)
#define MCG_BRD_C2_IRCS(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_IRCS_SHIFT, MCG_C2_IRCS_WIDTH))

/*! @brief Set the IRCS field to a new value. */
#define MCG_WR_C2_IRCS(base, value) (MCG_RMW_C2(base, MCG_C2_IRCS_MASK, MCG_C2_IRCS(value)))
#define MCG_BWR_C2_IRCS(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_IRCS_SHIFT), MCG_C2_IRCS_SHIFT, MCG_C2_IRCS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field LP[1] (RW)
 *
 * Controls whether the FLL is disabled in BLPI and BLPE modes. In FBE mode,
 * setting this bit to 1 will transition the MCG into BLPE mode; in FBI mode,
 * setting this bit to 1 will transition the MCG into BLPI mode. In any other MCG mode,
 * LP bit has no affect.
 *
 * Values:
 * - 0b0 - FLL is not disabled in bypass modes.
 * - 0b1 - FLL is disabled in bypass modes (lower power)
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_LP field. */
#define MCG_RD_C2_LP(base)   ((MCG_C2_REG(base) & MCG_C2_LP_MASK) >> MCG_C2_LP_SHIFT)
#define MCG_BRD_C2_LP(base)  (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_LP_SHIFT, MCG_C2_LP_WIDTH))

/*! @brief Set the LP field to a new value. */
#define MCG_WR_C2_LP(base, value) (MCG_RMW_C2(base, MCG_C2_LP_MASK, MCG_C2_LP(value)))
#define MCG_BWR_C2_LP(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_LP_SHIFT), MCG_C2_LP_SHIFT, MCG_C2_LP_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field EREFS[2] (RW)
 *
 * Selects the source for the external reference clock. See the Oscillator (OSC)
 * chapter for more details.
 *
 * Values:
 * - 0b0 - External reference clock requested.
 * - 0b1 - Oscillator requested.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_EREFS field. */
#define MCG_RD_C2_EREFS(base) ((MCG_C2_REG(base) & MCG_C2_EREFS_MASK) >> MCG_C2_EREFS_SHIFT)
#define MCG_BRD_C2_EREFS(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_EREFS_SHIFT, MCG_C2_EREFS_WIDTH))

/*! @brief Set the EREFS field to a new value. */
#define MCG_WR_C2_EREFS(base, value) (MCG_RMW_C2(base, MCG_C2_EREFS_MASK, MCG_C2_EREFS(value)))
#define MCG_BWR_C2_EREFS(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_EREFS_SHIFT), MCG_C2_EREFS_SHIFT, MCG_C2_EREFS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field HGO[3] (RW)
 *
 * Controls the crystal oscillator mode of operation. See the Oscillator (OSC)
 * chapter for more details.
 *
 * Values:
 * - 0b0 - Configure crystal oscillator for low-power operation.
 * - 0b1 - Configure crystal oscillator for high-gain operation.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_HGO field. */
#define MCG_RD_C2_HGO(base)  ((MCG_C2_REG(base) & MCG_C2_HGO_MASK) >> MCG_C2_HGO_SHIFT)
#define MCG_BRD_C2_HGO(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_HGO_SHIFT, MCG_C2_HGO_WIDTH))

/*! @brief Set the HGO field to a new value. */
#define MCG_WR_C2_HGO(base, value) (MCG_RMW_C2(base, MCG_C2_HGO_MASK, MCG_C2_HGO(value)))
#define MCG_BWR_C2_HGO(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_HGO_SHIFT), MCG_C2_HGO_SHIFT, MCG_C2_HGO_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field RANGE[5:4] (RW)
 *
 * Selects the frequency range for the crystal oscillator or external clock
 * source. See the Oscillator (OSC) chapter for more details and the device data
 * sheet for the frequency ranges used.
 *
 * Values:
 * - 0b00 - Encoding 0 - Low frequency range selected for the crystal oscillator
 *     .
 * - 0b01 - Encoding 1 - High frequency range selected for the crystal
 *     oscillator .
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_RANGE field. */
#define MCG_RD_C2_RANGE(base) ((MCG_C2_REG(base) & MCG_C2_RANGE_MASK) >> MCG_C2_RANGE_SHIFT)
#define MCG_BRD_C2_RANGE(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_RANGE_SHIFT, MCG_C2_RANGE_WIDTH))

/*! @brief Set the RANGE field to a new value. */
#define MCG_WR_C2_RANGE(base, value) (MCG_RMW_C2(base, MCG_C2_RANGE_MASK, MCG_C2_RANGE(value)))
#define MCG_BWR_C2_RANGE(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_RANGE_SHIFT), MCG_C2_RANGE_SHIFT, MCG_C2_RANGE_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field FCFTRIM[6] (RW)
 *
 * FCFTRIM controls the smallest adjustment of the fast internal reference clock
 * frequency. Setting FCFTRIM increases the period and clearing FCFTRIM
 * decreases the period by the smallest amount possible. If an FCFTRIM value stored in
 * nonvolatile memory is to be used, it is your responsibility to copy that value
 * from the nonvolatile memory location to this bit.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_FCFTRIM field. */
#define MCG_RD_C2_FCFTRIM(base) ((MCG_C2_REG(base) & MCG_C2_FCFTRIM_MASK) >> MCG_C2_FCFTRIM_SHIFT)
#define MCG_BRD_C2_FCFTRIM(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_FCFTRIM_SHIFT, MCG_C2_FCFTRIM_WIDTH))

/*! @brief Set the FCFTRIM field to a new value. */
#define MCG_WR_C2_FCFTRIM(base, value) (MCG_RMW_C2(base, MCG_C2_FCFTRIM_MASK, MCG_C2_FCFTRIM(value)))
#define MCG_BWR_C2_FCFTRIM(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_FCFTRIM_SHIFT), MCG_C2_FCFTRIM_SHIFT, MCG_C2_FCFTRIM_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field LOCRE0[7] (RW)
 *
 * Determines whether an interrupt or a reset request is made following a loss
 * of OSC0 external reference clock. The LOCRE0 only has an affect when CME0 is
 * set.
 *
 * Values:
 * - 0b0 - Interrupt request is generated on a loss of OSC0 external reference
 *     clock.
 * - 0b1 - Generate a reset request on a loss of OSC0 external reference clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_LOCRE0 field. */
#define MCG_RD_C2_LOCRE0(base) ((MCG_C2_REG(base) & MCG_C2_LOCRE0_MASK) >> MCG_C2_LOCRE0_SHIFT)
#define MCG_BRD_C2_LOCRE0(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_LOCRE0_SHIFT, MCG_C2_LOCRE0_WIDTH))

/*! @brief Set the LOCRE0 field to a new value. */
#define MCG_WR_C2_LOCRE0(base, value) (MCG_RMW_C2(base, MCG_C2_LOCRE0_MASK, MCG_C2_LOCRE0(value)))
#define MCG_BWR_C2_LOCRE0(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_LOCRE0_SHIFT), MCG_C2_LOCRE0_SHIFT, MCG_C2_LOCRE0_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_C3 - MCG Control 3 Register
 ******************************************************************************/

/*!
 * @brief MCG_C3 - MCG Control 3 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C3 register
 */
/*@{*/
#define MCG_RD_C3(base)          (MCG_C3_REG(base))
#define MCG_WR_C3(base, value)   (MCG_C3_REG(base) = (value))
#define MCG_RMW_C3(base, mask, value) (MCG_WR_C3(base, (MCG_RD_C3(base) & ~(mask)) | (value)))
#define MCG_SET_C3(base, value)  (BME_OR8(&MCG_C3_REG(base), (uint8_t)(value)))
#define MCG_CLR_C3(base, value)  (BME_AND8(&MCG_C3_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C3(base, value)  (BME_XOR8(&MCG_C3_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * MCG_C4 - MCG Control 4 Register
 ******************************************************************************/

/*!
 * @brief MCG_C4 - MCG Control 4 Register (RW)
 *
 * Reset value: 0x00U
 *
 * Reset values for DRST and DMX32 bits are 0.
 */
/*!
 * @name Constants and macros for entire MCG_C4 register
 */
/*@{*/
#define MCG_RD_C4(base)          (MCG_C4_REG(base))
#define MCG_WR_C4(base, value)   (MCG_C4_REG(base) = (value))
#define MCG_RMW_C4(base, mask, value) (MCG_WR_C4(base, (MCG_RD_C4(base) & ~(mask)) | (value)))
#define MCG_SET_C4(base, value)  (BME_OR8(&MCG_C4_REG(base), (uint8_t)(value)))
#define MCG_CLR_C4(base, value)  (BME_AND8(&MCG_C4_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C4(base, value)  (BME_XOR8(&MCG_C4_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C4 bitfields
 */

/*!
 * @name Register MCG_C4, field SCFTRIM[0] (RW)
 *
 * SCFTRIM A value for SCFTRIM is loaded during reset from a factory programmed
 * location . Initially out of reset, SCFTRIM gets reset to 0x0, bus soon after
 * reset, the IFR load enable gets asserted causing SCFTRIM value to get replaced
 * with the IFR (SCFTRIM=IFR[0]) value. controls the smallest adjustment of the
 * slow internal reference clock frequency. Setting SCFTRIM increases the period
 * and clearing SCFTRIM decreases the period by the smallest amount possible. If
 * an SCFTRIM value stored in nonvolatile memory is to be used, it is your
 * responsibility to copy that value from the nonvolatile memory location to this bit.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_SCFTRIM field. */
#define MCG_RD_C4_SCFTRIM(base) ((MCG_C4_REG(base) & MCG_C4_SCFTRIM_MASK) >> MCG_C4_SCFTRIM_SHIFT)
#define MCG_BRD_C4_SCFTRIM(base) (BME_UBFX8(&MCG_C4_REG(base), MCG_C4_SCFTRIM_SHIFT, MCG_C4_SCFTRIM_WIDTH))

/*! @brief Set the SCFTRIM field to a new value. */
#define MCG_WR_C4_SCFTRIM(base, value) (MCG_RMW_C4(base, MCG_C4_SCFTRIM_MASK, MCG_C4_SCFTRIM(value)))
#define MCG_BWR_C4_SCFTRIM(base, value) (BME_BFI8(&MCG_C4_REG(base), ((uint8_t)(value) << MCG_C4_SCFTRIM_SHIFT), MCG_C4_SCFTRIM_SHIFT, MCG_C4_SCFTRIM_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C4, field FCTRIM[4:1] (RW)
 *
 * FCTRIM A value for FCTRIM is loaded during reset from a factory programmed
 * location. Initially out of reset, FCTRIM gets reset to 0x8, bus soon after
 * reset, the IFR load enable gets asserted causing FCTRIM value to get replaced with
 * the IFR (FCTRIM=IFR[12:9]) value. controls the fast internal reference clock
 * frequency by controlling the fast internal reference clock period. The FCTRIM
 * bits are binary weighted, that is, bit 1 adjusts twice as much as bit 0.
 * Increasing the binary value increases the period, and decreasing the value decreases
 * the period. If an FCTRIM[3:0] value stored in nonvolatile memory is to be
 * used, it is your responsibility to copy that value from the nonvolatile memory
 * location to this register.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_FCTRIM field. */
#define MCG_RD_C4_FCTRIM(base) ((MCG_C4_REG(base) & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT)
#define MCG_BRD_C4_FCTRIM(base) (BME_UBFX8(&MCG_C4_REG(base), MCG_C4_FCTRIM_SHIFT, MCG_C4_FCTRIM_WIDTH))

/*! @brief Set the FCTRIM field to a new value. */
#define MCG_WR_C4_FCTRIM(base, value) (MCG_RMW_C4(base, MCG_C4_FCTRIM_MASK, MCG_C4_FCTRIM(value)))
#define MCG_BWR_C4_FCTRIM(base, value) (BME_BFI8(&MCG_C4_REG(base), ((uint8_t)(value) << MCG_C4_FCTRIM_SHIFT), MCG_C4_FCTRIM_SHIFT, MCG_C4_FCTRIM_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C4, field DRST_DRS[6:5] (RW)
 *
 * The DRS bits select the frequency range for the FLL output, DCOOUT. When the
 * LP bit is set, writes to the DRS bits are ignored. The DRST read field
 * indicates the current frequency range for DCOOUT. The DRST field does not update
 * immediately after a write to the DRS field due to internal synchronization between
 * clock domains. See the DCO Frequency Range table for more details.
 *
 * Values:
 * - 0b00 - Encoding 0 - Low range (reset default).
 * - 0b01 - Encoding 1 - Mid range.
 * - 0b10 - Encoding 2 - Mid-high range.
 * - 0b11 - Encoding 3 - High range.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_DRST_DRS field. */
#define MCG_RD_C4_DRST_DRS(base) ((MCG_C4_REG(base) & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT)
#define MCG_BRD_C4_DRST_DRS(base) (BME_UBFX8(&MCG_C4_REG(base), MCG_C4_DRST_DRS_SHIFT, MCG_C4_DRST_DRS_WIDTH))

/*! @brief Set the DRST_DRS field to a new value. */
#define MCG_WR_C4_DRST_DRS(base, value) (MCG_RMW_C4(base, MCG_C4_DRST_DRS_MASK, MCG_C4_DRST_DRS(value)))
#define MCG_BWR_C4_DRST_DRS(base, value) (BME_BFI8(&MCG_C4_REG(base), ((uint8_t)(value) << MCG_C4_DRST_DRS_SHIFT), MCG_C4_DRST_DRS_SHIFT, MCG_C4_DRST_DRS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C4, field DMX32[7] (RW)
 *
 * The DMX32 bit controls whether the DCO frequency range is narrowed to its
 * maximum frequency with a 32.768 kHz reference. The following table identifies
 * settings for the DCO frequency range. The system clocks derived from this source
 * should not exceed their specified maximums. DRST_DRS DMX32 Reference Range FLL
 * Factor DCO Range 00 0 31.25-39.0625 kHz 640 20-25 MHz 1 32.768 kHz 732 24 MHz
 * 01 0 31.25-39.0625 kHz 1280 40-50 MHz 1 32.768 kHz 1464 48 MHz 10 0
 * 31.25-39.0625 kHz 1920 60-75 MHz 1 32.768 kHz 2197 72 MHz 11 0 31.25-39.0625 kHz 2560
 * 80-100 MHz 1 32.768 kHz 2929 96 MHz
 *
 * Values:
 * - 0b0 - DCO has a default range of 25%.
 * - 0b1 - DCO is fine-tuned for maximum frequency with 32.768 kHz reference.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_DMX32 field. */
#define MCG_RD_C4_DMX32(base) ((MCG_C4_REG(base) & MCG_C4_DMX32_MASK) >> MCG_C4_DMX32_SHIFT)
#define MCG_BRD_C4_DMX32(base) (BME_UBFX8(&MCG_C4_REG(base), MCG_C4_DMX32_SHIFT, MCG_C4_DMX32_WIDTH))

/*! @brief Set the DMX32 field to a new value. */
#define MCG_WR_C4_DMX32(base, value) (MCG_RMW_C4(base, MCG_C4_DMX32_MASK, MCG_C4_DMX32(value)))
#define MCG_BWR_C4_DMX32(base, value) (BME_BFI8(&MCG_C4_REG(base), ((uint8_t)(value) << MCG_C4_DMX32_SHIFT), MCG_C4_DMX32_SHIFT, MCG_C4_DMX32_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_C5 - MCG Control 5 Register
 ******************************************************************************/

/*!
 * @brief MCG_C5 - MCG Control 5 Register (ROZ)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C5 register
 */
/*@{*/
#define MCG_RD_C5(base)          (MCG_C5_REG(base))
/*@}*/

/*******************************************************************************
 * MCG_C6 - MCG Control 6 Register
 ******************************************************************************/

/*!
 * @brief MCG_C6 - MCG Control 6 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C6 register
 */
/*@{*/
#define MCG_RD_C6(base)          (MCG_C6_REG(base))
#define MCG_WR_C6(base, value)   (MCG_C6_REG(base) = (value))
#define MCG_RMW_C6(base, mask, value) (MCG_WR_C6(base, (MCG_RD_C6(base) & ~(mask)) | (value)))
#define MCG_SET_C6(base, value)  (BME_OR8(&MCG_C6_REG(base), (uint8_t)(value)))
#define MCG_CLR_C6(base, value)  (BME_AND8(&MCG_C6_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C6(base, value)  (BME_XOR8(&MCG_C6_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C6 bitfields
 */

/*!
 * @name Register MCG_C6, field CME[5] (RW)
 *
 * Determines if a reset request is made following a loss of external clock
 * indication. The CME bit should only be set to a logic 1 when the MCG is in an
 * operational mode that uses the external clock (FEE, FBE, or BLPE). Whenever the
 * CME bit is set to a logic 1, the value of the RANGE bits in the C2 register
 * should not be changed. CME bit should be set to a logic 0 before the MCG enters
 * any Stop mode. Otherwise, a reset request may occur when in Stop mode. CME
 * should also be set to a logic 0 before entering VLPR or VLPW power modes if the MCG
 * is in BLPE mode.
 *
 * Values:
 * - 0b0 - External clock monitor is disabled.
 * - 0b1 - Generate a reset request on loss of external clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_C6_CME field. */
#define MCG_RD_C6_CME(base)  ((MCG_C6_REG(base) & MCG_C6_CME_MASK) >> MCG_C6_CME_SHIFT)
#define MCG_BRD_C6_CME(base) (BME_UBFX8(&MCG_C6_REG(base), MCG_C6_CME_SHIFT, MCG_C6_CME_WIDTH))

/*! @brief Set the CME field to a new value. */
#define MCG_WR_C6_CME(base, value) (MCG_RMW_C6(base, MCG_C6_CME_MASK, MCG_C6_CME(value)))
#define MCG_BWR_C6_CME(base, value) (BME_BFI8(&MCG_C6_REG(base), ((uint8_t)(value) << MCG_C6_CME_SHIFT), MCG_C6_CME_SHIFT, MCG_C6_CME_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_S - MCG Status Register
 ******************************************************************************/

/*!
 * @brief MCG_S - MCG Status Register (RO)
 *
 * Reset value: 0x10U
 */
/*!
 * @name Constants and macros for entire MCG_S register
 */
/*@{*/
#define MCG_RD_S(base)           (MCG_S_REG(base))
/*@}*/

/*
 * Constants & macros for individual MCG_S bitfields
 */

/*!
 * @name Register MCG_S, field IRCST[0] (RO)
 *
 * The IRCST bit indicates the current source for the internal reference clock
 * select clock (IRCSCLK). The IRCST bit does not update immediately after a write
 * to the IRCS bit due to internal synchronization between clock domains. The
 * IRCST bit will only be updated if the internal reference clock is enabled,
 * either by the MCG being in a mode that uses the IRC or by setting the C1[IRCLKEN]
 * bit .
 *
 * Values:
 * - 0b0 - Source of internal reference clock is the slow clock (32 kHz IRC).
 * - 0b1 - Source of internal reference clock is the fast clock (4 MHz IRC).
 */
/*@{*/
/*! @brief Read current value of the MCG_S_IRCST field. */
#define MCG_RD_S_IRCST(base) ((MCG_S_REG(base) & MCG_S_IRCST_MASK) >> MCG_S_IRCST_SHIFT)
#define MCG_BRD_S_IRCST(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_IRCST_SHIFT, MCG_S_IRCST_WIDTH))
/*@}*/

/*!
 * @name Register MCG_S, field OSCINIT0[1] (RO)
 *
 * This bit, which resets to 0, is set to 1 after the initialization cycles of
 * the crystal oscillator clock have completed. After being set, the bit is
 * cleared to 0 if the OSC is subsequently disabled. See the OSC module's detailed
 * description for more information.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_OSCINIT0 field. */
#define MCG_RD_S_OSCINIT0(base) ((MCG_S_REG(base) & MCG_S_OSCINIT0_MASK) >> MCG_S_OSCINIT0_SHIFT)
#define MCG_BRD_S_OSCINIT0(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_OSCINIT0_SHIFT, MCG_S_OSCINIT0_WIDTH))
/*@}*/

/*!
 * @name Register MCG_S, field CLKST[3:2] (RO)
 *
 * These bits indicate the current clock mode. The CLKST bits do not update
 * immediately after a write to the CLKS bits due to internal synchronization between
 * clock domains.
 *
 * Values:
 * - 0b00 - Encoding 0 - Output of the FLL is selected (reset default).
 * - 0b01 - Encoding 1 - Internal reference clock is selected.
 * - 0b10 - Encoding 2 - External reference clock is selected.
 * - 0b11 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_CLKST field. */
#define MCG_RD_S_CLKST(base) ((MCG_S_REG(base) & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT)
#define MCG_BRD_S_CLKST(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_CLKST_SHIFT, MCG_S_CLKST_WIDTH))
/*@}*/

/*!
 * @name Register MCG_S, field IREFST[4] (RO)
 *
 * This bit indicates the current source for the FLL reference clock. The IREFST
 * bit does not update immediately after a write to the IREFS bit due to
 * internal synchronization between clock domains.
 *
 * Values:
 * - 0b0 - Source of FLL reference clock is the external reference clock.
 * - 0b1 - Source of FLL reference clock is the internal reference clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_IREFST field. */
#define MCG_RD_S_IREFST(base) ((MCG_S_REG(base) & MCG_S_IREFST_MASK) >> MCG_S_IREFST_SHIFT)
#define MCG_BRD_S_IREFST(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_IREFST_SHIFT, MCG_S_IREFST_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_SC - MCG Status and Control Register
 ******************************************************************************/

/*!
 * @brief MCG_SC - MCG Status and Control Register (RW)
 *
 * Reset value: 0x02U
 */
/*!
 * @name Constants and macros for entire MCG_SC register
 */
/*@{*/
#define MCG_RD_SC(base)          (MCG_SC_REG(base))
#define MCG_WR_SC(base, value)   (MCG_SC_REG(base) = (value))
#define MCG_RMW_SC(base, mask, value) (MCG_WR_SC(base, (MCG_RD_SC(base) & ~(mask)) | (value)))
#define MCG_SET_SC(base, value)  (BME_OR8(&MCG_SC_REG(base), (uint8_t)(value)))
#define MCG_CLR_SC(base, value)  (BME_AND8(&MCG_SC_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_SC(base, value)  (BME_XOR8(&MCG_SC_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_SC bitfields
 */

/*!
 * @name Register MCG_SC, field LOCS0[0] (W1C)
 *
 * The LOCS0 indicates when a loss of OSC0 reference clock has occurred. The
 * LOCS0 bit only has an effect when CME0 is set. This bit is cleared by writing a
 * logic 1 to it when set.
 *
 * Values:
 * - 0b0 - Loss of OSC0 has not occurred.
 * - 0b1 - Loss of OSC0 has occurred.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_LOCS0 field. */
#define MCG_RD_SC_LOCS0(base) ((MCG_SC_REG(base) & MCG_SC_LOCS0_MASK) >> MCG_SC_LOCS0_SHIFT)
#define MCG_BRD_SC_LOCS0(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_LOCS0_SHIFT, MCG_SC_LOCS0_WIDTH))

/*! @brief Set the LOCS0 field to a new value. */
#define MCG_WR_SC_LOCS0(base, value) (MCG_RMW_SC(base, (MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_LOCS0(value)))
#define MCG_BWR_SC_LOCS0(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_LOCS0_SHIFT), MCG_SC_LOCS0_SHIFT, MCG_SC_LOCS0_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field FCRDIV[3:1] (RW)
 *
 * Selects the amount to divide down the fast internal reference clock. The
 * resulting frequency will be in the range 31.25 kHz to 4 MHz (Note: Changing the
 * divider when the Fast IRC is enabled is not supported).
 *
 * Values:
 * - 0b000 - Divide Factor is 1
 * - 0b001 - Divide Factor is 2.
 * - 0b010 - Divide Factor is 4.
 * - 0b011 - Divide Factor is 8.
 * - 0b100 - Divide Factor is 16
 * - 0b101 - Divide Factor is 32
 * - 0b110 - Divide Factor is 64
 * - 0b111 - Divide Factor is 128.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_FCRDIV field. */
#define MCG_RD_SC_FCRDIV(base) ((MCG_SC_REG(base) & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)
#define MCG_BRD_SC_FCRDIV(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_FCRDIV_SHIFT, MCG_SC_FCRDIV_WIDTH))

/*! @brief Set the FCRDIV field to a new value. */
#define MCG_WR_SC_FCRDIV(base, value) (MCG_RMW_SC(base, (MCG_SC_FCRDIV_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_FCRDIV(value)))
#define MCG_BWR_SC_FCRDIV(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_FCRDIV_SHIFT), MCG_SC_FCRDIV_SHIFT, MCG_SC_FCRDIV_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field FLTPRSRV[4] (RW)
 *
 * This bit will prevent the FLL filter values from resetting allowing the FLL
 * output frequency to remain the same during clock mode changes where the FLL/DCO
 * output is still valid. (Note: This requires that the FLL reference frequency
 * to remain the same as what it was prior to the new clock mode switch.
 * Otherwise FLL filter and frequency values will change.)
 *
 * Values:
 * - 0b0 - FLL filter and FLL frequency will reset on changes to currect clock
 *     mode.
 * - 0b1 - Fll filter and FLL frequency retain their previous values during new
 *     clock mode change.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_FLTPRSRV field. */
#define MCG_RD_SC_FLTPRSRV(base) ((MCG_SC_REG(base) & MCG_SC_FLTPRSRV_MASK) >> MCG_SC_FLTPRSRV_SHIFT)
#define MCG_BRD_SC_FLTPRSRV(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_FLTPRSRV_SHIFT, MCG_SC_FLTPRSRV_WIDTH))

/*! @brief Set the FLTPRSRV field to a new value. */
#define MCG_WR_SC_FLTPRSRV(base, value) (MCG_RMW_SC(base, (MCG_SC_FLTPRSRV_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_FLTPRSRV(value)))
#define MCG_BWR_SC_FLTPRSRV(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_FLTPRSRV_SHIFT), MCG_SC_FLTPRSRV_SHIFT, MCG_SC_FLTPRSRV_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field ATMF[5] (W1C)
 *
 * Fail flag for the Automatic Trim Machine (ATM). This bit asserts when the
 * Automatic Trim Machine is enabled, ATME=1, and a write to the C1, C3, C4, and SC
 * registers is detected or the MCG enters into any Stop mode. A write to ATMF
 * clears the flag.
 *
 * Values:
 * - 0b0 - Automatic Trim Machine completed normally.
 * - 0b1 - Automatic Trim Machine failed.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_ATMF field. */
#define MCG_RD_SC_ATMF(base) ((MCG_SC_REG(base) & MCG_SC_ATMF_MASK) >> MCG_SC_ATMF_SHIFT)
#define MCG_BRD_SC_ATMF(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_ATMF_SHIFT, MCG_SC_ATMF_WIDTH))

/*! @brief Set the ATMF field to a new value. */
#define MCG_WR_SC_ATMF(base, value) (MCG_RMW_SC(base, (MCG_SC_ATMF_MASK | MCG_SC_LOCS0_MASK), MCG_SC_ATMF(value)))
#define MCG_BWR_SC_ATMF(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_ATMF_SHIFT), MCG_SC_ATMF_SHIFT, MCG_SC_ATMF_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field ATMS[6] (RW)
 *
 * Selects the IRCS clock for Auto Trim Test.
 *
 * Values:
 * - 0b0 - 32 kHz Internal Reference Clock selected.
 * - 0b1 - 4 MHz Internal Reference Clock selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_ATMS field. */
#define MCG_RD_SC_ATMS(base) ((MCG_SC_REG(base) & MCG_SC_ATMS_MASK) >> MCG_SC_ATMS_SHIFT)
#define MCG_BRD_SC_ATMS(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_ATMS_SHIFT, MCG_SC_ATMS_WIDTH))

/*! @brief Set the ATMS field to a new value. */
#define MCG_WR_SC_ATMS(base, value) (MCG_RMW_SC(base, (MCG_SC_ATMS_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_ATMS(value)))
#define MCG_BWR_SC_ATMS(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_ATMS_SHIFT), MCG_SC_ATMS_SHIFT, MCG_SC_ATMS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field ATME[7] (RW)
 *
 * Enables the Auto Trim Machine to start automatically trimming the selected
 * Internal Reference Clock. ATME deasserts after the Auto Trim Machine has
 * completed trimming all trim bits of the IRCS clock selected by the ATMS bit. Writing
 * to C1, C3, C4, and SC registers or entering Stop mode aborts the auto trim
 * operation and clears this bit.
 *
 * Values:
 * - 0b0 - Auto Trim Machine disabled.
 * - 0b1 - Auto Trim Machine enabled.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_ATME field. */
#define MCG_RD_SC_ATME(base) ((MCG_SC_REG(base) & MCG_SC_ATME_MASK) >> MCG_SC_ATME_SHIFT)
#define MCG_BRD_SC_ATME(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_ATME_SHIFT, MCG_SC_ATME_WIDTH))

/*! @brief Set the ATME field to a new value. */
#define MCG_WR_SC_ATME(base, value) (MCG_RMW_SC(base, (MCG_SC_ATME_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_ATME(value)))
#define MCG_BWR_SC_ATME(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_ATME_SHIFT), MCG_SC_ATME_SHIFT, MCG_SC_ATME_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_ATCVH - MCG Auto Trim Compare Value High Register
 ******************************************************************************/

/*!
 * @brief MCG_ATCVH - MCG Auto Trim Compare Value High Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_ATCVH register
 */
/*@{*/
#define MCG_RD_ATCVH(base)       (MCG_ATCVH_REG(base))
#define MCG_WR_ATCVH(base, value) (MCG_ATCVH_REG(base) = (value))
#define MCG_RMW_ATCVH(base, mask, value) (MCG_WR_ATCVH(base, (MCG_RD_ATCVH(base) & ~(mask)) | (value)))
#define MCG_SET_ATCVH(base, value) (BME_OR8(&MCG_ATCVH_REG(base), (uint8_t)(value)))
#define MCG_CLR_ATCVH(base, value) (BME_AND8(&MCG_ATCVH_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_ATCVH(base, value) (BME_XOR8(&MCG_ATCVH_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * MCG_ATCVL - MCG Auto Trim Compare Value Low Register
 ******************************************************************************/

/*!
 * @brief MCG_ATCVL - MCG Auto Trim Compare Value Low Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_ATCVL register
 */
/*@{*/
#define MCG_RD_ATCVL(base)       (MCG_ATCVL_REG(base))
#define MCG_WR_ATCVL(base, value) (MCG_ATCVL_REG(base) = (value))
#define MCG_RMW_ATCVL(base, mask, value) (MCG_WR_ATCVL(base, (MCG_RD_ATCVL(base) & ~(mask)) | (value)))
#define MCG_SET_ATCVL(base, value) (BME_OR8(&MCG_ATCVL_REG(base), (uint8_t)(value)))
#define MCG_CLR_ATCVL(base, value) (BME_AND8(&MCG_ATCVL_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_ATCVL(base, value) (BME_XOR8(&MCG_ATCVL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * MCG_C7 - MCG Control 7 Register
 ******************************************************************************/

/*!
 * @brief MCG_C7 - MCG Control 7 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C7 register
 */
/*@{*/
#define MCG_RD_C7(base)          (MCG_C7_REG(base))
#define MCG_WR_C7(base, value)   (MCG_C7_REG(base) = (value))
#define MCG_RMW_C7(base, mask, value) (MCG_WR_C7(base, (MCG_RD_C7(base) & ~(mask)) | (value)))
#define MCG_SET_C7(base, value)  (BME_OR8(&MCG_C7_REG(base), (uint8_t)(value)))
#define MCG_CLR_C7(base, value)  (BME_AND8(&MCG_C7_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C7(base, value)  (BME_XOR8(&MCG_C7_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C7 bitfields
 */

/*!
 * @name Register MCG_C7, field OSCSEL[0] (RW)
 *
 * Selects the MCG FLL external reference clock
 *
 * Values:
 * - 0b0 - Selects Oscillator (OSCCLK).
 * - 0b1 - Selects 32 kHz RTC Oscillator.
 */
/*@{*/
/*! @brief Read current value of the MCG_C7_OSCSEL field. */
#define MCG_RD_C7_OSCSEL(base) ((MCG_C7_REG(base) & MCG_C7_OSCSEL_MASK) >> MCG_C7_OSCSEL_SHIFT)
#define MCG_BRD_C7_OSCSEL(base) (BME_UBFX8(&MCG_C7_REG(base), MCG_C7_OSCSEL_SHIFT, MCG_C7_OSCSEL_WIDTH))

/*! @brief Set the OSCSEL field to a new value. */
#define MCG_WR_C7_OSCSEL(base, value) (MCG_RMW_C7(base, MCG_C7_OSCSEL_MASK, MCG_C7_OSCSEL(value)))
#define MCG_BWR_C7_OSCSEL(base, value) (BME_BFI8(&MCG_C7_REG(base), ((uint8_t)(value) << MCG_C7_OSCSEL_SHIFT), MCG_C7_OSCSEL_SHIFT, MCG_C7_OSCSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_C8 - MCG Control 8 Register
 ******************************************************************************/

/*!
 * @brief MCG_C8 - MCG Control 8 Register (RW)
 *
 * Reset value: 0x80U
 */
/*!
 * @name Constants and macros for entire MCG_C8 register
 */
/*@{*/
#define MCG_RD_C8(base)          (MCG_C8_REG(base))
#define MCG_WR_C8(base, value)   (MCG_C8_REG(base) = (value))
#define MCG_RMW_C8(base, mask, value) (MCG_WR_C8(base, (MCG_RD_C8(base) & ~(mask)) | (value)))
#define MCG_SET_C8(base, value)  (BME_OR8(&MCG_C8_REG(base), (uint8_t)(value)))
#define MCG_CLR_C8(base, value)  (BME_AND8(&MCG_C8_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C8(base, value)  (BME_XOR8(&MCG_C8_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C8 bitfields
 */

/*!
 * @name Register MCG_C8, field LOCS1[0] (W1C)
 *
 * This bit indicates when a loss of clock has occurred. This bit is cleared by
 * writing a logic 1 to it when set.
 *
 * Values:
 * - 0b0 - Loss of RTC has not occur.
 * - 0b1 - Loss of RTC has occur
 */
/*@{*/
/*! @brief Read current value of the MCG_C8_LOCS1 field. */
#define MCG_RD_C8_LOCS1(base) ((MCG_C8_REG(base) & MCG_C8_LOCS1_MASK) >> MCG_C8_LOCS1_SHIFT)
#define MCG_BRD_C8_LOCS1(base) (BME_UBFX8(&MCG_C8_REG(base), MCG_C8_LOCS1_SHIFT, MCG_C8_LOCS1_WIDTH))

/*! @brief Set the LOCS1 field to a new value. */
#define MCG_WR_C8_LOCS1(base, value) (MCG_RMW_C8(base, MCG_C8_LOCS1_MASK, MCG_C8_LOCS1(value)))
#define MCG_BWR_C8_LOCS1(base, value) (BME_BFI8(&MCG_C8_REG(base), ((uint8_t)(value) << MCG_C8_LOCS1_SHIFT), MCG_C8_LOCS1_SHIFT, MCG_C8_LOCS1_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C8, field CME1[5] (RW)
 *
 * Enables the loss of clock monitoring circuit for the output of the RTC
 * external reference clock. The LOCRE1 bit will determine whether an interrupt or a
 * reset request is generated following a loss of RTC clock indication. The CME1
 * bit should be set to a logic 1 when the MCG is in an operational mode that uses
 * the RTC as its external reference clock or if the RTC is operational. CME1 bit
 * must be set to a logic 0 before the MCG enters any Stop mode. Otherwise, a
 * reset request may occur when in Stop mode. CME1 should also be set to a logic 0
 * before entering VLPR or VLPW power modes.
 *
 * Values:
 * - 0b0 - External clock monitor is disabled for RTC clock.
 * - 0b1 - External clock monitor is enabled for RTC clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_C8_CME1 field. */
#define MCG_RD_C8_CME1(base) ((MCG_C8_REG(base) & MCG_C8_CME1_MASK) >> MCG_C8_CME1_SHIFT)
#define MCG_BRD_C8_CME1(base) (BME_UBFX8(&MCG_C8_REG(base), MCG_C8_CME1_SHIFT, MCG_C8_CME1_WIDTH))

/*! @brief Set the CME1 field to a new value. */
#define MCG_WR_C8_CME1(base, value) (MCG_RMW_C8(base, (MCG_C8_CME1_MASK | MCG_C8_LOCS1_MASK), MCG_C8_CME1(value)))
#define MCG_BWR_C8_CME1(base, value) (BME_BFI8(&MCG_C8_REG(base), ((uint8_t)(value) << MCG_C8_CME1_SHIFT), MCG_C8_CME1_SHIFT, MCG_C8_CME1_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C8, field LOCRE1[7] (RW)
 *
 * Determines if a interrupt or a reset request is made following a loss of RTC
 * external reference clock. The LOCRE1 only has an affect when CME1 is set.
 *
 * Values:
 * - 0b0 - Interrupt request is generated on a loss of RTC external reference
 *     clock.
 * - 0b1 - Generate a reset request on a loss of RTC external reference clock
 */
/*@{*/
/*! @brief Read current value of the MCG_C8_LOCRE1 field. */
#define MCG_RD_C8_LOCRE1(base) ((MCG_C8_REG(base) & MCG_C8_LOCRE1_MASK) >> MCG_C8_LOCRE1_SHIFT)
#define MCG_BRD_C8_LOCRE1(base) (BME_UBFX8(&MCG_C8_REG(base), MCG_C8_LOCRE1_SHIFT, MCG_C8_LOCRE1_WIDTH))

/*! @brief Set the LOCRE1 field to a new value. */
#define MCG_WR_C8_LOCRE1(base, value) (MCG_RMW_C8(base, (MCG_C8_LOCRE1_MASK | MCG_C8_LOCS1_MASK), MCG_C8_LOCRE1(value)))
#define MCG_BWR_C8_LOCRE1(base, value) (BME_BFI8(&MCG_C8_REG(base), ((uint8_t)(value) << MCG_C8_LOCRE1_SHIFT), MCG_C8_LOCRE1_SHIFT, MCG_C8_LOCRE1_WIDTH))
/*@}*/

/*
 * MKW40Z4 MCM
 *
 * Core Platform Miscellaneous Control Module
 *
 * Registers defined in this header file:
 * - MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration
 * - MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration
 * - MCM_PLACR - Platform Control Register
 * - MCM_CPO - Compute Operation Control Register
 */

#define MCM_INSTANCE_COUNT (1U) /*!< Number of instances of the MCM module. */
#define MCM_IDX (0U) /*!< Instance number for MCM. */

/*******************************************************************************
 * MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration
 ******************************************************************************/

/*!
 * @brief MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration (RO)
 *
 * Reset value: 0x0007U
 *
 * PLASC is a 16-bit read-only register identifying the presence/absence of bus
 * slave connections to the device's crossbar switch.
 */
/*!
 * @name Constants and macros for entire MCM_PLASC register
 */
/*@{*/
#define MCM_RD_PLASC(base)       (MCM_PLASC_REG(base))
/*@}*/

/*
 * Constants & macros for individual MCM_PLASC bitfields
 */

/*!
 * @name Register MCM_PLASC, field ASC[7:0] (RO)
 *
 * Values:
 * - 0b00000000 - A bus slave connection to AXBS input port n is absent.
 * - 0b00000001 - A bus slave connection to AXBS input port n is present.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLASC_ASC field. */
#define MCM_RD_PLASC_ASC(base) ((MCM_PLASC_REG(base) & MCM_PLASC_ASC_MASK) >> MCM_PLASC_ASC_SHIFT)
#define MCM_BRD_PLASC_ASC(base) (MCM_RD_PLASC_ASC(base))
/*@}*/

/*******************************************************************************
 * MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration
 ******************************************************************************/

/*!
 * @brief MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration (RO)
 *
 * Reset value: 0x0005U
 *
 * PLAMC is a 16-bit read-only register identifying the presence/absence of bus
 * master connections to the device's crossbar switch.
 */
/*!
 * @name Constants and macros for entire MCM_PLAMC register
 */
/*@{*/
#define MCM_RD_PLAMC(base)       (MCM_PLAMC_REG(base))
/*@}*/

/*
 * Constants & macros for individual MCM_PLAMC bitfields
 */

/*!
 * @name Register MCM_PLAMC, field AMC[7:0] (RO)
 *
 * Values:
 * - 0b00000000 - A bus master connection to AXBS input port n is absent
 * - 0b00000001 - A bus master connection to AXBS input port n is present
 */
/*@{*/
/*! @brief Read current value of the MCM_PLAMC_AMC field. */
#define MCM_RD_PLAMC_AMC(base) ((MCM_PLAMC_REG(base) & MCM_PLAMC_AMC_MASK) >> MCM_PLAMC_AMC_SHIFT)
#define MCM_BRD_PLAMC_AMC(base) (MCM_RD_PLAMC_AMC(base))
/*@}*/

/*******************************************************************************
 * MCM_PLACR - Platform Control Register
 ******************************************************************************/

/*!
 * @brief MCM_PLACR - Platform Control Register (RW)
 *
 * Reset value: 0x00000050U
 *
 * The PLACR register selects the arbitration policy for the crossbar masters
 * and configures the flash memory controller. The speculation buffer and cache in
 * the flash memory controller is configurable via PLACR[15:10 ]. The speculation
 * buffer is enabled only for instructions after reset. It is possible to have
 * these states for the speculation buffer: DFCS EFDS Description 0 0 Speculation
 * buffer is on for instruction and off for data. 0 1 Speculation buffer is on
 * for instruction and on for data. 1 X Speculation buffer is off. The cache in
 * flash controller is enabled and caching both instruction and data type fetches
 * after reset. It is possible to have these states for the cache: DFCC DFCIC DFCDA
 * Description 0 0 0 Cache is on for both instruction and data. 0 0 1 Cache is
 * on for instruction and off for data. 0 1 0 Cache is off for instruction and on
 * for data. 0 1 1 Cache is off for both instruction and data. 1 X X Cache is
 * off. ***FOR APACHE ONLY (as far as Alan Ratliff knows on 17 June 2014) from...
 * Document Number: APACHE PLATREQ, Rev 6.0, Oct.15, 2013*** Some of these bits may
 * be for internal use only: [1:0] AXBS stall FSM (read-only) [2] AXBS stall
 * request (read-only) [3] AXBS halted (read-only) [4] PFLASHC idle (read-only) [6]
 * PBRIDGE Idle (read-only) [18] Enable inserting 1T delay on BME undecorated
 * read data path [19] Enable inserting 1T delay on BME undecorated write data path
 */
/*!
 * @name Constants and macros for entire MCM_PLACR register
 */
/*@{*/
#define MCM_RD_PLACR(base)       (MCM_PLACR_REG(base))
#define MCM_WR_PLACR(base, value) (MCM_PLACR_REG(base) = (value))
#define MCM_RMW_PLACR(base, mask, value) (MCM_WR_PLACR(base, (MCM_RD_PLACR(base) & ~(mask)) | (value)))
#define MCM_SET_PLACR(base, value) (MCM_WR_PLACR(base, MCM_RD_PLACR(base) |  (value)))
#define MCM_CLR_PLACR(base, value) (MCM_WR_PLACR(base, MCM_RD_PLACR(base) & ~(value)))
#define MCM_TOG_PLACR(base, value) (MCM_WR_PLACR(base, MCM_RD_PLACR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_PLACR bitfields
 */

/*!
 * @name Register MCM_PLACR, field ARB[9] (RW)
 *
 * Values:
 * - 0b0 - Fixed-priority arbitration for the crossbar masters
 * - 0b1 - Round-robin arbitration for the crossbar masters
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_ARB field. */
#define MCM_RD_PLACR_ARB(base) ((MCM_PLACR_REG(base) & MCM_PLACR_ARB_MASK) >> MCM_PLACR_ARB_SHIFT)
#define MCM_BRD_PLACR_ARB(base) (MCM_RD_PLACR_ARB(base))

/*! @brief Set the ARB field to a new value. */
#define MCM_WR_PLACR_ARB(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_ARB_MASK, MCM_PLACR_ARB(value)))
#define MCM_BWR_PLACR_ARB(base, value) (MCM_WR_PLACR_ARB(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field CFCC[10] (WORZ)
 *
 * Writing a 1 to this field clears the cache. Writing a 0 to this field is
 * ignored. This field always reads as 0.
 */
/*@{*/
/*! @brief Set the CFCC field to a new value. */
#define MCM_WR_PLACR_CFCC(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_CFCC_MASK, MCM_PLACR_CFCC(value)))
#define MCM_BWR_PLACR_CFCC(base, value) (MCM_WR_PLACR_CFCC(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCDA[11] (RW)
 *
 * Disables flash controller data caching.
 *
 * Values:
 * - 0b0 - Enable flash controller data caching
 * - 0b1 - Disable flash controller data caching.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_DFCDA field. */
#define MCM_RD_PLACR_DFCDA(base) ((MCM_PLACR_REG(base) & MCM_PLACR_DFCDA_MASK) >> MCM_PLACR_DFCDA_SHIFT)
#define MCM_BRD_PLACR_DFCDA(base) (MCM_RD_PLACR_DFCDA(base))

/*! @brief Set the DFCDA field to a new value. */
#define MCM_WR_PLACR_DFCDA(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_DFCDA_MASK, MCM_PLACR_DFCDA(value)))
#define MCM_BWR_PLACR_DFCDA(base, value) (MCM_WR_PLACR_DFCDA(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCIC[12] (RW)
 *
 * Disables flash controller instruction caching.
 *
 * Values:
 * - 0b0 - Enable flash controller instruction caching.
 * - 0b1 - Disable flash controller instruction caching.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_DFCIC field. */
#define MCM_RD_PLACR_DFCIC(base) ((MCM_PLACR_REG(base) & MCM_PLACR_DFCIC_MASK) >> MCM_PLACR_DFCIC_SHIFT)
#define MCM_BRD_PLACR_DFCIC(base) (MCM_RD_PLACR_DFCIC(base))

/*! @brief Set the DFCIC field to a new value. */
#define MCM_WR_PLACR_DFCIC(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_DFCIC_MASK, MCM_PLACR_DFCIC(value)))
#define MCM_BWR_PLACR_DFCIC(base, value) (MCM_WR_PLACR_DFCIC(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCC[13] (RW)
 *
 * Disables flash controller cache.
 *
 * Values:
 * - 0b0 - Enable flash controller cache.
 * - 0b1 - Disable flash controller cache.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_DFCC field. */
#define MCM_RD_PLACR_DFCC(base) ((MCM_PLACR_REG(base) & MCM_PLACR_DFCC_MASK) >> MCM_PLACR_DFCC_SHIFT)
#define MCM_BRD_PLACR_DFCC(base) (MCM_RD_PLACR_DFCC(base))

/*! @brief Set the DFCC field to a new value. */
#define MCM_WR_PLACR_DFCC(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_DFCC_MASK, MCM_PLACR_DFCC(value)))
#define MCM_BWR_PLACR_DFCC(base, value) (MCM_WR_PLACR_DFCC(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field EFDS[14] (RW)
 *
 * Enables flash data speculation.
 *
 * Values:
 * - 0b0 - Disable flash data speculation.
 * - 0b1 - Enable flash data speculation.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_EFDS field. */
#define MCM_RD_PLACR_EFDS(base) ((MCM_PLACR_REG(base) & MCM_PLACR_EFDS_MASK) >> MCM_PLACR_EFDS_SHIFT)
#define MCM_BRD_PLACR_EFDS(base) (MCM_RD_PLACR_EFDS(base))

/*! @brief Set the EFDS field to a new value. */
#define MCM_WR_PLACR_EFDS(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_EFDS_MASK, MCM_PLACR_EFDS(value)))
#define MCM_BWR_PLACR_EFDS(base, value) (MCM_WR_PLACR_EFDS(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCS[15] (RW)
 *
 * Disables flash controller speculation.
 *
 * Values:
 * - 0b0 - Enable flash controller speculation.
 * - 0b1 - Disable flash controller speculation.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_DFCS field. */
#define MCM_RD_PLACR_DFCS(base) ((MCM_PLACR_REG(base) & MCM_PLACR_DFCS_MASK) >> MCM_PLACR_DFCS_SHIFT)
#define MCM_BRD_PLACR_DFCS(base) (MCM_RD_PLACR_DFCS(base))

/*! @brief Set the DFCS field to a new value. */
#define MCM_WR_PLACR_DFCS(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_DFCS_MASK, MCM_PLACR_DFCS(value)))
#define MCM_BWR_PLACR_DFCS(base, value) (MCM_WR_PLACR_DFCS(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field ESFC[16] (RW)
 *
 * Enables stalling flash controller when flash is busy. When software needs to
 * access the flash memory while a flash memory resource is being manipulated by
 * a flash command, software can enable a stall mechanism to avoid a read
 * collision. The stall mechanism allows software to execute code from the same block on
 * which flash operations are being performed. However, software must ensure the
 * sector the flash operations are being performed on is not the same sector
 * from which the code is executing. ESFC enables the stall mechanism. This bit must
 * be set only just before the flash operation is executed and must be cleared
 * when the operation completes.
 *
 * Values:
 * - 0b0 - Disable stalling flash controller when flash is busy.
 * - 0b1 - Enable stalling flash controller when flash is busy.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_ESFC field. */
#define MCM_RD_PLACR_ESFC(base) ((MCM_PLACR_REG(base) & MCM_PLACR_ESFC_MASK) >> MCM_PLACR_ESFC_SHIFT)
#define MCM_BRD_PLACR_ESFC(base) (MCM_RD_PLACR_ESFC(base))

/*! @brief Set the ESFC field to a new value. */
#define MCM_WR_PLACR_ESFC(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_ESFC_MASK, MCM_PLACR_ESFC(value)))
#define MCM_BWR_PLACR_ESFC(base, value) (MCM_WR_PLACR_ESFC(base, value))
/*@}*/

/*******************************************************************************
 * MCM_CPO - Compute Operation Control Register
 ******************************************************************************/

/*!
 * @brief MCM_CPO - Compute Operation Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the Compute Operation.
 */
/*!
 * @name Constants and macros for entire MCM_CPO register
 */
/*@{*/
#define MCM_RD_CPO(base)         (MCM_CPO_REG(base))
#define MCM_WR_CPO(base, value)  (MCM_CPO_REG(base) = (value))
#define MCM_RMW_CPO(base, mask, value) (MCM_WR_CPO(base, (MCM_RD_CPO(base) & ~(mask)) | (value)))
#define MCM_SET_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) |  (value)))
#define MCM_CLR_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) & ~(value)))
#define MCM_TOG_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_CPO bitfields
 */

/*!
 * @name Register MCM_CPO, field CPOREQ[0] (RW)
 *
 * This bit is auto-cleared by vector fetching if CPOWOI = 1.
 *
 * Values:
 * - 0b0 - Request is cleared.
 * - 0b1 - Request Compute Operation.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOREQ field. */
#define MCM_RD_CPO_CPOREQ(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOREQ_MASK) >> MCM_CPO_CPOREQ_SHIFT)
#define MCM_BRD_CPO_CPOREQ(base) (MCM_RD_CPO_CPOREQ(base))

/*! @brief Set the CPOREQ field to a new value. */
#define MCM_WR_CPO_CPOREQ(base, value) (MCM_RMW_CPO(base, MCM_CPO_CPOREQ_MASK, MCM_CPO_CPOREQ(value)))
#define MCM_BWR_CPO_CPOREQ(base, value) (MCM_WR_CPO_CPOREQ(base, value))
/*@}*/

/*!
 * @name Register MCM_CPO, field CPOACK[1] (RO)
 *
 * Values:
 * - 0b0 - Compute operation entry has not completed or compute operation exit
 *     has completed.
 * - 0b1 - Compute operation entry has completed or compute operation exit has
 *     not completed.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOACK field. */
#define MCM_RD_CPO_CPOACK(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOACK_MASK) >> MCM_CPO_CPOACK_SHIFT)
#define MCM_BRD_CPO_CPOACK(base) (MCM_RD_CPO_CPOACK(base))
/*@}*/

/*!
 * @name Register MCM_CPO, field CPOWOI[2] (RW)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - When set, the CPOREQ is cleared on any interrupt or exception vector
 *     fetch.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOWOI field. */
#define MCM_RD_CPO_CPOWOI(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOWOI_MASK) >> MCM_CPO_CPOWOI_SHIFT)
#define MCM_BRD_CPO_CPOWOI(base) (MCM_RD_CPO_CPOWOI(base))

/*! @brief Set the CPOWOI field to a new value. */
#define MCM_WR_CPO_CPOWOI(base, value) (MCM_RMW_CPO(base, MCM_CPO_CPOWOI_MASK, MCM_CPO_CPOWOI(value)))
#define MCM_BWR_CPO_CPOWOI(base, value) (MCM_WR_CPO_CPOWOI(base, value))
/*@}*/

/*
 * MKW40Z4 MTB
 *
 * Micro Trace Buffer
 *
 * Registers defined in this header file:
 * - MTB_POSITION - MTB Position Register
 * - MTB_MASTER - MTB Master Register
 * - MTB_FLOW - MTB Flow Register
 * - MTB_BASE - MTB Base Register
 * - MTB_MODECTRL - Integration Mode Control Register
 * - MTB_TAGSET - Claim TAG Set Register
 * - MTB_TAGCLEAR - Claim TAG Clear Register
 * - MTB_LOCKACCESS - Lock Access Register
 * - MTB_LOCKSTAT - Lock Status Register
 * - MTB_AUTHSTAT - Authentication Status Register
 * - MTB_DEVICEARCH - Device Architecture Register
 * - MTB_DEVICECFG - Device Configuration Register
 * - MTB_DEVICETYPID - Device Type Identifier Register
 * - MTB_PERIPHID - Peripheral ID Register
 * - MTB_COMPID - Component ID Register
 */

#define MTB_INSTANCE_COUNT (1U) /*!< Number of instances of the MTB module. */
#define MTB_IDX (0U) /*!< Instance number for MTB. */

/*******************************************************************************
 * MTB_POSITION - MTB Position Register
 ******************************************************************************/

/*!
 * @brief MTB_POSITION - MTB Position Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTB_POSITION register contains the Trace Write Address Pointer and Wrap
 * fields. This register can be modified by the explicit programming model writes.
 * It is also automatically updated by the MTB hardware when trace packets are
 * being recorded. The base address of the system RAM in the memory map dictates
 * special consideration for the placement of the MTB. Consider the following
 * guidelines: For the standard configuration where the size of the MTB is <= 25% of
 * the total RAM capacity, it is recommended the MTB be based at the address
 * defined by the MTB_BASE register. The read-only MTB_BASE register is defined by
 * the expression (0x2000_0000 - (RAM_Size/4)). For this configuration, the
 * MTB_POSITION register is initialized to MTB_BASE & 0x0000_7FF8. If the size of the
 * MTB is more than 25% but less than or equal to 50% of the total RAM capacity, it
 * is recommended the MTB be based at address 0x2000_0000. In this
 * configuration, the MTB_POSITION register is initialized to (0x2000_0000 & 0x0000_7FF8) =
 * 0x0000_00000. Following these two suggested placements provides a full-featured
 * circular memory buffer containing program trace packets. In the unlikely event
 * an even larger trace buffer is required, a write-once capacity of 75% of the
 * total RAM capacity can be based at address 0x2000_0000. The MTB_POSITION
 * register is initialized to (0x2000_0000 & 0x0000_7FF8) = 0x0000_0000. However, this
 * configuration cannot support operation as a circular queue and instead
 * requires the use of the MTB_FLOW[WATERMARK] capability to automatically disable
 * tracing or halting the processor as the number of packet writes approach the
 * buffer capacity. See the MTB_FLOW register description for more details.
 */
/*!
 * @name Constants and macros for entire MTB_POSITION register
 */
/*@{*/
#define MTB_RD_POSITION(base)    (MTB_POSITION_REG(base))
#define MTB_WR_POSITION(base, value) (MTB_POSITION_REG(base) = (value))
#define MTB_RMW_POSITION(base, mask, value) (MTB_WR_POSITION(base, (MTB_RD_POSITION(base) & ~(mask)) | (value)))
#define MTB_SET_POSITION(base, value) (MTB_WR_POSITION(base, MTB_RD_POSITION(base) |  (value)))
#define MTB_CLR_POSITION(base, value) (MTB_WR_POSITION(base, MTB_RD_POSITION(base) & ~(value)))
#define MTB_TOG_POSITION(base, value) (MTB_WR_POSITION(base, MTB_RD_POSITION(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTB_POSITION bitfields
 */

/*!
 * @name Register MTB_POSITION, field WRAP[2] (RW)
 *
 * This field is set to 1 automatically when the POINTER value wraps as
 * determined by the MTB_MASTER[MASK] field in the MASTER Trace Control Register. A debug
 * agent might use the WRAP field to determine whether the trace information
 * above and below the pointer address is valid.
 */
/*@{*/
/*! @brief Read current value of the MTB_POSITION_WRAP field. */
#define MTB_RD_POSITION_WRAP(base) ((MTB_POSITION_REG(base) & MTB_POSITION_WRAP_MASK) >> MTB_POSITION_WRAP_SHIFT)
#define MTB_BRD_POSITION_WRAP(base) (MTB_RD_POSITION_WRAP(base))

/*! @brief Set the WRAP field to a new value. */
#define MTB_WR_POSITION_WRAP(base, value) (MTB_RMW_POSITION(base, MTB_POSITION_WRAP_MASK, MTB_POSITION_WRAP(value)))
#define MTB_BWR_POSITION_WRAP(base, value) (MTB_WR_POSITION_WRAP(base, value))
/*@}*/

/*!
 * @name Register MTB_POSITION, field POINTER[31:3] (RW)
 *
 * Because a packet consists of two words, the POINTER field is the address of
 * the first word of a packet. This field contains bits[31:3] of the RAM address
 * where the next trace packet is written. Therefore, it points to an unused
 * location and is automatically incremented. A debug agent can calculate the system
 * memory map address for the current location in the MTB using the following
 * "generic" equation: Given mtb_size = 1 << (MTB_MASTER[MASK] + 4), systemAddress =
 * MTB_BASE + (((MTB_POSITION & 0xFFFF_FFF8) + (mtb_size - (MTB_BASE &
 * (mtb_size-1)))) & 0x0000_7FF8); For this device, a simpler expression also applies. See
 * the following pseudo-code: if ((MTB_POSITION >> 13) == 0x3) systemAddress =
 * (0x1FFF << 16) + (0x1 << 15) + (MTB_POSITION & 0x7FF8); else systemAddress =
 * (0x2000 << 16) + (0x0 << 15) + (MTB_POSITION & 0x7FF8); The size of the RAM is
 * parameterized and the most significant bits of the POINTER field are RAZ/WI. For
 * these devices, POSITION[31:15] == POSITION[POINTER[28:12]] are RAZ/WI.
 * Therefore, the active bits in this field are POSITION[14:3] ==
 * POSITION[POINTER[11:0]].
 */
/*@{*/
/*! @brief Read current value of the MTB_POSITION_POINTER field. */
#define MTB_RD_POSITION_POINTER(base) ((MTB_POSITION_REG(base) & MTB_POSITION_POINTER_MASK) >> MTB_POSITION_POINTER_SHIFT)
#define MTB_BRD_POSITION_POINTER(base) (MTB_RD_POSITION_POINTER(base))

/*! @brief Set the POINTER field to a new value. */
#define MTB_WR_POSITION_POINTER(base, value) (MTB_RMW_POSITION(base, MTB_POSITION_POINTER_MASK, MTB_POSITION_POINTER(value)))
#define MTB_BWR_POSITION_POINTER(base, value) (MTB_WR_POSITION_POINTER(base, value))
/*@}*/

/*******************************************************************************
 * MTB_MASTER - MTB Master Register
 ******************************************************************************/

/*!
 * @brief MTB_MASTER - MTB Master Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * The MTB_MASTER register contains the main program trace enable plus other
 * trace controls. This register can be modified by the explicit programming model
 * writes. MTB_MASTER[EN] and MTB_MASTER[HALTREQ] fields are also automatically
 * updated by the MTB hardware. Before MTB_MASTER[EN] or MTB_MASTER[TSTARTEN] are
 * set to 1, the software must initialize the MTB_POSITION and MTB_FLOW registers.
 * If MTB_FLOW[WATERMARK] is used to stop tracing or to halt the processor,
 * MTB_MASTER[MASK] must still be set to a value that prevents MTB_POSITION[POINTER]
 * from wrapping before it reaches the MTB_FLOW[WATERMARK] value. The format of
 * this mask field is different than MTBDWT_MASKn[MASK].
 */
/*!
 * @name Constants and macros for entire MTB_MASTER register
 */
/*@{*/
#define MTB_RD_MASTER(base)      (MTB_MASTER_REG(base))
#define MTB_WR_MASTER(base, value) (MTB_MASTER_REG(base) = (value))
#define MTB_RMW_MASTER(base, mask, value) (MTB_WR_MASTER(base, (MTB_RD_MASTER(base) & ~(mask)) | (value)))
#define MTB_SET_MASTER(base, value) (MTB_WR_MASTER(base, MTB_RD_MASTER(base) |  (value)))
#define MTB_CLR_MASTER(base, value) (MTB_WR_MASTER(base, MTB_RD_MASTER(base) & ~(value)))
#define MTB_TOG_MASTER(base, value) (MTB_WR_MASTER(base, MTB_RD_MASTER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTB_MASTER bitfields
 */

/*!
 * @name Register MTB_MASTER, field MASK[4:0] (RW)
 *
 * This value determines the maximum size of the trace buffer in RAM. It
 * specifies the most-significant bit of the MTB_POSITION[POINTER] field that can be
 * updated by automatic increment. If the trace tries to advance past this power of
 * 2, the MTB_POSITION[WRAP] bit is set to 1, the MTB_POSITION[MASK+3:3] ==
 * MTB_POSITION[POINTER[MASK:0]] bits are set to 0, and the MTB_POSITION[14:MASK+3] ==
 * MTB_POSITION[POINTER[11:MASK+1]] bits remain unchanged. This field causes the
 * trace packet information to be stored in a circular buffer of size 2^[MASK+4]
 * bytes, that can be positioned in memory at multiples of this size. As
 * detailed in the MTB_POSITION description, typical "upper limits" for the MTB size are
 * RAM_Size/4 or RAM_Size/2. Values greater than the maximum have the same
 * effect as the maximum.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_MASK field. */
#define MTB_RD_MASTER_MASK(base) ((MTB_MASTER_REG(base) & MTB_MASTER_MASK_MASK) >> MTB_MASTER_MASK_SHIFT)
#define MTB_BRD_MASTER_MASK(base) (MTB_RD_MASTER_MASK(base))

/*! @brief Set the MASK field to a new value. */
#define MTB_WR_MASTER_MASK(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_MASK_MASK, MTB_MASTER_MASK(value)))
#define MTB_BWR_MASTER_MASK(base, value) (MTB_WR_MASTER_MASK(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field TSTARTEN[5] (RW)
 *
 * If this field is 1 and the TSTART signal is HIGH, then EN is set to 1.
 * Tracing continues until a stop condition occurs.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_TSTARTEN field. */
#define MTB_RD_MASTER_TSTARTEN(base) ((MTB_MASTER_REG(base) & MTB_MASTER_TSTARTEN_MASK) >> MTB_MASTER_TSTARTEN_SHIFT)
#define MTB_BRD_MASTER_TSTARTEN(base) (MTB_RD_MASTER_TSTARTEN(base))

/*! @brief Set the TSTARTEN field to a new value. */
#define MTB_WR_MASTER_TSTARTEN(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_TSTARTEN_MASK, MTB_MASTER_TSTARTEN(value)))
#define MTB_BWR_MASTER_TSTARTEN(base, value) (MTB_WR_MASTER_TSTARTEN(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field TSTOPEN[6] (RW)
 *
 * If this field is 1 and the TSTOP signal is HIGH, then EN is set to 0. If a
 * trace packet is being written to memory, the write is completed before tracing
 * is stopped.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_TSTOPEN field. */
#define MTB_RD_MASTER_TSTOPEN(base) ((MTB_MASTER_REG(base) & MTB_MASTER_TSTOPEN_MASK) >> MTB_MASTER_TSTOPEN_SHIFT)
#define MTB_BRD_MASTER_TSTOPEN(base) (MTB_RD_MASTER_TSTOPEN(base))

/*! @brief Set the TSTOPEN field to a new value. */
#define MTB_WR_MASTER_TSTOPEN(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_TSTOPEN_MASK, MTB_MASTER_TSTOPEN(value)))
#define MTB_BWR_MASTER_TSTOPEN(base, value) (MTB_WR_MASTER_TSTOPEN(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field SFRWPRIV[7] (RW)
 *
 * If this field is 0, then user or privileged AHB read and write accesses to
 * the MTB_RAM Special Function Registers (programming model) are permitted. If
 * this field is 1, then only privileged write accesses are permitted; user write
 * accesses are ignored. The HPROT[1] signal determines if an access is user or
 * privileged. Note MTB_RAM SFR read access are not controlled by this bit and are
 * always permitted.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_SFRWPRIV field. */
#define MTB_RD_MASTER_SFRWPRIV(base) ((MTB_MASTER_REG(base) & MTB_MASTER_SFRWPRIV_MASK) >> MTB_MASTER_SFRWPRIV_SHIFT)
#define MTB_BRD_MASTER_SFRWPRIV(base) (MTB_RD_MASTER_SFRWPRIV(base))

/*! @brief Set the SFRWPRIV field to a new value. */
#define MTB_WR_MASTER_SFRWPRIV(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_SFRWPRIV_MASK, MTB_MASTER_SFRWPRIV(value)))
#define MTB_BWR_MASTER_SFRWPRIV(base, value) (MTB_WR_MASTER_SFRWPRIV(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field RAMPRIV[8] (RW)
 *
 * If this field is 0, then user or privileged AHB read and write accesses to
 * the RAM are permitted. If this field is 1, then only privileged AHB read and
 * write accesses to the RAM are permitted and user accesses are RAZ/WI. The
 * HPROT[1] signal determines if an access is a user or privileged mode reference.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_RAMPRIV field. */
#define MTB_RD_MASTER_RAMPRIV(base) ((MTB_MASTER_REG(base) & MTB_MASTER_RAMPRIV_MASK) >> MTB_MASTER_RAMPRIV_SHIFT)
#define MTB_BRD_MASTER_RAMPRIV(base) (MTB_RD_MASTER_RAMPRIV(base))

/*! @brief Set the RAMPRIV field to a new value. */
#define MTB_WR_MASTER_RAMPRIV(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_RAMPRIV_MASK, MTB_MASTER_RAMPRIV(value)))
#define MTB_BWR_MASTER_RAMPRIV(base, value) (MTB_WR_MASTER_RAMPRIV(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field HALTREQ[9] (RW)
 *
 * This field is connected to the halt request signal of the trace logic,
 * EDBGRQ. When HALTREQ is set to 1, the EDBFGRQ is asserted if DBGEN (invasive debug
 * enable, one of the debug authentication interface signals) is also HIGH.
 * HALTREQ can be automatically set to 1 using MTB_FLOW[WATERMARK].
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_HALTREQ field. */
#define MTB_RD_MASTER_HALTREQ(base) ((MTB_MASTER_REG(base) & MTB_MASTER_HALTREQ_MASK) >> MTB_MASTER_HALTREQ_SHIFT)
#define MTB_BRD_MASTER_HALTREQ(base) (MTB_RD_MASTER_HALTREQ(base))

/*! @brief Set the HALTREQ field to a new value. */
#define MTB_WR_MASTER_HALTREQ(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_HALTREQ_MASK, MTB_MASTER_HALTREQ(value)))
#define MTB_BWR_MASTER_HALTREQ(base, value) (MTB_WR_MASTER_HALTREQ(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field EN[31] (RW)
 *
 * When this field is 1, trace data is written into the RAM memory location
 * addressed by MTB_POSITION[POINTER]. The MTB_POSITION[POINTER] value auto
 * increments after the trace data packet is written. EN can be automatically set to 0
 * using the MTB_FLOW[WATERMARK] field and the MTB_FLOW[AUTOSTOP] bit. EN is
 * automatically set to 1 if TSTARTEN is 1 and the TSTART signal is HIGH. EN is
 * automatically set to 0 if TSTOPEN is 1 and the TSTOP signal is HIGH. If EN is set to 0
 * because MTB_FLOW[WATERMARK] is set, then it is not automatically set to 1 if
 * TSTARTEN is 1 and the TSTART input is HIGH. In this case, tracing can only be
 * restarted if MTB_FLOW[WATERMARK] or MTB_POSITION[POINTER] value is changed by
 * software.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_EN field. */
#define MTB_RD_MASTER_EN(base) ((MTB_MASTER_REG(base) & MTB_MASTER_EN_MASK) >> MTB_MASTER_EN_SHIFT)
#define MTB_BRD_MASTER_EN(base) (MTB_RD_MASTER_EN(base))

/*! @brief Set the EN field to a new value. */
#define MTB_WR_MASTER_EN(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_EN_MASK, MTB_MASTER_EN(value)))
#define MTB_BWR_MASTER_EN(base, value) (MTB_WR_MASTER_EN(base, value))
/*@}*/

/*******************************************************************************
 * MTB_FLOW - MTB Flow Register
 ******************************************************************************/

/*!
 * @brief MTB_FLOW - MTB Flow Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTB_FLOW register contains the watermark address and the
 * autostop/autohalt control bits. If tracing is stopped using the watermark autostop feature, it
 * cannot be restarted until software clears the watermark autostop. This can be
 * achieved in one of the following ways: Changing the MTB_POSITION[POINTER]
 * field value to point to the beginning of the trace buffer, or Setting
 * MTB_FLOW[AUTOSTOP] = 0. A debug agent can use MTB_FLOW[AUTOSTOP] to fill the trace buffer
 * once only without halting the processor. A debug agent can use
 * MTB_FLOW[AUTOHALT] to fill the trace buffer once before causing the Cortex-M0+ processor to
 * enter the Debug state. To enter Debug state, the Cortex-M0+ processor might
 * have to perform additional branch type operations. Therefore, the
 * MTB_FLOW[WATERMARK] field must be set below the final entry in the trace buffer region.
 */
/*!
 * @name Constants and macros for entire MTB_FLOW register
 */
/*@{*/
#define MTB_RD_FLOW(base)        (MTB_FLOW_REG(base))
#define MTB_WR_FLOW(base, value) (MTB_FLOW_REG(base) = (value))
#define MTB_RMW_FLOW(base, mask, value) (MTB_WR_FLOW(base, (MTB_RD_FLOW(base) & ~(mask)) | (value)))
#define MTB_SET_FLOW(base, value) (MTB_WR_FLOW(base, MTB_RD_FLOW(base) |  (value)))
#define MTB_CLR_FLOW(base, value) (MTB_WR_FLOW(base, MTB_RD_FLOW(base) & ~(value)))
#define MTB_TOG_FLOW(base, value) (MTB_WR_FLOW(base, MTB_RD_FLOW(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTB_FLOW bitfields
 */

/*!
 * @name Register MTB_FLOW, field AUTOSTOP[0] (RW)
 *
 * If this field is 1 and WATERMARK is equal to MTB_POSITION[POINTER], then
 * MTB_MASTER[EN] is automatically set to 0. This stops tracing.
 */
/*@{*/
/*! @brief Read current value of the MTB_FLOW_AUTOSTOP field. */
#define MTB_RD_FLOW_AUTOSTOP(base) ((MTB_FLOW_REG(base) & MTB_FLOW_AUTOSTOP_MASK) >> MTB_FLOW_AUTOSTOP_SHIFT)
#define MTB_BRD_FLOW_AUTOSTOP(base) (MTB_RD_FLOW_AUTOSTOP(base))

/*! @brief Set the AUTOSTOP field to a new value. */
#define MTB_WR_FLOW_AUTOSTOP(base, value) (MTB_RMW_FLOW(base, MTB_FLOW_AUTOSTOP_MASK, MTB_FLOW_AUTOSTOP(value)))
#define MTB_BWR_FLOW_AUTOSTOP(base, value) (MTB_WR_FLOW_AUTOSTOP(base, value))
/*@}*/

/*!
 * @name Register MTB_FLOW, field AUTOHALT[1] (RW)
 *
 * If this field is 1 and WATERMARK is equal to MTB_POSITION[POINTER], then
 * MTB_MASTER[HALTREQ] is automatically set to 1. If the DBGEN signal is HIGH, the
 * MTB asserts this halt request to the Cortex-M0+ processor by asserting the
 * EDBGRQ signal.
 */
/*@{*/
/*! @brief Read current value of the MTB_FLOW_AUTOHALT field. */
#define MTB_RD_FLOW_AUTOHALT(base) ((MTB_FLOW_REG(base) & MTB_FLOW_AUTOHALT_MASK) >> MTB_FLOW_AUTOHALT_SHIFT)
#define MTB_BRD_FLOW_AUTOHALT(base) (MTB_RD_FLOW_AUTOHALT(base))

/*! @brief Set the AUTOHALT field to a new value. */
#define MTB_WR_FLOW_AUTOHALT(base, value) (MTB_RMW_FLOW(base, MTB_FLOW_AUTOHALT_MASK, MTB_FLOW_AUTOHALT(value)))
#define MTB_BWR_FLOW_AUTOHALT(base, value) (MTB_WR_FLOW_AUTOHALT(base, value))
/*@}*/

/*!
 * @name Register MTB_FLOW, field WATERMARK[31:3] (RW)
 *
 * This field contains an address in the same format as the
 * MTB_POSITION[POINTER] field. When MTB_POSITION[POINTER] matches the WATERMARK field value, actions
 * defined by the AUTOHALT and AUTOSTOP bits are performed.
 */
/*@{*/
/*! @brief Read current value of the MTB_FLOW_WATERMARK field. */
#define MTB_RD_FLOW_WATERMARK(base) ((MTB_FLOW_REG(base) & MTB_FLOW_WATERMARK_MASK) >> MTB_FLOW_WATERMARK_SHIFT)
#define MTB_BRD_FLOW_WATERMARK(base) (MTB_RD_FLOW_WATERMARK(base))

/*! @brief Set the WATERMARK field to a new value. */
#define MTB_WR_FLOW_WATERMARK(base, value) (MTB_RMW_FLOW(base, MTB_FLOW_WATERMARK_MASK, MTB_FLOW_WATERMARK(value)))
#define MTB_BWR_FLOW_WATERMARK(base, value) (MTB_WR_FLOW_WATERMARK(base, value))
/*@}*/

/*******************************************************************************
 * MTB_BASE - MTB Base Register
 ******************************************************************************/

/*!
 * @brief MTB_BASE - MTB Base Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The read-only MTB_BASE Register indicates where the RAM is located in the
 * system memory map. This register is provided to enable auto discovery of the MTB
 * RAM location, by a debug agent and is defined by a hardware design parameter.
 * For this device, the base address is defined by the expression:
 * MTB_BASE[BASEADDR] = 0x2000_0000 - (RAM_Size/4)
 */
/*!
 * @name Constants and macros for entire MTB_BASE register
 */
/*@{*/
#define MTB_RD_BASE(base)        (MTB_BASE_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_MODECTRL - Integration Mode Control Register
 ******************************************************************************/

/*!
 * @brief MTB_MODECTRL - Integration Mode Control Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register enables the device to switch from a functional mode, or default
 * behavior, into integration mode. It is hardwired to specific values used
 * during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_MODECTRL register
 */
/*@{*/
#define MTB_RD_MODECTRL(base)    (MTB_MODECTRL_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_TAGSET - Claim TAG Set Register
 ******************************************************************************/

/*!
 * @brief MTB_TAGSET - Claim TAG Set Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Claim Tag Set Register returns the number of bits that can be set on a
 * read, and enables individual bits to be set on a write. It is hardwired to
 * specific values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_TAGSET register
 */
/*@{*/
#define MTB_RD_TAGSET(base)      (MTB_TAGSET_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_TAGCLEAR - Claim TAG Clear Register
 ******************************************************************************/

/*!
 * @brief MTB_TAGCLEAR - Claim TAG Clear Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The read/write Claim Tag Clear Register is used to read the claim status on
 * debug resources. A read indicates the claim tag status. Writing 1 to a specific
 * bit clears the corresponding claim tag to 0. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_TAGCLEAR register
 */
/*@{*/
#define MTB_RD_TAGCLEAR(base)    (MTB_TAGCLEAR_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_LOCKACCESS - Lock Access Register
 ******************************************************************************/

/*!
 * @brief MTB_LOCKACCESS - Lock Access Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Lock Access Register enables a write access to component registers. It is
 * hardwired to specific values used during the auto-discovery process by an
 * external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_LOCKACCESS register
 */
/*@{*/
#define MTB_RD_LOCKACCESS(base)  (MTB_LOCKACCESS_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_LOCKSTAT - Lock Status Register
 ******************************************************************************/

/*!
 * @brief MTB_LOCKSTAT - Lock Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Lock Status Register indicates the status of the lock control mechanism.
 * This register is used in conjunction with the Lock Access Register. It is
 * hardwired to specific values used during the auto-discovery process by an external
 * debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_LOCKSTAT register
 */
/*@{*/
#define MTB_RD_LOCKSTAT(base)    (MTB_LOCKSTAT_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_AUTHSTAT - Authentication Status Register
 ******************************************************************************/

/*!
 * @brief MTB_AUTHSTAT - Authentication Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Authentication Status Register reports the required security level and
 * current status of the security enable bit pairs. Where functionality changes on
 * a given security level, this change must be reported in this register. It is
 * connected to specific signals used during the auto-discovery process by an
 * external debug agent. MTB_AUTHSTAT[3:2] indicates if nonsecure, noninvasive debug
 * is enabled or disabled, while MTB_AUTHSTAT[1:0] indicates the enabled/disabled
 * state of nonsecure, invasive debug. For both 2-bit fields, 0b10 indicates the
 * functionality is disabled and 0b11 indicates it is enabled.
 */
/*!
 * @name Constants and macros for entire MTB_AUTHSTAT register
 */
/*@{*/
#define MTB_RD_AUTHSTAT(base)    (MTB_AUTHSTAT_REG(base))
/*@}*/

/*
 * Constants & macros for individual MTB_AUTHSTAT bitfields
 */

/*!
 * @name Register MTB_AUTHSTAT, field BIT0[0] (RO)
 *
 * Connected to DBGEN.
 */
/*@{*/
/*! @brief Read current value of the MTB_AUTHSTAT_BIT0 field. */
#define MTB_RD_AUTHSTAT_BIT0(base) ((MTB_AUTHSTAT_REG(base) & MTB_AUTHSTAT_BIT0_MASK) >> MTB_AUTHSTAT_BIT0_SHIFT)
#define MTB_BRD_AUTHSTAT_BIT0(base) (MTB_RD_AUTHSTAT_BIT0(base))
/*@}*/

/*!
 * @name Register MTB_AUTHSTAT, field BIT1[1] (ROO)
 *
 * Hardwired to 1.
 */
/*@{*/
/*! @brief Read current value of the MTB_AUTHSTAT_BIT1 field. */
#define MTB_RD_AUTHSTAT_BIT1(base) ((MTB_AUTHSTAT_REG(base) & MTB_AUTHSTAT_BIT1_MASK) >> MTB_AUTHSTAT_BIT1_SHIFT)
#define MTB_BRD_AUTHSTAT_BIT1(base) (MTB_RD_AUTHSTAT_BIT1(base))
/*@}*/

/*!
 * @name Register MTB_AUTHSTAT, field BIT2[2] (RO)
 *
 * Connected to NIDEN or DBGEN signal.
 */
/*@{*/
/*! @brief Read current value of the MTB_AUTHSTAT_BIT2 field. */
#define MTB_RD_AUTHSTAT_BIT2(base) ((MTB_AUTHSTAT_REG(base) & MTB_AUTHSTAT_BIT2_MASK) >> MTB_AUTHSTAT_BIT2_SHIFT)
#define MTB_BRD_AUTHSTAT_BIT2(base) (MTB_RD_AUTHSTAT_BIT2(base))
/*@}*/

/*!
 * @name Register MTB_AUTHSTAT, field BIT3[3] (ROO)
 *
 * Hardwired to 1.
 */
/*@{*/
/*! @brief Read current value of the MTB_AUTHSTAT_BIT3 field. */
#define MTB_RD_AUTHSTAT_BIT3(base) ((MTB_AUTHSTAT_REG(base) & MTB_AUTHSTAT_BIT3_MASK) >> MTB_AUTHSTAT_BIT3_SHIFT)
#define MTB_BRD_AUTHSTAT_BIT3(base) (MTB_RD_AUTHSTAT_BIT3(base))
/*@}*/

/*******************************************************************************
 * MTB_DEVICEARCH - Device Architecture Register
 ******************************************************************************/

/*!
 * @brief MTB_DEVICEARCH - Device Architecture Register (RO)
 *
 * Reset value: 0x47700A31U
 *
 * This register indicates the device architecture. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_DEVICEARCH register
 */
/*@{*/
#define MTB_RD_DEVICEARCH(base)  (MTB_DEVICEARCH_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_DEVICECFG - Device Configuration Register
 ******************************************************************************/

/*!
 * @brief MTB_DEVICECFG - Device Configuration Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register indicates the device configuration. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_DEVICECFG register
 */
/*@{*/
#define MTB_RD_DEVICECFG(base)   (MTB_DEVICECFG_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_DEVICETYPID - Device Type Identifier Register
 ******************************************************************************/

/*!
 * @brief MTB_DEVICETYPID - Device Type Identifier Register (RO)
 *
 * Reset value: 0x00000031U
 *
 * This register indicates the device type ID. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_DEVICETYPID register
 */
/*@{*/
#define MTB_RD_DEVICETYPID(base) (MTB_DEVICETYPID_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_PERIPHID - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief MTB_PERIPHID - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_PERIPHID register
 */
/*@{*/
#define MTB_RD_PERIPHID(base, index) (MTB_PERIPHID_REG(base, index))
/*@}*/

/*******************************************************************************
 * MTB_COMPID - Component ID Register
 ******************************************************************************/

/*!
 * @brief MTB_COMPID - Component ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the component IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_COMPID register
 */
/*@{*/
#define MTB_RD_COMPID(base, index) (MTB_COMPID_REG(base, index))
/*@}*/

/*
 * MKW40Z4 MTBDWT
 *
 * MTB data watchpoint and trace
 *
 * Registers defined in this header file:
 * - MTBDWT_CTRL - MTB DWT Control Register
 * - MTBDWT_COMP - MTB_DWT Comparator Register
 * - MTBDWT_MASK - MTB_DWT Comparator Mask Register
 * - MTBDWT_FCT - MTB_DWT Comparator Function Register 0
 * - MTBDWT_TBCTRL - MTB_DWT Trace Buffer Control Register
 * - MTBDWT_DEVICECFG - Device Configuration Register
 * - MTBDWT_DEVICETYPID - Device Type Identifier Register
 * - MTBDWT_PERIPHID - Peripheral ID Register
 * - MTBDWT_COMPID - Component ID Register
 */

#define MTBDWT_INSTANCE_COUNT (1U) /*!< Number of instances of the MTBDWT module. */
#define MTBDWT_IDX (0U) /*!< Instance number for MTBDWT. */

/*******************************************************************************
 * MTBDWT_CTRL - MTB DWT Control Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_CTRL - MTB DWT Control Register (RO)
 *
 * Reset value: 0x2F000000U
 *
 * The MTBDWT_CTRL register provides read-only information on the watchpoint
 * configuration for the MTB_DWT.
 */
/*!
 * @name Constants and macros for entire MTBDWT_CTRL register
 */
/*@{*/
#define MTBDWT_RD_CTRL(base)     (MTBDWT_CTRL_REG(base))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_CTRL bitfields
 */

/*!
 * @name Register MTBDWT_CTRL, field DWTCFGCTRL[27:0] (RO)
 *
 * This field is hardwired to 0xF00_0000, disabling all the remaining DWT
 * functionality. The specific fields and their state are: MTBDWT_CTRL[27] = NOTRCPKT =
 * 1, trace sample and exception trace is not supported MTBDWT_CTRL[26] =
 * NOEXTTRIG = 1, external match signals are not supported MTBDWT_CTRL[25] = NOCYCCNT =
 * 1, cycle counter is not supported MTBDWT_CTRL[24] = NOPRFCNT = 1, profiling
 * counters are not supported MTBDWT_CTRL[22] = CYCEBTENA = 0, no POSTCNT
 * underflow packets generated MTBDWT_CTRL[21] = FOLDEVTENA = 0, no folded instruction
 * counter overflow events MTBDWT_CTRL[20] = LSUEVTENA = 0, no LSU counter overflow
 * events MTBDWT_CTRL[19] = SLEEPEVTENA = 0, no sleep counter overflow events
 * MTBDWT_CTRL[18] = EXCEVTENA = 0, no exception overhead counter events
 * MTBDWT_CTRL[17] = CPIEVTENA = 0, no CPI counter overflow events MTBDWT_CTRL[16] =
 * EXCTRCENA = 0, generation of exception trace disabled MTBDWT_CTRL[12] = PCSAMPLENA =
 * 0, no periodic PC sample packets generated MTBDWT_CTRL[11:10] = SYNCTAP = 0,
 * no synchronization packets MTBDWT_CTRL[9] = CYCTAP = 0, cycle counter is not
 * supported MTBDWT_CTRL[8:5] = POSTINIT = 0, cycle counter is not supported
 * MTBDWT_CTRL[4:1] = POSTPRESET = 0, cycle counter is not supported MTBDWT_CTRL[0] =
 * CYCCNTENA = 0, cycle counter is not supported
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_CTRL_DWTCFGCTRL field. */
#define MTBDWT_RD_CTRL_DWTCFGCTRL(base) ((MTBDWT_CTRL_REG(base) & MTBDWT_CTRL_DWTCFGCTRL_MASK) >> MTBDWT_CTRL_DWTCFGCTRL_SHIFT)
#define MTBDWT_BRD_CTRL_DWTCFGCTRL(base) (MTBDWT_RD_CTRL_DWTCFGCTRL(base))
/*@}*/

/*!
 * @name Register MTBDWT_CTRL, field NUMCMP[31:28] (RO)
 *
 * The MTB_DWT implements two comparators.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_CTRL_NUMCMP field. */
#define MTBDWT_RD_CTRL_NUMCMP(base) ((MTBDWT_CTRL_REG(base) & MTBDWT_CTRL_NUMCMP_MASK) >> MTBDWT_CTRL_NUMCMP_SHIFT)
#define MTBDWT_BRD_CTRL_NUMCMP(base) (MTBDWT_RD_CTRL_NUMCMP(base))
/*@}*/

/*******************************************************************************
 * MTBDWT_COMP - MTB_DWT Comparator Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_COMP - MTB_DWT Comparator Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTBDWT_COMPn registers provide the reference value for comparator n.
 */
/*!
 * @name Constants and macros for entire MTBDWT_COMP register
 */
/*@{*/
#define MTBDWT_RD_COMP(base, index) (MTBDWT_COMP_REG(base, index))
#define MTBDWT_WR_COMP(base, index, value) (MTBDWT_COMP_REG(base, index) = (value))
#define MTBDWT_RMW_COMP(base, index, mask, value) (MTBDWT_WR_COMP(base, index, (MTBDWT_RD_COMP(base, index) & ~(mask)) | (value)))
#define MTBDWT_SET_COMP(base, index, value) (MTBDWT_WR_COMP(base, index, MTBDWT_RD_COMP(base, index) |  (value)))
#define MTBDWT_CLR_COMP(base, index, value) (MTBDWT_WR_COMP(base, index, MTBDWT_RD_COMP(base, index) & ~(value)))
#define MTBDWT_TOG_COMP(base, index, value) (MTBDWT_WR_COMP(base, index, MTBDWT_RD_COMP(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * MTBDWT_MASK - MTB_DWT Comparator Mask Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_MASK - MTB_DWT Comparator Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTBDWT_MASKn registers define the size of the ignore mask applied to the
 * reference address for address range matching by comparator n. Note the format
 * of this mask field is different than the MTB_MASTER[MASK].
 */
/*!
 * @name Constants and macros for entire MTBDWT_MASK register
 */
/*@{*/
#define MTBDWT_RD_MASK(base, index) (MTBDWT_MASK_REG(base, index))
#define MTBDWT_WR_MASK(base, index, value) (MTBDWT_MASK_REG(base, index) = (value))
#define MTBDWT_RMW_MASK(base, index, mask, value) (MTBDWT_WR_MASK(base, index, (MTBDWT_RD_MASK(base, index) & ~(mask)) | (value)))
#define MTBDWT_SET_MASK(base, index, value) (MTBDWT_WR_MASK(base, index, MTBDWT_RD_MASK(base, index) |  (value)))
#define MTBDWT_CLR_MASK(base, index, value) (MTBDWT_WR_MASK(base, index, MTBDWT_RD_MASK(base, index) & ~(value)))
#define MTBDWT_TOG_MASK(base, index, value) (MTBDWT_WR_MASK(base, index, MTBDWT_RD_MASK(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_MASK bitfields
 */

/*!
 * @name Register MTBDWT_MASK, field MASK[4:0] (RW)
 *
 * The value of the ignore mask, 0-31 bits, is applied to address range
 * matching. MASK = 0 is used to include all bits of the address in the comparison,
 * except if MASK = 0 and the comparator is configured to watch instruction fetch
 * addresses, address bit [0] is ignored by the hardware since all fetches must be at
 * least halfword aligned. For MASK != 0 and regardless of watch type, address
 * bits [x-1:0] are ignored in the address comparison. Using a mask means the
 * comparator matches on a range of addresses, defined by the unmasked most
 * significant bits of the address, bits [31:x]. The maximum MASK value is 24, producing a
 * 16 Mbyte mask. An attempted write of a MASK value > 24 is limited by the
 * MTBDWT hardware to 24. If MTBDWT_COMP0 is used as a data value comparator, then
 * MTBDWT_MASK0 should be programmed to zero.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_MASK_MASK field. */
#define MTBDWT_RD_MASK_MASK(base, index) ((MTBDWT_MASK_REG(base, index) & MTBDWT_MASK_MASK_MASK) >> MTBDWT_MASK_MASK_SHIFT)
#define MTBDWT_BRD_MASK_MASK(base, index) (MTBDWT_RD_MASK_MASK(base, index))

/*! @brief Set the MASK field to a new value. */
#define MTBDWT_WR_MASK_MASK(base, index, value) (MTBDWT_RMW_MASK(base, index, MTBDWT_MASK_MASK_MASK, MTBDWT_MASK_MASK(value)))
#define MTBDWT_BWR_MASK_MASK(base, index, value) (MTBDWT_WR_MASK_MASK(base, index, value))
/*@}*/

/*******************************************************************************
 * MTBDWT_FCT - MTB_DWT Comparator Function Register 0
 ******************************************************************************/

/*!
 * @brief MTBDWT_FCT - MTB_DWT Comparator Function Register 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTBDWT_FCTn registers control the operation of comparator n.
 */
/*!
 * @name Constants and macros for entire MTBDWT_FCT register
 */
/*@{*/
#define MTBDWT_RD_FCT(base, index) (MTBDWT_FCT_REG(base, index))
#define MTBDWT_WR_FCT(base, index, value) (MTBDWT_FCT_REG(base, index) = (value))
#define MTBDWT_RMW_FCT(base, index, mask, value) (MTBDWT_WR_FCT(base, index, (MTBDWT_RD_FCT(base, index) & ~(mask)) | (value)))
#define MTBDWT_SET_FCT(base, index, value) (MTBDWT_WR_FCT(base, index, MTBDWT_RD_FCT(base, index) |  (value)))
#define MTBDWT_CLR_FCT(base, index, value) (MTBDWT_WR_FCT(base, index, MTBDWT_RD_FCT(base, index) & ~(value)))
#define MTBDWT_TOG_FCT(base, index, value) (MTBDWT_WR_FCT(base, index, MTBDWT_RD_FCT(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_FCT bitfields
 */

/*!
 * @name Register MTBDWT_FCT, field FUNCTION[3:0] (RW)
 *
 * Selects the action taken on a comparator match. If MTBDWT_COMP0 is used for a
 * data value and MTBDWT_COMP1 for an address value, then MTBDWT_FCT1[FUNCTION]
 * must be set to zero. For this configuration, MTBDWT_MASK1 can be set to a
 * non-zero value, so the combined comparators match on a range of addresses.
 *
 * Values:
 * - 0b0000 - Disabled.
 * - 0b0100 - Instruction fetch.
 * - 0b0101 - Data operand read.
 * - 0b0110 - Data operand write.
 * - 0b0111 - Data operand (read + write).
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_FCT_FUNCTION field. */
#define MTBDWT_RD_FCT_FUNCTION(base, index) ((MTBDWT_FCT_REG(base, index) & MTBDWT_FCT_FUNCTION_MASK) >> MTBDWT_FCT_FUNCTION_SHIFT)
#define MTBDWT_BRD_FCT_FUNCTION(base, index) (MTBDWT_RD_FCT_FUNCTION(base, index))

/*! @brief Set the FUNCTION field to a new value. */
#define MTBDWT_WR_FCT_FUNCTION(base, index, value) (MTBDWT_RMW_FCT(base, index, MTBDWT_FCT_FUNCTION_MASK, MTBDWT_FCT_FUNCTION(value)))
#define MTBDWT_BWR_FCT_FUNCTION(base, index, value) (MTBDWT_WR_FCT_FUNCTION(base, index, value))
/*@}*/

/*!
 * @name Register MTBDWT_FCT, field DATAVMATCH[8] (RW)
 *
 * When this field is 1, it enables data value comparison. For this
 * implementation, MTBDWT_COMP0 supports address or data value comparisons; MTBDWT_COMP1 only
 * supports address comparisons.
 *
 * Values:
 * - 0b0 - Perform address comparison.
 * - 0b1 - Perform data value comparison.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_FCT_DATAVMATCH field. */
#define MTBDWT_RD_FCT_DATAVMATCH(base, index) ((MTBDWT_FCT_REG(base, index) & MTBDWT_FCT_DATAVMATCH_MASK) >> MTBDWT_FCT_DATAVMATCH_SHIFT)
#define MTBDWT_BRD_FCT_DATAVMATCH(base, index) (MTBDWT_RD_FCT_DATAVMATCH(base, index))

/*! @brief Set the DATAVMATCH field to a new value. */
#define MTBDWT_WR_FCT_DATAVMATCH(base, index, value) (MTBDWT_RMW_FCT(base, index, MTBDWT_FCT_DATAVMATCH_MASK, MTBDWT_FCT_DATAVMATCH(value)))
#define MTBDWT_BWR_FCT_DATAVMATCH(base, index, value) (MTBDWT_WR_FCT_DATAVMATCH(base, index, value))
/*@}*/

/*!
 * @name Register MTBDWT_FCT, field DATAVSIZE[11:10] (RW)
 *
 * For data value matching, this field defines the size of the required data
 * comparison.
 *
 * Values:
 * - 0b00 - Byte.
 * - 0b01 - Halfword.
 * - 0b10 - Word.
 * - 0b11 - Reserved. Any attempts to use this value results in UNPREDICTABLE
 *     behavior.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_FCT_DATAVSIZE field. */
#define MTBDWT_RD_FCT_DATAVSIZE(base, index) ((MTBDWT_FCT_REG(base, index) & MTBDWT_FCT_DATAVSIZE_MASK) >> MTBDWT_FCT_DATAVSIZE_SHIFT)
#define MTBDWT_BRD_FCT_DATAVSIZE(base, index) (MTBDWT_RD_FCT_DATAVSIZE(base, index))

/*! @brief Set the DATAVSIZE field to a new value. */
#define MTBDWT_WR_FCT_DATAVSIZE(base, index, value) (MTBDWT_RMW_FCT(base, index, MTBDWT_FCT_DATAVSIZE_MASK, MTBDWT_FCT_DATAVSIZE(value)))
#define MTBDWT_BWR_FCT_DATAVSIZE(base, index, value) (MTBDWT_WR_FCT_DATAVSIZE(base, index, value))
/*@}*/

/*!
 * @name Register MTBDWT_FCT, field DATAVADDR0[15:12] (RW)
 *
 * Since the MTB_DWT implements two comparators, the DATAVADDR0 field is
 * restricted to values {0,1}. When the DATAVMATCH bit is asserted, this field defines
 * the comparator number to use for linked address comparison. If MTBDWT_COMP0 is
 * used as a data watchpoint and MTBDWT_COMP1 as an address watchpoint,
 * DATAVADDR0 must be set.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_FCT_DATAVADDR0 field. */
#define MTBDWT_RD_FCT_DATAVADDR0(base, index) ((MTBDWT_FCT_REG(base, index) & MTBDWT_FCT_DATAVADDR0_MASK) >> MTBDWT_FCT_DATAVADDR0_SHIFT)
#define MTBDWT_BRD_FCT_DATAVADDR0(base, index) (MTBDWT_RD_FCT_DATAVADDR0(base, index))

/*! @brief Set the DATAVADDR0 field to a new value. */
#define MTBDWT_WR_FCT_DATAVADDR0(base, index, value) (MTBDWT_RMW_FCT(base, index, MTBDWT_FCT_DATAVADDR0_MASK, MTBDWT_FCT_DATAVADDR0(value)))
#define MTBDWT_BWR_FCT_DATAVADDR0(base, index, value) (MTBDWT_WR_FCT_DATAVADDR0(base, index, value))
/*@}*/

/*!
 * @name Register MTBDWT_FCT, field MATCHED[24] (RO)
 *
 * If this read-only flag is asserted, it indicates the operation defined by the
 * FUNCTION field occurred since the last read of the register. Reading the
 * register clears this bit.
 *
 * Values:
 * - 0b0 - No match.
 * - 0b1 - Match occurred.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_FCT_MATCHED field. */
#define MTBDWT_RD_FCT_MATCHED(base, index) ((MTBDWT_FCT_REG(base, index) & MTBDWT_FCT_MATCHED_MASK) >> MTBDWT_FCT_MATCHED_SHIFT)
#define MTBDWT_BRD_FCT_MATCHED(base, index) (MTBDWT_RD_FCT_MATCHED(base, index))
/*@}*/

/*******************************************************************************
 * MTBDWT_TBCTRL - MTB_DWT Trace Buffer Control Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_TBCTRL - MTB_DWT Trace Buffer Control Register (RW)
 *
 * Reset value: 0x20000000U
 *
 * The MTBDWT_TBCTRL register defines how the watchpoint comparisons control the
 * actual trace buffer operation. Recall the MTB supports starting and stopping
 * the program trace based on the watchpoint comparisons signaled via TSTART and
 * TSTOP. The watchpoint comparison signals are enabled in the MTB's control
 * logic by setting the appropriate enable bits, MTB_MASTER[TSTARTEN, TSTOPEN]. In
 * the event of simultaneous assertion of both TSTART and TSTOP, TSTART takes
 * priority.
 */
/*!
 * @name Constants and macros for entire MTBDWT_TBCTRL register
 */
/*@{*/
#define MTBDWT_RD_TBCTRL(base)   (MTBDWT_TBCTRL_REG(base))
#define MTBDWT_WR_TBCTRL(base, value) (MTBDWT_TBCTRL_REG(base) = (value))
#define MTBDWT_RMW_TBCTRL(base, mask, value) (MTBDWT_WR_TBCTRL(base, (MTBDWT_RD_TBCTRL(base) & ~(mask)) | (value)))
#define MTBDWT_SET_TBCTRL(base, value) (MTBDWT_WR_TBCTRL(base, MTBDWT_RD_TBCTRL(base) |  (value)))
#define MTBDWT_CLR_TBCTRL(base, value) (MTBDWT_WR_TBCTRL(base, MTBDWT_RD_TBCTRL(base) & ~(value)))
#define MTBDWT_TOG_TBCTRL(base, value) (MTBDWT_WR_TBCTRL(base, MTBDWT_RD_TBCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_TBCTRL bitfields
 */

/*!
 * @name Register MTBDWT_TBCTRL, field ACOMP0[0] (RW)
 *
 * When the MTBDWT_FCT0[MATCHED] is set, it indicates MTBDWT_COMP0 address
 * compare has triggered and the trace buffer's recording state is changed. The
 * assertion of MTBDWT_FCT0[MATCHED] is caused by the following conditions: Address
 * match in MTBDWT_COMP0 when MTBDWT_FCT0[DATAVMATCH] = 0 Data match in MTBDWT_COMP0
 * when MTBDWT_FCT0[DATAVMATCH, DATAVADDR0] = {1,0} Data match in MTBDWT_COMP0
 * and address match in MTBDWT_COMP1 when MTBDWT_FCT0[DATAVMATCH, DATAVADDR0] =
 * {1,1}
 *
 * Values:
 * - 0b0 - Trigger TSTOP based on the assertion of MTBDWT_FCT0[MATCHED].
 * - 0b1 - Trigger TSTART based on the assertion of MTBDWT_FCT0[MATCHED].
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_TBCTRL_ACOMP0 field. */
#define MTBDWT_RD_TBCTRL_ACOMP0(base) ((MTBDWT_TBCTRL_REG(base) & MTBDWT_TBCTRL_ACOMP0_MASK) >> MTBDWT_TBCTRL_ACOMP0_SHIFT)
#define MTBDWT_BRD_TBCTRL_ACOMP0(base) (MTBDWT_RD_TBCTRL_ACOMP0(base))

/*! @brief Set the ACOMP0 field to a new value. */
#define MTBDWT_WR_TBCTRL_ACOMP0(base, value) (MTBDWT_RMW_TBCTRL(base, MTBDWT_TBCTRL_ACOMP0_MASK, MTBDWT_TBCTRL_ACOMP0(value)))
#define MTBDWT_BWR_TBCTRL_ACOMP0(base, value) (MTBDWT_WR_TBCTRL_ACOMP0(base, value))
/*@}*/

/*!
 * @name Register MTBDWT_TBCTRL, field ACOMP1[1] (RW)
 *
 * When the MTBDWT_FCT1[MATCHED] is set, it indicates MTBDWT_COMP1 address
 * compare has triggered and the trace buffer's recording state is changed.
 *
 * Values:
 * - 0b0 - Trigger TSTOP based on the assertion of MTBDWT_FCT1[MATCHED].
 * - 0b1 - Trigger TSTART based on the assertion of MTBDWT_FCT1[MATCHED].
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_TBCTRL_ACOMP1 field. */
#define MTBDWT_RD_TBCTRL_ACOMP1(base) ((MTBDWT_TBCTRL_REG(base) & MTBDWT_TBCTRL_ACOMP1_MASK) >> MTBDWT_TBCTRL_ACOMP1_SHIFT)
#define MTBDWT_BRD_TBCTRL_ACOMP1(base) (MTBDWT_RD_TBCTRL_ACOMP1(base))

/*! @brief Set the ACOMP1 field to a new value. */
#define MTBDWT_WR_TBCTRL_ACOMP1(base, value) (MTBDWT_RMW_TBCTRL(base, MTBDWT_TBCTRL_ACOMP1_MASK, MTBDWT_TBCTRL_ACOMP1(value)))
#define MTBDWT_BWR_TBCTRL_ACOMP1(base, value) (MTBDWT_WR_TBCTRL_ACOMP1(base, value))
/*@}*/

/*!
 * @name Register MTBDWT_TBCTRL, field NUMCOMP[31:28] (RO)
 *
 * This read-only field specifies the number of comparators in the MTB_DWT. This
 * implementation includes two registers.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_TBCTRL_NUMCOMP field. */
#define MTBDWT_RD_TBCTRL_NUMCOMP(base) ((MTBDWT_TBCTRL_REG(base) & MTBDWT_TBCTRL_NUMCOMP_MASK) >> MTBDWT_TBCTRL_NUMCOMP_SHIFT)
#define MTBDWT_BRD_TBCTRL_NUMCOMP(base) (MTBDWT_RD_TBCTRL_NUMCOMP(base))
/*@}*/

/*******************************************************************************
 * MTBDWT_DEVICECFG - Device Configuration Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_DEVICECFG - Device Configuration Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register indicates the device configuration. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTBDWT_DEVICECFG register
 */
/*@{*/
#define MTBDWT_RD_DEVICECFG(base) (MTBDWT_DEVICECFG_REG(base))
/*@}*/

/*******************************************************************************
 * MTBDWT_DEVICETYPID - Device Type Identifier Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_DEVICETYPID - Device Type Identifier Register (RO)
 *
 * Reset value: 0x00000004U
 *
 * This register indicates the device type ID. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTBDWT_DEVICETYPID register
 */
/*@{*/
#define MTBDWT_RD_DEVICETYPID(base) (MTBDWT_DEVICETYPID_REG(base))
/*@}*/

/*******************************************************************************
 * MTBDWT_PERIPHID - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_PERIPHID - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTBDWT_PERIPHID register
 */
/*@{*/
#define MTBDWT_RD_PERIPHID(base, index) (MTBDWT_PERIPHID_REG(base, index))
/*@}*/

/*******************************************************************************
 * MTBDWT_COMPID - Component ID Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_COMPID - Component ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the component IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTBDWT_COMPID register
 */
/*@{*/
#define MTBDWT_RD_COMPID(base, index) (MTBDWT_COMPID_REG(base, index))
/*@}*/

/*
 * MKW40Z4 NV
 *
 * Flash configuration field
 *
 * Registers defined in this header file:
 * - NV_BACKKEY3 - Backdoor Comparison Key 3.
 * - NV_BACKKEY2 - Backdoor Comparison Key 2.
 * - NV_BACKKEY1 - Backdoor Comparison Key 1.
 * - NV_BACKKEY0 - Backdoor Comparison Key 0.
 * - NV_BACKKEY7 - Backdoor Comparison Key 7.
 * - NV_BACKKEY6 - Backdoor Comparison Key 6.
 * - NV_BACKKEY5 - Backdoor Comparison Key 5.
 * - NV_BACKKEY4 - Backdoor Comparison Key 4.
 * - NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register
 * - NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register
 * - NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register
 * - NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register
 * - NV_FSEC - Non-volatile Flash Security Register
 * - NV_FOPT - Non-volatile Flash Option Register
 */

#define NV_INSTANCE_COUNT (1U) /*!< Number of instances of the NV module. */
#define FTFA_FlashConfig_IDX (0U) /*!< Instance number for FTFA_FlashConfig. */

/*******************************************************************************
 * NV_BACKKEY3 - Backdoor Comparison Key 3.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY3 - Backdoor Comparison Key 3. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY3 register
 */
/*@{*/
#define NV_RD_BACKKEY3(base)     (NV_BACKKEY3_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY2 - Backdoor Comparison Key 2.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY2 - Backdoor Comparison Key 2. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY2 register
 */
/*@{*/
#define NV_RD_BACKKEY2(base)     (NV_BACKKEY2_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY1 - Backdoor Comparison Key 1.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY1 - Backdoor Comparison Key 1. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY1 register
 */
/*@{*/
#define NV_RD_BACKKEY1(base)     (NV_BACKKEY1_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY0 - Backdoor Comparison Key 0.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY0 - Backdoor Comparison Key 0. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY0 register
 */
/*@{*/
#define NV_RD_BACKKEY0(base)     (NV_BACKKEY0_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY7 - Backdoor Comparison Key 7.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY7 - Backdoor Comparison Key 7. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY7 register
 */
/*@{*/
#define NV_RD_BACKKEY7(base)     (NV_BACKKEY7_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY6 - Backdoor Comparison Key 6.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY6 - Backdoor Comparison Key 6. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY6 register
 */
/*@{*/
#define NV_RD_BACKKEY6(base)     (NV_BACKKEY6_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY5 - Backdoor Comparison Key 5.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY5 - Backdoor Comparison Key 5. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY5 register
 */
/*@{*/
#define NV_RD_BACKKEY5(base)     (NV_BACKKEY5_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY4 - Backdoor Comparison Key 4.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY4 - Backdoor Comparison Key 4. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY4 register
 */
/*@{*/
#define NV_RD_BACKKEY4(base)     (NV_BACKKEY4_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT3 register
 */
/*@{*/
#define NV_RD_FPROT3(base)       (NV_FPROT3_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT2 register
 */
/*@{*/
#define NV_RD_FPROT2(base)       (NV_FPROT2_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT1 register
 */
/*@{*/
#define NV_RD_FPROT1(base)       (NV_FPROT1_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT0 register
 */
/*@{*/
#define NV_RD_FPROT0(base)       (NV_FPROT0_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FSEC - Non-volatile Flash Security Register
 ******************************************************************************/

/*!
 * @brief NV_FSEC - Non-volatile Flash Security Register (RO)
 *
 * Reset value: 0xFFU
 *
 * Allows the user to customize the operation of the MCU at boot time
 */
/*!
 * @name Constants and macros for entire NV_FSEC register
 */
/*@{*/
#define NV_RD_FSEC(base)         (NV_FSEC_REG(base))
/*@}*/

/*
 * Constants & macros for individual NV_FSEC bitfields
 */

/*!
 * @name Register NV_FSEC, field SEC[1:0] (RO)
 *
 * Values:
 * - 0b10 - MCU security status is unsecure
 * - 0b11 - MCU security status is secure
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_SEC field. */
#define NV_RD_FSEC_SEC(base) ((NV_FSEC_REG(base) & NV_FSEC_SEC_MASK) >> NV_FSEC_SEC_SHIFT)
#define NV_BRD_FSEC_SEC(base) (NV_RD_FSEC_SEC(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field FSLACC[3:2] (RO)
 *
 * Values:
 * - 0b10 - Freescale factory access denied
 * - 0b11 - Freescale factory access granted
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_FSLACC field. */
#define NV_RD_FSEC_FSLACC(base) ((NV_FSEC_REG(base) & NV_FSEC_FSLACC_MASK) >> NV_FSEC_FSLACC_SHIFT)
#define NV_BRD_FSEC_FSLACC(base) (NV_RD_FSEC_FSLACC(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field MEEN[5:4] (RO)
 *
 * Values:
 * - 0b10 - Mass erase is disabled
 * - 0b11 - Mass erase is enabled
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_MEEN field. */
#define NV_RD_FSEC_MEEN(base) ((NV_FSEC_REG(base) & NV_FSEC_MEEN_MASK) >> NV_FSEC_MEEN_SHIFT)
#define NV_BRD_FSEC_MEEN(base) (NV_RD_FSEC_MEEN(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field KEYEN[7:6] (RO)
 *
 * Values:
 * - 0b10 - Backdoor key access enabled
 * - 0b11 - Backdoor key access disabled
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_KEYEN field. */
#define NV_RD_FSEC_KEYEN(base) ((NV_FSEC_REG(base) & NV_FSEC_KEYEN_MASK) >> NV_FSEC_KEYEN_SHIFT)
#define NV_BRD_FSEC_KEYEN(base) (NV_RD_FSEC_KEYEN(base))
/*@}*/

/*******************************************************************************
 * NV_FOPT - Non-volatile Flash Option Register
 ******************************************************************************/

/*!
 * @brief NV_FOPT - Non-volatile Flash Option Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FOPT register
 */
/*@{*/
#define NV_RD_FOPT(base)         (NV_FOPT_REG(base))
/*@}*/

/*
 * Constants & macros for individual NV_FOPT bitfields
 */

/*!
 * @name Register NV_FOPT, field LPBOOT0[0] (RO)
 *
 * Values:
 * - 0b0 - Core and system clock divider (OUTDIV1) is 0x7 (divide by 8) when
 *     LPBOOT1=0 or 0x1 (divide by 2) when LPBOOT1=1.
 * - 0b1 - Core and system clock divider (OUTDIV1) is 0x3 (divide by 4) when
 *     LPBOOT1=0 or 0x0 (divide by 1) when LPBOOT1=1.
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_LPBOOT0 field. */
#define NV_RD_FOPT_LPBOOT0(base) ((NV_FOPT_REG(base) & NV_FOPT_LPBOOT0_MASK) >> NV_FOPT_LPBOOT0_SHIFT)
#define NV_BRD_FOPT_LPBOOT0(base) (NV_RD_FOPT_LPBOOT0(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field NMI_DIS[2] (RO)
 *
 * Values:
 * - 0b0 - NMI interrupts are always blocked
 * - 0b1 - NMI_b pin/interrupts reset default to enabled
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_NMI_DIS field. */
#define NV_RD_FOPT_NMI_DIS(base) ((NV_FOPT_REG(base) & NV_FOPT_NMI_DIS_MASK) >> NV_FOPT_NMI_DIS_SHIFT)
#define NV_BRD_FOPT_NMI_DIS(base) (NV_RD_FOPT_NMI_DIS(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field RESET_PIN_CFG[3] (RO)
 *
 * Values:
 * - 0b0 - RESET pin is disabled following a POR and cannot be enabled as reset
 *     function
 * - 0b1 - RESET_b pin is dedicated
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_RESET_PIN_CFG field. */
#define NV_RD_FOPT_RESET_PIN_CFG(base) ((NV_FOPT_REG(base) & NV_FOPT_RESET_PIN_CFG_MASK) >> NV_FOPT_RESET_PIN_CFG_SHIFT)
#define NV_BRD_FOPT_RESET_PIN_CFG(base) (NV_RD_FOPT_RESET_PIN_CFG(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field LPBOOT1[4] (RO)
 *
 * Values:
 * - 0b0 - Core and system clock divider (OUTDIV1) is 0x7 (divide by 8) when
 *     LPBOOT0=0 or 0x3 (divide by 4) when LPBOOT0=1.
 * - 0b1 - Core and system clock divider (OUTDIV1) is 0x1 (divide by 2) when
 *     LPBOOT0=0 or 0x0 (divide by 1) when LPBOOT0=1.
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_LPBOOT1 field. */
#define NV_RD_FOPT_LPBOOT1(base) ((NV_FOPT_REG(base) & NV_FOPT_LPBOOT1_MASK) >> NV_FOPT_LPBOOT1_SHIFT)
#define NV_BRD_FOPT_LPBOOT1(base) (NV_RD_FOPT_LPBOOT1(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field FAST_INIT[5] (RO)
 *
 * Values:
 * - 0b0 - Slower initialization
 * - 0b1 - Fast Initialization
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_FAST_INIT field. */
#define NV_RD_FOPT_FAST_INIT(base) ((NV_FOPT_REG(base) & NV_FOPT_FAST_INIT_MASK) >> NV_FOPT_FAST_INIT_SHIFT)
#define NV_BRD_FOPT_FAST_INIT(base) (NV_RD_FOPT_FAST_INIT(base))
/*@}*/

/*
 * MKW40Z4 PIT
 *
 * Periodic Interrupt Timer
 *
 * Registers defined in this header file:
 * - PIT_MCR - PIT Module Control Register
 * - PIT_LTMR64H - PIT Upper Lifetime Timer Register
 * - PIT_LTMR64L - PIT Lower Lifetime Timer Register
 * - PIT_LDVAL - Timer Load Value Register
 * - PIT_CVAL - Current Timer Value Register
 * - PIT_TCTRL - Timer Control Register
 * - PIT_TFLG - Timer Flag Register
 */

#define PIT_INSTANCE_COUNT (1U) /*!< Number of instances of the PIT module. */
#define PIT_IDX (0U) /*!< Instance number for PIT. */

/*******************************************************************************
 * PIT_MCR - PIT Module Control Register
 ******************************************************************************/

/*!
 * @brief PIT_MCR - PIT Module Control Register (RW)
 *
 * Reset value: 0x00000006U
 *
 * This register enables or disables the PIT timer clocks and controls the
 * timers when the PIT enters the Debug mode. The clock gating function of the MDIS
 * bit is described in more detail in the integraton guide. Access: User read/write
 */
/*!
 * @name Constants and macros for entire PIT_MCR register
 */
/*@{*/
#define PIT_RD_MCR(base)         (PIT_MCR_REG(base))
#define PIT_WR_MCR(base, value)  (PIT_MCR_REG(base) = (value))
#define PIT_RMW_MCR(base, mask, value) (PIT_WR_MCR(base, (PIT_RD_MCR(base) & ~(mask)) | (value)))
#define PIT_SET_MCR(base, value) (BME_OR32(&PIT_MCR_REG(base), (uint32_t)(value)))
#define PIT_CLR_MCR(base, value) (BME_AND32(&PIT_MCR_REG(base), (uint32_t)(~(value))))
#define PIT_TOG_MCR(base, value) (BME_XOR32(&PIT_MCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PIT_MCR bitfields
 */

/*!
 * @name Register PIT_MCR, field FRZ[0] (RW)
 *
 * Allows the timers to be stopped when the device enters the Debug mode.
 *
 * Values:
 * - 0b0 - Timers continue to run in Debug mode.
 * - 0b1 - Timers are stopped in Debug mode.
 */
/*@{*/
/*! @brief Read current value of the PIT_MCR_FRZ field. */
#define PIT_RD_MCR_FRZ(base) ((PIT_MCR_REG(base) & PIT_MCR_FRZ_MASK) >> PIT_MCR_FRZ_SHIFT)
#define PIT_BRD_MCR_FRZ(base) (BME_UBFX32(&PIT_MCR_REG(base), PIT_MCR_FRZ_SHIFT, PIT_MCR_FRZ_WIDTH))

/*! @brief Set the FRZ field to a new value. */
#define PIT_WR_MCR_FRZ(base, value) (PIT_RMW_MCR(base, PIT_MCR_FRZ_MASK, PIT_MCR_FRZ(value)))
#define PIT_BWR_MCR_FRZ(base, value) (BME_BFI32(&PIT_MCR_REG(base), ((uint32_t)(value) << PIT_MCR_FRZ_SHIFT), PIT_MCR_FRZ_SHIFT, PIT_MCR_FRZ_WIDTH))
/*@}*/

/*!
 * @name Register PIT_MCR, field MDIS[1] (RW)
 *
 * Disables the standard timers. This field must be enabled before any other
 * setup is done.
 *
 * Values:
 * - 0b0 - Clock for standard PIT timers is enabled.
 * - 0b1 - Clock for standard PIT timers is disabled.
 */
/*@{*/
/*! @brief Read current value of the PIT_MCR_MDIS field. */
#define PIT_RD_MCR_MDIS(base) ((PIT_MCR_REG(base) & PIT_MCR_MDIS_MASK) >> PIT_MCR_MDIS_SHIFT)
#define PIT_BRD_MCR_MDIS(base) (BME_UBFX32(&PIT_MCR_REG(base), PIT_MCR_MDIS_SHIFT, PIT_MCR_MDIS_WIDTH))

/*! @brief Set the MDIS field to a new value. */
#define PIT_WR_MCR_MDIS(base, value) (PIT_RMW_MCR(base, PIT_MCR_MDIS_MASK, PIT_MCR_MDIS(value)))
#define PIT_BWR_MCR_MDIS(base, value) (BME_BFI32(&PIT_MCR_REG(base), ((uint32_t)(value) << PIT_MCR_MDIS_SHIFT), PIT_MCR_MDIS_SHIFT, PIT_MCR_MDIS_WIDTH))
/*@}*/

/*******************************************************************************
 * PIT_LTMR64H - PIT Upper Lifetime Timer Register
 ******************************************************************************/

/*!
 * @brief PIT_LTMR64H - PIT Upper Lifetime Timer Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register is intended for applications that chain timer 0 and timer 1 to
 * build a 64-bit lifetimer. Access: User read only
 */
/*!
 * @name Constants and macros for entire PIT_LTMR64H register
 */
/*@{*/
#define PIT_RD_LTMR64H(base)     (PIT_LTMR64H_REG(base))
/*@}*/

/*******************************************************************************
 * PIT_LTMR64L - PIT Lower Lifetime Timer Register
 ******************************************************************************/

/*!
 * @brief PIT_LTMR64L - PIT Lower Lifetime Timer Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register is intended for applications that chain timer 0 and timer 1 to
 * build a 64-bit lifetimer. To use LTMR64H and LTMR64L, timer 0 and timer 1 need
 * to be chained. To obtain the correct value, first read LTMR64H and then
 * LTMR64L. LTMR64H will have the value of CVAL1 at the time of the first access,
 * LTMR64L will have the value of CVAL0 at the time of the first access, therefore
 * the application does not need to worry about carry-over effects of the running
 * counter. Access: User read only
 */
/*!
 * @name Constants and macros for entire PIT_LTMR64L register
 */
/*@{*/
#define PIT_RD_LTMR64L(base)     (PIT_LTMR64L_REG(base))
/*@}*/

/*******************************************************************************
 * PIT_LDVAL - Timer Load Value Register
 ******************************************************************************/

/*!
 * @brief PIT_LDVAL - Timer Load Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers select the timeout period for the timer interrupts. Access:
 * User read/write
 */
/*!
 * @name Constants and macros for entire PIT_LDVAL register
 */
/*@{*/
#define PIT_RD_LDVAL(base, index) (PIT_LDVAL_REG(base, index))
#define PIT_WR_LDVAL(base, index, value) (PIT_LDVAL_REG(base, index) = (value))
#define PIT_RMW_LDVAL(base, index, mask, value) (PIT_WR_LDVAL(base, index, (PIT_RD_LDVAL(base, index) & ~(mask)) | (value)))
#define PIT_SET_LDVAL(base, index, value) (BME_OR32(&PIT_LDVAL_REG(base, index), (uint32_t)(value)))
#define PIT_CLR_LDVAL(base, index, value) (BME_AND32(&PIT_LDVAL_REG(base, index), (uint32_t)(~(value))))
#define PIT_TOG_LDVAL(base, index, value) (BME_XOR32(&PIT_LDVAL_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * PIT_CVAL - Current Timer Value Register
 ******************************************************************************/

/*!
 * @brief PIT_CVAL - Current Timer Value Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the current timer position. Access: User read only
 */
/*!
 * @name Constants and macros for entire PIT_CVAL register
 */
/*@{*/
#define PIT_RD_CVAL(base, index) (PIT_CVAL_REG(base, index))
/*@}*/

/*******************************************************************************
 * PIT_TCTRL - Timer Control Register
 ******************************************************************************/

/*!
 * @brief PIT_TCTRL - Timer Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the control bits for each timer. Access: User
 * read/write
 */
/*!
 * @name Constants and macros for entire PIT_TCTRL register
 */
/*@{*/
#define PIT_RD_TCTRL(base, index) (PIT_TCTRL_REG(base, index))
#define PIT_WR_TCTRL(base, index, value) (PIT_TCTRL_REG(base, index) = (value))
#define PIT_RMW_TCTRL(base, index, mask, value) (PIT_WR_TCTRL(base, index, (PIT_RD_TCTRL(base, index) & ~(mask)) | (value)))
#define PIT_SET_TCTRL(base, index, value) (BME_OR32(&PIT_TCTRL_REG(base, index), (uint32_t)(value)))
#define PIT_CLR_TCTRL(base, index, value) (BME_AND32(&PIT_TCTRL_REG(base, index), (uint32_t)(~(value))))
#define PIT_TOG_TCTRL(base, index, value) (BME_XOR32(&PIT_TCTRL_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PIT_TCTRL bitfields
 */

/*!
 * @name Register PIT_TCTRL, field TEN[0] (RW)
 *
 * Enables or disables the timer.
 *
 * Values:
 * - 0b0 - Timer n is disabled.
 * - 0b1 - Timer n is enabled.
 */
/*@{*/
/*! @brief Read current value of the PIT_TCTRL_TEN field. */
#define PIT_RD_TCTRL_TEN(base, index) ((PIT_TCTRL_REG(base, index) & PIT_TCTRL_TEN_MASK) >> PIT_TCTRL_TEN_SHIFT)
#define PIT_BRD_TCTRL_TEN(base, index) (BME_UBFX32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_TEN_SHIFT, PIT_TCTRL_TEN_WIDTH))

/*! @brief Set the TEN field to a new value. */
#define PIT_WR_TCTRL_TEN(base, index, value) (PIT_RMW_TCTRL(base, index, PIT_TCTRL_TEN_MASK, PIT_TCTRL_TEN(value)))
#define PIT_BWR_TCTRL_TEN(base, index, value) (BME_BFI32(&PIT_TCTRL_REG(base, index), ((uint32_t)(value) << PIT_TCTRL_TEN_SHIFT), PIT_TCTRL_TEN_SHIFT, PIT_TCTRL_TEN_WIDTH))
/*@}*/

/*!
 * @name Register PIT_TCTRL, field TIE[1] (RW)
 *
 * When an interrupt is pending, or, TFLGn[TIF] is set, enabling the interrupt
 * will immediately cause an interrupt event. To avoid this, the associated
 * TFLGn[TIF] must be cleared first.
 *
 * Values:
 * - 0b0 - Interrupt requests from Timer n are disabled.
 * - 0b1 - Interrupt will be requested whenever TIF is set.
 */
/*@{*/
/*! @brief Read current value of the PIT_TCTRL_TIE field. */
#define PIT_RD_TCTRL_TIE(base, index) ((PIT_TCTRL_REG(base, index) & PIT_TCTRL_TIE_MASK) >> PIT_TCTRL_TIE_SHIFT)
#define PIT_BRD_TCTRL_TIE(base, index) (BME_UBFX32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_TIE_SHIFT, PIT_TCTRL_TIE_WIDTH))

/*! @brief Set the TIE field to a new value. */
#define PIT_WR_TCTRL_TIE(base, index, value) (PIT_RMW_TCTRL(base, index, PIT_TCTRL_TIE_MASK, PIT_TCTRL_TIE(value)))
#define PIT_BWR_TCTRL_TIE(base, index, value) (BME_BFI32(&PIT_TCTRL_REG(base, index), ((uint32_t)(value) << PIT_TCTRL_TIE_SHIFT), PIT_TCTRL_TIE_SHIFT, PIT_TCTRL_TIE_WIDTH))
/*@}*/

/*!
 * @name Register PIT_TCTRL, field CHN[2] (RW)
 *
 * When activated, Timer n-1 needs to expire before timer n can decrement by 1.
 * Timer 0 cannot be chained.
 *
 * Values:
 * - 0b0 - Timer is not chained.
 * - 0b1 - Timer is chained to previous timer. For example, for Channel 2, if
 *     this field is set, Timer 2 is chained to Timer 1.
 */
/*@{*/
/*! @brief Read current value of the PIT_TCTRL_CHN field. */
#define PIT_RD_TCTRL_CHN(base, index) ((PIT_TCTRL_REG(base, index) & PIT_TCTRL_CHN_MASK) >> PIT_TCTRL_CHN_SHIFT)
#define PIT_BRD_TCTRL_CHN(base, index) (BME_UBFX32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_CHN_SHIFT, PIT_TCTRL_CHN_WIDTH))

/*! @brief Set the CHN field to a new value. */
#define PIT_WR_TCTRL_CHN(base, index, value) (PIT_RMW_TCTRL(base, index, PIT_TCTRL_CHN_MASK, PIT_TCTRL_CHN(value)))
#define PIT_BWR_TCTRL_CHN(base, index, value) (BME_BFI32(&PIT_TCTRL_REG(base, index), ((uint32_t)(value) << PIT_TCTRL_CHN_SHIFT), PIT_TCTRL_CHN_SHIFT, PIT_TCTRL_CHN_WIDTH))
/*@}*/

/*******************************************************************************
 * PIT_TFLG - Timer Flag Register
 ******************************************************************************/

/*!
 * @brief PIT_TFLG - Timer Flag Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers hold the PIT interrupt flags. Access: User read/write
 */
/*!
 * @name Constants and macros for entire PIT_TFLG register
 */
/*@{*/
#define PIT_RD_TFLG(base, index) (PIT_TFLG_REG(base, index))
#define PIT_WR_TFLG(base, index, value) (PIT_TFLG_REG(base, index) = (value))
#define PIT_RMW_TFLG(base, index, mask, value) (PIT_WR_TFLG(base, index, (PIT_RD_TFLG(base, index) & ~(mask)) | (value)))
#define PIT_SET_TFLG(base, index, value) (BME_OR32(&PIT_TFLG_REG(base, index), (uint32_t)(value)))
#define PIT_CLR_TFLG(base, index, value) (BME_AND32(&PIT_TFLG_REG(base, index), (uint32_t)(~(value))))
#define PIT_TOG_TFLG(base, index, value) (BME_XOR32(&PIT_TFLG_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PIT_TFLG bitfields
 */

/*!
 * @name Register PIT_TFLG, field TIF[0] (W1C)
 *
 * Sets to 1 at the end of the timer period. Writing 1 to this flag clears it.
 * Writing 0 has no effect. If enabled, or, when TCTRLn[TIE] = 1, TIF causes an
 * interrupt request.
 *
 * Values:
 * - 0b0 - Timeout has not yet occurred.
 * - 0b1 - Timeout has occurred.
 */
/*@{*/
/*! @brief Read current value of the PIT_TFLG_TIF field. */
#define PIT_RD_TFLG_TIF(base, index) ((PIT_TFLG_REG(base, index) & PIT_TFLG_TIF_MASK) >> PIT_TFLG_TIF_SHIFT)
#define PIT_BRD_TFLG_TIF(base, index) (BME_UBFX32(&PIT_TFLG_REG(base, index), PIT_TFLG_TIF_SHIFT, PIT_TFLG_TIF_WIDTH))

/*! @brief Set the TIF field to a new value. */
#define PIT_WR_TFLG_TIF(base, index, value) (PIT_RMW_TFLG(base, index, PIT_TFLG_TIF_MASK, PIT_TFLG_TIF(value)))
#define PIT_BWR_TFLG_TIF(base, index, value) (BME_BFI32(&PIT_TFLG_REG(base, index), ((uint32_t)(value) << PIT_TFLG_TIF_SHIFT), PIT_TFLG_TIF_SHIFT, PIT_TFLG_TIF_WIDTH))
/*@}*/

/*
 * MKW40Z4 PMC
 *
 * Power Management Controller
 *
 * Registers defined in this header file:
 * - PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register
 * - PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register
 * - PMC_REGSC - Regulator Status And Control register
 */

#define PMC_INSTANCE_COUNT (1U) /*!< Number of instances of the PMC module. */
#define PMC_IDX (0U) /*!< Instance number for PMC. */

/*******************************************************************************
 * PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register
 ******************************************************************************/

/*!
 * @brief PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register (RW)
 *
 * Reset value: 0x10U
 *
 * This register contains status and control bits to support the low voltage
 * detect function. This register should be written during the reset initialization
 * program to set the desired controls even if the desired settings are the same
 * as the reset settings. While the device is in the very low power or low
 * leakage modes, the LVD system is disabled regardless of LVDSC1 settings. To protect
 * systems that must have LVD always on, configure the Power Mode Protection
 * (PMPROT) register of the SMC module (SMC_PMPROT) to disallow any very low power or
 * low leakage modes from being enabled. See the device's data sheet for the
 * exact LVD trip voltages. The LVDV bits are reset solely on a POR Only event. The
 * register's other bits are reset on Chip Reset Not VLLS. For more information
 * about these reset types, refer to the Reset section details.
 */
/*!
 * @name Constants and macros for entire PMC_LVDSC1 register
 */
/*@{*/
#define PMC_RD_LVDSC1(base)      (PMC_LVDSC1_REG(base))
#define PMC_WR_LVDSC1(base, value) (PMC_LVDSC1_REG(base) = (value))
#define PMC_RMW_LVDSC1(base, mask, value) (PMC_WR_LVDSC1(base, (PMC_RD_LVDSC1(base) & ~(mask)) | (value)))
#define PMC_SET_LVDSC1(base, value) (BME_OR8(&PMC_LVDSC1_REG(base), (uint8_t)(value)))
#define PMC_CLR_LVDSC1(base, value) (BME_AND8(&PMC_LVDSC1_REG(base), (uint8_t)(~(value))))
#define PMC_TOG_LVDSC1(base, value) (BME_XOR8(&PMC_LVDSC1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC1 bitfields
 */

/*!
 * @name Register PMC_LVDSC1, field LVDV[1:0] (RW)
 *
 * Selects the LVD trip point voltage (V LVD ).
 *
 * Values:
 * - 0b00 - Low trip point selected (V LVD = V LVDL )
 * - 0b01 - High trip point selected (V LVD = V LVDH )
 * - 0b10 - Reserved
 * - 0b11 - NON-CUSTOMER INFO: High trip point selected (VLVD = VLVDH). Change
 *     11 from reserved on 5V devices to high trip point.
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDV field. */
#define PMC_RD_LVDSC1_LVDV(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDV_MASK) >> PMC_LVDSC1_LVDV_SHIFT)
#define PMC_BRD_LVDSC1_LVDV(base) (BME_UBFX8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDV_SHIFT, PMC_LVDSC1_LVDV_WIDTH))

/*! @brief Set the LVDV field to a new value. */
#define PMC_WR_LVDSC1_LVDV(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDV_MASK, PMC_LVDSC1_LVDV(value)))
#define PMC_BWR_LVDSC1_LVDV(base, value) (BME_BFI8(&PMC_LVDSC1_REG(base), ((uint8_t)(value) << PMC_LVDSC1_LVDV_SHIFT), PMC_LVDSC1_LVDV_SHIFT, PMC_LVDSC1_LVDV_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDRE[4] (RW)
 *
 * This write-once bit enables LVDF events to generate a hardware reset.
 * Additional writes are ignored.
 *
 * Values:
 * - 0b0 - LVDF does not generate hardware resets
 * - 0b1 - Force an MCU reset when LVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDRE field. */
#define PMC_RD_LVDSC1_LVDRE(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDRE_MASK) >> PMC_LVDSC1_LVDRE_SHIFT)
#define PMC_BRD_LVDSC1_LVDRE(base) (BME_UBFX8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDRE_SHIFT, PMC_LVDSC1_LVDRE_WIDTH))

/*! @brief Set the LVDRE field to a new value. */
#define PMC_WR_LVDSC1_LVDRE(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDRE_MASK, PMC_LVDSC1_LVDRE(value)))
#define PMC_BWR_LVDSC1_LVDRE(base, value) (BME_BFI8(&PMC_LVDSC1_REG(base), ((uint8_t)(value) << PMC_LVDSC1_LVDRE_SHIFT), PMC_LVDSC1_LVDRE_SHIFT, PMC_LVDSC1_LVDRE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDIE[5] (RW)
 *
 * Enables hardware interrupt requests for LVDF.
 *
 * Values:
 * - 0b0 - Hardware interrupt disabled (use polling)
 * - 0b1 - Request a hardware interrupt when LVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDIE field. */
#define PMC_RD_LVDSC1_LVDIE(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDIE_MASK) >> PMC_LVDSC1_LVDIE_SHIFT)
#define PMC_BRD_LVDSC1_LVDIE(base) (BME_UBFX8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDIE_SHIFT, PMC_LVDSC1_LVDIE_WIDTH))

/*! @brief Set the LVDIE field to a new value. */
#define PMC_WR_LVDSC1_LVDIE(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDIE_MASK, PMC_LVDSC1_LVDIE(value)))
#define PMC_BWR_LVDSC1_LVDIE(base, value) (BME_BFI8(&PMC_LVDSC1_REG(base), ((uint8_t)(value) << PMC_LVDSC1_LVDIE_SHIFT), PMC_LVDSC1_LVDIE_SHIFT, PMC_LVDSC1_LVDIE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge low voltage detection errors.
 * Write 1 to clear LVDF. Reads always return 0.
 */
/*@{*/
/*! @brief Set the LVDACK field to a new value. */
#define PMC_WR_LVDSC1_LVDACK(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDACK_MASK, PMC_LVDSC1_LVDACK(value)))
#define PMC_BWR_LVDSC1_LVDACK(base, value) (BME_BFI8(&PMC_LVDSC1_REG(base), ((uint8_t)(value) << PMC_LVDSC1_LVDACK_SHIFT), PMC_LVDSC1_LVDACK_SHIFT, PMC_LVDSC1_LVDACK_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDF[7] (RO)
 *
 * This read-only status field indicates a low-voltage detect event.
 *
 * Values:
 * - 0b0 - Low-voltage event not detected
 * - 0b1 - Low-voltage event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDF field. */
#define PMC_RD_LVDSC1_LVDF(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDF_MASK) >> PMC_LVDSC1_LVDF_SHIFT)
#define PMC_BRD_LVDSC1_LVDF(base) (BME_UBFX8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDF_SHIFT, PMC_LVDSC1_LVDF_WIDTH))
/*@}*/

/*******************************************************************************
 * PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register
 ******************************************************************************/

/*!
 * @brief PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains status and control bits to support the low voltage
 * warning function. While the device is in the very low power or low leakage modes,
 * the LVD system is disabled regardless of LVDSC2 settings. See the device's
 * data sheet for the exact LVD trip voltages. The LVW trip voltages depend on LVWV
 * and LVDV. LVWV is reset solely on a POR Only event. The other fields of the
 * register are reset on Chip Reset Not VLLS. For more information about these
 * reset types, refer to the Reset section details.
 */
/*!
 * @name Constants and macros for entire PMC_LVDSC2 register
 */
/*@{*/
#define PMC_RD_LVDSC2(base)      (PMC_LVDSC2_REG(base))
#define PMC_WR_LVDSC2(base, value) (PMC_LVDSC2_REG(base) = (value))
#define PMC_RMW_LVDSC2(base, mask, value) (PMC_WR_LVDSC2(base, (PMC_RD_LVDSC2(base) & ~(mask)) | (value)))
#define PMC_SET_LVDSC2(base, value) (BME_OR8(&PMC_LVDSC2_REG(base), (uint8_t)(value)))
#define PMC_CLR_LVDSC2(base, value) (BME_AND8(&PMC_LVDSC2_REG(base), (uint8_t)(~(value))))
#define PMC_TOG_LVDSC2(base, value) (BME_XOR8(&PMC_LVDSC2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC2 bitfields
 */

/*!
 * @name Register PMC_LVDSC2, field LVWV[1:0] (RW)
 *
 * Selects the LVW trip point voltage (VLVW). The actual voltage for the warning
 * depends on LVDSC1[LVDV].
 *
 * Values:
 * - 0b00 - Low trip point selected (VLVW = VLVW1)
 * - 0b01 - Mid 1 trip point selected (VLVW = VLVW2)
 * - 0b10 - Mid 2 trip point selected (VLVW = VLVW3)
 * - 0b11 - High trip point selected (VLVW = VLVW4)
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWV field. */
#define PMC_RD_LVDSC2_LVWV(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWV_MASK) >> PMC_LVDSC2_LVWV_SHIFT)
#define PMC_BRD_LVDSC2_LVWV(base) (BME_UBFX8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWV_SHIFT, PMC_LVDSC2_LVWV_WIDTH))

/*! @brief Set the LVWV field to a new value. */
#define PMC_WR_LVDSC2_LVWV(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWV_MASK, PMC_LVDSC2_LVWV(value)))
#define PMC_BWR_LVDSC2_LVWV(base, value) (BME_BFI8(&PMC_LVDSC2_REG(base), ((uint8_t)(value) << PMC_LVDSC2_LVWV_SHIFT), PMC_LVDSC2_LVWV_SHIFT, PMC_LVDSC2_LVWV_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWIE[5] (RW)
 *
 * Enables hardware interrupt requests for LVWF.
 *
 * Values:
 * - 0b0 - Hardware interrupt disabled (use polling)
 * - 0b1 - Request a hardware interrupt when LVWF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWIE field. */
#define PMC_RD_LVDSC2_LVWIE(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWIE_MASK) >> PMC_LVDSC2_LVWIE_SHIFT)
#define PMC_BRD_LVDSC2_LVWIE(base) (BME_UBFX8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWIE_SHIFT, PMC_LVDSC2_LVWIE_WIDTH))

/*! @brief Set the LVWIE field to a new value. */
#define PMC_WR_LVDSC2_LVWIE(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWIE_MASK, PMC_LVDSC2_LVWIE(value)))
#define PMC_BWR_LVDSC2_LVWIE(base, value) (BME_BFI8(&PMC_LVDSC2_REG(base), ((uint8_t)(value) << PMC_LVDSC2_LVWIE_SHIFT), PMC_LVDSC2_LVWIE_SHIFT, PMC_LVDSC2_LVWIE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge low voltage warning errors.
 * Write 1 to clear LVWF. Reads always return 0.
 */
/*@{*/
/*! @brief Set the LVWACK field to a new value. */
#define PMC_WR_LVDSC2_LVWACK(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWACK_MASK, PMC_LVDSC2_LVWACK(value)))
#define PMC_BWR_LVDSC2_LVWACK(base, value) (BME_BFI8(&PMC_LVDSC2_REG(base), ((uint8_t)(value) << PMC_LVDSC2_LVWACK_SHIFT), PMC_LVDSC2_LVWACK_SHIFT, PMC_LVDSC2_LVWACK_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWF[7] (RO)
 *
 * This read-only status field indicates a low-voltage warning event. LVWF is
 * set when VSupply transitions below the trip point, or after reset and VSupply is
 * already below VLVW. LVWF may be 1 after power-on reset, therefore, to use LVW
 * interrupt function, before enabling LVWIE, LVWF must be cleared by writing
 * LVWACK first.
 *
 * Values:
 * - 0b0 - Low-voltage warning event not detected
 * - 0b1 - Low-voltage warning event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWF field. */
#define PMC_RD_LVDSC2_LVWF(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWF_MASK) >> PMC_LVDSC2_LVWF_SHIFT)
#define PMC_BRD_LVDSC2_LVWF(base) (BME_UBFX8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWF_SHIFT, PMC_LVDSC2_LVWF_WIDTH))
/*@}*/

/*******************************************************************************
 * PMC_REGSC - Regulator Status And Control register
 ******************************************************************************/

/*!
 * @brief PMC_REGSC - Regulator Status And Control register (RW)
 *
 * Reset value: 0x04U
 *
 * The PMC contains an internal voltage regulator. The voltage regulator design
 * uses a bandgap reference that is also available through a buffer as input to
 * certain internal peripherals, such as the CMP and ADC. The internal regulator
 * provides a status bit (REGONS) indicating the regulator is in run regulation.
 * This register is reset on Chip Reset Not VLLS and by reset types that trigger
 * Chip Reset not VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire PMC_REGSC register
 */
/*@{*/
#define PMC_RD_REGSC(base)       (PMC_REGSC_REG(base))
#define PMC_WR_REGSC(base, value) (PMC_REGSC_REG(base) = (value))
#define PMC_RMW_REGSC(base, mask, value) (PMC_WR_REGSC(base, (PMC_RD_REGSC(base) & ~(mask)) | (value)))
#define PMC_SET_REGSC(base, value) (BME_OR8(&PMC_REGSC_REG(base), (uint8_t)(value)))
#define PMC_CLR_REGSC(base, value) (BME_AND8(&PMC_REGSC_REG(base), (uint8_t)(~(value))))
#define PMC_TOG_REGSC(base, value) (BME_XOR8(&PMC_REGSC_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PMC_REGSC bitfields
 */

/*!
 * @name Register PMC_REGSC, field BGBE[0] (RW)
 *
 * Enables the bandgap buffer.
 *
 * Values:
 * - 0b0 - Bandgap buffer not enabled
 * - 0b1 - Bandgap buffer enabled
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_BGBE field. */
#define PMC_RD_REGSC_BGBE(base) ((PMC_REGSC_REG(base) & PMC_REGSC_BGBE_MASK) >> PMC_REGSC_BGBE_SHIFT)
#define PMC_BRD_REGSC_BGBE(base) (BME_UBFX8(&PMC_REGSC_REG(base), PMC_REGSC_BGBE_SHIFT, PMC_REGSC_BGBE_WIDTH))

/*! @brief Set the BGBE field to a new value. */
#define PMC_WR_REGSC_BGBE(base, value) (PMC_RMW_REGSC(base, (PMC_REGSC_BGBE_MASK | PMC_REGSC_ACKISO_MASK), PMC_REGSC_BGBE(value)))
#define PMC_BWR_REGSC_BGBE(base, value) (BME_BFI8(&PMC_REGSC_REG(base), ((uint8_t)(value) << PMC_REGSC_BGBE_SHIFT), PMC_REGSC_BGBE_SHIFT, PMC_REGSC_BGBE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_REGSC, field REGONS[2] (RO)
 *
 * This read-only field provides the current status of the internal voltage
 * regulator.
 *
 * Values:
 * - 0b0 - Regulator is in stop regulation or in transition to/from it
 * - 0b1 - Regulator is in run regulation
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_REGONS field. */
#define PMC_RD_REGSC_REGONS(base) ((PMC_REGSC_REG(base) & PMC_REGSC_REGONS_MASK) >> PMC_REGSC_REGONS_SHIFT)
#define PMC_BRD_REGSC_REGONS(base) (BME_UBFX8(&PMC_REGSC_REG(base), PMC_REGSC_REGONS_SHIFT, PMC_REGSC_REGONS_WIDTH))
/*@}*/

/*!
 * @name Register PMC_REGSC, field ACKISO[3] (W1C)
 *
 * Reading this field indicates whether certain peripherals and the I/O pads are
 * in a latched state as a result of having been in a VLLS mode. Writing 1 to
 * this field when it is set releases the I/O pads and certain peripherals to their
 * normal run mode state. After recovering from a VLLS mode, user should restore
 * chip configuration before clearing ACKISO. In particular, pin configuration
 * for enabled LLWU wakeup pins should be restored to avoid any LLWU flag from
 * being falsely set when ACKISO is cleared.
 *
 * Values:
 * - 0b0 - Peripherals and I/O pads are in normal run state.
 * - 0b1 - Certain peripherals and I/O pads are in an isolated and latched state.
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_ACKISO field. */
#define PMC_RD_REGSC_ACKISO(base) ((PMC_REGSC_REG(base) & PMC_REGSC_ACKISO_MASK) >> PMC_REGSC_ACKISO_SHIFT)
#define PMC_BRD_REGSC_ACKISO(base) (BME_UBFX8(&PMC_REGSC_REG(base), PMC_REGSC_ACKISO_SHIFT, PMC_REGSC_ACKISO_WIDTH))

/*! @brief Set the ACKISO field to a new value. */
#define PMC_WR_REGSC_ACKISO(base, value) (PMC_RMW_REGSC(base, PMC_REGSC_ACKISO_MASK, PMC_REGSC_ACKISO(value)))
#define PMC_BWR_REGSC_ACKISO(base, value) (BME_BFI8(&PMC_REGSC_REG(base), ((uint8_t)(value) << PMC_REGSC_ACKISO_SHIFT), PMC_REGSC_ACKISO_SHIFT, PMC_REGSC_ACKISO_WIDTH))
/*@}*/

/*!
 * @name Register PMC_REGSC, field VLPO[6] (RW)
 *
 * When used in conjunction with BGEN, this bit allows additional clock sources
 * and higher frequency operation (at the cost of higher power) to be selected
 * during VLPx modes.
 *
 * Values:
 * - 0b0 - Operating frequencies and MCG clocking modes are restricted during
 *     VLPx modes as listed in the Power Management chapter.
 * - 0b1 - If BGEN is also set, operating frequencies and MCG clocking modes are
 *     unrestricted during VLPx modes. Note that flash access frequency is still
 *     restricted however.
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_VLPO field. */
#define PMC_RD_REGSC_VLPO(base) ((PMC_REGSC_REG(base) & PMC_REGSC_VLPO_MASK) >> PMC_REGSC_VLPO_SHIFT)
#define PMC_BRD_REGSC_VLPO(base) (BME_UBFX8(&PMC_REGSC_REG(base), PMC_REGSC_VLPO_SHIFT, PMC_REGSC_VLPO_WIDTH))

/*! @brief Set the VLPO field to a new value. */
#define PMC_WR_REGSC_VLPO(base, value) (PMC_RMW_REGSC(base, (PMC_REGSC_VLPO_MASK | PMC_REGSC_ACKISO_MASK), PMC_REGSC_VLPO(value)))
#define PMC_BWR_REGSC_VLPO(base, value) (BME_BFI8(&PMC_REGSC_REG(base), ((uint8_t)(value) << PMC_REGSC_VLPO_SHIFT), PMC_REGSC_VLPO_SHIFT, PMC_REGSC_VLPO_WIDTH))
/*@}*/

/*
 * MKW40Z4 PORT
 *
 * Pin Control and Interrupts
 *
 * Registers defined in this header file:
 * - PORT_PCR - Pin Control Register n
 * - PORT_GPCLR - Global Pin Control Low Register
 * - PORT_GPCHR - Global Pin Control High Register
 * - PORT_ISFR - Interrupt Status Flag Register
 */

#define PORT_INSTANCE_COUNT (3U) /*!< Number of instances of the PORT module. */
#define PORTA_IDX (0U) /*!< Instance number for PORTA. */
#define PORTB_IDX (1U) /*!< Instance number for PORTB. */
#define PORTC_IDX (2U) /*!< Instance number for PORTC. */

/*******************************************************************************
 * PORT_PCR - Pin Control Register n
 ******************************************************************************/

/*!
 * @brief PORT_PCR - Pin Control Register n (RW)
 *
 * Reset value: 0x00000706U
 *
 * See the Signal Multiplexing and Pin Assignment chapter for the reset value of
 * this device. See the GPIO Configuration section for details on the available
 * functions for each pin. Do not modify pin configuration registers associated
 * with pins not available in your selected package. All unbonded pins not
 * available in your package will default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire PORT_PCR register
 */
/*@{*/
#define PORT_RD_PCR(base, index) (PORT_PCR_REG(base, index))
#define PORT_WR_PCR(base, index, value) (PORT_PCR_REG(base, index) = (value))
#define PORT_RMW_PCR(base, index, mask, value) (PORT_WR_PCR(base, index, (PORT_RD_PCR(base, index) & ~(mask)) | (value)))
#define PORT_SET_PCR(base, index, value) (BME_OR32(&PORT_PCR_REG(base, index), (uint32_t)(value)))
#define PORT_CLR_PCR(base, index, value) (BME_AND32(&PORT_PCR_REG(base, index), (uint32_t)(~(value))))
#define PORT_TOG_PCR(base, index, value) (BME_XOR32(&PORT_PCR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PORT_PCR bitfields
 */

/*!
 * @name Register PORT_PCR, field PS[0] (RW)
 *
 * This bit is read only for pins that do not support a configurable pull
 * resistor direction. Pull configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Internal pulldown resistor is enabled on the corresponding pin, if
 *     the corresponding PE field is set.
 * - 0b1 - Internal pullup resistor is enabled on the corresponding pin, if the
 *     corresponding PE field is set.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PS field. */
#define PORT_RD_PCR_PS(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PS_MASK) >> PORT_PCR_PS_SHIFT)
#define PORT_BRD_PCR_PS(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_PS_SHIFT, PORT_PCR_PS_WIDTH))

/*! @brief Set the PS field to a new value. */
#define PORT_WR_PCR_PS(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PS_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PS(value)))
#define PORT_BWR_PCR_PS(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_PS_SHIFT), PORT_PCR_PS_SHIFT, PORT_PCR_PS_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field PE[1] (RW)
 *
 * This field is read-only for pins that do not support a configurable pull
 * resistor. Refer to the Chapter of Signal Multiplexing and Signal Descriptions for
 * the pins that support a configurable pull resistor. Pull configuration is
 * valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Internal pullup or pulldown resistor is not enabled on the
 *     corresponding pin.
 * - 0b1 - Internal pullup or pulldown resistor is enabled on the corresponding
 *     pin, if the pin is configured as a digital input.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PE field. */
#define PORT_RD_PCR_PE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PE_MASK) >> PORT_PCR_PE_SHIFT)
#define PORT_BRD_PCR_PE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_PE_SHIFT, PORT_PCR_PE_WIDTH))

/*! @brief Set the PE field to a new value. */
#define PORT_WR_PCR_PE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PE(value)))
#define PORT_BWR_PCR_PE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_PE_SHIFT), PORT_PCR_PE_SHIFT, PORT_PCR_PE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field SRE[2] (RW)
 *
 * This field is read-only for pins that do not support a configurable slew
 * rate. Slew rate configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Fast slew rate is configured on the corresponding pin, if the pin is
 *     configured as a digital output.
 * - 0b1 - Slow slew rate is configured on the corresponding pin, if the pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_SRE field. */
#define PORT_RD_PCR_SRE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_SRE_MASK) >> PORT_PCR_SRE_SHIFT)
#define PORT_BRD_PCR_SRE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_SRE_SHIFT, PORT_PCR_SRE_WIDTH))

/*! @brief Set the SRE field to a new value. */
#define PORT_WR_PCR_SRE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_SRE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_SRE(value)))
#define PORT_BWR_PCR_SRE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_SRE_SHIFT), PORT_PCR_SRE_SHIFT, PORT_PCR_SRE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field PFE[4] (RW)
 *
 * This field is read-only for pins that do not support a configurable passive
 * input filter. Passive filter configuration is valid in all digital pin muxing
 * modes.
 *
 * Values:
 * - 0b0 - Passive input filter is disabled on the corresponding pin.
 * - 0b1 - Passive input filter is enabled on the corresponding pin, if the pin
 *     is configured as a digital input. Refer to the device data sheet for
 *     filter characteristics.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PFE field. */
#define PORT_RD_PCR_PFE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PFE_MASK) >> PORT_PCR_PFE_SHIFT)
#define PORT_BRD_PCR_PFE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_PFE_SHIFT, PORT_PCR_PFE_WIDTH))

/*! @brief Set the PFE field to a new value. */
#define PORT_WR_PCR_PFE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PFE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PFE(value)))
#define PORT_BWR_PCR_PFE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_PFE_SHIFT), PORT_PCR_PFE_SHIFT, PORT_PCR_PFE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field DSE[6] (RW)
 *
 * This field is read-only for pins that do not support a configurable drive
 * strength. Drive strength configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Low drive strength is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 * - 0b1 - High drive strength is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_DSE field. */
#define PORT_RD_PCR_DSE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_DSE_MASK) >> PORT_PCR_DSE_SHIFT)
#define PORT_BRD_PCR_DSE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_DSE_SHIFT, PORT_PCR_DSE_WIDTH))

/*! @brief Set the DSE field to a new value. */
#define PORT_WR_PCR_DSE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_DSE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_DSE(value)))
#define PORT_BWR_PCR_DSE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_DSE_SHIFT), PORT_PCR_DSE_SHIFT, PORT_PCR_DSE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field MUX[10:8] (RW)
 *
 * Not all pins support all pin muxing slots. Unimplemented pin muxing slots are
 * reserved and may result in configuring the pin for a different pin muxing
 * slot. The corresponding pin is configured in the following pin muxing slot as
 * follows:
 *
 * Values:
 * - 0b000 - Pin disabled (analog).
 * - 0b001 - Alternative 1 (GPIO).
 * - 0b010 - Alternative 2 (chip-specific).
 * - 0b011 - Alternative 3 (chip-specific).
 * - 0b100 - Alternative 4 (chip-specific).
 * - 0b101 - Alternative 5 (chip-specific).
 * - 0b110 - Alternative 6 (chip-specific).
 * - 0b111 - Alternative 7 (chip-specific).
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_MUX field. */
#define PORT_RD_PCR_MUX(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_MUX_MASK) >> PORT_PCR_MUX_SHIFT)
#define PORT_BRD_PCR_MUX(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_MUX_SHIFT, PORT_PCR_MUX_WIDTH))

/*! @brief Set the MUX field to a new value. */
#define PORT_WR_PCR_MUX(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_MUX_MASK | PORT_PCR_ISF_MASK), PORT_PCR_MUX(value)))
#define PORT_BWR_PCR_MUX(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_MUX_SHIFT), PORT_PCR_MUX_SHIFT, PORT_PCR_MUX_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field IRQC[19:16] (RW)
 *
 * This field is read-only for pins that do not support interrupt generation.
 * The pin interrupt configuration is valid in all digital pin muxing modes. The
 * corresponding pin is configured to generate interrupt/DMA request as follows:
 *
 * Values:
 * - 0b0000 - Interrupt Status Flag (ISF) is disabled.
 * - 0b0001 - ISF flag and DMA request on rising edge.
 * - 0b0010 - ISF flag and DMA request on falling edge.
 * - 0b0011 - ISF flag and DMA request on either edge.
 * - 0b0100 - Reserved.
 * - 0b0101 - Reserved.
 * - 0b0110 - Reserved.
 * - 0b0111 - Reserved.
 * - 0b1000 - ISF flag and Interrupt when logic 0.
 * - 0b1001 - ISF flag and Interrupt on rising-edge.
 * - 0b1010 - ISF flag and Interrupt on falling-edge.
 * - 0b1011 - ISF flag and Interrupt on either edge.
 * - 0b1100 - ISF flag and Interrupt when logic 1.
 * - 0b1101 - Reserved.
 * - 0b1110 - Reserved.
 * - 0b1111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_IRQC field. */
#define PORT_RD_PCR_IRQC(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_IRQC_MASK) >> PORT_PCR_IRQC_SHIFT)
#define PORT_BRD_PCR_IRQC(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_IRQC_SHIFT, PORT_PCR_IRQC_WIDTH))

/*! @brief Set the IRQC field to a new value. */
#define PORT_WR_PCR_IRQC(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_IRQC_MASK | PORT_PCR_ISF_MASK), PORT_PCR_IRQC(value)))
#define PORT_BWR_PCR_IRQC(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_IRQC_SHIFT), PORT_PCR_IRQC_SHIFT, PORT_PCR_IRQC_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field ISF[24] (W1C)
 *
 * This field is read-only for pins that do not support interrupt generation.
 * The pin interrupt configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Configured interrupt is not detected.
 * - 0b1 - Configured interrupt is detected. If the pin is configured to
 *     generate a DMA request, then the corresponding flag will be cleared automatically
 *     at the completion of the requested DMA transfer. Otherwise, the flag
 *     remains set until a logic 1 is written to the flag. If the pin is configured
 *     for a level sensitive interrupt and the pin remains asserted, then the flag
 *     is set again immediately after it is cleared.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_ISF field. */
#define PORT_RD_PCR_ISF(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_ISF_MASK) >> PORT_PCR_ISF_SHIFT)
#define PORT_BRD_PCR_ISF(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_ISF_SHIFT, PORT_PCR_ISF_WIDTH))

/*! @brief Set the ISF field to a new value. */
#define PORT_WR_PCR_ISF(base, index, value) (PORT_RMW_PCR(base, index, PORT_PCR_ISF_MASK, PORT_PCR_ISF(value)))
#define PORT_BWR_PCR_ISF(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_ISF_SHIFT), PORT_PCR_ISF_SHIFT, PORT_PCR_ISF_WIDTH))
/*@}*/

/*******************************************************************************
 * PORT_GPCLR - Global Pin Control Low Register
 ******************************************************************************/

/*!
 * @brief PORT_GPCLR - Global Pin Control Low Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
/*!
 * @name Constants and macros for entire PORT_GPCLR register
 */
/*@{*/
#define PORT_RD_GPCLR(base)      (PORT_GPCLR_REG(base))
#define PORT_WR_GPCLR(base, value) (PORT_GPCLR_REG(base) = (value))
#define PORT_RMW_GPCLR(base, mask, value) (PORT_WR_GPCLR(base, (PORT_RD_GPCLR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCLR bitfields
 */

/*!
 * @name Register PORT_GPCLR, field GPWD[15:0] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [15:0] that are
 * selected by GPWE.
 */
/*@{*/
/*! @brief Set the GPWD field to a new value. */
#define PORT_WR_GPCLR_GPWD(base, value) (PORT_RMW_GPCLR(base, PORT_GPCLR_GPWD_MASK, PORT_GPCLR_GPWD(value)))
#define PORT_BWR_GPCLR_GPWD(base, value) (BME_BFI32(&PORT_GPCLR_REG(base), ((uint32_t)(value) << PORT_GPCLR_GPWD_SHIFT), PORT_GPCLR_GPWD_SHIFT, PORT_GPCLR_GPWD_WIDTH))
/*@}*/

/*!
 * @name Register PORT_GPCLR, field GPWE[31:16] (WORZ)
 *
 * Selects which Pin Control Registers (15 through 0) bits [15:0] update with
 * the value in GPWD.
 *
 * Values:
 * - 0b0000000000000000 - Corresponding Pin Control Register is not updated with
 *     the value in GPWD.
 * - 0b0000000000000001 - Corresponding Pin Control Register is updated with the
 *     value in GPWD.
 */
/*@{*/
/*! @brief Set the GPWE field to a new value. */
#define PORT_WR_GPCLR_GPWE(base, value) (PORT_RMW_GPCLR(base, PORT_GPCLR_GPWE_MASK, PORT_GPCLR_GPWE(value)))
#define PORT_BWR_GPCLR_GPWE(base, value) (BME_BFI32(&PORT_GPCLR_REG(base), ((uint32_t)(value) << PORT_GPCLR_GPWE_SHIFT), PORT_GPCLR_GPWE_SHIFT, PORT_GPCLR_GPWE_WIDTH))
/*@}*/

/*******************************************************************************
 * PORT_GPCHR - Global Pin Control High Register
 ******************************************************************************/

/*!
 * @brief PORT_GPCHR - Global Pin Control High Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
/*!
 * @name Constants and macros for entire PORT_GPCHR register
 */
/*@{*/
#define PORT_RD_GPCHR(base)      (PORT_GPCHR_REG(base))
#define PORT_WR_GPCHR(base, value) (PORT_GPCHR_REG(base) = (value))
#define PORT_RMW_GPCHR(base, mask, value) (PORT_WR_GPCHR(base, (PORT_RD_GPCHR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCHR bitfields
 */

/*!
 * @name Register PORT_GPCHR, field GPWD[15:0] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [15:0] that are
 * selected by GPWE.
 */
/*@{*/
/*! @brief Set the GPWD field to a new value. */
#define PORT_WR_GPCHR_GPWD(base, value) (PORT_RMW_GPCHR(base, PORT_GPCHR_GPWD_MASK, PORT_GPCHR_GPWD(value)))
#define PORT_BWR_GPCHR_GPWD(base, value) (BME_BFI32(&PORT_GPCHR_REG(base), ((uint32_t)(value) << PORT_GPCHR_GPWD_SHIFT), PORT_GPCHR_GPWD_SHIFT, PORT_GPCHR_GPWD_WIDTH))
/*@}*/

/*!
 * @name Register PORT_GPCHR, field GPWE[31:16] (WORZ)
 *
 * Selects which Pin Control Registers (31 through 16) bits [15:0] update with
 * the value in GPWD.
 *
 * Values:
 * - 0b0000000000000000 - Corresponding Pin Control Register is not updated with
 *     the value in GPWD.
 * - 0b0000000000000001 - Corresponding Pin Control Register is updated with the
 *     value in GPWD.
 */
/*@{*/
/*! @brief Set the GPWE field to a new value. */
#define PORT_WR_GPCHR_GPWE(base, value) (PORT_RMW_GPCHR(base, PORT_GPCHR_GPWE_MASK, PORT_GPCHR_GPWE(value)))
#define PORT_BWR_GPCHR_GPWE(base, value) (BME_BFI32(&PORT_GPCHR_REG(base), ((uint32_t)(value) << PORT_GPCHR_GPWE_SHIFT), PORT_GPCHR_GPWE_SHIFT, PORT_GPCHR_GPWE_WIDTH))
/*@}*/

/*******************************************************************************
 * PORT_ISFR - Interrupt Status Flag Register
 ******************************************************************************/

/*!
 * @brief PORT_ISFR - Interrupt Status Flag Register (W1C)
 *
 * Reset value: 0x00000000U
 *
 * The corresponding bit is read only for pins that do not support interrupt
 * generation. The pin interrupt configuration is valid in all digital pin muxing
 * modes. The Interrupt Status Flag for each pin is also visible in the
 * corresponding Pin Control Register, and each flag can be cleared in either location.
 */
/*!
 * @name Constants and macros for entire PORT_ISFR register
 */
/*@{*/
#define PORT_RD_ISFR(base)       (PORT_ISFR_REG(base))
#define PORT_WR_ISFR(base, value) (PORT_ISFR_REG(base) = (value))
#define PORT_RMW_ISFR(base, mask, value) (PORT_WR_ISFR(base, (PORT_RD_ISFR(base) & ~(mask)) | (value)))
#define PORT_SET_ISFR(base, value) (BME_OR32(&PORT_ISFR_REG(base), (uint32_t)(value)))
#define PORT_CLR_ISFR(base, value) (BME_AND32(&PORT_ISFR_REG(base), (uint32_t)(~(value))))
#define PORT_TOG_ISFR(base, value) (BME_XOR32(&PORT_ISFR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * MKW40Z4 RCM
 *
 * Reset Control Module
 *
 * Registers defined in this header file:
 * - RCM_SRS0 - System Reset Status Register 0
 * - RCM_SRS1 - System Reset Status Register 1
 * - RCM_RPFC - Reset Pin Filter Control register
 * - RCM_RPFW - Reset Pin Filter Width register
 */

#define RCM_INSTANCE_COUNT (1U) /*!< Number of instances of the RCM module. */
#define RCM_IDX (0U) /*!< Instance number for RCM. */

/*******************************************************************************
 * RCM_SRS0 - System Reset Status Register 0
 ******************************************************************************/

/*!
 * @brief RCM_SRS0 - System Reset Status Register 0 (RO)
 *
 * Reset value: 0x82U
 *
 * This register includes read-only status flags to indicate the source of the
 * most recent reset. The reset state of these bits depends on what caused the MCU
 * to reset. The reset value of this register depends on the reset source: POR
 * (including LVD) - 0x82 LVD (without POR) - 0x02 VLLS mode wakeup due to RESET
 * pin assertion - 0x41 VLLS mode wakeup due to other wakeup sources - 0x01 Other
 * reset - a bit is set if its corresponding reset source caused the reset
 */
/*!
 * @name Constants and macros for entire RCM_SRS0 register
 */
/*@{*/
#define RCM_RD_SRS0(base)        (RCM_SRS0_REG(base))
/*@}*/

/*
 * Constants & macros for individual RCM_SRS0 bitfields
 */

/*!
 * @name Register RCM_SRS0, field WAKEUP[0] (RO)
 *
 * Indicates a reset has been caused by an enabled LLWU module wakeup source
 * while the chip was in a low leakage mode. In LLS mode, the RESET pin is the only
 * wakeup source that can cause this reset. Any enabled wakeup source in a VLLSx
 * mode causes a reset. This bit is cleared by any reset except WAKEUP.
 *
 * Values:
 * - 0b0 - Reset not caused by LLWU module wakeup source
 * - 0b1 - Reset caused by LLWU module wakeup source
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_WAKEUP field. */
#define RCM_RD_SRS0_WAKEUP(base) ((RCM_SRS0_REG(base) & RCM_SRS0_WAKEUP_MASK) >> RCM_SRS0_WAKEUP_SHIFT)
#define RCM_BRD_SRS0_WAKEUP(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_WAKEUP_SHIFT, RCM_SRS0_WAKEUP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LVD[1] (RO)
 *
 * If PMC_LVDSC1[LVDRE] is set and the supply drops below the LVD trip voltage,
 * an LVD reset occurs. This field is also set by POR.
 *
 * Values:
 * - 0b0 - Reset not caused by LVD trip or POR
 * - 0b1 - Reset caused by LVD trip or POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_LVD field. */
#define RCM_RD_SRS0_LVD(base) ((RCM_SRS0_REG(base) & RCM_SRS0_LVD_MASK) >> RCM_SRS0_LVD_SHIFT)
#define RCM_BRD_SRS0_LVD(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_LVD_SHIFT, RCM_SRS0_LVD_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LOC[2] (RO)
 *
 * Indicates a reset has been caused by a loss of external clock. The MCG clock
 * monitor must be enabled for a loss of clock to be detected. Refer to the
 * detailed MCG description for information on enabling the clock monitor.
 *
 * Values:
 * - 0b0 - Reset not caused by a loss of external clock.
 * - 0b1 - Reset caused by a loss of external clock.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_LOC field. */
#define RCM_RD_SRS0_LOC(base) ((RCM_SRS0_REG(base) & RCM_SRS0_LOC_MASK) >> RCM_SRS0_LOC_SHIFT)
#define RCM_BRD_SRS0_LOC(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_LOC_SHIFT, RCM_SRS0_LOC_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field WDOG[5] (RO)
 *
 * Indicates a reset has been caused by the watchdog timer timing out. This
 * reset source can be blocked by disabling the watchdog.
 *
 * Values:
 * - 0b0 - Reset not caused by watchdog timeout
 * - 0b1 - Reset caused by watchdog timeout
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_WDOG field. */
#define RCM_RD_SRS0_WDOG(base) ((RCM_SRS0_REG(base) & RCM_SRS0_WDOG_MASK) >> RCM_SRS0_WDOG_SHIFT)
#define RCM_BRD_SRS0_WDOG(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_WDOG_SHIFT, RCM_SRS0_WDOG_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field PIN[6] (RO)
 *
 * Indicates a reset has been caused by an active-low level on the external
 * RESET pin.
 *
 * Values:
 * - 0b0 - Reset not caused by external reset pin
 * - 0b1 - Reset caused by external reset pin
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_PIN field. */
#define RCM_RD_SRS0_PIN(base) ((RCM_SRS0_REG(base) & RCM_SRS0_PIN_MASK) >> RCM_SRS0_PIN_SHIFT)
#define RCM_BRD_SRS0_PIN(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_PIN_SHIFT, RCM_SRS0_PIN_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field POR[7] (RO)
 *
 * Indicates a reset has been caused by the power-on detection logic. Because
 * the internal supply voltage was ramping up at the time, the low-voltage reset
 * (LVD) status bit is also set to indicate that the reset occurred while the
 * internal supply was below the LVD threshold.
 *
 * Values:
 * - 0b0 - Reset not caused by POR
 * - 0b1 - Reset caused by POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_POR field. */
#define RCM_RD_SRS0_POR(base) ((RCM_SRS0_REG(base) & RCM_SRS0_POR_MASK) >> RCM_SRS0_POR_SHIFT)
#define RCM_BRD_SRS0_POR(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_POR_SHIFT, RCM_SRS0_POR_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_SRS1 - System Reset Status Register 1
 ******************************************************************************/

/*!
 * @brief RCM_SRS1 - System Reset Status Register 1 (RO)
 *
 * Reset value: 0x00U
 *
 * This register includes read-only status flags to indicate the source of the
 * most recent reset. The reset state of these bits depends on what caused the MCU
 * to reset. The reset value of this register depends on the reset source: POR
 * (including LVD) - 0x00 LVD (without POR) - 0x00 VLLS mode wakeup - 0x00 Other
 * reset - a bit is set if its corresponding reset source caused the reset
 */
/*!
 * @name Constants and macros for entire RCM_SRS1 register
 */
/*@{*/
#define RCM_RD_SRS1(base)        (RCM_SRS1_REG(base))
/*@}*/

/*
 * Constants & macros for individual RCM_SRS1 bitfields
 */

/*!
 * @name Register RCM_SRS1, field LOCKUP[1] (RO)
 *
 * Indicates a reset has been caused by the ARM core indication of a LOCKUP
 * event.
 *
 * Values:
 * - 0b0 - Reset not caused by core LOCKUP event
 * - 0b1 - Reset caused by core LOCKUP event
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_LOCKUP field. */
#define RCM_RD_SRS1_LOCKUP(base) ((RCM_SRS1_REG(base) & RCM_SRS1_LOCKUP_MASK) >> RCM_SRS1_LOCKUP_SHIFT)
#define RCM_BRD_SRS1_LOCKUP(base) (BME_UBFX8(&RCM_SRS1_REG(base), RCM_SRS1_LOCKUP_SHIFT, RCM_SRS1_LOCKUP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS1, field SW[2] (RO)
 *
 * Indicates a reset has been caused by software setting of SYSRESETREQ bit in
 * Application Interrupt and Reset Control Register in the ARM core.
 *
 * Values:
 * - 0b0 - Reset not caused by software setting of SYSRESETREQ bit
 * - 0b1 - Reset caused by software setting of SYSRESETREQ bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_SW field. */
#define RCM_RD_SRS1_SW(base) ((RCM_SRS1_REG(base) & RCM_SRS1_SW_MASK) >> RCM_SRS1_SW_SHIFT)
#define RCM_BRD_SRS1_SW(base) (BME_UBFX8(&RCM_SRS1_REG(base), RCM_SRS1_SW_SHIFT, RCM_SRS1_SW_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS1, field MDM_AP[3] (RO)
 *
 * Indicates a reset has been caused by the host debugger system setting of the
 * System Reset Request bit in the MDM-AP Control Register.
 *
 * Values:
 * - 0b0 - Reset not caused by host debugger system setting of the System Reset
 *     Request bit
 * - 0b1 - Reset caused by host debugger system setting of the System Reset
 *     Request bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_MDM_AP field. */
#define RCM_RD_SRS1_MDM_AP(base) ((RCM_SRS1_REG(base) & RCM_SRS1_MDM_AP_MASK) >> RCM_SRS1_MDM_AP_SHIFT)
#define RCM_BRD_SRS1_MDM_AP(base) (BME_UBFX8(&RCM_SRS1_REG(base), RCM_SRS1_MDM_AP_SHIFT, RCM_SRS1_MDM_AP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS1, field SACKERR[5] (RO)
 *
 * Indicates that after an attempt to enter Stop mode, a reset has been caused
 * by a failure of one or more peripherals to acknowledge within approximately one
 * second to enter stop mode.
 *
 * Values:
 * - 0b0 - Reset not caused by peripheral failure to acknowledge attempt to
 *     enter stop mode
 * - 0b1 - Reset caused by peripheral failure to acknowledge attempt to enter
 *     stop mode
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_SACKERR field. */
#define RCM_RD_SRS1_SACKERR(base) ((RCM_SRS1_REG(base) & RCM_SRS1_SACKERR_MASK) >> RCM_SRS1_SACKERR_SHIFT)
#define RCM_BRD_SRS1_SACKERR(base) (BME_UBFX8(&RCM_SRS1_REG(base), RCM_SRS1_SACKERR_SHIFT, RCM_SRS1_SACKERR_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_RPFC - Reset Pin Filter Control register
 ******************************************************************************/

/*!
 * @brief RCM_RPFC - Reset Pin Filter Control register (RW)
 *
 * Reset value: 0x00U
 *
 * The reset values of bits 2-0 are for Chip POR only. They are unaffected by
 * other reset types. The bus clock filter is reset when disabled or when entering
 * stop mode. The LPO filter is reset when disabled .
 */
/*!
 * @name Constants and macros for entire RCM_RPFC register
 */
/*@{*/
#define RCM_RD_RPFC(base)        (RCM_RPFC_REG(base))
#define RCM_WR_RPFC(base, value) (RCM_RPFC_REG(base) = (value))
#define RCM_RMW_RPFC(base, mask, value) (RCM_WR_RPFC(base, (RCM_RD_RPFC(base) & ~(mask)) | (value)))
#define RCM_SET_RPFC(base, value) (BME_OR8(&RCM_RPFC_REG(base), (uint8_t)(value)))
#define RCM_CLR_RPFC(base, value) (BME_AND8(&RCM_RPFC_REG(base), (uint8_t)(~(value))))
#define RCM_TOG_RPFC(base, value) (BME_XOR8(&RCM_RPFC_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RCM_RPFC bitfields
 */

/*!
 * @name Register RCM_RPFC, field RSTFLTSRW[1:0] (RW)
 *
 * Selects how the reset pin filter is enabled in run and wait modes.
 *
 * Values:
 * - 0b00 - All filtering disabled
 * - 0b01 - Bus clock filter enabled for normal operation
 * - 0b10 - LPO clock filter enabled for normal operation
 * - 0b11 - Reserved (all filtering disabled)
 */
/*@{*/
/*! @brief Read current value of the RCM_RPFC_RSTFLTSRW field. */
#define RCM_RD_RPFC_RSTFLTSRW(base) ((RCM_RPFC_REG(base) & RCM_RPFC_RSTFLTSRW_MASK) >> RCM_RPFC_RSTFLTSRW_SHIFT)
#define RCM_BRD_RPFC_RSTFLTSRW(base) (BME_UBFX8(&RCM_RPFC_REG(base), RCM_RPFC_RSTFLTSRW_SHIFT, RCM_RPFC_RSTFLTSRW_WIDTH))

/*! @brief Set the RSTFLTSRW field to a new value. */
#define RCM_WR_RPFC_RSTFLTSRW(base, value) (RCM_RMW_RPFC(base, RCM_RPFC_RSTFLTSRW_MASK, RCM_RPFC_RSTFLTSRW(value)))
#define RCM_BWR_RPFC_RSTFLTSRW(base, value) (BME_BFI8(&RCM_RPFC_REG(base), ((uint8_t)(value) << RCM_RPFC_RSTFLTSRW_SHIFT), RCM_RPFC_RSTFLTSRW_SHIFT, RCM_RPFC_RSTFLTSRW_WIDTH))
/*@}*/

/*!
 * @name Register RCM_RPFC, field RSTFLTSS[2] (RW)
 *
 * Selects how the reset pin filter is enabled in Stop and VLPS modes , and also
 * during LLS and VLLS modes. On exit from VLLS mode, this bit should be
 * reconfigured before clearing PMC_REGSC[ACKISO].
 *
 * Values:
 * - 0b0 - All filtering disabled
 * - 0b1 - LPO clock filter enabled
 */
/*@{*/
/*! @brief Read current value of the RCM_RPFC_RSTFLTSS field. */
#define RCM_RD_RPFC_RSTFLTSS(base) ((RCM_RPFC_REG(base) & RCM_RPFC_RSTFLTSS_MASK) >> RCM_RPFC_RSTFLTSS_SHIFT)
#define RCM_BRD_RPFC_RSTFLTSS(base) (BME_UBFX8(&RCM_RPFC_REG(base), RCM_RPFC_RSTFLTSS_SHIFT, RCM_RPFC_RSTFLTSS_WIDTH))

/*! @brief Set the RSTFLTSS field to a new value. */
#define RCM_WR_RPFC_RSTFLTSS(base, value) (RCM_RMW_RPFC(base, RCM_RPFC_RSTFLTSS_MASK, RCM_RPFC_RSTFLTSS(value)))
#define RCM_BWR_RPFC_RSTFLTSS(base, value) (BME_BFI8(&RCM_RPFC_REG(base), ((uint8_t)(value) << RCM_RPFC_RSTFLTSS_SHIFT), RCM_RPFC_RSTFLTSS_SHIFT, RCM_RPFC_RSTFLTSS_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_RPFW - Reset Pin Filter Width register
 ******************************************************************************/

/*!
 * @brief RCM_RPFW - Reset Pin Filter Width register (RW)
 *
 * Reset value: 0x00U
 *
 * The reset values of the bits in the RSTFLTSEL field are for Chip POR only.
 * They are unaffected by other reset types.
 */
/*!
 * @name Constants and macros for entire RCM_RPFW register
 */
/*@{*/
#define RCM_RD_RPFW(base)        (RCM_RPFW_REG(base))
#define RCM_WR_RPFW(base, value) (RCM_RPFW_REG(base) = (value))
#define RCM_RMW_RPFW(base, mask, value) (RCM_WR_RPFW(base, (RCM_RD_RPFW(base) & ~(mask)) | (value)))
#define RCM_SET_RPFW(base, value) (BME_OR8(&RCM_RPFW_REG(base), (uint8_t)(value)))
#define RCM_CLR_RPFW(base, value) (BME_AND8(&RCM_RPFW_REG(base), (uint8_t)(~(value))))
#define RCM_TOG_RPFW(base, value) (BME_XOR8(&RCM_RPFW_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RCM_RPFW bitfields
 */

/*!
 * @name Register RCM_RPFW, field RSTFLTSEL[4:0] (RW)
 *
 * Selects the reset pin bus clock filter width.
 *
 * Values:
 * - 0b00000 - Bus clock filter count is 1
 * - 0b00001 - Bus clock filter count is 2
 * - 0b00010 - Bus clock filter count is 3
 * - 0b00011 - Bus clock filter count is 4
 * - 0b00100 - Bus clock filter count is 5
 * - 0b00101 - Bus clock filter count is 6
 * - 0b00110 - Bus clock filter count is 7
 * - 0b00111 - Bus clock filter count is 8
 * - 0b01000 - Bus clock filter count is 9
 * - 0b01001 - Bus clock filter count is 10
 * - 0b01010 - Bus clock filter count is 11
 * - 0b01011 - Bus clock filter count is 12
 * - 0b01100 - Bus clock filter count is 13
 * - 0b01101 - Bus clock filter count is 14
 * - 0b01110 - Bus clock filter count is 15
 * - 0b01111 - Bus clock filter count is 16
 * - 0b10000 - Bus clock filter count is 17
 * - 0b10001 - Bus clock filter count is 18
 * - 0b10010 - Bus clock filter count is 19
 * - 0b10011 - Bus clock filter count is 20
 * - 0b10100 - Bus clock filter count is 21
 * - 0b10101 - Bus clock filter count is 22
 * - 0b10110 - Bus clock filter count is 23
 * - 0b10111 - Bus clock filter count is 24
 * - 0b11000 - Bus clock filter count is 25
 * - 0b11001 - Bus clock filter count is 26
 * - 0b11010 - Bus clock filter count is 27
 * - 0b11011 - Bus clock filter count is 28
 * - 0b11100 - Bus clock filter count is 29
 * - 0b11101 - Bus clock filter count is 30
 * - 0b11110 - Bus clock filter count is 31
 * - 0b11111 - Bus clock filter count is 32
 */
/*@{*/
/*! @brief Read current value of the RCM_RPFW_RSTFLTSEL field. */
#define RCM_RD_RPFW_RSTFLTSEL(base) ((RCM_RPFW_REG(base) & RCM_RPFW_RSTFLTSEL_MASK) >> RCM_RPFW_RSTFLTSEL_SHIFT)
#define RCM_BRD_RPFW_RSTFLTSEL(base) (BME_UBFX8(&RCM_RPFW_REG(base), RCM_RPFW_RSTFLTSEL_SHIFT, RCM_RPFW_RSTFLTSEL_WIDTH))

/*! @brief Set the RSTFLTSEL field to a new value. */
#define RCM_WR_RPFW_RSTFLTSEL(base, value) (RCM_RMW_RPFW(base, RCM_RPFW_RSTFLTSEL_MASK, RCM_RPFW_RSTFLTSEL(value)))
#define RCM_BWR_RPFW_RSTFLTSEL(base, value) (BME_BFI8(&RCM_RPFW_REG(base), ((uint8_t)(value) << RCM_RPFW_RSTFLTSEL_SHIFT), RCM_RPFW_RSTFLTSEL_SHIFT, RCM_RPFW_RSTFLTSEL_WIDTH))
/*@}*/

/*
 * MKW40Z4 ROM
 *
 * System ROM
 *
 * Registers defined in this header file:
 * - ROM_ENTRY - Entry
 * - ROM_TABLEMARK - End of Table Marker Register
 * - ROM_SYSACCESS - System Access Register
 * - ROM_PERIPHID4 - Peripheral ID Register
 * - ROM_PERIPHID5 - Peripheral ID Register
 * - ROM_PERIPHID6 - Peripheral ID Register
 * - ROM_PERIPHID7 - Peripheral ID Register
 * - ROM_PERIPHID0 - Peripheral ID Register
 * - ROM_PERIPHID1 - Peripheral ID Register
 * - ROM_PERIPHID2 - Peripheral ID Register
 * - ROM_PERIPHID3 - Peripheral ID Register
 * - ROM_COMPID - Component ID Register
 */

#define ROM_INSTANCE_COUNT (1U) /*!< Number of instances of the ROM module. */
#define ROM_IDX (0U) /*!< Instance number for ROM. */

/*******************************************************************************
 * ROM_ENTRY - Entry
 ******************************************************************************/

/*!
 * @brief ROM_ENTRY - Entry (RO)
 *
 * Reset value: 0x00000000U
 *
 * The System ROM Table begins with "n" relative 32-bit addresses, one for each
 * debug component present in the device and terminating with an all-zero value
 * signaling the end of the table at the "n+1"-th value. It is hardwired to
 * specific values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_ENTRY register
 */
/*@{*/
#define ROM_RD_ENTRY(base, index) (ROM_ENTRY_REG(base, index))
/*@}*/

/*******************************************************************************
 * ROM_TABLEMARK - End of Table Marker Register
 ******************************************************************************/

/*!
 * @brief ROM_TABLEMARK - End of Table Marker Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register indicates end of table marker. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_TABLEMARK register
 */
/*@{*/
#define ROM_RD_TABLEMARK(base)   (ROM_TABLEMARK_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_SYSACCESS - System Access Register
 ******************************************************************************/

/*!
 * @brief ROM_SYSACCESS - System Access Register (RO)
 *
 * Reset value: 0x00000001U
 *
 * This register indicates system access. It is hardwired to specific values
 * used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_SYSACCESS register
 */
/*@{*/
#define ROM_RD_SYSACCESS(base)   (ROM_SYSACCESS_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID4 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID4 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID4 register
 */
/*@{*/
#define ROM_RD_PERIPHID4(base)   (ROM_PERIPHID4_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID5 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID5 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID5 register
 */
/*@{*/
#define ROM_RD_PERIPHID5(base)   (ROM_PERIPHID5_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID6 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID6 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID6 register
 */
/*@{*/
#define ROM_RD_PERIPHID6(base)   (ROM_PERIPHID6_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID7 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID7 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID7 register
 */
/*@{*/
#define ROM_RD_PERIPHID7(base)   (ROM_PERIPHID7_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID0 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID0 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID0 register
 */
/*@{*/
#define ROM_RD_PERIPHID0(base)   (ROM_PERIPHID0_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID1 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID1 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID1 register
 */
/*@{*/
#define ROM_RD_PERIPHID1(base)   (ROM_PERIPHID1_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID2 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID2 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID2 register
 */
/*@{*/
#define ROM_RD_PERIPHID2(base)   (ROM_PERIPHID2_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID3 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID3 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID3 register
 */
/*@{*/
#define ROM_RD_PERIPHID3(base)   (ROM_PERIPHID3_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_COMPID - Component ID Register
 ******************************************************************************/

/*!
 * @brief ROM_COMPID - Component ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the component IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_COMPID register
 */
/*@{*/
#define ROM_RD_COMPID(base, index) (ROM_COMPID_REG(base, index))
/*@}*/

/*
 * MKW40Z4 RSIM
 *
 * Radio System Integration Module
 *
 * Registers defined in this header file:
 * - RSIM_CONTROL - RSIM Control
 * - RSIM_ACTIVE_DELAY - RSIM BLE Active Delay
 * - RSIM_MAC_MSB - RSIM MAC MSB
 * - RSIM_MAC_LSB - RSIM MAC LSB
 * - RSIM_ANA_TEST - RSIM Analog Test
 */

#define RSIM_INSTANCE_COUNT (1U) /*!< Number of instances of the RSIM module. */
#define RSIM_IDX (0U) /*!< Instance number for RSIM. */

/*******************************************************************************
 * RSIM_CONTROL - RSIM Control
 ******************************************************************************/

/*!
 * @brief RSIM_CONTROL - RSIM Control (RW)
 *
 * Reset value: 0x00C00000U
 *
 * The RSIM Control register provides various control bits for the Radio System
 * and for its interaction with the SoC Systems.
 */
/*!
 * @name Constants and macros for entire RSIM_CONTROL register
 */
/*@{*/
#define RSIM_RD_CONTROL(base)    (RSIM_CONTROL_REG(base))
#define RSIM_WR_CONTROL(base, value) (RSIM_CONTROL_REG(base) = (value))
#define RSIM_RMW_CONTROL(base, mask, value) (RSIM_WR_CONTROL(base, (RSIM_RD_CONTROL(base) & ~(mask)) | (value)))
#define RSIM_SET_CONTROL(base, value) (BME_OR32(&RSIM_CONTROL_REG(base), (uint32_t)(value)))
#define RSIM_CLR_CONTROL(base, value) (BME_AND32(&RSIM_CONTROL_REG(base), (uint32_t)(~(value))))
#define RSIM_TOG_CONTROL(base, value) (BME_XOR32(&RSIM_CONTROL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RSIM_CONTROL bitfields
 */

/*!
 * @name Register RSIM_CONTROL, field BLE_RF_OSC_REQ_EN[0] (RW)
 *
 * This bit resets on POR only. If this bit is cleared (the default state), then
 * all BLE link layer requests to turn on the RF Ref Oscillator (Sysclk Req)
 * will be blocked and ignored. In BLE protocols the BLE link layer will always
 * restart when exiting reset by first Requesting the RF Ref Osc (Sysclk Req), this
 * bit blocks that behavior until software configures the Radio and enables the
 * requests.
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_BLE_RF_OSC_REQ_EN field. */
#define RSIM_RD_CONTROL_BLE_RF_OSC_REQ_EN(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_BLE_RF_OSC_REQ_EN_MASK) >> RSIM_CONTROL_BLE_RF_OSC_REQ_EN_SHIFT)
#define RSIM_BRD_CONTROL_BLE_RF_OSC_REQ_EN(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_BLE_RF_OSC_REQ_EN_SHIFT, RSIM_CONTROL_BLE_RF_OSC_REQ_EN_WIDTH))

/*! @brief Set the BLE_RF_OSC_REQ_EN field to a new value. */
#define RSIM_WR_CONTROL_BLE_RF_OSC_REQ_EN(base, value) (RSIM_RMW_CONTROL(base, (RSIM_CONTROL_BLE_RF_OSC_REQ_EN_MASK | RSIM_CONTROL_BLE_RF_OSC_REQ_INT_MASK), RSIM_CONTROL_BLE_RF_OSC_REQ_EN(value)))
#define RSIM_BWR_CONTROL_BLE_RF_OSC_REQ_EN(base, value) (BME_BFI32(&RSIM_CONTROL_REG(base), ((uint32_t)(value) << RSIM_CONTROL_BLE_RF_OSC_REQ_EN_SHIFT), RSIM_CONTROL_BLE_RF_OSC_REQ_EN_SHIFT, RSIM_CONTROL_BLE_RF_OSC_REQ_EN_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_CONTROL, field BLE_RF_OSC_REQ_STAT[1] (RO)
 *
 * This bit indicates the current status of the BLE link layer request to turn
 * on the RF Ref Oscillator (Sysclk Req).
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_BLE_RF_OSC_REQ_STAT field. */
#define RSIM_RD_CONTROL_BLE_RF_OSC_REQ_STAT(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_BLE_RF_OSC_REQ_STAT_MASK) >> RSIM_CONTROL_BLE_RF_OSC_REQ_STAT_SHIFT)
#define RSIM_BRD_CONTROL_BLE_RF_OSC_REQ_STAT(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_BLE_RF_OSC_REQ_STAT_SHIFT, RSIM_CONTROL_BLE_RF_OSC_REQ_STAT_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_CONTROL, field BLE_RF_OSC_REQ_INT_EN[4] (RW)
 *
 * This bit enables an interrupt request when the enabled version of the BLE Ref
 * Osc (Sysclk) Request is asserted high.
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_BLE_RF_OSC_REQ_INT_EN field. */
#define RSIM_RD_CONTROL_BLE_RF_OSC_REQ_INT_EN(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_BLE_RF_OSC_REQ_INT_EN_MASK) >> RSIM_CONTROL_BLE_RF_OSC_REQ_INT_EN_SHIFT)
#define RSIM_BRD_CONTROL_BLE_RF_OSC_REQ_INT_EN(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_BLE_RF_OSC_REQ_INT_EN_SHIFT, RSIM_CONTROL_BLE_RF_OSC_REQ_INT_EN_WIDTH))

/*! @brief Set the BLE_RF_OSC_REQ_INT_EN field to a new value. */
#define RSIM_WR_CONTROL_BLE_RF_OSC_REQ_INT_EN(base, value) (RSIM_RMW_CONTROL(base, (RSIM_CONTROL_BLE_RF_OSC_REQ_INT_EN_MASK | RSIM_CONTROL_BLE_RF_OSC_REQ_INT_MASK), RSIM_CONTROL_BLE_RF_OSC_REQ_INT_EN(value)))
#define RSIM_BWR_CONTROL_BLE_RF_OSC_REQ_INT_EN(base, value) (BME_BFI32(&RSIM_CONTROL_REG(base), ((uint32_t)(value) << RSIM_CONTROL_BLE_RF_OSC_REQ_INT_EN_SHIFT), RSIM_CONTROL_BLE_RF_OSC_REQ_INT_EN_SHIFT, RSIM_CONTROL_BLE_RF_OSC_REQ_INT_EN_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_CONTROL, field BLE_RF_OSC_REQ_INT[5] (W1C)
 *
 * This bit is an interrupt flag that is set when the enabled version of the BLE
 * Ref Osc (Sysclk) Request is asserted high. This interrupt flag is cleared by
 * writing a 1 to it.
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_BLE_RF_OSC_REQ_INT field. */
#define RSIM_RD_CONTROL_BLE_RF_OSC_REQ_INT(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_BLE_RF_OSC_REQ_INT_MASK) >> RSIM_CONTROL_BLE_RF_OSC_REQ_INT_SHIFT)
#define RSIM_BRD_CONTROL_BLE_RF_OSC_REQ_INT(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_BLE_RF_OSC_REQ_INT_SHIFT, RSIM_CONTROL_BLE_RF_OSC_REQ_INT_WIDTH))

/*! @brief Set the BLE_RF_OSC_REQ_INT field to a new value. */
#define RSIM_WR_CONTROL_BLE_RF_OSC_REQ_INT(base, value) (RSIM_RMW_CONTROL(base, RSIM_CONTROL_BLE_RF_OSC_REQ_INT_MASK, RSIM_CONTROL_BLE_RF_OSC_REQ_INT(value)))
#define RSIM_BWR_CONTROL_BLE_RF_OSC_REQ_INT(base, value) (BME_BFI32(&RSIM_CONTROL_REG(base), ((uint32_t)(value) << RSIM_CONTROL_BLE_RF_OSC_REQ_INT_SHIFT), RSIM_CONTROL_BLE_RF_OSC_REQ_INT_SHIFT, RSIM_CONTROL_BLE_RF_OSC_REQ_INT_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_CONTROL, field RF_OSC_EN[11:8] (RW)
 *
 * The RF Reference Oscillator can be enabled by the BLE link layer, by an SoC
 * MCG mode, or by these bits. If these bits are all cleared, 0000, then the RF
 * Ref Osc will be controlled by the SoC or the BLE link layer. If any of these
 * bits are set then the RF Ref Osc will be on in the SoC power modes as shown
 * below. Note that the enables are additive; each bit adds another low power mode.
 *
 * Values:
 * - 0b0000 - RF Ref Osc will be controlled by the SoC or the BLE link layer
 * - 0b0001 - RF Ref Osc on in Run/Wait
 * - 0b0011 - RF Ref Osc on in Stop
 * - 0b0111 - RF Ref Osc on in VLPR/VLPW
 * - 0b1111 - RF Ref Osc on in VLPS
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_RF_OSC_EN field. */
#define RSIM_RD_CONTROL_RF_OSC_EN(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_RF_OSC_EN_MASK) >> RSIM_CONTROL_RF_OSC_EN_SHIFT)
#define RSIM_BRD_CONTROL_RF_OSC_EN(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_RF_OSC_EN_SHIFT, RSIM_CONTROL_RF_OSC_EN_WIDTH))

/*! @brief Set the RF_OSC_EN field to a new value. */
#define RSIM_WR_CONTROL_RF_OSC_EN(base, value) (RSIM_RMW_CONTROL(base, (RSIM_CONTROL_RF_OSC_EN_MASK | RSIM_CONTROL_BLE_RF_OSC_REQ_INT_MASK), RSIM_CONTROL_RF_OSC_EN(value)))
#define RSIM_BWR_CONTROL_RF_OSC_EN(base, value) (BME_BFI32(&RSIM_CONTROL_REG(base), ((uint32_t)(value) << RSIM_CONTROL_RF_OSC_EN_SHIFT), RSIM_CONTROL_RF_OSC_EN_SHIFT, RSIM_CONTROL_RF_OSC_EN_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_CONTROL, field GASKET_BYPASS_OVRD_EN[12] (RW)
 *
 * The SoC platform has an asynchronous gasket that allows register access for
 * the Radio registers in all SoC clocking modes. This bit allows software to
 * directly control the SoC platform asynchronous gasket bypass signal.
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_GASKET_BYPASS_OVRD_EN field. */
#define RSIM_RD_CONTROL_GASKET_BYPASS_OVRD_EN(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_GASKET_BYPASS_OVRD_EN_MASK) >> RSIM_CONTROL_GASKET_BYPASS_OVRD_EN_SHIFT)
#define RSIM_BRD_CONTROL_GASKET_BYPASS_OVRD_EN(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_GASKET_BYPASS_OVRD_EN_SHIFT, RSIM_CONTROL_GASKET_BYPASS_OVRD_EN_WIDTH))

/*! @brief Set the GASKET_BYPASS_OVRD_EN field to a new value. */
#define RSIM_WR_CONTROL_GASKET_BYPASS_OVRD_EN(base, value) (RSIM_RMW_CONTROL(base, (RSIM_CONTROL_GASKET_BYPASS_OVRD_EN_MASK | RSIM_CONTROL_BLE_RF_OSC_REQ_INT_MASK), RSIM_CONTROL_GASKET_BYPASS_OVRD_EN(value)))
#define RSIM_BWR_CONTROL_GASKET_BYPASS_OVRD_EN(base, value) (BME_BFI32(&RSIM_CONTROL_REG(base), ((uint32_t)(value) << RSIM_CONTROL_GASKET_BYPASS_OVRD_EN_SHIFT), RSIM_CONTROL_GASKET_BYPASS_OVRD_EN_SHIFT, RSIM_CONTROL_GASKET_BYPASS_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_CONTROL, field GASKET_BYPASS_OVRD[13] (RW)
 *
 * This bit directly controls the SoC platform asynchronous gasket bypass signal
 * when the Gasket Bypass Override is enabled. The default behavior of the SoC
 * Asynchronous Gasket is Not Bypassed, which means the Radio registers are
 * accessed using the RF Ref Osc clock. The Radio sends the RF Ref Osc to the
 * asynchronous gasket which then uses that clock for SoC register accesses of the Radio
 * registers. This requires the RF Ref Osc to be Enabled and Ready. If the RF Ref
 * Osc is not Enabled and Ready, then the IPS Gasket can be overridden to be in
 * Bypass Mode, which forces the use of the SoC IPG clock as the register access
 * clock. If the RF Ref Osc IS Enabled and Ready, then the IPS Gasket can be
 * overridden to be in Bypass Mode, but this is an ILLEGALL ACCESS if the Radio is
 * operational, DO NOT write Radio registers with the Asynchronous Gasket Bypassed
 * when the Radio is Operating. Test mode access is allowed but glitches may
 * occur. The intent of Bypass Mode is to allow software to configure the Radio before
 * the RF Ref Osc is Enabled and Ready. Note that the BLE Link Layer registers
 * can only be accessed when the RF Ref Osc is Enabled and Ready. The following
 * table shows which clock is being used to access the Radio XCVR and Zigbee
 * registers. Gasket Bypass Override Enable Gasket Bypass Override XCVR and Zigbee
 * Register Clock 1 0 RF Ref Osc Clock 1 1 SoC IPG Clock 0 x RF Ref Osc Clock
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_GASKET_BYPASS_OVRD field. */
#define RSIM_RD_CONTROL_GASKET_BYPASS_OVRD(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_GASKET_BYPASS_OVRD_MASK) >> RSIM_CONTROL_GASKET_BYPASS_OVRD_SHIFT)
#define RSIM_BRD_CONTROL_GASKET_BYPASS_OVRD(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_GASKET_BYPASS_OVRD_SHIFT, RSIM_CONTROL_GASKET_BYPASS_OVRD_WIDTH))

/*! @brief Set the GASKET_BYPASS_OVRD field to a new value. */
#define RSIM_WR_CONTROL_GASKET_BYPASS_OVRD(base, value) (RSIM_RMW_CONTROL(base, (RSIM_CONTROL_GASKET_BYPASS_OVRD_MASK | RSIM_CONTROL_BLE_RF_OSC_REQ_INT_MASK), RSIM_CONTROL_GASKET_BYPASS_OVRD(value)))
#define RSIM_BWR_CONTROL_GASKET_BYPASS_OVRD(base, value) (BME_BFI32(&RSIM_CONTROL_REG(base), ((uint32_t)(value) << RSIM_CONTROL_GASKET_BYPASS_OVRD_SHIFT), RSIM_CONTROL_GASKET_BYPASS_OVRD_SHIFT, RSIM_CONTROL_GASKET_BYPASS_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_CONTROL, field RF_OSC_BYPASS_EN[14] (RW)
 *
 * This bit engages the RF Ref Osc analog bypass circuit if the RF Ref Osc is
 * enabled. When the RF Ref Osc is in bypass mode it passes the EXTAL clock as the
 * RF Ref Osc clock. Note that the RF Ref Osc Ready signal is always asserted in
 * RF Ref Osc Bypass mode, unless overridden with the RF_OSC_READY_OVRD_EN bit.
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_RF_OSC_BYPASS_EN field. */
#define RSIM_RD_CONTROL_RF_OSC_BYPASS_EN(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_RF_OSC_BYPASS_EN_MASK) >> RSIM_CONTROL_RF_OSC_BYPASS_EN_SHIFT)
#define RSIM_BRD_CONTROL_RF_OSC_BYPASS_EN(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_RF_OSC_BYPASS_EN_SHIFT, RSIM_CONTROL_RF_OSC_BYPASS_EN_WIDTH))

/*! @brief Set the RF_OSC_BYPASS_EN field to a new value. */
#define RSIM_WR_CONTROL_RF_OSC_BYPASS_EN(base, value) (RSIM_RMW_CONTROL(base, (RSIM_CONTROL_RF_OSC_BYPASS_EN_MASK | RSIM_CONTROL_BLE_RF_OSC_REQ_INT_MASK), RSIM_CONTROL_RF_OSC_BYPASS_EN(value)))
#define RSIM_BWR_CONTROL_RF_OSC_BYPASS_EN(base, value) (BME_BFI32(&RSIM_CONTROL_REG(base), ((uint32_t)(value) << RSIM_CONTROL_RF_OSC_BYPASS_EN_SHIFT), RSIM_CONTROL_RF_OSC_BYPASS_EN_SHIFT, RSIM_CONTROL_RF_OSC_BYPASS_EN_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_CONTROL, field BLE_ACTIVE_PORT_1_SEL[16] (RW)
 *
 * This bit enables the Output Driver (OBE) on the SoC port 1 that provides the
 * BLE Active signal as a pad interface option.
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_BLE_ACTIVE_PORT_1_SEL field. */
#define RSIM_RD_CONTROL_BLE_ACTIVE_PORT_1_SEL(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_BLE_ACTIVE_PORT_1_SEL_MASK) >> RSIM_CONTROL_BLE_ACTIVE_PORT_1_SEL_SHIFT)
#define RSIM_BRD_CONTROL_BLE_ACTIVE_PORT_1_SEL(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_BLE_ACTIVE_PORT_1_SEL_SHIFT, RSIM_CONTROL_BLE_ACTIVE_PORT_1_SEL_WIDTH))

/*! @brief Set the BLE_ACTIVE_PORT_1_SEL field to a new value. */
#define RSIM_WR_CONTROL_BLE_ACTIVE_PORT_1_SEL(base, value) (RSIM_RMW_CONTROL(base, (RSIM_CONTROL_BLE_ACTIVE_PORT_1_SEL_MASK | RSIM_CONTROL_BLE_RF_OSC_REQ_INT_MASK), RSIM_CONTROL_BLE_ACTIVE_PORT_1_SEL(value)))
#define RSIM_BWR_CONTROL_BLE_ACTIVE_PORT_1_SEL(base, value) (BME_BFI32(&RSIM_CONTROL_REG(base), ((uint32_t)(value) << RSIM_CONTROL_BLE_ACTIVE_PORT_1_SEL_SHIFT), RSIM_CONTROL_BLE_ACTIVE_PORT_1_SEL_SHIFT, RSIM_CONTROL_BLE_ACTIVE_PORT_1_SEL_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_CONTROL, field BLE_ACTIVE_PORT_2_SEL[17] (RW)
 *
 * This bit enables the Output Driver (OBE) on the SoC port 2 that provides the
 * BLE Active signal as a pad interface option.
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_BLE_ACTIVE_PORT_2_SEL field. */
#define RSIM_RD_CONTROL_BLE_ACTIVE_PORT_2_SEL(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_BLE_ACTIVE_PORT_2_SEL_MASK) >> RSIM_CONTROL_BLE_ACTIVE_PORT_2_SEL_SHIFT)
#define RSIM_BRD_CONTROL_BLE_ACTIVE_PORT_2_SEL(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_BLE_ACTIVE_PORT_2_SEL_SHIFT, RSIM_CONTROL_BLE_ACTIVE_PORT_2_SEL_WIDTH))

/*! @brief Set the BLE_ACTIVE_PORT_2_SEL field to a new value. */
#define RSIM_WR_CONTROL_BLE_ACTIVE_PORT_2_SEL(base, value) (RSIM_RMW_CONTROL(base, (RSIM_CONTROL_BLE_ACTIVE_PORT_2_SEL_MASK | RSIM_CONTROL_BLE_RF_OSC_REQ_INT_MASK), RSIM_CONTROL_BLE_ACTIVE_PORT_2_SEL(value)))
#define RSIM_BWR_CONTROL_BLE_ACTIVE_PORT_2_SEL(base, value) (BME_BFI32(&RSIM_CONTROL_REG(base), ((uint32_t)(value) << RSIM_CONTROL_BLE_ACTIVE_PORT_2_SEL_SHIFT), RSIM_CONTROL_BLE_ACTIVE_PORT_2_SEL_SHIFT, RSIM_CONTROL_BLE_ACTIVE_PORT_2_SEL_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_CONTROL, field BLE_DEEP_SLEEP_EXIT[20] (RW)
 *
 * This bit forces the BLE link layer to wakeup from Deep Sleep Mode.
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_BLE_DEEP_SLEEP_EXIT field. */
#define RSIM_RD_CONTROL_BLE_DEEP_SLEEP_EXIT(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_BLE_DEEP_SLEEP_EXIT_MASK) >> RSIM_CONTROL_BLE_DEEP_SLEEP_EXIT_SHIFT)
#define RSIM_BRD_CONTROL_BLE_DEEP_SLEEP_EXIT(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_BLE_DEEP_SLEEP_EXIT_SHIFT, RSIM_CONTROL_BLE_DEEP_SLEEP_EXIT_WIDTH))

/*! @brief Set the BLE_DEEP_SLEEP_EXIT field to a new value. */
#define RSIM_WR_CONTROL_BLE_DEEP_SLEEP_EXIT(base, value) (RSIM_RMW_CONTROL(base, (RSIM_CONTROL_BLE_DEEP_SLEEP_EXIT_MASK | RSIM_CONTROL_BLE_RF_OSC_REQ_INT_MASK), RSIM_CONTROL_BLE_DEEP_SLEEP_EXIT(value)))
#define RSIM_BWR_CONTROL_BLE_DEEP_SLEEP_EXIT(base, value) (BME_BFI32(&RSIM_CONTROL_REG(base), ((uint32_t)(value) << RSIM_CONTROL_BLE_DEEP_SLEEP_EXIT_SHIFT), RSIM_CONTROL_BLE_DEEP_SLEEP_EXIT_SHIFT, RSIM_CONTROL_BLE_DEEP_SLEEP_EXIT_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_CONTROL, field STOP_ACK_OVRD_EN[22] (RW)
 *
 * This bit enables an override of the Stop Acknowledge signal. If not
 * overwritten, Radio Stop Acknowledge is nominally based on the enabled version of the
 * BLE Ref Osc (Sysclk) Request. The following table shows the state of the nominal
 * Radio Stop Acknowledge signal as presented to the SoC Core Platform BLE Ref
 * Osc (Sysclk) Request Enable BLE Ref Osc (Sysclk) Request Radio Stop Acknowledge
 * to SoC 1 0 1 1 1 0 0 x 1
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_STOP_ACK_OVRD_EN field. */
#define RSIM_RD_CONTROL_STOP_ACK_OVRD_EN(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_STOP_ACK_OVRD_EN_MASK) >> RSIM_CONTROL_STOP_ACK_OVRD_EN_SHIFT)
#define RSIM_BRD_CONTROL_STOP_ACK_OVRD_EN(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_STOP_ACK_OVRD_EN_SHIFT, RSIM_CONTROL_STOP_ACK_OVRD_EN_WIDTH))

/*! @brief Set the STOP_ACK_OVRD_EN field to a new value. */
#define RSIM_WR_CONTROL_STOP_ACK_OVRD_EN(base, value) (RSIM_RMW_CONTROL(base, (RSIM_CONTROL_STOP_ACK_OVRD_EN_MASK | RSIM_CONTROL_BLE_RF_OSC_REQ_INT_MASK), RSIM_CONTROL_STOP_ACK_OVRD_EN(value)))
#define RSIM_BWR_CONTROL_STOP_ACK_OVRD_EN(base, value) (BME_BFI32(&RSIM_CONTROL_REG(base), ((uint32_t)(value) << RSIM_CONTROL_STOP_ACK_OVRD_EN_SHIFT), RSIM_CONTROL_STOP_ACK_OVRD_EN_SHIFT, RSIM_CONTROL_STOP_ACK_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_CONTROL, field STOP_ACK_OVRD[23] (RW)
 *
 * This bit controls the Stop Acknowledge signal to the SoC Core Platform in
 * Override mode.
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_STOP_ACK_OVRD field. */
#define RSIM_RD_CONTROL_STOP_ACK_OVRD(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_STOP_ACK_OVRD_MASK) >> RSIM_CONTROL_STOP_ACK_OVRD_SHIFT)
#define RSIM_BRD_CONTROL_STOP_ACK_OVRD(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_STOP_ACK_OVRD_SHIFT, RSIM_CONTROL_STOP_ACK_OVRD_WIDTH))

/*! @brief Set the STOP_ACK_OVRD field to a new value. */
#define RSIM_WR_CONTROL_STOP_ACK_OVRD(base, value) (RSIM_RMW_CONTROL(base, (RSIM_CONTROL_STOP_ACK_OVRD_MASK | RSIM_CONTROL_BLE_RF_OSC_REQ_INT_MASK), RSIM_CONTROL_STOP_ACK_OVRD(value)))
#define RSIM_BWR_CONTROL_STOP_ACK_OVRD(base, value) (BME_BFI32(&RSIM_CONTROL_REG(base), ((uint32_t)(value) << RSIM_CONTROL_STOP_ACK_OVRD_SHIFT), RSIM_CONTROL_STOP_ACK_OVRD_SHIFT, RSIM_CONTROL_STOP_ACK_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_CONTROL, field RF_OSC_READY[24] (RO)
 *
 * The RF Reference Oscillator has an internal counter that gates off the RF Ref
 * Osc clock until the selected count is reached. This bit shows the status of
 * the RF Ref Osc ready signal that comes from that counter, except in RF Ref Osc
 * Bypass Mode. In RF Ref Osc Bypass Mode this bit will always be asserted, but
 * the signals that are derived from the RF Ref Osc Ready signal can be overridden
 * using the RF_OSC_READY_OVRD bit
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_RF_OSC_READY field. */
#define RSIM_RD_CONTROL_RF_OSC_READY(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_RF_OSC_READY_MASK) >> RSIM_CONTROL_RF_OSC_READY_SHIFT)
#define RSIM_BRD_CONTROL_RF_OSC_READY(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_RF_OSC_READY_SHIFT, RSIM_CONTROL_RF_OSC_READY_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_CONTROL, field RF_OSC_READY_OVRD_EN[25] (RW)
 *
 * This bit enables the RF Ref Osc Ready Override bit.
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_RF_OSC_READY_OVRD_EN field. */
#define RSIM_RD_CONTROL_RF_OSC_READY_OVRD_EN(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_RF_OSC_READY_OVRD_EN_MASK) >> RSIM_CONTROL_RF_OSC_READY_OVRD_EN_SHIFT)
#define RSIM_BRD_CONTROL_RF_OSC_READY_OVRD_EN(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_RF_OSC_READY_OVRD_EN_SHIFT, RSIM_CONTROL_RF_OSC_READY_OVRD_EN_WIDTH))

/*! @brief Set the RF_OSC_READY_OVRD_EN field to a new value. */
#define RSIM_WR_CONTROL_RF_OSC_READY_OVRD_EN(base, value) (RSIM_RMW_CONTROL(base, (RSIM_CONTROL_RF_OSC_READY_OVRD_EN_MASK | RSIM_CONTROL_BLE_RF_OSC_REQ_INT_MASK), RSIM_CONTROL_RF_OSC_READY_OVRD_EN(value)))
#define RSIM_BWR_CONTROL_RF_OSC_READY_OVRD_EN(base, value) (BME_BFI32(&RSIM_CONTROL_REG(base), ((uint32_t)(value) << RSIM_CONTROL_RF_OSC_READY_OVRD_EN_SHIFT), RSIM_CONTROL_RF_OSC_READY_OVRD_EN_SHIFT, RSIM_CONTROL_RF_OSC_READY_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_CONTROL, field RF_OSC_READY_OVRD[26] (RW)
 *
 * This bit directly controls the Radio RF Ref Osc Ready signal when the RF Ref
 * Osc Ready Override is enabled. All Radio and SoC signals that are derived from
 * the RF Ref Osc Ready signal can be overridden using this bit.
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_RF_OSC_READY_OVRD field. */
#define RSIM_RD_CONTROL_RF_OSC_READY_OVRD(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_RF_OSC_READY_OVRD_MASK) >> RSIM_CONTROL_RF_OSC_READY_OVRD_SHIFT)
#define RSIM_BRD_CONTROL_RF_OSC_READY_OVRD(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_RF_OSC_READY_OVRD_SHIFT, RSIM_CONTROL_RF_OSC_READY_OVRD_WIDTH))

/*! @brief Set the RF_OSC_READY_OVRD field to a new value. */
#define RSIM_WR_CONTROL_RF_OSC_READY_OVRD(base, value) (RSIM_RMW_CONTROL(base, (RSIM_CONTROL_RF_OSC_READY_OVRD_MASK | RSIM_CONTROL_BLE_RF_OSC_REQ_INT_MASK), RSIM_CONTROL_RF_OSC_READY_OVRD(value)))
#define RSIM_BWR_CONTROL_RF_OSC_READY_OVRD(base, value) (BME_BFI32(&RSIM_CONTROL_REG(base), ((uint32_t)(value) << RSIM_CONTROL_RF_OSC_READY_OVRD_SHIFT), RSIM_CONTROL_RF_OSC_READY_OVRD_SHIFT, RSIM_CONTROL_RF_OSC_READY_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_CONTROL, field BLOCK_RADIO_RESETS[28] (RW)
 *
 * This bit resets on POR only. This bit is intended to allow the SoC to perform
 * concurrent testing of various SoC logic while the Radio is operating
 * independently. Any SoC resets will be blocked and the Radio will not be affected by
 * them when this bit is set.
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_BLOCK_RADIO_RESETS field. */
#define RSIM_RD_CONTROL_BLOCK_RADIO_RESETS(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_BLOCK_RADIO_RESETS_MASK) >> RSIM_CONTROL_BLOCK_RADIO_RESETS_SHIFT)
#define RSIM_BRD_CONTROL_BLOCK_RADIO_RESETS(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_BLOCK_RADIO_RESETS_SHIFT, RSIM_CONTROL_BLOCK_RADIO_RESETS_WIDTH))

/*! @brief Set the BLOCK_RADIO_RESETS field to a new value. */
#define RSIM_WR_CONTROL_BLOCK_RADIO_RESETS(base, value) (RSIM_RMW_CONTROL(base, (RSIM_CONTROL_BLOCK_RADIO_RESETS_MASK | RSIM_CONTROL_BLE_RF_OSC_REQ_INT_MASK), RSIM_CONTROL_BLOCK_RADIO_RESETS(value)))
#define RSIM_BWR_CONTROL_BLOCK_RADIO_RESETS(base, value) (BME_BFI32(&RSIM_CONTROL_REG(base), ((uint32_t)(value) << RSIM_CONTROL_BLOCK_RADIO_RESETS_SHIFT), RSIM_CONTROL_BLOCK_RADIO_RESETS_SHIFT, RSIM_CONTROL_BLOCK_RADIO_RESETS_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_CONTROL, field BLOCK_RADIO_OUTPUTS[29] (RW)
 *
 * This bit resets on POR only. This bit is intended to allow the SoC to perform
 * concurrent testing of various SoC logic while the Radio is operating
 * independently. Any Radio output signals that go to the SoC will be blocked so as to
 * not affect the SoC testing when this bit is set.
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_BLOCK_RADIO_OUTPUTS field. */
#define RSIM_RD_CONTROL_BLOCK_RADIO_OUTPUTS(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_BLOCK_RADIO_OUTPUTS_MASK) >> RSIM_CONTROL_BLOCK_RADIO_OUTPUTS_SHIFT)
#define RSIM_BRD_CONTROL_BLOCK_RADIO_OUTPUTS(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_BLOCK_RADIO_OUTPUTS_SHIFT, RSIM_CONTROL_BLOCK_RADIO_OUTPUTS_WIDTH))

/*! @brief Set the BLOCK_RADIO_OUTPUTS field to a new value. */
#define RSIM_WR_CONTROL_BLOCK_RADIO_OUTPUTS(base, value) (RSIM_RMW_CONTROL(base, (RSIM_CONTROL_BLOCK_RADIO_OUTPUTS_MASK | RSIM_CONTROL_BLE_RF_OSC_REQ_INT_MASK), RSIM_CONTROL_BLOCK_RADIO_OUTPUTS(value)))
#define RSIM_BWR_CONTROL_BLOCK_RADIO_OUTPUTS(base, value) (BME_BFI32(&RSIM_CONTROL_REG(base), ((uint32_t)(value) << RSIM_CONTROL_BLOCK_RADIO_OUTPUTS_SHIFT), RSIM_CONTROL_BLOCK_RADIO_OUTPUTS_SHIFT, RSIM_CONTROL_BLOCK_RADIO_OUTPUTS_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_CONTROL, field RADIO_RESET[31] (RW)
 *
 * This bit resets on POR only. When the Radio Resets are Blocked, setting this
 * bit will reset all the radio logic until this bit is cleared. Note that due to
 * internal Radio Reset Exit synchronizing logic there must be a second access
 * to an RSIM register to clear this software reset, so please write this bit to 0
 * twice when clearing it.
 */
/*@{*/
/*! @brief Read current value of the RSIM_CONTROL_RADIO_RESET field. */
#define RSIM_RD_CONTROL_RADIO_RESET(base) ((RSIM_CONTROL_REG(base) & RSIM_CONTROL_RADIO_RESET_MASK) >> RSIM_CONTROL_RADIO_RESET_SHIFT)
#define RSIM_BRD_CONTROL_RADIO_RESET(base) (BME_UBFX32(&RSIM_CONTROL_REG(base), RSIM_CONTROL_RADIO_RESET_SHIFT, RSIM_CONTROL_RADIO_RESET_WIDTH))

/*! @brief Set the RADIO_RESET field to a new value. */
#define RSIM_WR_CONTROL_RADIO_RESET(base, value) (RSIM_RMW_CONTROL(base, (RSIM_CONTROL_RADIO_RESET_MASK | RSIM_CONTROL_BLE_RF_OSC_REQ_INT_MASK), RSIM_CONTROL_RADIO_RESET(value)))
#define RSIM_BWR_CONTROL_RADIO_RESET(base, value) (BME_BFI32(&RSIM_CONTROL_REG(base), ((uint32_t)(value) << RSIM_CONTROL_RADIO_RESET_SHIFT), RSIM_CONTROL_RADIO_RESET_SHIFT, RSIM_CONTROL_RADIO_RESET_WIDTH))
/*@}*/

/*******************************************************************************
 * RSIM_ACTIVE_DELAY - RSIM BLE Active Delay
 ******************************************************************************/

/*!
 * @brief RSIM_ACTIVE_DELAY - RSIM BLE Active Delay (RW)
 *
 * Reset value: 0x00000000U
 *
 * The RSIM BLE Active Delay register provides control bits to adjust the delay
 * of the BLE Active signal that is presented to the SoC Flash System.
 */
/*!
 * @name Constants and macros for entire RSIM_ACTIVE_DELAY register
 */
/*@{*/
#define RSIM_RD_ACTIVE_DELAY(base) (RSIM_ACTIVE_DELAY_REG(base))
#define RSIM_WR_ACTIVE_DELAY(base, value) (RSIM_ACTIVE_DELAY_REG(base) = (value))
#define RSIM_RMW_ACTIVE_DELAY(base, mask, value) (RSIM_WR_ACTIVE_DELAY(base, (RSIM_RD_ACTIVE_DELAY(base) & ~(mask)) | (value)))
#define RSIM_SET_ACTIVE_DELAY(base, value) (BME_OR32(&RSIM_ACTIVE_DELAY_REG(base), (uint32_t)(value)))
#define RSIM_CLR_ACTIVE_DELAY(base, value) (BME_AND32(&RSIM_ACTIVE_DELAY_REG(base), (uint32_t)(~(value))))
#define RSIM_TOG_ACTIVE_DELAY(base, value) (BME_XOR32(&RSIM_ACTIVE_DELAY_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RSIM_ACTIVE_DELAY bitfields
 */

/*!
 * @name Register RSIM_ACTIVE_DELAY, field BLE_ACTIVE_FINE_DELAY[5:0] (RW)
 *
 * The SoC Flash is presented with a BLE Active early warning signal to allow
 * the Flash to complete any program or erase activities prior to a Radio
 * communication event. This warning signal is delayed from the BLE Active signal provided
 * by the BLE link layer. The amount of the delay from the BLE link layer is
 * calculated as follows: BLE Active link layer delay - ( BLE Active Flash Fine
 * Delay x 32 kHz clock period x 4 ) - ( BLE Active Flash Coarse Delay x 32 kHz clock
 * period x 64 )
 */
/*@{*/
/*! @brief Read current value of the RSIM_ACTIVE_DELAY_BLE_ACTIVE_FINE_DELAY field. */
#define RSIM_RD_ACTIVE_DELAY_BLE_ACTIVE_FINE_DELAY(base) ((RSIM_ACTIVE_DELAY_REG(base) & RSIM_ACTIVE_DELAY_BLE_ACTIVE_FINE_DELAY_MASK) >> RSIM_ACTIVE_DELAY_BLE_ACTIVE_FINE_DELAY_SHIFT)
#define RSIM_BRD_ACTIVE_DELAY_BLE_ACTIVE_FINE_DELAY(base) (BME_UBFX32(&RSIM_ACTIVE_DELAY_REG(base), RSIM_ACTIVE_DELAY_BLE_ACTIVE_FINE_DELAY_SHIFT, RSIM_ACTIVE_DELAY_BLE_ACTIVE_FINE_DELAY_WIDTH))

/*! @brief Set the BLE_ACTIVE_FINE_DELAY field to a new value. */
#define RSIM_WR_ACTIVE_DELAY_BLE_ACTIVE_FINE_DELAY(base, value) (RSIM_RMW_ACTIVE_DELAY(base, RSIM_ACTIVE_DELAY_BLE_ACTIVE_FINE_DELAY_MASK, RSIM_ACTIVE_DELAY_BLE_ACTIVE_FINE_DELAY(value)))
#define RSIM_BWR_ACTIVE_DELAY_BLE_ACTIVE_FINE_DELAY(base, value) (BME_BFI32(&RSIM_ACTIVE_DELAY_REG(base), ((uint32_t)(value) << RSIM_ACTIVE_DELAY_BLE_ACTIVE_FINE_DELAY_SHIFT), RSIM_ACTIVE_DELAY_BLE_ACTIVE_FINE_DELAY_SHIFT, RSIM_ACTIVE_DELAY_BLE_ACTIVE_FINE_DELAY_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_ACTIVE_DELAY, field BLE_ACTIVE_COARSE_DELAY[19:16] (RW)
 *
 * The SoC Flash is presented with a BLE Active early warning signal to allow
 * the Flash to complete any program or erase activities prior to a Radio
 * communication event. This warning signal is delayed from the BLE Active signal provided
 * by the BLE link layer. The timing of the Flash delay is calculated as
 * follows: BLE Active link layer delay - ( BLE Active Flash Fine Delay x 32 kHz clock
 * period x 4 ) - ( BLE Active Flash Coarse Delay x 32 kHz clock period x 64 )
 */
/*@{*/
/*! @brief Read current value of the RSIM_ACTIVE_DELAY_BLE_ACTIVE_COARSE_DELAY field. */
#define RSIM_RD_ACTIVE_DELAY_BLE_ACTIVE_COARSE_DELAY(base) ((RSIM_ACTIVE_DELAY_REG(base) & RSIM_ACTIVE_DELAY_BLE_ACTIVE_COARSE_DELAY_MASK) >> RSIM_ACTIVE_DELAY_BLE_ACTIVE_COARSE_DELAY_SHIFT)
#define RSIM_BRD_ACTIVE_DELAY_BLE_ACTIVE_COARSE_DELAY(base) (BME_UBFX32(&RSIM_ACTIVE_DELAY_REG(base), RSIM_ACTIVE_DELAY_BLE_ACTIVE_COARSE_DELAY_SHIFT, RSIM_ACTIVE_DELAY_BLE_ACTIVE_COARSE_DELAY_WIDTH))

/*! @brief Set the BLE_ACTIVE_COARSE_DELAY field to a new value. */
#define RSIM_WR_ACTIVE_DELAY_BLE_ACTIVE_COARSE_DELAY(base, value) (RSIM_RMW_ACTIVE_DELAY(base, RSIM_ACTIVE_DELAY_BLE_ACTIVE_COARSE_DELAY_MASK, RSIM_ACTIVE_DELAY_BLE_ACTIVE_COARSE_DELAY(value)))
#define RSIM_BWR_ACTIVE_DELAY_BLE_ACTIVE_COARSE_DELAY(base, value) (BME_BFI32(&RSIM_ACTIVE_DELAY_REG(base), ((uint32_t)(value) << RSIM_ACTIVE_DELAY_BLE_ACTIVE_COARSE_DELAY_SHIFT), RSIM_ACTIVE_DELAY_BLE_ACTIVE_COARSE_DELAY_SHIFT, RSIM_ACTIVE_DELAY_BLE_ACTIVE_COARSE_DELAY_WIDTH))
/*@}*/

/*******************************************************************************
 * RSIM_MAC_MSB - RSIM MAC MSB
 ******************************************************************************/

/*!
 * @brief RSIM_MAC_MSB - RSIM MAC MSB (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RSIM MAC Address registers provide a unique ID that is stored in the
 * Flash during factory test
 */
/*!
 * @name Constants and macros for entire RSIM_MAC_MSB register
 */
/*@{*/
#define RSIM_RD_MAC_MSB(base)    (RSIM_MAC_MSB_REG(base))
/*@}*/

/*
 * Constants & macros for individual RSIM_MAC_MSB bitfields
 */

/*!
 * @name Register RSIM_MAC_MSB, field MAC_ADDR_MSB[7:0] (RO)
 *
 * The RSIM MAC Address is loaded from the Flash IFR during the SoC Power on
 * Reset sequence. The MAC Address is a unique ID that is stored in the Flash during
 * factory test.
 */
/*@{*/
/*! @brief Read current value of the RSIM_MAC_MSB_MAC_ADDR_MSB field. */
#define RSIM_RD_MAC_MSB_MAC_ADDR_MSB(base) ((RSIM_MAC_MSB_REG(base) & RSIM_MAC_MSB_MAC_ADDR_MSB_MASK) >> RSIM_MAC_MSB_MAC_ADDR_MSB_SHIFT)
#define RSIM_BRD_MAC_MSB_MAC_ADDR_MSB(base) (BME_UBFX32(&RSIM_MAC_MSB_REG(base), RSIM_MAC_MSB_MAC_ADDR_MSB_SHIFT, RSIM_MAC_MSB_MAC_ADDR_MSB_WIDTH))
/*@}*/

/*******************************************************************************
 * RSIM_MAC_LSB - RSIM MAC LSB
 ******************************************************************************/

/*!
 * @brief RSIM_MAC_LSB - RSIM MAC LSB (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RSIM MAC Address registers provide a unique ID that is stored in the
 * Flash during factory test
 */
/*!
 * @name Constants and macros for entire RSIM_MAC_LSB register
 */
/*@{*/
#define RSIM_RD_MAC_LSB(base)    (RSIM_MAC_LSB_REG(base))
/*@}*/

/*******************************************************************************
 * RSIM_ANA_TEST - RSIM Analog Test
 ******************************************************************************/

/*!
 * @brief RSIM_ANA_TEST - RSIM Analog Test (RW)
 *
 * Reset value: 0x01000000U
 *
 * The RSIM Analog Test register provides controls for validation and factory
 * test of the RF Analog Circuits.
 */
/*!
 * @name Constants and macros for entire RSIM_ANA_TEST register
 */
/*@{*/
#define RSIM_RD_ANA_TEST(base)   (RSIM_ANA_TEST_REG(base))
#define RSIM_WR_ANA_TEST(base, value) (RSIM_ANA_TEST_REG(base) = (value))
#define RSIM_RMW_ANA_TEST(base, mask, value) (RSIM_WR_ANA_TEST(base, (RSIM_RD_ANA_TEST(base) & ~(mask)) | (value)))
#define RSIM_SET_ANA_TEST(base, value) (BME_OR32(&RSIM_ANA_TEST_REG(base), (uint32_t)(value)))
#define RSIM_CLR_ANA_TEST(base, value) (BME_AND32(&RSIM_ANA_TEST_REG(base), (uint32_t)(~(value))))
#define RSIM_TOG_ANA_TEST(base, value) (BME_XOR32(&RSIM_ANA_TEST_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RSIM_ANA_TEST bitfields
 */

/*!
 * @name Register RSIM_ANA_TEST, field ATST_GATE_EN[4:0] (RW)
 *
 * The RSIM Analog Transmission Gate Enables open up the transmissions gates in
 * the pads to allow testing of the Radio analog signals. Each bit opens up one
 * Analog Transmission gate in the padring.
 */
/*@{*/
/*! @brief Read current value of the RSIM_ANA_TEST_ATST_GATE_EN field. */
#define RSIM_RD_ANA_TEST_ATST_GATE_EN(base) ((RSIM_ANA_TEST_REG(base) & RSIM_ANA_TEST_ATST_GATE_EN_MASK) >> RSIM_ANA_TEST_ATST_GATE_EN_SHIFT)
#define RSIM_BRD_ANA_TEST_ATST_GATE_EN(base) (BME_UBFX32(&RSIM_ANA_TEST_REG(base), RSIM_ANA_TEST_ATST_GATE_EN_SHIFT, RSIM_ANA_TEST_ATST_GATE_EN_WIDTH))

/*! @brief Set the ATST_GATE_EN field to a new value. */
#define RSIM_WR_ANA_TEST_ATST_GATE_EN(base, value) (RSIM_RMW_ANA_TEST(base, RSIM_ANA_TEST_ATST_GATE_EN_MASK, RSIM_ANA_TEST_ATST_GATE_EN(value)))
#define RSIM_BWR_ANA_TEST_ATST_GATE_EN(base, value) (BME_BFI32(&RSIM_ANA_TEST_REG(base), ((uint32_t)(value) << RSIM_ANA_TEST_ATST_GATE_EN_SHIFT), RSIM_ANA_TEST_ATST_GATE_EN_SHIFT, RSIM_ANA_TEST_ATST_GATE_EN_WIDTH))
/*@}*/

/*!
 * @name Register RSIM_ANA_TEST, field RADIO_ID[27:24] (RO)
 *
 * This register value can be read to identify the Version of the Radio.
 *
 * Values:
 * - 0b0001 - Apache 1.0
 * - 0b0010 - Apache 2.0
 * - 0b0011 - 2.4 GHz Radio 2.0, Used by various SoC implementations
 */
/*@{*/
/*! @brief Read current value of the RSIM_ANA_TEST_RADIO_ID field. */
#define RSIM_RD_ANA_TEST_RADIO_ID(base) ((RSIM_ANA_TEST_REG(base) & RSIM_ANA_TEST_RADIO_ID_MASK) >> RSIM_ANA_TEST_RADIO_ID_SHIFT)
#define RSIM_BRD_ANA_TEST_RADIO_ID(base) (BME_UBFX32(&RSIM_ANA_TEST_REG(base), RSIM_ANA_TEST_RADIO_ID_SHIFT, RSIM_ANA_TEST_RADIO_ID_WIDTH))
/*@}*/

/*
 * MKW40Z4 RTC
 *
 * Secure Real Time Clock
 *
 * Registers defined in this header file:
 * - RTC_TSR - RTC Time Seconds Register
 * - RTC_TPR - RTC Time Prescaler Register
 * - RTC_TAR - RTC Time Alarm Register
 * - RTC_TCR - RTC Time Compensation Register
 * - RTC_CR - RTC Control Register
 * - RTC_SR - RTC Status Register
 * - RTC_LR - RTC Lock Register
 * - RTC_IER - RTC Interrupt Enable Register
 */

#define RTC_INSTANCE_COUNT (1U) /*!< Number of instances of the RTC module. */
#define RTC_IDX (0U) /*!< Instance number for RTC. */

/*******************************************************************************
 * RTC_TSR - RTC Time Seconds Register
 ******************************************************************************/

/*!
 * @brief RTC_TSR - RTC Time Seconds Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TSR register
 */
/*@{*/
#define RTC_RD_TSR(base)         (RTC_TSR_REG(base))
#define RTC_WR_TSR(base, value)  (RTC_TSR_REG(base) = (value))
#define RTC_RMW_TSR(base, mask, value) (RTC_WR_TSR(base, (RTC_RD_TSR(base) & ~(mask)) | (value)))
#define RTC_SET_TSR(base, value) (BME_OR32(&RTC_TSR_REG(base), (uint32_t)(value)))
#define RTC_CLR_TSR(base, value) (BME_AND32(&RTC_TSR_REG(base), (uint32_t)(~(value))))
#define RTC_TOG_TSR(base, value) (BME_XOR32(&RTC_TSR_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * RTC_TPR - RTC Time Prescaler Register
 ******************************************************************************/

/*!
 * @brief RTC_TPR - RTC Time Prescaler Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TPR register
 */
/*@{*/
#define RTC_RD_TPR(base)         (RTC_TPR_REG(base))
#define RTC_WR_TPR(base, value)  (RTC_TPR_REG(base) = (value))
#define RTC_RMW_TPR(base, mask, value) (RTC_WR_TPR(base, (RTC_RD_TPR(base) & ~(mask)) | (value)))
#define RTC_SET_TPR(base, value) (BME_OR32(&RTC_TPR_REG(base), (uint32_t)(value)))
#define RTC_CLR_TPR(base, value) (BME_AND32(&RTC_TPR_REG(base), (uint32_t)(~(value))))
#define RTC_TOG_TPR(base, value) (BME_XOR32(&RTC_TPR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_TPR bitfields
 */

/*!
 * @name Register RTC_TPR, field TPR[15:0] (RW)
 *
 * When the time counter is enabled, the TPR is read only and increments every
 * 32.768 kHz clock cycle. The time counter will read as zero when SR[TOF] or
 * SR[TIF] are set. When the time counter is disabled, the TPR can be read or
 * written. The TSR[TSR] increments when bit 14 of the TPR transitions from a logic one
 * to a logic zero.
 */
/*@{*/
/*! @brief Read current value of the RTC_TPR_TPR field. */
#define RTC_RD_TPR_TPR(base) ((RTC_TPR_REG(base) & RTC_TPR_TPR_MASK) >> RTC_TPR_TPR_SHIFT)
#define RTC_BRD_TPR_TPR(base) (BME_UBFX32(&RTC_TPR_REG(base), RTC_TPR_TPR_SHIFT, RTC_TPR_TPR_WIDTH))

/*! @brief Set the TPR field to a new value. */
#define RTC_WR_TPR_TPR(base, value) (RTC_RMW_TPR(base, RTC_TPR_TPR_MASK, RTC_TPR_TPR(value)))
#define RTC_BWR_TPR_TPR(base, value) (BME_BFI32(&RTC_TPR_REG(base), ((uint32_t)(value) << RTC_TPR_TPR_SHIFT), RTC_TPR_TPR_SHIFT, RTC_TPR_TPR_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_TAR - RTC Time Alarm Register
 ******************************************************************************/

/*!
 * @brief RTC_TAR - RTC Time Alarm Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TAR register
 */
/*@{*/
#define RTC_RD_TAR(base)         (RTC_TAR_REG(base))
#define RTC_WR_TAR(base, value)  (RTC_TAR_REG(base) = (value))
#define RTC_RMW_TAR(base, mask, value) (RTC_WR_TAR(base, (RTC_RD_TAR(base) & ~(mask)) | (value)))
#define RTC_SET_TAR(base, value) (BME_OR32(&RTC_TAR_REG(base), (uint32_t)(value)))
#define RTC_CLR_TAR(base, value) (BME_AND32(&RTC_TAR_REG(base), (uint32_t)(~(value))))
#define RTC_TOG_TAR(base, value) (BME_XOR32(&RTC_TAR_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * RTC_TCR - RTC Time Compensation Register
 ******************************************************************************/

/*!
 * @brief RTC_TCR - RTC Time Compensation Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TCR register
 */
/*@{*/
#define RTC_RD_TCR(base)         (RTC_TCR_REG(base))
#define RTC_WR_TCR(base, value)  (RTC_TCR_REG(base) = (value))
#define RTC_RMW_TCR(base, mask, value) (RTC_WR_TCR(base, (RTC_RD_TCR(base) & ~(mask)) | (value)))
#define RTC_SET_TCR(base, value) (BME_OR32(&RTC_TCR_REG(base), (uint32_t)(value)))
#define RTC_CLR_TCR(base, value) (BME_AND32(&RTC_TCR_REG(base), (uint32_t)(~(value))))
#define RTC_TOG_TCR(base, value) (BME_XOR32(&RTC_TCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_TCR bitfields
 */

/*!
 * @name Register RTC_TCR, field TCR[7:0] (RW)
 *
 * Configures the number of 32.768 kHz clock cycles in each second. This
 * register is double buffered and writes do not take affect until the end of the
 * current compensation interval.
 *
 * Values:
 * - 0b10000000 - Time Prescaler Register overflows every 32896 clock cycles.
 * - 0b11111111 - Time Prescaler Register overflows every 32769 clock cycles.
 * - 0b00000000 - Time Prescaler Register overflows every 32768 clock cycles.
 * - 0b00000001 - Time Prescaler Register overflows every 32767 clock cycles.
 * - 0b01111111 - Time Prescaler Register overflows every 32641 clock cycles.
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_TCR field. */
#define RTC_RD_TCR_TCR(base) ((RTC_TCR_REG(base) & RTC_TCR_TCR_MASK) >> RTC_TCR_TCR_SHIFT)
#define RTC_BRD_TCR_TCR(base) (BME_UBFX32(&RTC_TCR_REG(base), RTC_TCR_TCR_SHIFT, RTC_TCR_TCR_WIDTH))

/*! @brief Set the TCR field to a new value. */
#define RTC_WR_TCR_TCR(base, value) (RTC_RMW_TCR(base, RTC_TCR_TCR_MASK, RTC_TCR_TCR(value)))
#define RTC_BWR_TCR_TCR(base, value) (BME_BFI32(&RTC_TCR_REG(base), ((uint32_t)(value) << RTC_TCR_TCR_SHIFT), RTC_TCR_TCR_SHIFT, RTC_TCR_TCR_WIDTH))
/*@}*/

/*!
 * @name Register RTC_TCR, field CIR[15:8] (RW)
 *
 * Configures the compensation interval in seconds from 1 to 256 to control how
 * frequently the TCR should adjust the number of 32.768 kHz cycles in each
 * second. The value written should be one less than the number of seconds. For
 * example, write zero to configure for a compensation interval of one second. This
 * register is double buffered and writes do not take affect until the end of the
 * current compensation interval.
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_CIR field. */
#define RTC_RD_TCR_CIR(base) ((RTC_TCR_REG(base) & RTC_TCR_CIR_MASK) >> RTC_TCR_CIR_SHIFT)
#define RTC_BRD_TCR_CIR(base) (BME_UBFX32(&RTC_TCR_REG(base), RTC_TCR_CIR_SHIFT, RTC_TCR_CIR_WIDTH))

/*! @brief Set the CIR field to a new value. */
#define RTC_WR_TCR_CIR(base, value) (RTC_RMW_TCR(base, RTC_TCR_CIR_MASK, RTC_TCR_CIR(value)))
#define RTC_BWR_TCR_CIR(base, value) (BME_BFI32(&RTC_TCR_REG(base), ((uint32_t)(value) << RTC_TCR_CIR_SHIFT), RTC_TCR_CIR_SHIFT, RTC_TCR_CIR_WIDTH))
/*@}*/

/*!
 * @name Register RTC_TCR, field TCV[23:16] (RO)
 *
 * Current value used by the compensation logic for the present second interval.
 * Updated once a second if the CIC equals 0 with the contents of the TCR field.
 * If the CIC does not equal zero then it is loaded with zero (compensation is
 * not enabled for that second increment).
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_TCV field. */
#define RTC_RD_TCR_TCV(base) ((RTC_TCR_REG(base) & RTC_TCR_TCV_MASK) >> RTC_TCR_TCV_SHIFT)
#define RTC_BRD_TCR_TCV(base) (BME_UBFX32(&RTC_TCR_REG(base), RTC_TCR_TCV_SHIFT, RTC_TCR_TCV_WIDTH))
/*@}*/

/*!
 * @name Register RTC_TCR, field CIC[31:24] (RO)
 *
 * Current value of the compensation interval counter. If the compensation
 * interval counter equals zero then it is loaded with the contents of the CIR. If the
 * CIC does not equal zero then it is decremented once a second.
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_CIC field. */
#define RTC_RD_TCR_CIC(base) ((RTC_TCR_REG(base) & RTC_TCR_CIC_MASK) >> RTC_TCR_CIC_SHIFT)
#define RTC_BRD_TCR_CIC(base) (BME_UBFX32(&RTC_TCR_REG(base), RTC_TCR_CIC_SHIFT, RTC_TCR_CIC_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_CR - RTC Control Register
 ******************************************************************************/

/*!
 * @brief RTC_CR - RTC Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_CR register
 */
/*@{*/
#define RTC_RD_CR(base)          (RTC_CR_REG(base))
#define RTC_WR_CR(base, value)   (RTC_CR_REG(base) = (value))
#define RTC_RMW_CR(base, mask, value) (RTC_WR_CR(base, (RTC_RD_CR(base) & ~(mask)) | (value)))
#define RTC_SET_CR(base, value)  (BME_OR32(&RTC_CR_REG(base), (uint32_t)(value)))
#define RTC_CLR_CR(base, value)  (BME_AND32(&RTC_CR_REG(base), (uint32_t)(~(value))))
#define RTC_TOG_CR(base, value)  (BME_XOR32(&RTC_CR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_CR bitfields
 */

/*!
 * @name Register RTC_CR, field SWR[0] (RW)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Resets all RTC registers except for the SWR bit . The SWR bit is
 *     cleared by POR and by software explicitly clearing it.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SWR field. */
#define RTC_RD_CR_SWR(base)  ((RTC_CR_REG(base) & RTC_CR_SWR_MASK) >> RTC_CR_SWR_SHIFT)
#define RTC_BRD_CR_SWR(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_SWR_SHIFT, RTC_CR_SWR_WIDTH))

/*! @brief Set the SWR field to a new value. */
#define RTC_WR_CR_SWR(base, value) (RTC_RMW_CR(base, RTC_CR_SWR_MASK, RTC_CR_SWR(value)))
#define RTC_BWR_CR_SWR(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_SWR_SHIFT), RTC_CR_SWR_SHIFT, RTC_CR_SWR_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field WPE[1] (RW)
 *
 * The wakeup pin is optional and not available on all devices.
 *
 * Values:
 * - 0b0 - Wakeup pin is disabled.
 * - 0b1 - Wakeup pin is enabled and wakeup pin asserts if the RTC interrupt
 *     asserts or the wakeup pin is turned on.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_WPE field. */
#define RTC_RD_CR_WPE(base)  ((RTC_CR_REG(base) & RTC_CR_WPE_MASK) >> RTC_CR_WPE_SHIFT)
#define RTC_BRD_CR_WPE(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_WPE_SHIFT, RTC_CR_WPE_WIDTH))

/*! @brief Set the WPE field to a new value. */
#define RTC_WR_CR_WPE(base, value) (RTC_RMW_CR(base, RTC_CR_WPE_MASK, RTC_CR_WPE(value)))
#define RTC_BWR_CR_WPE(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_WPE_SHIFT), RTC_CR_WPE_SHIFT, RTC_CR_WPE_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field SUP[2] (RW)
 *
 * Values:
 * - 0b0 - Non-supervisor mode write accesses are not supported and generate a
 *     bus error.
 * - 0b1 - Non-supervisor mode write accesses are supported.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SUP field. */
#define RTC_RD_CR_SUP(base)  ((RTC_CR_REG(base) & RTC_CR_SUP_MASK) >> RTC_CR_SUP_SHIFT)
#define RTC_BRD_CR_SUP(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_SUP_SHIFT, RTC_CR_SUP_WIDTH))

/*! @brief Set the SUP field to a new value. */
#define RTC_WR_CR_SUP(base, value) (RTC_RMW_CR(base, RTC_CR_SUP_MASK, RTC_CR_SUP(value)))
#define RTC_BWR_CR_SUP(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_SUP_SHIFT), RTC_CR_SUP_SHIFT, RTC_CR_SUP_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field UM[3] (RW)
 *
 * Allows SR[TCE] to be written even when the Status Register is locked. When
 * set, the SR[TCE] can always be written if the SR[TIF] or SR[TOF] are set or if
 * the SR[TCE] is clear.
 *
 * Values:
 * - 0b0 - Registers cannot be written when locked.
 * - 0b1 - Registers can be written when locked under limited conditions.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_UM field. */
#define RTC_RD_CR_UM(base)   ((RTC_CR_REG(base) & RTC_CR_UM_MASK) >> RTC_CR_UM_SHIFT)
#define RTC_BRD_CR_UM(base)  (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_UM_SHIFT, RTC_CR_UM_WIDTH))

/*! @brief Set the UM field to a new value. */
#define RTC_WR_CR_UM(base, value) (RTC_RMW_CR(base, RTC_CR_UM_MASK, RTC_CR_UM(value)))
#define RTC_BWR_CR_UM(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_UM_SHIFT), RTC_CR_UM_SHIFT, RTC_CR_UM_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field WPS[4] (RW)
 *
 * The wakeup pin is optional and not available on all devices.
 *
 * Values:
 * - 0b0 - Wakeup pin asserts (active low, open drain) if the RTC interrupt
 *     asserts or the wakeup pin is turned on.
 * - 0b1 - Wakeup pin instead outputs the RTC 32kHz clock, provided the wakeup
 *     pin is turned on and the 32kHz clock is output to other peripherals.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_WPS field. */
#define RTC_RD_CR_WPS(base)  ((RTC_CR_REG(base) & RTC_CR_WPS_MASK) >> RTC_CR_WPS_SHIFT)
#define RTC_BRD_CR_WPS(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_WPS_SHIFT, RTC_CR_WPS_WIDTH))

/*! @brief Set the WPS field to a new value. */
#define RTC_WR_CR_WPS(base, value) (RTC_RMW_CR(base, RTC_CR_WPS_MASK, RTC_CR_WPS(value)))
#define RTC_BWR_CR_WPS(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_WPS_SHIFT), RTC_CR_WPS_SHIFT, RTC_CR_WPS_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field OSCE[8] (RW)
 *
 * Values:
 * - 0b0 - 32.768 kHz oscillator is disabled.
 * - 0b1 - 32.768 kHz oscillator is enabled. After setting this bit, wait the
 *     oscillator startup time before enabling the time counter to allow the 32.768
 *     kHz clock time to stabilize.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_OSCE field. */
#define RTC_RD_CR_OSCE(base) ((RTC_CR_REG(base) & RTC_CR_OSCE_MASK) >> RTC_CR_OSCE_SHIFT)
#define RTC_BRD_CR_OSCE(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_OSCE_SHIFT, RTC_CR_OSCE_WIDTH))

/*! @brief Set the OSCE field to a new value. */
#define RTC_WR_CR_OSCE(base, value) (RTC_RMW_CR(base, RTC_CR_OSCE_MASK, RTC_CR_OSCE(value)))
#define RTC_BWR_CR_OSCE(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_OSCE_SHIFT), RTC_CR_OSCE_SHIFT, RTC_CR_OSCE_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field CLKO[9] (RW)
 *
 * Values:
 * - 0b0 - The 32 kHz clock is output to other peripherals.
 * - 0b1 - The 32 kHz clock is not output to other peripherals.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_CLKO field. */
#define RTC_RD_CR_CLKO(base) ((RTC_CR_REG(base) & RTC_CR_CLKO_MASK) >> RTC_CR_CLKO_SHIFT)
#define RTC_BRD_CR_CLKO(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_CLKO_SHIFT, RTC_CR_CLKO_WIDTH))

/*! @brief Set the CLKO field to a new value. */
#define RTC_WR_CR_CLKO(base, value) (RTC_RMW_CR(base, RTC_CR_CLKO_MASK, RTC_CR_CLKO(value)))
#define RTC_BWR_CR_CLKO(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_CLKO_SHIFT), RTC_CR_CLKO_SHIFT, RTC_CR_CLKO_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field SC16P[10] (RW)
 *
 * Values:
 * - 0b0 - Disable the load.
 * - 0b1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC16P field. */
#define RTC_RD_CR_SC16P(base) ((RTC_CR_REG(base) & RTC_CR_SC16P_MASK) >> RTC_CR_SC16P_SHIFT)
#define RTC_BRD_CR_SC16P(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_SC16P_SHIFT, RTC_CR_SC16P_WIDTH))

/*! @brief Set the SC16P field to a new value. */
#define RTC_WR_CR_SC16P(base, value) (RTC_RMW_CR(base, RTC_CR_SC16P_MASK, RTC_CR_SC16P(value)))
#define RTC_BWR_CR_SC16P(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_SC16P_SHIFT), RTC_CR_SC16P_SHIFT, RTC_CR_SC16P_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field SC8P[11] (RW)
 *
 * Values:
 * - 0b0 - Disable the load.
 * - 0b1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC8P field. */
#define RTC_RD_CR_SC8P(base) ((RTC_CR_REG(base) & RTC_CR_SC8P_MASK) >> RTC_CR_SC8P_SHIFT)
#define RTC_BRD_CR_SC8P(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_SC8P_SHIFT, RTC_CR_SC8P_WIDTH))

/*! @brief Set the SC8P field to a new value. */
#define RTC_WR_CR_SC8P(base, value) (RTC_RMW_CR(base, RTC_CR_SC8P_MASK, RTC_CR_SC8P(value)))
#define RTC_BWR_CR_SC8P(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_SC8P_SHIFT), RTC_CR_SC8P_SHIFT, RTC_CR_SC8P_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field SC4P[12] (RW)
 *
 * Values:
 * - 0b0 - Disable the load.
 * - 0b1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC4P field. */
#define RTC_RD_CR_SC4P(base) ((RTC_CR_REG(base) & RTC_CR_SC4P_MASK) >> RTC_CR_SC4P_SHIFT)
#define RTC_BRD_CR_SC4P(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_SC4P_SHIFT, RTC_CR_SC4P_WIDTH))

/*! @brief Set the SC4P field to a new value. */
#define RTC_WR_CR_SC4P(base, value) (RTC_RMW_CR(base, RTC_CR_SC4P_MASK, RTC_CR_SC4P(value)))
#define RTC_BWR_CR_SC4P(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_SC4P_SHIFT), RTC_CR_SC4P_SHIFT, RTC_CR_SC4P_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field SC2P[13] (RW)
 *
 * Values:
 * - 0b0 - Disable the load.
 * - 0b1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC2P field. */
#define RTC_RD_CR_SC2P(base) ((RTC_CR_REG(base) & RTC_CR_SC2P_MASK) >> RTC_CR_SC2P_SHIFT)
#define RTC_BRD_CR_SC2P(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_SC2P_SHIFT, RTC_CR_SC2P_WIDTH))

/*! @brief Set the SC2P field to a new value. */
#define RTC_WR_CR_SC2P(base, value) (RTC_RMW_CR(base, RTC_CR_SC2P_MASK, RTC_CR_SC2P(value)))
#define RTC_BWR_CR_SC2P(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_SC2P_SHIFT), RTC_CR_SC2P_SHIFT, RTC_CR_SC2P_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_SR - RTC Status Register
 ******************************************************************************/

/*!
 * @brief RTC_SR - RTC Status Register (RW)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire RTC_SR register
 */
/*@{*/
#define RTC_RD_SR(base)          (RTC_SR_REG(base))
#define RTC_WR_SR(base, value)   (RTC_SR_REG(base) = (value))
#define RTC_RMW_SR(base, mask, value) (RTC_WR_SR(base, (RTC_RD_SR(base) & ~(mask)) | (value)))
#define RTC_SET_SR(base, value)  (BME_OR32(&RTC_SR_REG(base), (uint32_t)(value)))
#define RTC_CLR_SR(base, value)  (BME_AND32(&RTC_SR_REG(base), (uint32_t)(~(value))))
#define RTC_TOG_SR(base, value)  (BME_XOR32(&RTC_SR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_SR bitfields
 */

/*!
 * @name Register RTC_SR, field TIF[0] (RO)
 *
 * The time invalid flag is set on POR or software reset. The TSR and TPR do not
 * increment and read as zero when this bit is set. This bit is cleared by
 * writing the TSR register when the time counter is disabled.
 *
 * Values:
 * - 0b0 - Time is valid.
 * - 0b1 - Time is invalid and time counter is read as zero.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TIF field. */
#define RTC_RD_SR_TIF(base)  ((RTC_SR_REG(base) & RTC_SR_TIF_MASK) >> RTC_SR_TIF_SHIFT)
#define RTC_BRD_SR_TIF(base) (BME_UBFX32(&RTC_SR_REG(base), RTC_SR_TIF_SHIFT, RTC_SR_TIF_WIDTH))
/*@}*/

/*!
 * @name Register RTC_SR, field TOF[1] (RO)
 *
 * Time overflow flag is set when the time counter is enabled and overflows. The
 * TSR and TPR do not increment and read as zero when this bit is set. This bit
 * is cleared by writing the TSR register when the time counter is disabled.
 *
 * Values:
 * - 0b0 - Time overflow has not occurred.
 * - 0b1 - Time overflow has occurred and time counter is read as zero.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TOF field. */
#define RTC_RD_SR_TOF(base)  ((RTC_SR_REG(base) & RTC_SR_TOF_MASK) >> RTC_SR_TOF_SHIFT)
#define RTC_BRD_SR_TOF(base) (BME_UBFX32(&RTC_SR_REG(base), RTC_SR_TOF_SHIFT, RTC_SR_TOF_WIDTH))
/*@}*/

/*!
 * @name Register RTC_SR, field TAF[2] (RO)
 *
 * Time alarm flag is set when the TAR[TAR] equals the TSR[TSR] and the TSR[TSR]
 * increments. This bit is cleared by writing the TAR register.
 *
 * Values:
 * - 0b0 - Time alarm has not occurred.
 * - 0b1 - Time alarm has occurred.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TAF field. */
#define RTC_RD_SR_TAF(base)  ((RTC_SR_REG(base) & RTC_SR_TAF_MASK) >> RTC_SR_TAF_SHIFT)
#define RTC_BRD_SR_TAF(base) (BME_UBFX32(&RTC_SR_REG(base), RTC_SR_TAF_SHIFT, RTC_SR_TAF_WIDTH))
/*@}*/

/*!
 * @name Register RTC_SR, field TCE[4] (RW)
 *
 * When time counter is disabled the TSR register and TPR register are
 * writeable, but do not increment. When time counter is enabled the TSR register and TPR
 * register are not writeable, but increment.
 *
 * Values:
 * - 0b0 - Time counter is disabled.
 * - 0b1 - Time counter is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TCE field. */
#define RTC_RD_SR_TCE(base)  ((RTC_SR_REG(base) & RTC_SR_TCE_MASK) >> RTC_SR_TCE_SHIFT)
#define RTC_BRD_SR_TCE(base) (BME_UBFX32(&RTC_SR_REG(base), RTC_SR_TCE_SHIFT, RTC_SR_TCE_WIDTH))

/*! @brief Set the TCE field to a new value. */
#define RTC_WR_SR_TCE(base, value) (RTC_RMW_SR(base, RTC_SR_TCE_MASK, RTC_SR_TCE(value)))
#define RTC_BWR_SR_TCE(base, value) (BME_BFI32(&RTC_SR_REG(base), ((uint32_t)(value) << RTC_SR_TCE_SHIFT), RTC_SR_TCE_SHIFT, RTC_SR_TCE_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_LR - RTC Lock Register
 ******************************************************************************/

/*!
 * @brief RTC_LR - RTC Lock Register (RW)
 *
 * Reset value: 0x000000FFU
 */
/*!
 * @name Constants and macros for entire RTC_LR register
 */
/*@{*/
#define RTC_RD_LR(base)          (RTC_LR_REG(base))
#define RTC_WR_LR(base, value)   (RTC_LR_REG(base) = (value))
#define RTC_RMW_LR(base, mask, value) (RTC_WR_LR(base, (RTC_RD_LR(base) & ~(mask)) | (value)))
#define RTC_SET_LR(base, value)  (BME_OR32(&RTC_LR_REG(base), (uint32_t)(value)))
#define RTC_CLR_LR(base, value)  (BME_AND32(&RTC_LR_REG(base), (uint32_t)(~(value))))
#define RTC_TOG_LR(base, value)  (BME_XOR32(&RTC_LR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_LR bitfields
 */

/*!
 * @name Register RTC_LR, field TCL[3] (RW)
 *
 * After being cleared, this bit can be set only by POR or software reset.
 *
 * Values:
 * - 0b0 - Time Compensation Register is locked and writes are ignored.
 * - 0b1 - Time Compensation Register is not locked and writes complete as
 *     normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_TCL field. */
#define RTC_RD_LR_TCL(base)  ((RTC_LR_REG(base) & RTC_LR_TCL_MASK) >> RTC_LR_TCL_SHIFT)
#define RTC_BRD_LR_TCL(base) (BME_UBFX32(&RTC_LR_REG(base), RTC_LR_TCL_SHIFT, RTC_LR_TCL_WIDTH))

/*! @brief Set the TCL field to a new value. */
#define RTC_WR_LR_TCL(base, value) (RTC_RMW_LR(base, RTC_LR_TCL_MASK, RTC_LR_TCL(value)))
#define RTC_BWR_LR_TCL(base, value) (BME_BFI32(&RTC_LR_REG(base), ((uint32_t)(value) << RTC_LR_TCL_SHIFT), RTC_LR_TCL_SHIFT, RTC_LR_TCL_WIDTH))
/*@}*/

/*!
 * @name Register RTC_LR, field CRL[4] (RW)
 *
 * After being cleared, this bit can only be set by POR.
 *
 * Values:
 * - 0b0 - Control Register is locked and writes are ignored.
 * - 0b1 - Control Register is not locked and writes complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_CRL field. */
#define RTC_RD_LR_CRL(base)  ((RTC_LR_REG(base) & RTC_LR_CRL_MASK) >> RTC_LR_CRL_SHIFT)
#define RTC_BRD_LR_CRL(base) (BME_UBFX32(&RTC_LR_REG(base), RTC_LR_CRL_SHIFT, RTC_LR_CRL_WIDTH))

/*! @brief Set the CRL field to a new value. */
#define RTC_WR_LR_CRL(base, value) (RTC_RMW_LR(base, RTC_LR_CRL_MASK, RTC_LR_CRL(value)))
#define RTC_BWR_LR_CRL(base, value) (BME_BFI32(&RTC_LR_REG(base), ((uint32_t)(value) << RTC_LR_CRL_SHIFT), RTC_LR_CRL_SHIFT, RTC_LR_CRL_WIDTH))
/*@}*/

/*!
 * @name Register RTC_LR, field SRL[5] (RW)
 *
 * After being cleared, this bit can be set only by POR or software reset.
 *
 * Values:
 * - 0b0 - Status Register is locked and writes are ignored.
 * - 0b1 - Status Register is not locked and writes complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_SRL field. */
#define RTC_RD_LR_SRL(base)  ((RTC_LR_REG(base) & RTC_LR_SRL_MASK) >> RTC_LR_SRL_SHIFT)
#define RTC_BRD_LR_SRL(base) (BME_UBFX32(&RTC_LR_REG(base), RTC_LR_SRL_SHIFT, RTC_LR_SRL_WIDTH))

/*! @brief Set the SRL field to a new value. */
#define RTC_WR_LR_SRL(base, value) (RTC_RMW_LR(base, RTC_LR_SRL_MASK, RTC_LR_SRL(value)))
#define RTC_BWR_LR_SRL(base, value) (BME_BFI32(&RTC_LR_REG(base), ((uint32_t)(value) << RTC_LR_SRL_SHIFT), RTC_LR_SRL_SHIFT, RTC_LR_SRL_WIDTH))
/*@}*/

/*!
 * @name Register RTC_LR, field LRL[6] (RW)
 *
 * After being cleared, this bit can be set only by POR or software reset.
 *
 * Values:
 * - 0b0 - Lock Register is locked and writes are ignored.
 * - 0b1 - Lock Register is not locked and writes complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_LRL field. */
#define RTC_RD_LR_LRL(base)  ((RTC_LR_REG(base) & RTC_LR_LRL_MASK) >> RTC_LR_LRL_SHIFT)
#define RTC_BRD_LR_LRL(base) (BME_UBFX32(&RTC_LR_REG(base), RTC_LR_LRL_SHIFT, RTC_LR_LRL_WIDTH))

/*! @brief Set the LRL field to a new value. */
#define RTC_WR_LR_LRL(base, value) (RTC_RMW_LR(base, RTC_LR_LRL_MASK, RTC_LR_LRL(value)))
#define RTC_BWR_LR_LRL(base, value) (BME_BFI32(&RTC_LR_REG(base), ((uint32_t)(value) << RTC_LR_LRL_SHIFT), RTC_LR_LRL_SHIFT, RTC_LR_LRL_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_IER - RTC Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief RTC_IER - RTC Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000007U
 */
/*!
 * @name Constants and macros for entire RTC_IER register
 */
/*@{*/
#define RTC_RD_IER(base)         (RTC_IER_REG(base))
#define RTC_WR_IER(base, value)  (RTC_IER_REG(base) = (value))
#define RTC_RMW_IER(base, mask, value) (RTC_WR_IER(base, (RTC_RD_IER(base) & ~(mask)) | (value)))
#define RTC_SET_IER(base, value) (BME_OR32(&RTC_IER_REG(base), (uint32_t)(value)))
#define RTC_CLR_IER(base, value) (BME_AND32(&RTC_IER_REG(base), (uint32_t)(~(value))))
#define RTC_TOG_IER(base, value) (BME_XOR32(&RTC_IER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_IER bitfields
 */

/*!
 * @name Register RTC_IER, field TIIE[0] (RW)
 *
 * Values:
 * - 0b0 - Time invalid flag does not generate an interrupt.
 * - 0b1 - Time invalid flag does generate an interrupt.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TIIE field. */
#define RTC_RD_IER_TIIE(base) ((RTC_IER_REG(base) & RTC_IER_TIIE_MASK) >> RTC_IER_TIIE_SHIFT)
#define RTC_BRD_IER_TIIE(base) (BME_UBFX32(&RTC_IER_REG(base), RTC_IER_TIIE_SHIFT, RTC_IER_TIIE_WIDTH))

/*! @brief Set the TIIE field to a new value. */
#define RTC_WR_IER_TIIE(base, value) (RTC_RMW_IER(base, RTC_IER_TIIE_MASK, RTC_IER_TIIE(value)))
#define RTC_BWR_IER_TIIE(base, value) (BME_BFI32(&RTC_IER_REG(base), ((uint32_t)(value) << RTC_IER_TIIE_SHIFT), RTC_IER_TIIE_SHIFT, RTC_IER_TIIE_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field TOIE[1] (RW)
 *
 * Values:
 * - 0b0 - Time overflow flag does not generate an interrupt.
 * - 0b1 - Time overflow flag does generate an interrupt.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TOIE field. */
#define RTC_RD_IER_TOIE(base) ((RTC_IER_REG(base) & RTC_IER_TOIE_MASK) >> RTC_IER_TOIE_SHIFT)
#define RTC_BRD_IER_TOIE(base) (BME_UBFX32(&RTC_IER_REG(base), RTC_IER_TOIE_SHIFT, RTC_IER_TOIE_WIDTH))

/*! @brief Set the TOIE field to a new value. */
#define RTC_WR_IER_TOIE(base, value) (RTC_RMW_IER(base, RTC_IER_TOIE_MASK, RTC_IER_TOIE(value)))
#define RTC_BWR_IER_TOIE(base, value) (BME_BFI32(&RTC_IER_REG(base), ((uint32_t)(value) << RTC_IER_TOIE_SHIFT), RTC_IER_TOIE_SHIFT, RTC_IER_TOIE_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field TAIE[2] (RW)
 *
 * Values:
 * - 0b0 - Time alarm flag does not generate an interrupt.
 * - 0b1 - Time alarm flag does generate an interrupt.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TAIE field. */
#define RTC_RD_IER_TAIE(base) ((RTC_IER_REG(base) & RTC_IER_TAIE_MASK) >> RTC_IER_TAIE_SHIFT)
#define RTC_BRD_IER_TAIE(base) (BME_UBFX32(&RTC_IER_REG(base), RTC_IER_TAIE_SHIFT, RTC_IER_TAIE_WIDTH))

/*! @brief Set the TAIE field to a new value. */
#define RTC_WR_IER_TAIE(base, value) (RTC_RMW_IER(base, RTC_IER_TAIE_MASK, RTC_IER_TAIE(value)))
#define RTC_BWR_IER_TAIE(base, value) (BME_BFI32(&RTC_IER_REG(base), ((uint32_t)(value) << RTC_IER_TAIE_SHIFT), RTC_IER_TAIE_SHIFT, RTC_IER_TAIE_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field TSIE[4] (RW)
 *
 * The seconds interrupt is an edge-sensitive interrupt with a dedicated
 * interrupt vector. It is generated once a second and requires no software overhead
 * (there is no corresponding status flag to clear).
 *
 * Values:
 * - 0b0 - Seconds interrupt is disabled.
 * - 0b1 - Seconds interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TSIE field. */
#define RTC_RD_IER_TSIE(base) ((RTC_IER_REG(base) & RTC_IER_TSIE_MASK) >> RTC_IER_TSIE_SHIFT)
#define RTC_BRD_IER_TSIE(base) (BME_UBFX32(&RTC_IER_REG(base), RTC_IER_TSIE_SHIFT, RTC_IER_TSIE_WIDTH))

/*! @brief Set the TSIE field to a new value. */
#define RTC_WR_IER_TSIE(base, value) (RTC_RMW_IER(base, RTC_IER_TSIE_MASK, RTC_IER_TSIE(value)))
#define RTC_BWR_IER_TSIE(base, value) (BME_BFI32(&RTC_IER_REG(base), ((uint32_t)(value) << RTC_IER_TSIE_SHIFT), RTC_IER_TSIE_SHIFT, RTC_IER_TSIE_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field WPON[7] (RW)
 *
 * The wakeup pin is optional and not available on all devices. Whenever the
 * wakeup pin is enabled and this bit is set, the wakeup pin will assert.
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - If the wakeup pin is enabled, then the wakeup pin will assert.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_WPON field. */
#define RTC_RD_IER_WPON(base) ((RTC_IER_REG(base) & RTC_IER_WPON_MASK) >> RTC_IER_WPON_SHIFT)
#define RTC_BRD_IER_WPON(base) (BME_UBFX32(&RTC_IER_REG(base), RTC_IER_WPON_SHIFT, RTC_IER_WPON_WIDTH))

/*! @brief Set the WPON field to a new value. */
#define RTC_WR_IER_WPON(base, value) (RTC_RMW_IER(base, RTC_IER_WPON_MASK, RTC_IER_WPON(value)))
#define RTC_BWR_IER_WPON(base, value) (BME_BFI32(&RTC_IER_REG(base), ((uint32_t)(value) << RTC_IER_WPON_SHIFT), RTC_IER_WPON_SHIFT, RTC_IER_WPON_WIDTH))
/*@}*/

/*
 * MKW40Z4 SIM
 *
 * System Integration Module
 *
 * Registers defined in this header file:
 * - SIM_SOPT1 - System Options Register 1
 * - SIM_SOPT2 - System Options Register 2
 * - SIM_SOPT4 - System Options Register 4
 * - SIM_SOPT5 - System Options Register 5
 * - SIM_SOPT7 - System Options Register 7
 * - SIM_SDID - System Device Identification Register
 * - SIM_SCGC4 - System Clock Gating Control Register 4
 * - SIM_SCGC5 - System Clock Gating Control Register 5
 * - SIM_SCGC6 - System Clock Gating Control Register 6
 * - SIM_SCGC7 - System Clock Gating Control Register 7
 * - SIM_CLKDIV1 - System Clock Divider Register 1
 * - SIM_FCFG1 - Flash Configuration Register 1
 * - SIM_FCFG2 - Flash Configuration Register 2
 * - SIM_UIDMH - Unique Identification Register Mid-High
 * - SIM_UIDML - Unique Identification Register Mid Low
 * - SIM_UIDL - Unique Identification Register Low
 * - SIM_COPC - COP Control Register
 * - SIM_SRVCOP - Service COP
 */

#define SIM_INSTANCE_COUNT (1U) /*!< Number of instances of the SIM module. */
#define SIM_IDX (0U) /*!< Instance number for SIM. */

/*******************************************************************************
 * SIM_SOPT1 - System Options Register 1
 ******************************************************************************/

/*!
 * @brief SIM_SOPT1 - System Options Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SOPT1 register is only reset on POR or LVD. Reset value loaded during
 * System Reset from Flash IFR.
 */
/*!
 * @name Constants and macros for entire SIM_SOPT1 register
 */
/*@{*/
#define SIM_RD_SOPT1(base)       (SIM_SOPT1_REG(base))
#define SIM_WR_SOPT1(base, value) (SIM_SOPT1_REG(base) = (value))
#define SIM_RMW_SOPT1(base, mask, value) (SIM_WR_SOPT1(base, (SIM_RD_SOPT1(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT1(base, value) (BME_OR32(&SIM_SOPT1_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT1(base, value) (BME_AND32(&SIM_SOPT1_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT1(base, value) (BME_XOR32(&SIM_SOPT1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT1 bitfields
 */

/*!
 * @name Register SIM_SOPT1, field OSC32KOUT[17:16] (RW)
 *
 * Outputs the ERCLK32K on the selected pin in all modes of operation (including
 * LLS/VLLS and System Reset), overriding the existing pin mux configuration for
 * that pin. This field is reset only on POR/LVD.
 *
 * Values:
 * - 0b00 - ERCLK32K is not output.
 * - 0b01 - ERCLK32K is output on PTB3.
 * - 0b10 - Reserved.
 * - 0b11 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_OSC32KOUT field. */
#define SIM_RD_SOPT1_OSC32KOUT(base) ((SIM_SOPT1_REG(base) & SIM_SOPT1_OSC32KOUT_MASK) >> SIM_SOPT1_OSC32KOUT_SHIFT)
#define SIM_BRD_SOPT1_OSC32KOUT(base) (BME_UBFX32(&SIM_SOPT1_REG(base), SIM_SOPT1_OSC32KOUT_SHIFT, SIM_SOPT1_OSC32KOUT_WIDTH))

/*! @brief Set the OSC32KOUT field to a new value. */
#define SIM_WR_SOPT1_OSC32KOUT(base, value) (SIM_RMW_SOPT1(base, SIM_SOPT1_OSC32KOUT_MASK, SIM_SOPT1_OSC32KOUT(value)))
#define SIM_BWR_SOPT1_OSC32KOUT(base, value) (BME_BFI32(&SIM_SOPT1_REG(base), ((uint32_t)(value) << SIM_SOPT1_OSC32KOUT_SHIFT), SIM_SOPT1_OSC32KOUT_SHIFT, SIM_SOPT1_OSC32KOUT_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT1, field OSC32KSEL[19:18] (RW)
 *
 * Selects the 32 kHz clock source (ERCLK32K) for RTC and LPTMR. This field is
 * reset only on POR/LVD.
 *
 * Values:
 * - 0b00 - 32kHz oscillator (OSC32KCLK)
 * - 0b01 - Reserved
 * - 0b10 - RTC_CLKIN
 * - 0b11 - LPO 1kHz
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_OSC32KSEL field. */
#define SIM_RD_SOPT1_OSC32KSEL(base) ((SIM_SOPT1_REG(base) & SIM_SOPT1_OSC32KSEL_MASK) >> SIM_SOPT1_OSC32KSEL_SHIFT)
#define SIM_BRD_SOPT1_OSC32KSEL(base) (BME_UBFX32(&SIM_SOPT1_REG(base), SIM_SOPT1_OSC32KSEL_SHIFT, SIM_SOPT1_OSC32KSEL_WIDTH))

/*! @brief Set the OSC32KSEL field to a new value. */
#define SIM_WR_SOPT1_OSC32KSEL(base, value) (SIM_RMW_SOPT1(base, SIM_SOPT1_OSC32KSEL_MASK, SIM_SOPT1_OSC32KSEL(value)))
#define SIM_BWR_SOPT1_OSC32KSEL(base, value) (BME_BFI32(&SIM_SOPT1_REG(base), ((uint32_t)(value) << SIM_SOPT1_OSC32KSEL_SHIFT), SIM_SOPT1_OSC32KSEL_SHIFT, SIM_SOPT1_OSC32KSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SOPT2 - System Options Register 2
 ******************************************************************************/

/*!
 * @brief SIM_SOPT2 - System Options Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * SOPT2 contains the controls for selecting many of the module clock source
 * options on this device. See the Clock Distribution chapter for more information
 * including clocking diagrams and definitions of device clocks.
 */
/*!
 * @name Constants and macros for entire SIM_SOPT2 register
 */
/*@{*/
#define SIM_RD_SOPT2(base)       (SIM_SOPT2_REG(base))
#define SIM_WR_SOPT2(base, value) (SIM_SOPT2_REG(base) = (value))
#define SIM_RMW_SOPT2(base, mask, value) (SIM_WR_SOPT2(base, (SIM_RD_SOPT2(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT2(base, value) (BME_OR32(&SIM_SOPT2_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT2(base, value) (BME_AND32(&SIM_SOPT2_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT2(base, value) (BME_XOR32(&SIM_SOPT2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT2 bitfields
 */

/*!
 * @name Register SIM_SOPT2, field CLKOUTSEL[7:5] (RW)
 *
 * Selects the clock to output on the CLKOUT pin.
 *
 * Values:
 * - 0b000 - OSCERCLK DIV2
 * - 0b001 - OSCERCLK DIV4
 * - 0b010 - Bus clock
 * - 0b011 - LPO clock 1 kHz
 * - 0b100 - MCGIRCLK
 * - 0b101 - OSCERCLK DIV8
 * - 0b110 - OSCERCLK
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_CLKOUTSEL field. */
#define SIM_RD_SOPT2_CLKOUTSEL(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_CLKOUTSEL_MASK) >> SIM_SOPT2_CLKOUTSEL_SHIFT)
#define SIM_BRD_SOPT2_CLKOUTSEL(base) (BME_UBFX32(&SIM_SOPT2_REG(base), SIM_SOPT2_CLKOUTSEL_SHIFT, SIM_SOPT2_CLKOUTSEL_WIDTH))

/*! @brief Set the CLKOUTSEL field to a new value. */
#define SIM_WR_SOPT2_CLKOUTSEL(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_CLKOUTSEL_MASK, SIM_SOPT2_CLKOUTSEL(value)))
#define SIM_BWR_SOPT2_CLKOUTSEL(base, value) (BME_BFI32(&SIM_SOPT2_REG(base), ((uint32_t)(value) << SIM_SOPT2_CLKOUTSEL_SHIFT), SIM_SOPT2_CLKOUTSEL_SHIFT, SIM_SOPT2_CLKOUTSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field TPMSRC[25:24] (RW)
 *
 * Selects the clock source for the TPM counter clock
 *
 * Values:
 * - 0b00 - Clock disabled
 * - 0b01 - MCGFLLCLK clock
 * - 0b10 - OSCERCLK clock
 * - 0b11 - MCGIRCLK clock
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_TPMSRC field. */
#define SIM_RD_SOPT2_TPMSRC(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_TPMSRC_MASK) >> SIM_SOPT2_TPMSRC_SHIFT)
#define SIM_BRD_SOPT2_TPMSRC(base) (BME_UBFX32(&SIM_SOPT2_REG(base), SIM_SOPT2_TPMSRC_SHIFT, SIM_SOPT2_TPMSRC_WIDTH))

/*! @brief Set the TPMSRC field to a new value. */
#define SIM_WR_SOPT2_TPMSRC(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_TPMSRC_MASK, SIM_SOPT2_TPMSRC(value)))
#define SIM_BWR_SOPT2_TPMSRC(base, value) (BME_BFI32(&SIM_SOPT2_REG(base), ((uint32_t)(value) << SIM_SOPT2_TPMSRC_SHIFT), SIM_SOPT2_TPMSRC_SHIFT, SIM_SOPT2_TPMSRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field LPUART0SRC[27:26] (RW)
 *
 * Selects the clock source for the LPUART0 transmit and receive clock.
 *
 * Values:
 * - 0b00 - Clock disabled
 * - 0b01 - MCGFLLCLK clock
 * - 0b10 - OSCERCLK clock
 * - 0b11 - MCGIRCLK clock
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_LPUART0SRC field. */
#define SIM_RD_SOPT2_LPUART0SRC(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_LPUART0SRC_MASK) >> SIM_SOPT2_LPUART0SRC_SHIFT)
#define SIM_BRD_SOPT2_LPUART0SRC(base) (BME_UBFX32(&SIM_SOPT2_REG(base), SIM_SOPT2_LPUART0SRC_SHIFT, SIM_SOPT2_LPUART0SRC_WIDTH))

/*! @brief Set the LPUART0SRC field to a new value. */
#define SIM_WR_SOPT2_LPUART0SRC(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_LPUART0SRC_MASK, SIM_SOPT2_LPUART0SRC(value)))
#define SIM_BWR_SOPT2_LPUART0SRC(base, value) (BME_BFI32(&SIM_SOPT2_REG(base), ((uint32_t)(value) << SIM_SOPT2_LPUART0SRC_SHIFT), SIM_SOPT2_LPUART0SRC_SHIFT, SIM_SOPT2_LPUART0SRC_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SOPT4 - System Options Register 4
 ******************************************************************************/

/*!
 * @brief SIM_SOPT4 - System Options Register 4 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SOPT4 register
 */
/*@{*/
#define SIM_RD_SOPT4(base)       (SIM_SOPT4_REG(base))
#define SIM_WR_SOPT4(base, value) (SIM_SOPT4_REG(base) = (value))
#define SIM_RMW_SOPT4(base, mask, value) (SIM_WR_SOPT4(base, (SIM_RD_SOPT4(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT4(base, value) (BME_OR32(&SIM_SOPT4_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT4(base, value) (BME_AND32(&SIM_SOPT4_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT4(base, value) (BME_XOR32(&SIM_SOPT4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT4 bitfields
 */

/*!
 * @name Register SIM_SOPT4, field TPM1CH0SRC[18] (RW)
 *
 * Selects the source for TPM1 channel 0 input capture. When TPM1 is not in
 * input capture mode, clear this field.
 *
 * Values:
 * - 0b0 - TPM1_CH0 signal
 * - 0b1 - CMP0 output
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_TPM1CH0SRC field. */
#define SIM_RD_SOPT4_TPM1CH0SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_TPM1CH0SRC_MASK) >> SIM_SOPT4_TPM1CH0SRC_SHIFT)
#define SIM_BRD_SOPT4_TPM1CH0SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_TPM1CH0SRC_SHIFT, SIM_SOPT4_TPM1CH0SRC_WIDTH))

/*! @brief Set the TPM1CH0SRC field to a new value. */
#define SIM_WR_SOPT4_TPM1CH0SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_TPM1CH0SRC_MASK, SIM_SOPT4_TPM1CH0SRC(value)))
#define SIM_BWR_SOPT4_TPM1CH0SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_TPM1CH0SRC_SHIFT), SIM_SOPT4_TPM1CH0SRC_SHIFT, SIM_SOPT4_TPM1CH0SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field TPM2CH0SRC[20] (RW)
 *
 * Selects the source for TPM2 channel 0 input capture. When TPM2 is not in
 * input capture mode, clear this field.
 *
 * Values:
 * - 0b0 - TPM2_CH0 signal
 * - 0b1 - CMP0 output
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_TPM2CH0SRC field. */
#define SIM_RD_SOPT4_TPM2CH0SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_TPM2CH0SRC_MASK) >> SIM_SOPT4_TPM2CH0SRC_SHIFT)
#define SIM_BRD_SOPT4_TPM2CH0SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_TPM2CH0SRC_SHIFT, SIM_SOPT4_TPM2CH0SRC_WIDTH))

/*! @brief Set the TPM2CH0SRC field to a new value. */
#define SIM_WR_SOPT4_TPM2CH0SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_TPM2CH0SRC_MASK, SIM_SOPT4_TPM2CH0SRC(value)))
#define SIM_BWR_SOPT4_TPM2CH0SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_TPM2CH0SRC_SHIFT), SIM_SOPT4_TPM2CH0SRC_SHIFT, SIM_SOPT4_TPM2CH0SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field TPM0CLKSEL[24] (RW)
 *
 * Selects the external pin used to drive the clock to the TPM0 module. The
 * selected pin must also be configured for the TPM external clock function through
 * the appropriate pin control register in the port control module.
 *
 * Values:
 * - 0b0 - TPM0 external clock driven by TPM_CLKIN0 pin.
 * - 0b1 - TPM0 external clock driven by TPM_CLKIN1 pin.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_TPM0CLKSEL field. */
#define SIM_RD_SOPT4_TPM0CLKSEL(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_TPM0CLKSEL_MASK) >> SIM_SOPT4_TPM0CLKSEL_SHIFT)
#define SIM_BRD_SOPT4_TPM0CLKSEL(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_TPM0CLKSEL_SHIFT, SIM_SOPT4_TPM0CLKSEL_WIDTH))

/*! @brief Set the TPM0CLKSEL field to a new value. */
#define SIM_WR_SOPT4_TPM0CLKSEL(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_TPM0CLKSEL_MASK, SIM_SOPT4_TPM0CLKSEL(value)))
#define SIM_BWR_SOPT4_TPM0CLKSEL(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_TPM0CLKSEL_SHIFT), SIM_SOPT4_TPM0CLKSEL_SHIFT, SIM_SOPT4_TPM0CLKSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field TPM1CLKSEL[25] (RW)
 *
 * Selects the external pin used to drive the clock to the TPM1 module. The
 * selected pin must also be configured for the TPM external clock function through
 * the appropriate pin control register in the port control module.
 *
 * Values:
 * - 0b0 - TPM1 external clock driven by TPM_CLKIN0 pin.
 * - 0b1 - TPM1 external clock driven by TPM_CLKIN1 pin.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_TPM1CLKSEL field. */
#define SIM_RD_SOPT4_TPM1CLKSEL(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_TPM1CLKSEL_MASK) >> SIM_SOPT4_TPM1CLKSEL_SHIFT)
#define SIM_BRD_SOPT4_TPM1CLKSEL(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_TPM1CLKSEL_SHIFT, SIM_SOPT4_TPM1CLKSEL_WIDTH))

/*! @brief Set the TPM1CLKSEL field to a new value. */
#define SIM_WR_SOPT4_TPM1CLKSEL(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_TPM1CLKSEL_MASK, SIM_SOPT4_TPM1CLKSEL(value)))
#define SIM_BWR_SOPT4_TPM1CLKSEL(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_TPM1CLKSEL_SHIFT), SIM_SOPT4_TPM1CLKSEL_SHIFT, SIM_SOPT4_TPM1CLKSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field TPM2CLKSEL[26] (RW)
 *
 * Selects the external pin used to drive the clock to the TPM2 module. The
 * selected pin must also be configured for the TPM external clock function through
 * the appropriate Pin Control Register in the Port Control module.
 *
 * Values:
 * - 0b0 - TPM2 external clock driven by TPM_CLKIN0 pin.
 * - 0b1 - TPM2 external clock driven by TPM_CLKIN1 pin.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_TPM2CLKSEL field. */
#define SIM_RD_SOPT4_TPM2CLKSEL(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_TPM2CLKSEL_MASK) >> SIM_SOPT4_TPM2CLKSEL_SHIFT)
#define SIM_BRD_SOPT4_TPM2CLKSEL(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_TPM2CLKSEL_SHIFT, SIM_SOPT4_TPM2CLKSEL_WIDTH))

/*! @brief Set the TPM2CLKSEL field to a new value. */
#define SIM_WR_SOPT4_TPM2CLKSEL(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_TPM2CLKSEL_MASK, SIM_SOPT4_TPM2CLKSEL(value)))
#define SIM_BWR_SOPT4_TPM2CLKSEL(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_TPM2CLKSEL_SHIFT), SIM_SOPT4_TPM2CLKSEL_SHIFT, SIM_SOPT4_TPM2CLKSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SOPT5 - System Options Register 5
 ******************************************************************************/

/*!
 * @brief SIM_SOPT5 - System Options Register 5 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SOPT5 register
 */
/*@{*/
#define SIM_RD_SOPT5(base)       (SIM_SOPT5_REG(base))
#define SIM_WR_SOPT5(base, value) (SIM_SOPT5_REG(base) = (value))
#define SIM_RMW_SOPT5(base, mask, value) (SIM_WR_SOPT5(base, (SIM_RD_SOPT5(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT5(base, value) (BME_OR32(&SIM_SOPT5_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT5(base, value) (BME_AND32(&SIM_SOPT5_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT5(base, value) (BME_XOR32(&SIM_SOPT5_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT5 bitfields
 */

/*!
 * @name Register SIM_SOPT5, field LPUART0TXSRC[1:0] (RW)
 *
 * Selects the source for the LPUART0 transmit data.
 *
 * Values:
 * - 0b00 - LPUART0_TX pin
 * - 0b01 - LPUART0_TX pin modulated with TPM1 channel 0 output
 * - 0b10 - LPUART0_TX pin modulated with TPM2 channel 0 output
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_LPUART0TXSRC field. */
#define SIM_RD_SOPT5_LPUART0TXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_LPUART0TXSRC_MASK) >> SIM_SOPT5_LPUART0TXSRC_SHIFT)
#define SIM_BRD_SOPT5_LPUART0TXSRC(base) (BME_UBFX32(&SIM_SOPT5_REG(base), SIM_SOPT5_LPUART0TXSRC_SHIFT, SIM_SOPT5_LPUART0TXSRC_WIDTH))

/*! @brief Set the LPUART0TXSRC field to a new value. */
#define SIM_WR_SOPT5_LPUART0TXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_LPUART0TXSRC_MASK, SIM_SOPT5_LPUART0TXSRC(value)))
#define SIM_BWR_SOPT5_LPUART0TXSRC(base, value) (BME_BFI32(&SIM_SOPT5_REG(base), ((uint32_t)(value) << SIM_SOPT5_LPUART0TXSRC_SHIFT), SIM_SOPT5_LPUART0TXSRC_SHIFT, SIM_SOPT5_LPUART0TXSRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field LPUART0RXSRC[2] (RW)
 *
 * Selects the source for the LPUART0 receive data.
 *
 * Values:
 * - 0b0 - LPUART_RX pin
 * - 0b1 - CMP0 output
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_LPUART0RXSRC field. */
#define SIM_RD_SOPT5_LPUART0RXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_LPUART0RXSRC_MASK) >> SIM_SOPT5_LPUART0RXSRC_SHIFT)
#define SIM_BRD_SOPT5_LPUART0RXSRC(base) (BME_UBFX32(&SIM_SOPT5_REG(base), SIM_SOPT5_LPUART0RXSRC_SHIFT, SIM_SOPT5_LPUART0RXSRC_WIDTH))

/*! @brief Set the LPUART0RXSRC field to a new value. */
#define SIM_WR_SOPT5_LPUART0RXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_LPUART0RXSRC_MASK, SIM_SOPT5_LPUART0RXSRC(value)))
#define SIM_BWR_SOPT5_LPUART0RXSRC(base, value) (BME_BFI32(&SIM_SOPT5_REG(base), ((uint32_t)(value) << SIM_SOPT5_LPUART0RXSRC_SHIFT), SIM_SOPT5_LPUART0RXSRC_SHIFT, SIM_SOPT5_LPUART0RXSRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field LPUART0ODE[16] (RW)
 *
 * Values:
 * - 0b0 - Open drain is disabled on LPUART0.
 * - 0b1 - Open drain is enabled on LPUART0.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_LPUART0ODE field. */
#define SIM_RD_SOPT5_LPUART0ODE(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_LPUART0ODE_MASK) >> SIM_SOPT5_LPUART0ODE_SHIFT)
#define SIM_BRD_SOPT5_LPUART0ODE(base) (BME_UBFX32(&SIM_SOPT5_REG(base), SIM_SOPT5_LPUART0ODE_SHIFT, SIM_SOPT5_LPUART0ODE_WIDTH))

/*! @brief Set the LPUART0ODE field to a new value. */
#define SIM_WR_SOPT5_LPUART0ODE(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_LPUART0ODE_MASK, SIM_SOPT5_LPUART0ODE(value)))
#define SIM_BWR_SOPT5_LPUART0ODE(base, value) (BME_BFI32(&SIM_SOPT5_REG(base), ((uint32_t)(value) << SIM_SOPT5_LPUART0ODE_SHIFT), SIM_SOPT5_LPUART0ODE_SHIFT, SIM_SOPT5_LPUART0ODE_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SOPT7 - System Options Register 7
 ******************************************************************************/

/*!
 * @brief SIM_SOPT7 - System Options Register 7 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SOPT7 register
 */
/*@{*/
#define SIM_RD_SOPT7(base)       (SIM_SOPT7_REG(base))
#define SIM_WR_SOPT7(base, value) (SIM_SOPT7_REG(base) = (value))
#define SIM_RMW_SOPT7(base, mask, value) (SIM_WR_SOPT7(base, (SIM_RD_SOPT7(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT7(base, value) (BME_OR32(&SIM_SOPT7_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT7(base, value) (BME_AND32(&SIM_SOPT7_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT7(base, value) (BME_XOR32(&SIM_SOPT7_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT7 bitfields
 */

/*!
 * @name Register SIM_SOPT7, field ADC0TRGSEL[3:0] (RW)
 *
 * Selects 1 of 16 peripherals to initiate an ADC conversion via the ADHWDT
 * input, when ADC0ALTTRGEN =1, else is ignored by ADC0.
 *
 * Values:
 * - 0b0000 - External trigger pin input (EXTRG_IN)
 * - 0b0001 - CMP0 output
 * - 0b0010 - Reserved
 * - 0b0011 - Reserved
 * - 0b0100 - PIT trigger 0
 * - 0b0101 - PIT trigger 1
 * - 0b0110 - Reserved
 * - 0b0111 - Reserved
 * - 0b1000 - TPM0 overflow
 * - 0b1001 - TPM1 overflow
 * - 0b1010 - TPM2 overflow
 * - 0b1011 - Reserved
 * - 0b1100 - RTC alarm
 * - 0b1101 - RTC seconds
 * - 0b1110 - LPTMR0 trigger
 * - 0b1111 - Radio TSM
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_ADC0TRGSEL field. */
#define SIM_RD_SOPT7_ADC0TRGSEL(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_ADC0TRGSEL_MASK) >> SIM_SOPT7_ADC0TRGSEL_SHIFT)
#define SIM_BRD_SOPT7_ADC0TRGSEL(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC0TRGSEL_SHIFT, SIM_SOPT7_ADC0TRGSEL_WIDTH))

/*! @brief Set the ADC0TRGSEL field to a new value. */
#define SIM_WR_SOPT7_ADC0TRGSEL(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_ADC0TRGSEL_MASK, SIM_SOPT7_ADC0TRGSEL(value)))
#define SIM_BWR_SOPT7_ADC0TRGSEL(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_ADC0TRGSEL_SHIFT), SIM_SOPT7_ADC0TRGSEL_SHIFT, SIM_SOPT7_ADC0TRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC0PRETRGSEL[4] (RW)
 *
 * Selects the ADC0 pre-trigger source when alternative triggers are enabled
 * through ADC0ALTTRGEN.The ADC0PRETRGSEL function is ignored if ADC0ALTTRGEN = 0.
 *
 * Values:
 * - 0b0 - Pre-trigger ADHDWTSA is selected, thus ADC0 will use ADC0_SC1A
 *     configuration for the next ADC conversion and store the result in ADC0_RA
 *     register.
 * - 0b1 - Pre-trigger ADHDWTSB is selected, thus ADC0 will use ADC0_SC1B
 *     configuration for the next ADC conversion and store the result in ADC0_RB
 *     register.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_ADC0PRETRGSEL field. */
#define SIM_RD_SOPT7_ADC0PRETRGSEL(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_ADC0PRETRGSEL_MASK) >> SIM_SOPT7_ADC0PRETRGSEL_SHIFT)
#define SIM_BRD_SOPT7_ADC0PRETRGSEL(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC0PRETRGSEL_SHIFT, SIM_SOPT7_ADC0PRETRGSEL_WIDTH))

/*! @brief Set the ADC0PRETRGSEL field to a new value. */
#define SIM_WR_SOPT7_ADC0PRETRGSEL(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_ADC0PRETRGSEL_MASK, SIM_SOPT7_ADC0PRETRGSEL(value)))
#define SIM_BWR_SOPT7_ADC0PRETRGSEL(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_ADC0PRETRGSEL_SHIFT), SIM_SOPT7_ADC0PRETRGSEL_SHIFT, SIM_SOPT7_ADC0PRETRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC0ALTTRGEN[7] (RW)
 *
 * Enables alternative conversion triggers for ADC0.
 *
 * Values:
 * - 0b0 - ADC ADHWT trigger comes from TPM1 channel 0 and channel1. Prior to
 *     the assertion of TPM1 channel 0, a pre-trigger pulse will be sent to ADHWTSA
 *     to initiate an ADC acquisition using ADCx_SC1A configuration and store
 *     ADC conversion in ADCx_RA Register. Prior to the assertion of TPM1 channel 1
 *     a pre-trigger pulse will be sent to ADHWTSB to initiate an ADC
 *     acquisition using ADCx_SC1Bconfiguration and store ADC conversion in ADCx_RB
 *     Register.
 * - 0b1 - ADC ADHWT trigger comes from a peripheral event selected by
 *     ADC0TRGSEL bits.ADC0PRETRGSEL bit will select the optional ADHWTSA or ADHWTSB
 *     select lines for choosing the ADCx_SC1x config and ADCx_Rx result regsiter to
 *     store the ADC conversion.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_ADC0ALTTRGEN field. */
#define SIM_RD_SOPT7_ADC0ALTTRGEN(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_ADC0ALTTRGEN_MASK) >> SIM_SOPT7_ADC0ALTTRGEN_SHIFT)
#define SIM_BRD_SOPT7_ADC0ALTTRGEN(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC0ALTTRGEN_SHIFT, SIM_SOPT7_ADC0ALTTRGEN_WIDTH))

/*! @brief Set the ADC0ALTTRGEN field to a new value. */
#define SIM_WR_SOPT7_ADC0ALTTRGEN(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_ADC0ALTTRGEN_MASK, SIM_SOPT7_ADC0ALTTRGEN(value)))
#define SIM_BWR_SOPT7_ADC0ALTTRGEN(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_ADC0ALTTRGEN_SHIFT), SIM_SOPT7_ADC0ALTTRGEN_SHIFT, SIM_SOPT7_ADC0ALTTRGEN_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SDID - System Device Identification Register
 ******************************************************************************/

/*!
 * @brief SIM_SDID - System Device Identification Register (RO)
 *
 * Reset value: 0x00500000U
 *
 * Reset value loaded during System Reset from Flash IFR.
 */
/*!
 * @name Constants and macros for entire SIM_SDID register
 */
/*@{*/
#define SIM_RD_SDID(base)        (SIM_SDID_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_SDID bitfields
 */

/*!
 * @name Register SIM_SDID, field PINID[3:0] (RO)
 *
 * Specifies the pin count of the device.
 *
 * Values:
 * - 0b0000 - Reserved
 * - 0b0001 - Reserved
 * - 0b0010 - 32-pin
 * - 0b0011 - Reserved
 * - 0b0100 - 48-pin
 * - 0b0101 - Reserved
 * - 0b0110 - Reserved
 * - 0b0111 - Reserved
 * - 0b1000 - Reserved
 * - 0b1001 - Reserved
 * - 0b1010 - Reserved
 * - 0b1011 - CSP
 * - 0b1100 - Reserved
 * - 0b1101 - Reserved
 * - 0b1110 - Reserved
 * - 0b1111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_PINID field. */
#define SIM_RD_SDID_PINID(base) ((SIM_SDID_REG(base) & SIM_SDID_PINID_MASK) >> SIM_SDID_PINID_SHIFT)
#define SIM_BRD_SDID_PINID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_PINID_SHIFT, SIM_SDID_PINID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field DIEID[11:7] (RO)
 *
 * Specifies the silicon implementation number for the device.
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_DIEID field. */
#define SIM_RD_SDID_DIEID(base) ((SIM_SDID_REG(base) & SIM_SDID_DIEID_MASK) >> SIM_SDID_DIEID_SHIFT)
#define SIM_BRD_SDID_DIEID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_DIEID_SHIFT, SIM_SDID_DIEID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field REVID[15:12] (RO)
 *
 * Specifies the silicon implementation number for the device.
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_REVID field. */
#define SIM_RD_SDID_REVID(base) ((SIM_SDID_REG(base) & SIM_SDID_REVID_MASK) >> SIM_SDID_REVID_SHIFT)
#define SIM_BRD_SDID_REVID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_REVID_SHIFT, SIM_SDID_REVID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field SRAMSIZE[19:16] (RO)
 *
 * Specifies the size of the System SRAM
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_SRAMSIZE field. */
#define SIM_RD_SDID_SRAMSIZE(base) ((SIM_SDID_REG(base) & SIM_SDID_SRAMSIZE_MASK) >> SIM_SDID_SRAMSIZE_SHIFT)
#define SIM_BRD_SDID_SRAMSIZE(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_SRAMSIZE_SHIFT, SIM_SDID_SRAMSIZE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field SERIESID[23:20] (RO)
 *
 * Specifies the Kinetis family of the device.
 *
 * Values:
 * - 0b0101 - KW family
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_SERIESID field. */
#define SIM_RD_SDID_SERIESID(base) ((SIM_SDID_REG(base) & SIM_SDID_SERIESID_MASK) >> SIM_SDID_SERIESID_SHIFT)
#define SIM_BRD_SDID_SERIESID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_SERIESID_SHIFT, SIM_SDID_SERIESID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field SUBFAMID[25:24] (RO)
 *
 * Specifies the Kinetis sub-family of the device.
 *
 * Values:
 * - 0b00 - KWx0 Subfamily
 * - 0b01 - KWx1 Subfamily
 * - 0b10 - KWx2 Subfamily
 * - 0b11 - KWx3 Subfamily
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_SUBFAMID field. */
#define SIM_RD_SDID_SUBFAMID(base) ((SIM_SDID_REG(base) & SIM_SDID_SUBFAMID_MASK) >> SIM_SDID_SUBFAMID_SHIFT)
#define SIM_BRD_SDID_SUBFAMID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_SUBFAMID_SHIFT, SIM_SDID_SUBFAMID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field FAMID[31:28] (RO)
 *
 * Specifies the Kinetis family of the device. The FAMID will be loaded from the
 * BLE_EN and ZIGBEE_EN IFR bits.
 *
 * Values:
 * - 0b0010 - KW20 Family (802.15.4/ZigBee)
 * - 0b0011 - KW30 Family (BTLE)
 * - 0b0100 - KW40 Family (802.15.4/ZigBee or BTLE)
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_FAMID field. */
#define SIM_RD_SDID_FAMID(base) ((SIM_SDID_REG(base) & SIM_SDID_FAMID_MASK) >> SIM_SDID_FAMID_SHIFT)
#define SIM_BRD_SDID_FAMID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_FAMID_SHIFT, SIM_SDID_FAMID_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC4 - System Clock Gating Control Register 4
 ******************************************************************************/

/*!
 * @brief SIM_SCGC4 - System Clock Gating Control Register 4 (RW)
 *
 * Reset value: 0xF0000030U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC4 register
 */
/*@{*/
#define SIM_RD_SCGC4(base)       (SIM_SCGC4_REG(base))
#define SIM_WR_SCGC4(base, value) (SIM_SCGC4_REG(base) = (value))
#define SIM_RMW_SCGC4(base, mask, value) (SIM_WR_SCGC4(base, (SIM_RD_SCGC4(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC4(base, value) (BME_OR32(&SIM_SCGC4_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC4(base, value) (BME_AND32(&SIM_SCGC4_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC4(base, value) (BME_XOR32(&SIM_SCGC4_REG(base), (uint32_t)(value)))
/*@}*/

/* Unified clock gate bit access macros */
#define SIM_SCGC_BIT_REG(base, index)        (*((volatile uint32_t *)&SIM_SCGC4_REG(base) + (((uint32_t)(index) >> 5) - 3U)))
#define SIM_SCGC_BIT_SHIFT(index)            ((uint32_t)(index) & ((1U << 5) - 1U))
#define SIM_RD_SCGC_BIT(base, index)         (SIM_SCGC_BIT_REG((base), (index)) & (1U << SIM_SCGC_BIT_SHIFT(index)))
#define SIM_BRD_SCGC_BIT(base, index)        (BME_UBFX32(&SIM_SCGC_BIT_REG((base), (index)), SIM_SCGC_BIT_SHIFT(index), 1))
#define SIM_WR_SCGC_BIT(base, index, value)  (SIM_SCGC_BIT_REG((base), (index)) = (SIM_SCGC_BIT_REG((base), (index)) & ~(1U << SIM_SCGC_BIT_SHIFT(index))) | ((uint32_t)(value) << SIM_SCGC_BIT_SHIFT(index)))
#define SIM_BWR_SCGC_BIT(base, index, value) (BME_BFI32(&SIM_SCGC_BIT_REG((base), (index)), ((uint32_t)(value) << SIM_SCGC_BIT_SHIFT(index)), SIM_SCGC_BIT_SHIFT(index), 1))

/*
 * Constants & macros for individual SIM_SCGC4 bitfields
 */

/*!
 * @name Register SIM_SCGC4, field CMT[2] (RW)
 *
 * Controls the clock gate to the CMT module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_CMT field. */
#define SIM_RD_SCGC4_CMT(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_CMT_MASK) >> SIM_SCGC4_CMT_SHIFT)
#define SIM_BRD_SCGC4_CMT(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_CMT_SHIFT, SIM_SCGC4_CMT_WIDTH))

/*! @brief Set the CMT field to a new value. */
#define SIM_WR_SCGC4_CMT(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_CMT_MASK, SIM_SCGC4_CMT(value)))
#define SIM_BWR_SCGC4_CMT(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_CMT_SHIFT), SIM_SCGC4_CMT_SHIFT, SIM_SCGC4_CMT_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field I2C0[6] (RW)
 *
 * Controls the clock gate to the I2C0 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_I2C0 field. */
#define SIM_RD_SCGC4_I2C0(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_I2C0_MASK) >> SIM_SCGC4_I2C0_SHIFT)
#define SIM_BRD_SCGC4_I2C0(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_I2C0_SHIFT, SIM_SCGC4_I2C0_WIDTH))

/*! @brief Set the I2C0 field to a new value. */
#define SIM_WR_SCGC4_I2C0(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_I2C0_MASK, SIM_SCGC4_I2C0(value)))
#define SIM_BWR_SCGC4_I2C0(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_I2C0_SHIFT), SIM_SCGC4_I2C0_SHIFT, SIM_SCGC4_I2C0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field I2C1[7] (RW)
 *
 * Controls the clock gate to the I2C1 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_I2C1 field. */
#define SIM_RD_SCGC4_I2C1(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_I2C1_MASK) >> SIM_SCGC4_I2C1_SHIFT)
#define SIM_BRD_SCGC4_I2C1(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_I2C1_SHIFT, SIM_SCGC4_I2C1_WIDTH))

/*! @brief Set the I2C1 field to a new value. */
#define SIM_WR_SCGC4_I2C1(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_I2C1_MASK, SIM_SCGC4_I2C1(value)))
#define SIM_BWR_SCGC4_I2C1(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_I2C1_SHIFT), SIM_SCGC4_I2C1_SHIFT, SIM_SCGC4_I2C1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field CMP[19] (RW)
 *
 * Controls the clock gate to the comparator module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_CMP field. */
#define SIM_RD_SCGC4_CMP(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_CMP_MASK) >> SIM_SCGC4_CMP_SHIFT)
#define SIM_BRD_SCGC4_CMP(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_CMP_SHIFT, SIM_SCGC4_CMP_WIDTH))

/*! @brief Set the CMP field to a new value. */
#define SIM_WR_SCGC4_CMP(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_CMP_MASK, SIM_SCGC4_CMP(value)))
#define SIM_BWR_SCGC4_CMP(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_CMP_SHIFT), SIM_SCGC4_CMP_SHIFT, SIM_SCGC4_CMP_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC5 - System Clock Gating Control Register 5
 ******************************************************************************/

/*!
 * @brief SIM_SCGC5 - System Clock Gating Control Register 5 (RW)
 *
 * Reset value: 0x02000182U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC5 register
 */
/*@{*/
#define SIM_RD_SCGC5(base)       (SIM_SCGC5_REG(base))
#define SIM_WR_SCGC5(base, value) (SIM_SCGC5_REG(base) = (value))
#define SIM_RMW_SCGC5(base, mask, value) (SIM_WR_SCGC5(base, (SIM_RD_SCGC5(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC5(base, value) (BME_OR32(&SIM_SCGC5_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC5(base, value) (BME_AND32(&SIM_SCGC5_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC5(base, value) (BME_XOR32(&SIM_SCGC5_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC5 bitfields
 */

/*!
 * @name Register SIM_SCGC5, field LPTMR[0] (RW)
 *
 * Controls software access to the Low Power Timer module.
 *
 * Values:
 * - 0b0 - Access disabled
 * - 0b1 - Access enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_LPTMR field. */
#define SIM_RD_SCGC5_LPTMR(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_LPTMR_MASK) >> SIM_SCGC5_LPTMR_SHIFT)
#define SIM_BRD_SCGC5_LPTMR(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_LPTMR_SHIFT, SIM_SCGC5_LPTMR_WIDTH))

/*! @brief Set the LPTMR field to a new value. */
#define SIM_WR_SCGC5_LPTMR(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_LPTMR_MASK, SIM_SCGC5_LPTMR(value)))
#define SIM_BWR_SCGC5_LPTMR(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_LPTMR_SHIFT), SIM_SCGC5_LPTMR_SHIFT, SIM_SCGC5_LPTMR_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field TSI[5] (RW)
 *
 * Controls software access to the TSI module.
 *
 * Values:
 * - 0b0 - Access disabled
 * - 0b1 - Access enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_TSI field. */
#define SIM_RD_SCGC5_TSI(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_TSI_MASK) >> SIM_SCGC5_TSI_SHIFT)
#define SIM_BRD_SCGC5_TSI(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_TSI_SHIFT, SIM_SCGC5_TSI_WIDTH))

/*! @brief Set the TSI field to a new value. */
#define SIM_WR_SCGC5_TSI(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_TSI_MASK, SIM_SCGC5_TSI(value)))
#define SIM_BWR_SCGC5_TSI(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_TSI_SHIFT), SIM_SCGC5_TSI_SHIFT, SIM_SCGC5_TSI_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTA[9] (RW)
 *
 * Controls the clock gate to the Port A module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTA field. */
#define SIM_RD_SCGC5_PORTA(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTA_MASK) >> SIM_SCGC5_PORTA_SHIFT)
#define SIM_BRD_SCGC5_PORTA(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTA_SHIFT, SIM_SCGC5_PORTA_WIDTH))

/*! @brief Set the PORTA field to a new value. */
#define SIM_WR_SCGC5_PORTA(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTA_MASK, SIM_SCGC5_PORTA(value)))
#define SIM_BWR_SCGC5_PORTA(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTA_SHIFT), SIM_SCGC5_PORTA_SHIFT, SIM_SCGC5_PORTA_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTB[10] (RW)
 *
 * Controls the clock gate to the Port B module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTB field. */
#define SIM_RD_SCGC5_PORTB(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTB_MASK) >> SIM_SCGC5_PORTB_SHIFT)
#define SIM_BRD_SCGC5_PORTB(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTB_SHIFT, SIM_SCGC5_PORTB_WIDTH))

/*! @brief Set the PORTB field to a new value. */
#define SIM_WR_SCGC5_PORTB(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTB_MASK, SIM_SCGC5_PORTB(value)))
#define SIM_BWR_SCGC5_PORTB(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTB_SHIFT), SIM_SCGC5_PORTB_SHIFT, SIM_SCGC5_PORTB_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTC[11] (RW)
 *
 * Controls the clock gate to the Port C module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTC field. */
#define SIM_RD_SCGC5_PORTC(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTC_MASK) >> SIM_SCGC5_PORTC_SHIFT)
#define SIM_BRD_SCGC5_PORTC(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTC_SHIFT, SIM_SCGC5_PORTC_WIDTH))

/*! @brief Set the PORTC field to a new value. */
#define SIM_WR_SCGC5_PORTC(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTC_MASK, SIM_SCGC5_PORTC(value)))
#define SIM_BWR_SCGC5_PORTC(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTC_SHIFT), SIM_SCGC5_PORTC_SHIFT, SIM_SCGC5_PORTC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field LPUART0[20] (RW)
 *
 * This bit controls the clock gate to the LPUART0 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_LPUART0 field. */
#define SIM_RD_SCGC5_LPUART0(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_LPUART0_MASK) >> SIM_SCGC5_LPUART0_SHIFT)
#define SIM_BRD_SCGC5_LPUART0(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_LPUART0_SHIFT, SIM_SCGC5_LPUART0_WIDTH))

/*! @brief Set the LPUART0 field to a new value. */
#define SIM_WR_SCGC5_LPUART0(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_LPUART0_MASK, SIM_SCGC5_LPUART0(value)))
#define SIM_BWR_SCGC5_LPUART0(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_LPUART0_SHIFT), SIM_SCGC5_LPUART0_SHIFT, SIM_SCGC5_LPUART0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field LTC[24] (RW)
 *
 * This bit controls the clock gate to the LTC Security module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_LTC field. */
#define SIM_RD_SCGC5_LTC(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_LTC_MASK) >> SIM_SCGC5_LTC_SHIFT)
#define SIM_BRD_SCGC5_LTC(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_LTC_SHIFT, SIM_SCGC5_LTC_WIDTH))

/*! @brief Set the LTC field to a new value. */
#define SIM_WR_SCGC5_LTC(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_LTC_MASK, SIM_SCGC5_LTC(value)))
#define SIM_BWR_SCGC5_LTC(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_LTC_SHIFT), SIM_SCGC5_LTC_SHIFT, SIM_SCGC5_LTC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field RSIM[25] (RO)
 *
 * This bit controls the clock gate to the Radio SIM (RSIM) module. Always
 * enabled.
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_RSIM field. */
#define SIM_RD_SCGC5_RSIM(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_RSIM_MASK) >> SIM_SCGC5_RSIM_SHIFT)
#define SIM_BRD_SCGC5_RSIM(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_RSIM_SHIFT, SIM_SCGC5_RSIM_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field DCDC[26] (RW)
 *
 * This bit controls the clock gate to the DCDC module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_DCDC field. */
#define SIM_RD_SCGC5_DCDC(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_DCDC_MASK) >> SIM_SCGC5_DCDC_SHIFT)
#define SIM_BRD_SCGC5_DCDC(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_DCDC_SHIFT, SIM_SCGC5_DCDC_WIDTH))

/*! @brief Set the DCDC field to a new value. */
#define SIM_WR_SCGC5_DCDC(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_DCDC_MASK, SIM_SCGC5_DCDC(value)))
#define SIM_BWR_SCGC5_DCDC(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_DCDC_SHIFT), SIM_SCGC5_DCDC_SHIFT, SIM_SCGC5_DCDC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field BTLL[27] (RW)
 *
 * This bit controls the clock gate to the BlueTooth Link Layer (BTLL) module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_BTLL field. */
#define SIM_RD_SCGC5_BTLL(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_BTLL_MASK) >> SIM_SCGC5_BTLL_SHIFT)
#define SIM_BRD_SCGC5_BTLL(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_BTLL_SHIFT, SIM_SCGC5_BTLL_WIDTH))

/*! @brief Set the BTLL field to a new value. */
#define SIM_WR_SCGC5_BTLL(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_BTLL_MASK, SIM_SCGC5_BTLL(value)))
#define SIM_BWR_SCGC5_BTLL(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_BTLL_SHIFT), SIM_SCGC5_BTLL_SHIFT, SIM_SCGC5_BTLL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PHYDIG[28] (RW)
 *
 * This bit controls the clock gate to the Physical Layer (PHY) Digital module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PHYDIG field. */
#define SIM_RD_SCGC5_PHYDIG(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PHYDIG_MASK) >> SIM_SCGC5_PHYDIG_SHIFT)
#define SIM_BRD_SCGC5_PHYDIG(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PHYDIG_SHIFT, SIM_SCGC5_PHYDIG_WIDTH))

/*! @brief Set the PHYDIG field to a new value. */
#define SIM_WR_SCGC5_PHYDIG(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PHYDIG_MASK, SIM_SCGC5_PHYDIG(value)))
#define SIM_BWR_SCGC5_PHYDIG(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PHYDIG_SHIFT), SIM_SCGC5_PHYDIG_SHIFT, SIM_SCGC5_PHYDIG_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field ZigBee[29] (RW)
 *
 * This bit controls the clock gate to the ZigBee module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_ZigBee field. */
#define SIM_RD_SCGC5_ZigBee(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_ZigBee_MASK) >> SIM_SCGC5_ZigBee_SHIFT)
#define SIM_BRD_SCGC5_ZigBee(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_ZigBee_SHIFT, SIM_SCGC5_ZigBee_WIDTH))

/*! @brief Set the ZigBee field to a new value. */
#define SIM_WR_SCGC5_ZigBee(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_ZigBee_MASK, SIM_SCGC5_ZigBee(value)))
#define SIM_BWR_SCGC5_ZigBee(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_ZigBee_SHIFT), SIM_SCGC5_ZigBee_SHIFT, SIM_SCGC5_ZigBee_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC6 - System Clock Gating Control Register 6
 ******************************************************************************/

/*!
 * @brief SIM_SCGC6 - System Clock Gating Control Register 6 (RW)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC6 register
 */
/*@{*/
#define SIM_RD_SCGC6(base)       (SIM_SCGC6_REG(base))
#define SIM_WR_SCGC6(base, value) (SIM_SCGC6_REG(base) = (value))
#define SIM_RMW_SCGC6(base, mask, value) (SIM_WR_SCGC6(base, (SIM_RD_SCGC6(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC6(base, value) (BME_OR32(&SIM_SCGC6_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC6(base, value) (BME_AND32(&SIM_SCGC6_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC6(base, value) (BME_XOR32(&SIM_SCGC6_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC6 bitfields
 */

/*!
 * @name Register SIM_SCGC6, field FTF[0] (RW)
 *
 * Controls the clock gate to the flash memory. Flash reads are still supported
 * while the flash memory is clock gated, but entry into low power modes is
 * blocked.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FTF field. */
#define SIM_RD_SCGC6_FTF(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FTF_MASK) >> SIM_SCGC6_FTF_SHIFT)
#define SIM_BRD_SCGC6_FTF(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTF_SHIFT, SIM_SCGC6_FTF_WIDTH))

/*! @brief Set the FTF field to a new value. */
#define SIM_WR_SCGC6_FTF(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FTF_MASK, SIM_SCGC6_FTF(value)))
#define SIM_BWR_SCGC6_FTF(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_FTF_SHIFT), SIM_SCGC6_FTF_SHIFT, SIM_SCGC6_FTF_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field DMAMUX[1] (RW)
 *
 * Controls the clock gate to the DMA Mux module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_DMAMUX field. */
#define SIM_RD_SCGC6_DMAMUX(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_DMAMUX_MASK) >> SIM_SCGC6_DMAMUX_SHIFT)
#define SIM_BRD_SCGC6_DMAMUX(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_DMAMUX_SHIFT, SIM_SCGC6_DMAMUX_WIDTH))

/*! @brief Set the DMAMUX field to a new value. */
#define SIM_WR_SCGC6_DMAMUX(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_DMAMUX_MASK, SIM_SCGC6_DMAMUX(value)))
#define SIM_BWR_SCGC6_DMAMUX(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_DMAMUX_SHIFT), SIM_SCGC6_DMAMUX_SHIFT, SIM_SCGC6_DMAMUX_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field TRNG[9] (RW)
 *
 * Controls the clock gate to the Random Number Generator (TRNG) module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_TRNG field. */
#define SIM_RD_SCGC6_TRNG(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_TRNG_MASK) >> SIM_SCGC6_TRNG_SHIFT)
#define SIM_BRD_SCGC6_TRNG(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_TRNG_SHIFT, SIM_SCGC6_TRNG_WIDTH))

/*! @brief Set the TRNG field to a new value. */
#define SIM_WR_SCGC6_TRNG(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_TRNG_MASK, SIM_SCGC6_TRNG(value)))
#define SIM_BWR_SCGC6_TRNG(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_TRNG_SHIFT), SIM_SCGC6_TRNG_SHIFT, SIM_SCGC6_TRNG_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field SPI0[12] (RW)
 *
 * Controls the clock gate to the Serial Peripheral Interface (SPI0) module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_SPI0 field. */
#define SIM_RD_SCGC6_SPI0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_SPI0_MASK) >> SIM_SCGC6_SPI0_SHIFT)
#define SIM_BRD_SCGC6_SPI0(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_SPI0_SHIFT, SIM_SCGC6_SPI0_WIDTH))

/*! @brief Set the SPI0 field to a new value. */
#define SIM_WR_SCGC6_SPI0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_SPI0_MASK, SIM_SCGC6_SPI0(value)))
#define SIM_BWR_SCGC6_SPI0(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_SPI0_SHIFT), SIM_SCGC6_SPI0_SHIFT, SIM_SCGC6_SPI0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field SPI1[13] (RW)
 *
 * Controls the clock gate to the Serial Peripheral Interface (SPI1) module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_SPI1 field. */
#define SIM_RD_SCGC6_SPI1(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_SPI1_MASK) >> SIM_SCGC6_SPI1_SHIFT)
#define SIM_BRD_SCGC6_SPI1(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_SPI1_SHIFT, SIM_SCGC6_SPI1_WIDTH))

/*! @brief Set the SPI1 field to a new value. */
#define SIM_WR_SCGC6_SPI1(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_SPI1_MASK, SIM_SCGC6_SPI1(value)))
#define SIM_BWR_SCGC6_SPI1(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_SPI1_SHIFT), SIM_SCGC6_SPI1_SHIFT, SIM_SCGC6_SPI1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PIT[23] (RW)
 *
 * This bit controls the clock gate to the PIT module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_PIT field. */
#define SIM_RD_SCGC6_PIT(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_PIT_MASK) >> SIM_SCGC6_PIT_SHIFT)
#define SIM_BRD_SCGC6_PIT(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_PIT_SHIFT, SIM_SCGC6_PIT_WIDTH))

/*! @brief Set the PIT field to a new value. */
#define SIM_WR_SCGC6_PIT(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_PIT_MASK, SIM_SCGC6_PIT(value)))
#define SIM_BWR_SCGC6_PIT(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_PIT_SHIFT), SIM_SCGC6_PIT_SHIFT, SIM_SCGC6_PIT_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field TPM0[24] (RW)
 *
 * Controls the clock gate to the TPM0 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_TPM0 field. */
#define SIM_RD_SCGC6_TPM0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_TPM0_MASK) >> SIM_SCGC6_TPM0_SHIFT)
#define SIM_BRD_SCGC6_TPM0(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_TPM0_SHIFT, SIM_SCGC6_TPM0_WIDTH))

/*! @brief Set the TPM0 field to a new value. */
#define SIM_WR_SCGC6_TPM0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_TPM0_MASK, SIM_SCGC6_TPM0(value)))
#define SIM_BWR_SCGC6_TPM0(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_TPM0_SHIFT), SIM_SCGC6_TPM0_SHIFT, SIM_SCGC6_TPM0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field TPM1[25] (RW)
 *
 * Controls the clock gate to the TPM1 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_TPM1 field. */
#define SIM_RD_SCGC6_TPM1(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_TPM1_MASK) >> SIM_SCGC6_TPM1_SHIFT)
#define SIM_BRD_SCGC6_TPM1(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_TPM1_SHIFT, SIM_SCGC6_TPM1_WIDTH))

/*! @brief Set the TPM1 field to a new value. */
#define SIM_WR_SCGC6_TPM1(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_TPM1_MASK, SIM_SCGC6_TPM1(value)))
#define SIM_BWR_SCGC6_TPM1(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_TPM1_SHIFT), SIM_SCGC6_TPM1_SHIFT, SIM_SCGC6_TPM1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field TPM2[26] (RW)
 *
 * Controls the clock gate to the TPM2 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_TPM2 field. */
#define SIM_RD_SCGC6_TPM2(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_TPM2_MASK) >> SIM_SCGC6_TPM2_SHIFT)
#define SIM_BRD_SCGC6_TPM2(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_TPM2_SHIFT, SIM_SCGC6_TPM2_WIDTH))

/*! @brief Set the TPM2 field to a new value. */
#define SIM_WR_SCGC6_TPM2(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_TPM2_MASK, SIM_SCGC6_TPM2(value)))
#define SIM_BWR_SCGC6_TPM2(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_TPM2_SHIFT), SIM_SCGC6_TPM2_SHIFT, SIM_SCGC6_TPM2_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field ADC0[27] (RW)
 *
 * Controls the clock gate to the ADC0 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_ADC0 field. */
#define SIM_RD_SCGC6_ADC0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_ADC0_MASK) >> SIM_SCGC6_ADC0_SHIFT)
#define SIM_BRD_SCGC6_ADC0(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_ADC0_SHIFT, SIM_SCGC6_ADC0_WIDTH))

/*! @brief Set the ADC0 field to a new value. */
#define SIM_WR_SCGC6_ADC0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_ADC0_MASK, SIM_SCGC6_ADC0(value)))
#define SIM_BWR_SCGC6_ADC0(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_ADC0_SHIFT), SIM_SCGC6_ADC0_SHIFT, SIM_SCGC6_ADC0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field RTC[29] (RW)
 *
 * Controls software access and interrupts to the RTC module.
 *
 * Values:
 * - 0b0 - Access and interrupts disabled
 * - 0b1 - Access and interrupts enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_RTC field. */
#define SIM_RD_SCGC6_RTC(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_RTC_MASK) >> SIM_SCGC6_RTC_SHIFT)
#define SIM_BRD_SCGC6_RTC(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_RTC_SHIFT, SIM_SCGC6_RTC_WIDTH))

/*! @brief Set the RTC field to a new value. */
#define SIM_WR_SCGC6_RTC(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_RTC_MASK, SIM_SCGC6_RTC(value)))
#define SIM_BWR_SCGC6_RTC(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_RTC_SHIFT), SIM_SCGC6_RTC_SHIFT, SIM_SCGC6_RTC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field DAC0[31] (RW)
 *
 * This bit controls the clock gate to the DAC0 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_DAC0 field. */
#define SIM_RD_SCGC6_DAC0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_DAC0_MASK) >> SIM_SCGC6_DAC0_SHIFT)
#define SIM_BRD_SCGC6_DAC0(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_DAC0_SHIFT, SIM_SCGC6_DAC0_WIDTH))

/*! @brief Set the DAC0 field to a new value. */
#define SIM_WR_SCGC6_DAC0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_DAC0_MASK, SIM_SCGC6_DAC0(value)))
#define SIM_BWR_SCGC6_DAC0(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_DAC0_SHIFT), SIM_SCGC6_DAC0_SHIFT, SIM_SCGC6_DAC0_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC7 - System Clock Gating Control Register 7
 ******************************************************************************/

/*!
 * @brief SIM_SCGC7 - System Clock Gating Control Register 7 (RW)
 *
 * Reset value: 0x00000100U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC7 register
 */
/*@{*/
#define SIM_RD_SCGC7(base)       (SIM_SCGC7_REG(base))
#define SIM_WR_SCGC7(base, value) (SIM_SCGC7_REG(base) = (value))
#define SIM_RMW_SCGC7(base, mask, value) (SIM_WR_SCGC7(base, (SIM_RD_SCGC7(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC7(base, value) (BME_OR32(&SIM_SCGC7_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC7(base, value) (BME_AND32(&SIM_SCGC7_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC7(base, value) (BME_XOR32(&SIM_SCGC7_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC7 bitfields
 */

/*!
 * @name Register SIM_SCGC7, field DMA[8] (RW)
 *
 * Controls the clock gate to the DMA module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC7_DMA field. */
#define SIM_RD_SCGC7_DMA(base) ((SIM_SCGC7_REG(base) & SIM_SCGC7_DMA_MASK) >> SIM_SCGC7_DMA_SHIFT)
#define SIM_BRD_SCGC7_DMA(base) (BME_UBFX32(&SIM_SCGC7_REG(base), SIM_SCGC7_DMA_SHIFT, SIM_SCGC7_DMA_WIDTH))

/*! @brief Set the DMA field to a new value. */
#define SIM_WR_SCGC7_DMA(base, value) (SIM_RMW_SCGC7(base, SIM_SCGC7_DMA_MASK, SIM_SCGC7_DMA(value)))
#define SIM_BWR_SCGC7_DMA(base, value) (BME_BFI32(&SIM_SCGC7_REG(base), ((uint32_t)(value) << SIM_SCGC7_DMA_SHIFT), SIM_SCGC7_DMA_SHIFT, SIM_SCGC7_DMA_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_CLKDIV1 - System Clock Divider Register 1
 ******************************************************************************/

/*!
 * @brief SIM_CLKDIV1 - System Clock Divider Register 1 (RW)
 *
 * Reset value: 0x00010000U
 *
 * The CLKDIV1 register cannot be written to when the device is in VLPR mode.
 * Reset value loaded during System Reset from FTFA_FOPT[LPBOOT]"/>).
 */
/*!
 * @name Constants and macros for entire SIM_CLKDIV1 register
 */
/*@{*/
#define SIM_RD_CLKDIV1(base)     (SIM_CLKDIV1_REG(base))
#define SIM_WR_CLKDIV1(base, value) (SIM_CLKDIV1_REG(base) = (value))
#define SIM_RMW_CLKDIV1(base, mask, value) (SIM_WR_CLKDIV1(base, (SIM_RD_CLKDIV1(base) & ~(mask)) | (value)))
#define SIM_SET_CLKDIV1(base, value) (BME_OR32(&SIM_CLKDIV1_REG(base), (uint32_t)(value)))
#define SIM_CLR_CLKDIV1(base, value) (BME_AND32(&SIM_CLKDIV1_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_CLKDIV1(base, value) (BME_XOR32(&SIM_CLKDIV1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_CLKDIV1 bitfields
 */

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV4[18:16] (RW)
 *
 * Sets the divide value for the bus and flash clock and is in addition to the
 * System clock divide ratio. At the end of reset, it is loaded with 0001 (divide
 * by 2).
 *
 * Values:
 * - 0b000 - Divide-by-1.
 * - 0b001 - Divide-by-2.
 * - 0b010 - Divide-by-3.
 * - 0b011 - Divide-by-4.
 * - 0b100 - Divide-by-5.
 * - 0b101 - Divide-by-6.
 * - 0b110 - Divide-by-7.
 * - 0b111 - Divide-by-8.
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV4 field. */
#define SIM_RD_CLKDIV1_OUTDIV4(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_SHIFT)
#define SIM_BRD_CLKDIV1_OUTDIV4(base) (BME_UBFX32(&SIM_CLKDIV1_REG(base), SIM_CLKDIV1_OUTDIV4_SHIFT, SIM_CLKDIV1_OUTDIV4_WIDTH))

/*! @brief Set the OUTDIV4 field to a new value. */
#define SIM_WR_CLKDIV1_OUTDIV4(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_OUTDIV4_MASK, SIM_CLKDIV1_OUTDIV4(value)))
#define SIM_BWR_CLKDIV1_OUTDIV4(base, value) (BME_BFI32(&SIM_CLKDIV1_REG(base), ((uint32_t)(value) << SIM_CLKDIV1_OUTDIV4_SHIFT), SIM_CLKDIV1_OUTDIV4_SHIFT, SIM_CLKDIV1_OUTDIV4_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV1[31:28] (RW)
 *
 * Sets the divide value for the core/system clock, as well as the bus/flash
 * clocks. At the end of reset, it is loaded with 0000 (divide by one), 0001 (divide
 * by two), 0011 (divide by four), or 0111 (divide by eight) depending on the
 * setting of the FTFA_FOPT[LPBOOT]".
 *
 * Values:
 * - 0b0000 - Divide-by-1.
 * - 0b0001 - Divide-by-2.
 * - 0b0010 - Divide-by-3.
 * - 0b0011 - Divide-by-4.
 * - 0b0100 - Divide-by-5.
 * - 0b0101 - Divide-by-6.
 * - 0b0110 - Divide-by-7.
 * - 0b0111 - Divide-by-8.
 * - 0b1000 - Divide-by-9.
 * - 0b1001 - Divide-by-10.
 * - 0b1010 - Divide-by-11.
 * - 0b1011 - Divide-by-12.
 * - 0b1100 - Divide-by-13.
 * - 0b1101 - Divide-by-14.
 * - 0b1110 - Divide-by-15.
 * - 0b1111 - Divide-by-16.
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV1 field. */
#define SIM_RD_CLKDIV1_OUTDIV1(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)
#define SIM_BRD_CLKDIV1_OUTDIV1(base) (BME_UBFX32(&SIM_CLKDIV1_REG(base), SIM_CLKDIV1_OUTDIV1_SHIFT, SIM_CLKDIV1_OUTDIV1_WIDTH))

/*! @brief Set the OUTDIV1 field to a new value. */
#define SIM_WR_CLKDIV1_OUTDIV1(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_OUTDIV1_MASK, SIM_CLKDIV1_OUTDIV1(value)))
#define SIM_BWR_CLKDIV1_OUTDIV1(base, value) (BME_BFI32(&SIM_CLKDIV1_REG(base), ((uint32_t)(value) << SIM_CLKDIV1_OUTDIV1_SHIFT), SIM_CLKDIV1_OUTDIV1_SHIFT, SIM_CLKDIV1_OUTDIV1_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_FCFG1 - Flash Configuration Register 1
 ******************************************************************************/

/*!
 * @brief SIM_FCFG1 - Flash Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Reset value of PFSIZE loaded during System Reset from Flash IFR.
 */
/*!
 * @name Constants and macros for entire SIM_FCFG1 register
 */
/*@{*/
#define SIM_RD_FCFG1(base)       (SIM_FCFG1_REG(base))
#define SIM_WR_FCFG1(base, value) (SIM_FCFG1_REG(base) = (value))
#define SIM_RMW_FCFG1(base, mask, value) (SIM_WR_FCFG1(base, (SIM_RD_FCFG1(base) & ~(mask)) | (value)))
#define SIM_SET_FCFG1(base, value) (BME_OR32(&SIM_FCFG1_REG(base), (uint32_t)(value)))
#define SIM_CLR_FCFG1(base, value) (BME_AND32(&SIM_FCFG1_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_FCFG1(base, value) (BME_XOR32(&SIM_FCFG1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG1 bitfields
 */

/*!
 * @name Register SIM_FCFG1, field FLASHDIS[0] (RW)
 *
 * Flash accesses are disabled (and generate a bus error) and the flash memory
 * is placed in a low-power state. This field should not be changed during VLP
 * modes. Relocate the interrupt vectors out of Flash memory before disabling the
 * Flash.
 *
 * Values:
 * - 0b0 - Flash is enabled.
 * - 0b1 - Flash is disabled.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_FLASHDIS field. */
#define SIM_RD_FCFG1_FLASHDIS(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_FLASHDIS_MASK) >> SIM_FCFG1_FLASHDIS_SHIFT)
#define SIM_BRD_FCFG1_FLASHDIS(base) (BME_UBFX32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDIS_SHIFT, SIM_FCFG1_FLASHDIS_WIDTH))

/*! @brief Set the FLASHDIS field to a new value. */
#define SIM_WR_FCFG1_FLASHDIS(base, value) (SIM_RMW_FCFG1(base, SIM_FCFG1_FLASHDIS_MASK, SIM_FCFG1_FLASHDIS(value)))
#define SIM_BWR_FCFG1_FLASHDIS(base, value) (BME_BFI32(&SIM_FCFG1_REG(base), ((uint32_t)(value) << SIM_FCFG1_FLASHDIS_SHIFT), SIM_FCFG1_FLASHDIS_SHIFT, SIM_FCFG1_FLASHDIS_WIDTH))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field FLASHDOZE[1] (RW)
 *
 * When set, flash memory is disabled for the duration of Doze mode. This field
 * must be clear during VLP modes. The flash will be automatically enabled again
 * at the end of Doze mode so interrupt vectors do not need to be relocated out
 * of flash memory. The wake-up time from Doze mode is extended when this field is
 * set. An attempt by the DMA or other bus master to access the flash memory
 * when the flash is disabled will result in a bus error.
 *
 * Values:
 * - 0b0 - Flash remains enabled during Doze mode.
 * - 0b1 - Flash is disabled for the duration of Doze mode.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_FLASHDOZE field. */
#define SIM_RD_FCFG1_FLASHDOZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_FLASHDOZE_MASK) >> SIM_FCFG1_FLASHDOZE_SHIFT)
#define SIM_BRD_FCFG1_FLASHDOZE(base) (BME_UBFX32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDOZE_SHIFT, SIM_FCFG1_FLASHDOZE_WIDTH))

/*! @brief Set the FLASHDOZE field to a new value. */
#define SIM_WR_FCFG1_FLASHDOZE(base, value) (SIM_RMW_FCFG1(base, SIM_FCFG1_FLASHDOZE_MASK, SIM_FCFG1_FLASHDOZE(value)))
#define SIM_BWR_FCFG1_FLASHDOZE(base, value) (BME_BFI32(&SIM_FCFG1_REG(base), ((uint32_t)(value) << SIM_FCFG1_FLASHDOZE_SHIFT), SIM_FCFG1_FLASHDOZE_SHIFT, SIM_FCFG1_FLASHDOZE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field PFSIZE[27:24] (RO)
 *
 * Specifies the amount of program flash memory available on the device, as set
 * by IFR bits. These bits are used for device testing only and are read-only .
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_PFSIZE field. */
#define SIM_RD_FCFG1_PFSIZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_PFSIZE_MASK) >> SIM_FCFG1_PFSIZE_SHIFT)
#define SIM_BRD_FCFG1_PFSIZE(base) (BME_UBFX32(&SIM_FCFG1_REG(base), SIM_FCFG1_PFSIZE_SHIFT, SIM_FCFG1_PFSIZE_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_FCFG2 - Flash Configuration Register 2
 ******************************************************************************/

/*!
 * @brief SIM_FCFG2 - Flash Configuration Register 2 (RO)
 *
 * Reset value: 0x7FFF0000U
 *
 * This is read only register, any write to this register will cause transfer
 * error. Reset value of MAXADDR loaded during System Reset from Flash IFR.
 */
/*!
 * @name Constants and macros for entire SIM_FCFG2 register
 */
/*@{*/
#define SIM_RD_FCFG2(base)       (SIM_FCFG2_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG2 bitfields
 */

/*!
 * @name Register SIM_FCFG2, field MAXADDR1[22:16] (RO)
 *
 * This field concatenated with leading zeros plus the value of the MAXADDR1
 * field indicates the first invalid address of the second program flash block
 * (flash block 1). For example, if MAXADDR0 = MAXADDR1 = 0x10 the first invalid
 * address of flash block 1 is 0x2_0000 + 0x2_0000. This would be the MAXADDR1 value
 * for a device with 256 KB program flash memory across two flash blocks. Set by
 * IFR option.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG2_MAXADDR1 field. */
#define SIM_RD_FCFG2_MAXADDR1(base) ((SIM_FCFG2_REG(base) & SIM_FCFG2_MAXADDR1_MASK) >> SIM_FCFG2_MAXADDR1_SHIFT)
#define SIM_BRD_FCFG2_MAXADDR1(base) (BME_UBFX32(&SIM_FCFG2_REG(base), SIM_FCFG2_MAXADDR1_SHIFT, SIM_FCFG2_MAXADDR1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_FCFG2, field MAXADDR0[30:24] (RO)
 *
 * This field concatenated with 13 trailing zeros indicates the first invalid
 * address of program flash (block 0). Set by IFR option. For example, if MAXADDR0
 * = 0x10, the first invalid address of program flash (block 0) is 0x0002_0000.
 * This would be the MAXADDR0 value for a device with 128 KB program flash in
 * flash block 0.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG2_MAXADDR0 field. */
#define SIM_RD_FCFG2_MAXADDR0(base) ((SIM_FCFG2_REG(base) & SIM_FCFG2_MAXADDR0_MASK) >> SIM_FCFG2_MAXADDR0_SHIFT)
#define SIM_BRD_FCFG2_MAXADDR0(base) (BME_UBFX32(&SIM_FCFG2_REG(base), SIM_FCFG2_MAXADDR0_SHIFT, SIM_FCFG2_MAXADDR0_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_UIDMH - Unique Identification Register Mid-High
 ******************************************************************************/

/*!
 * @brief SIM_UIDMH - Unique Identification Register Mid-High (RO)
 *
 * Reset value: 0x00000000U
 *
 * Reset value loaded during System Reset from Flash IFR.
 */
/*!
 * @name Constants and macros for entire SIM_UIDMH register
 */
/*@{*/
#define SIM_RD_UIDMH(base)       (SIM_UIDMH_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_UIDMH bitfields
 */

/*!
 * @name Register SIM_UIDMH, field UID[15:0] (RO)
 *
 * Unique identification for the device. It is set by IFR bits.
 */
/*@{*/
/*! @brief Read current value of the SIM_UIDMH_UID field. */
#define SIM_RD_UIDMH_UID(base) ((SIM_UIDMH_REG(base) & SIM_UIDMH_UID_MASK) >> SIM_UIDMH_UID_SHIFT)
#define SIM_BRD_UIDMH_UID(base) (BME_UBFX32(&SIM_UIDMH_REG(base), SIM_UIDMH_UID_SHIFT, SIM_UIDMH_UID_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_UIDML - Unique Identification Register Mid Low
 ******************************************************************************/

/*!
 * @brief SIM_UIDML - Unique Identification Register Mid Low (RO)
 *
 * Reset value: 0x00000000U
 *
 * Reset value loaded during System Reset from Flash IFR.
 */
/*!
 * @name Constants and macros for entire SIM_UIDML register
 */
/*@{*/
#define SIM_RD_UIDML(base)       (SIM_UIDML_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDL - Unique Identification Register Low
 ******************************************************************************/

/*!
 * @brief SIM_UIDL - Unique Identification Register Low (RO)
 *
 * Reset value: 0x00000000U
 *
 * Reset value loaded during System Reset from Flash IFR.
 */
/*!
 * @name Constants and macros for entire SIM_UIDL register
 */
/*@{*/
#define SIM_RD_UIDL(base)        (SIM_UIDL_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_COPC - COP Control Register
 ******************************************************************************/

/*!
 * @brief SIM_COPC - COP Control Register (RW)
 *
 * Reset value: 0x0000000CU
 *
 * All of the bits in this register can be written only once after a reset,
 * writing this register will also reset the COP counter.
 */
/*!
 * @name Constants and macros for entire SIM_COPC register
 */
/*@{*/
#define SIM_RD_COPC(base)        (SIM_COPC_REG(base))
#define SIM_WR_COPC(base, value) (SIM_COPC_REG(base) = (value))
#define SIM_RMW_COPC(base, mask, value) (SIM_WR_COPC(base, (SIM_RD_COPC(base) & ~(mask)) | (value)))
#define SIM_SET_COPC(base, value) (BME_OR32(&SIM_COPC_REG(base), (uint32_t)(value)))
#define SIM_CLR_COPC(base, value) (BME_AND32(&SIM_COPC_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_COPC(base, value) (BME_XOR32(&SIM_COPC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_COPC bitfields
 */

/*!
 * @name Register SIM_COPC, field COPW[0] (RW)
 *
 * Windowed mode is supported for all COP clock sources, but only when the COP
 * is configured for a long timeout. The COP window is opened three quarters
 * through the timeout period and will generate a system reset if the COP is serviced
 * outside of that time.
 *
 * Values:
 * - 0b0 - Normal mode
 * - 0b1 - Windowed mode
 */
/*@{*/
/*! @brief Read current value of the SIM_COPC_COPW field. */
#define SIM_RD_COPC_COPW(base) ((SIM_COPC_REG(base) & SIM_COPC_COPW_MASK) >> SIM_COPC_COPW_SHIFT)
#define SIM_BRD_COPC_COPW(base) (BME_UBFX32(&SIM_COPC_REG(base), SIM_COPC_COPW_SHIFT, SIM_COPC_COPW_WIDTH))

/*! @brief Set the COPW field to a new value. */
#define SIM_WR_COPC_COPW(base, value) (SIM_RMW_COPC(base, SIM_COPC_COPW_MASK, SIM_COPC_COPW(value)))
#define SIM_BWR_COPC_COPW(base, value) (BME_BFI32(&SIM_COPC_REG(base), ((uint32_t)(value) << SIM_COPC_COPW_SHIFT), SIM_COPC_COPW_SHIFT, SIM_COPC_COPW_WIDTH))
/*@}*/

/*!
 * @name Register SIM_COPC, field COPCLKS[1] (RW)
 *
 * This write-once field selects between a short timeout or a long timeout, the
 * COP clock source is configured by COPCLKSEL.
 *
 * Values:
 * - 0b0 - COP configured for short timeout
 * - 0b1 - COP configured for long timeout
 */
/*@{*/
/*! @brief Read current value of the SIM_COPC_COPCLKS field. */
#define SIM_RD_COPC_COPCLKS(base) ((SIM_COPC_REG(base) & SIM_COPC_COPCLKS_MASK) >> SIM_COPC_COPCLKS_SHIFT)
#define SIM_BRD_COPC_COPCLKS(base) (BME_UBFX32(&SIM_COPC_REG(base), SIM_COPC_COPCLKS_SHIFT, SIM_COPC_COPCLKS_WIDTH))

/*! @brief Set the COPCLKS field to a new value. */
#define SIM_WR_COPC_COPCLKS(base, value) (SIM_RMW_COPC(base, SIM_COPC_COPCLKS_MASK, SIM_COPC_COPCLKS(value)))
#define SIM_BWR_COPC_COPCLKS(base, value) (BME_BFI32(&SIM_COPC_REG(base), ((uint32_t)(value) << SIM_COPC_COPCLKS_SHIFT), SIM_COPC_COPCLKS_SHIFT, SIM_COPC_COPCLKS_WIDTH))
/*@}*/

/*!
 * @name Register SIM_COPC, field COPT[3:2] (RW)
 *
 * This write-once field selects the timeout period of the COP. COPT along with
 * the COPCLKS field define the COP timeout period.
 *
 * Values:
 * - 0b00 - COP disabled
 * - 0b01 - COP timeout after 25 cycles for short timeout or 213 cycles for long
 *     timeout
 * - 0b10 - COP timeout after 28 cycles for short timeout or 216 cycles for long
 *     timeout
 * - 0b11 - COP timeout after 210 cycles for short timeout or 218 cycles for
 *     long timeout
 */
/*@{*/
/*! @brief Read current value of the SIM_COPC_COPT field. */
#define SIM_RD_COPC_COPT(base) ((SIM_COPC_REG(base) & SIM_COPC_COPT_MASK) >> SIM_COPC_COPT_SHIFT)
#define SIM_BRD_COPC_COPT(base) (BME_UBFX32(&SIM_COPC_REG(base), SIM_COPC_COPT_SHIFT, SIM_COPC_COPT_WIDTH))

/*! @brief Set the COPT field to a new value. */
#define SIM_WR_COPC_COPT(base, value) (SIM_RMW_COPC(base, SIM_COPC_COPT_MASK, SIM_COPC_COPT(value)))
#define SIM_BWR_COPC_COPT(base, value) (BME_BFI32(&SIM_COPC_REG(base), ((uint32_t)(value) << SIM_COPC_COPT_SHIFT), SIM_COPC_COPT_SHIFT, SIM_COPC_COPT_WIDTH))
/*@}*/

/*!
 * @name Register SIM_COPC, field COPSTPEN[4] (RW)
 *
 * Values:
 * - 0b0 - COP is disabled and the counter is reset in Stop modes
 * - 0b1 - COP is enabled in Stop modes
 */
/*@{*/
/*! @brief Read current value of the SIM_COPC_COPSTPEN field. */
#define SIM_RD_COPC_COPSTPEN(base) ((SIM_COPC_REG(base) & SIM_COPC_COPSTPEN_MASK) >> SIM_COPC_COPSTPEN_SHIFT)
#define SIM_BRD_COPC_COPSTPEN(base) (BME_UBFX32(&SIM_COPC_REG(base), SIM_COPC_COPSTPEN_SHIFT, SIM_COPC_COPSTPEN_WIDTH))

/*! @brief Set the COPSTPEN field to a new value. */
#define SIM_WR_COPC_COPSTPEN(base, value) (SIM_RMW_COPC(base, SIM_COPC_COPSTPEN_MASK, SIM_COPC_COPSTPEN(value)))
#define SIM_BWR_COPC_COPSTPEN(base, value) (BME_BFI32(&SIM_COPC_REG(base), ((uint32_t)(value) << SIM_COPC_COPSTPEN_SHIFT), SIM_COPC_COPSTPEN_SHIFT, SIM_COPC_COPSTPEN_WIDTH))
/*@}*/

/*!
 * @name Register SIM_COPC, field COPDBGEN[5] (RW)
 *
 * Values:
 * - 0b0 - COP is disabled and the counter is reset in Debug mode
 * - 0b1 - COP is enabled in Debug mode
 */
/*@{*/
/*! @brief Read current value of the SIM_COPC_COPDBGEN field. */
#define SIM_RD_COPC_COPDBGEN(base) ((SIM_COPC_REG(base) & SIM_COPC_COPDBGEN_MASK) >> SIM_COPC_COPDBGEN_SHIFT)
#define SIM_BRD_COPC_COPDBGEN(base) (BME_UBFX32(&SIM_COPC_REG(base), SIM_COPC_COPDBGEN_SHIFT, SIM_COPC_COPDBGEN_WIDTH))

/*! @brief Set the COPDBGEN field to a new value. */
#define SIM_WR_COPC_COPDBGEN(base, value) (SIM_RMW_COPC(base, SIM_COPC_COPDBGEN_MASK, SIM_COPC_COPDBGEN(value)))
#define SIM_BWR_COPC_COPDBGEN(base, value) (BME_BFI32(&SIM_COPC_REG(base), ((uint32_t)(value) << SIM_COPC_COPDBGEN_SHIFT), SIM_COPC_COPDBGEN_SHIFT, SIM_COPC_COPDBGEN_WIDTH))
/*@}*/

/*!
 * @name Register SIM_COPC, field COPCLKSEL[7:6] (RW)
 *
 * This write-once field selects the clock source of the COP watchdog.
 *
 * Values:
 * - 0b00 - LPO clock (1 kHz)
 * - 0b01 - MCGIRCLK
 * - 0b10 - OSCERCLK
 * - 0b11 - Bus clock
 */
/*@{*/
/*! @brief Read current value of the SIM_COPC_COPCLKSEL field. */
#define SIM_RD_COPC_COPCLKSEL(base) ((SIM_COPC_REG(base) & SIM_COPC_COPCLKSEL_MASK) >> SIM_COPC_COPCLKSEL_SHIFT)
#define SIM_BRD_COPC_COPCLKSEL(base) (BME_UBFX32(&SIM_COPC_REG(base), SIM_COPC_COPCLKSEL_SHIFT, SIM_COPC_COPCLKSEL_WIDTH))

/*! @brief Set the COPCLKSEL field to a new value. */
#define SIM_WR_COPC_COPCLKSEL(base, value) (SIM_RMW_COPC(base, SIM_COPC_COPCLKSEL_MASK, SIM_COPC_COPCLKSEL(value)))
#define SIM_BWR_COPC_COPCLKSEL(base, value) (BME_BFI32(&SIM_COPC_REG(base), ((uint32_t)(value) << SIM_COPC_COPCLKSEL_SHIFT), SIM_COPC_COPCLKSEL_SHIFT, SIM_COPC_COPCLKSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SRVCOP - Service COP
 ******************************************************************************/

/*!
 * @brief SIM_SRVCOP - Service COP (WO)
 *
 * Reset value: 0x00000000U
 *
 * This is write only register, any read to this register will cause transfer
 * error.
 */
/*!
 * @name Constants and macros for entire SIM_SRVCOP register
 */
/*@{*/
#define SIM_WR_SRVCOP(base, value) (SIM_SRVCOP_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual SIM_SRVCOP bitfields
 */

/*!
 * @name Register SIM_SRVCOP, field SRVCOP[7:0] (WO)
 *
 * Write 0x55 and then 0xAA (in that order) to reset the COP timeout counter,
 * writing any other value will generate a system reset.
 */
/*@{*/
/*! @brief Set the SRVCOP field to a new value. */
#define SIM_WR_SRVCOP_SRVCOP(base, value) (SIM_WR_SRVCOP(base, SIM_SRVCOP_SRVCOP(value)))
#define SIM_BWR_SRVCOP_SRVCOP(base, value) (SIM_WR_SRVCOP_SRVCOP(base, value))
/*@}*/

/*
 * MKW40Z4 SMC
 *
 * System Mode Controller
 *
 * Registers defined in this header file:
 * - SMC_PMPROT - Power Mode Protection register
 * - SMC_PMCTRL - Power Mode Control register
 * - SMC_STOPCTRL - Stop Control Register
 * - SMC_PMSTAT - Power Mode Status register
 */

#define SMC_INSTANCE_COUNT (1U) /*!< Number of instances of the SMC module. */
#define SMC_IDX (0U) /*!< Instance number for SMC. */

/*******************************************************************************
 * SMC_PMPROT - Power Mode Protection register
 ******************************************************************************/

/*!
 * @brief SMC_PMPROT - Power Mode Protection register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides protection for entry into any low-power run or stop
 * mode. The enabling of the low-power run or stop mode occurs by configuring the
 * Power Mode Control register (PMCTRL). The PMPROT register can be written only
 * once after any system reset. If the MCU is configured for a disallowed or
 * reserved power mode, the MCU remains in its current power mode. For example, if the
 * MCU is in normal RUN mode and AVLP is 0, an attempt to enter VLPR mode using
 * PMCTRL[RUNM] is blocked and PMCTRL[RUNM] remains 00b, indicating the MCU is
 * still in Normal Run mode. This register is reset on Chip Reset not VLLS and by
 * reset types that trigger Chip Reset not VLLS. It is unaffected by reset types
 * that do not trigger Chip Reset not VLLS. See the Reset section details for more
 * information.
 */
/*!
 * @name Constants and macros for entire SMC_PMPROT register
 */
/*@{*/
#define SMC_RD_PMPROT(base)      (SMC_PMPROT_REG(base))
#define SMC_WR_PMPROT(base, value) (SMC_PMPROT_REG(base) = (value))
#define SMC_RMW_PMPROT(base, mask, value) (SMC_WR_PMPROT(base, (SMC_RD_PMPROT(base) & ~(mask)) | (value)))
#define SMC_SET_PMPROT(base, value) (BME_OR8(&SMC_PMPROT_REG(base), (uint8_t)(value)))
#define SMC_CLR_PMPROT(base, value) (BME_AND8(&SMC_PMPROT_REG(base), (uint8_t)(~(value))))
#define SMC_TOG_PMPROT(base, value) (BME_XOR8(&SMC_PMPROT_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMPROT bitfields
 */

/*!
 * @name Register SMC_PMPROT, field AVLLS[1] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write once
 * bit allows the MCU to enter any very-low-leakage stop mode (VLLSx).
 *
 * Values:
 * - 0b0 - Any VLLSx mode is not allowed
 * - 0b1 - Any VLLSx mode is allowed
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AVLLS field. */
#define SMC_RD_PMPROT_AVLLS(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AVLLS_MASK) >> SMC_PMPROT_AVLLS_SHIFT)
#define SMC_BRD_PMPROT_AVLLS(base) (BME_UBFX8(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLLS_SHIFT, SMC_PMPROT_AVLLS_WIDTH))

/*! @brief Set the AVLLS field to a new value. */
#define SMC_WR_PMPROT_AVLLS(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AVLLS_MASK, SMC_PMPROT_AVLLS(value)))
#define SMC_BWR_PMPROT_AVLLS(base, value) (BME_BFI8(&SMC_PMPROT_REG(base), ((uint8_t)(value) << SMC_PMPROT_AVLLS_SHIFT), SMC_PMPROT_AVLLS_SHIFT, SMC_PMPROT_AVLLS_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field ALLS[3] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * field allows the MCU to enter any low-leakage stop mode (LLS).
 *
 * Values:
 * - 0b0 - Any LLSx mode is not allowed
 * - 0b1 - Any LLSx mode is allowed
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_ALLS field. */
#define SMC_RD_PMPROT_ALLS(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_ALLS_MASK) >> SMC_PMPROT_ALLS_SHIFT)
#define SMC_BRD_PMPROT_ALLS(base) (BME_UBFX8(&SMC_PMPROT_REG(base), SMC_PMPROT_ALLS_SHIFT, SMC_PMPROT_ALLS_WIDTH))

/*! @brief Set the ALLS field to a new value. */
#define SMC_WR_PMPROT_ALLS(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_ALLS_MASK, SMC_PMPROT_ALLS(value)))
#define SMC_BWR_PMPROT_ALLS(base, value) (BME_BFI8(&SMC_PMPROT_REG(base), ((uint8_t)(value) << SMC_PMPROT_ALLS_SHIFT), SMC_PMPROT_ALLS_SHIFT, SMC_PMPROT_ALLS_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field AVLP[5] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * field allows the MCU to enter any very-low-power mode (VLPR, VLPW, and VLPS).
 *
 * Values:
 * - 0b0 - VLPR, VLPW, and VLPS are not allowed.
 * - 0b1 - VLPR, VLPW, and VLPS are allowed.
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AVLP field. */
#define SMC_RD_PMPROT_AVLP(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AVLP_MASK) >> SMC_PMPROT_AVLP_SHIFT)
#define SMC_BRD_PMPROT_AVLP(base) (BME_UBFX8(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLP_SHIFT, SMC_PMPROT_AVLP_WIDTH))

/*! @brief Set the AVLP field to a new value. */
#define SMC_WR_PMPROT_AVLP(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AVLP_MASK, SMC_PMPROT_AVLP(value)))
#define SMC_BWR_PMPROT_AVLP(base, value) (BME_BFI8(&SMC_PMPROT_REG(base), ((uint8_t)(value) << SMC_PMPROT_AVLP_SHIFT), SMC_PMPROT_AVLP_SHIFT, SMC_PMPROT_AVLP_WIDTH))
/*@}*/

/*******************************************************************************
 * SMC_PMCTRL - Power Mode Control register
 ******************************************************************************/

/*!
 * @brief SMC_PMCTRL - Power Mode Control register (RW)
 *
 * Reset value: 0x00U
 *
 * The PMCTRL register controls entry into low-power Run and Stop modes,
 * provided that the selected power mode is allowed via an appropriate setting of the
 * protection (PMPROT) register. This register is reset on Chip POR not VLLS and by
 * reset types that trigger Chip POR not VLLS. It is unaffected by reset types
 * that do not trigger Chip POR not VLLS. See the Reset section details for more
 * information.
 */
/*!
 * @name Constants and macros for entire SMC_PMCTRL register
 */
/*@{*/
#define SMC_RD_PMCTRL(base)      (SMC_PMCTRL_REG(base))
#define SMC_WR_PMCTRL(base, value) (SMC_PMCTRL_REG(base) = (value))
#define SMC_RMW_PMCTRL(base, mask, value) (SMC_WR_PMCTRL(base, (SMC_RD_PMCTRL(base) & ~(mask)) | (value)))
#define SMC_SET_PMCTRL(base, value) (BME_OR8(&SMC_PMCTRL_REG(base), (uint8_t)(value)))
#define SMC_CLR_PMCTRL(base, value) (BME_AND8(&SMC_PMCTRL_REG(base), (uint8_t)(~(value))))
#define SMC_TOG_PMCTRL(base, value) (BME_XOR8(&SMC_PMCTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMCTRL bitfields
 */

/*!
 * @name Register SMC_PMCTRL, field STOPM[2:0] (RW)
 *
 * When written, controls entry into the selected stop mode when Sleep-Now or
 * Sleep-On-Exit mode is entered with SLEEPDEEP=1 . Writes to this field are
 * blocked if the protection level has not been enabled using the PMPROT register.
 * After any system reset, this field is cleared by hardware on any successful write
 * to the PMPROT register. When set to VLLSxor LLSx, the LLSM in the STOPCTRL
 * register is used to further select the particular VLLSor LLS submode which will
 * be entered. When set to STOP, the PSTOPO bits in the STOPCTRL register can be
 * used to select a Partial Stop mode if desired.
 *
 * Values:
 * - 0b000 - Normal Stop (STOP)
 * - 0b001 - Reserved
 * - 0b010 - Very-Low-Power Stop (VLPS)
 * - 0b011 - Low-Leakage Stop (LLSx)
 * - 0b100 - Very-Low-Leakage Stop (VLLSx)
 * - 0b101 - Reserved
 * - 0b110 - Reseved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_STOPM field. */
#define SMC_RD_PMCTRL_STOPM(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_STOPM_MASK) >> SMC_PMCTRL_STOPM_SHIFT)
#define SMC_BRD_PMCTRL_STOPM(base) (BME_UBFX8(&SMC_PMCTRL_REG(base), SMC_PMCTRL_STOPM_SHIFT, SMC_PMCTRL_STOPM_WIDTH))

/*! @brief Set the STOPM field to a new value. */
#define SMC_WR_PMCTRL_STOPM(base, value) (SMC_RMW_PMCTRL(base, SMC_PMCTRL_STOPM_MASK, SMC_PMCTRL_STOPM(value)))
#define SMC_BWR_PMCTRL_STOPM(base, value) (BME_BFI8(&SMC_PMCTRL_REG(base), ((uint8_t)(value) << SMC_PMCTRL_STOPM_SHIFT), SMC_PMCTRL_STOPM_SHIFT, SMC_PMCTRL_STOPM_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field STOPA[3] (RO)
 *
 * When set, this read-only status bit indicates an interrupt or reset occured
 * during the previous stop mode entry sequence, preventing the system from
 * entering that mode. This field is cleared by hardware at the beginning of any stop
 * mode entry sequence and is set if the sequence was aborted.
 *
 * Values:
 * - 0b0 - The previous stop mode entry was successsful.
 * - 0b1 - The previous stop mode entry was aborted.
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_STOPA field. */
#define SMC_RD_PMCTRL_STOPA(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_STOPA_MASK) >> SMC_PMCTRL_STOPA_SHIFT)
#define SMC_BRD_PMCTRL_STOPA(base) (BME_UBFX8(&SMC_PMCTRL_REG(base), SMC_PMCTRL_STOPA_SHIFT, SMC_PMCTRL_STOPA_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field RUNM[6:5] (RW)
 *
 * When written, causes entry into the selected run mode. Writes to this field
 * are blocked if the protection level has not been enabled using the PMPROT
 * register. RUNM may be set to VLPR only when PMSTAT=RUN. After being written to
 * VLPR, RUNM should not be written back to RUN until PMSTAT=VLPR.
 *
 * Values:
 * - 0b00 - Normal Run mode (RUN)
 * - 0b01 - Reserved
 * - 0b10 - Very-Low-Power Run mode (VLPR)
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_RUNM field. */
#define SMC_RD_PMCTRL_RUNM(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_RUNM_MASK) >> SMC_PMCTRL_RUNM_SHIFT)
#define SMC_BRD_PMCTRL_RUNM(base) (BME_UBFX8(&SMC_PMCTRL_REG(base), SMC_PMCTRL_RUNM_SHIFT, SMC_PMCTRL_RUNM_WIDTH))

/*! @brief Set the RUNM field to a new value. */
#define SMC_WR_PMCTRL_RUNM(base, value) (SMC_RMW_PMCTRL(base, SMC_PMCTRL_RUNM_MASK, SMC_PMCTRL_RUNM(value)))
#define SMC_BWR_PMCTRL_RUNM(base, value) (BME_BFI8(&SMC_PMCTRL_REG(base), ((uint8_t)(value) << SMC_PMCTRL_RUNM_SHIFT), SMC_PMCTRL_RUNM_SHIFT, SMC_PMCTRL_RUNM_WIDTH))
/*@}*/

/*******************************************************************************
 * SMC_STOPCTRL - Stop Control Register
 ******************************************************************************/

/*!
 * @brief SMC_STOPCTRL - Stop Control Register (RW)
 *
 * Reset value: 0x03U
 *
 * The STOPCTRL register provides various control bits allowing the user to fine
 * tune power consumption during the stop mode selected by the STOPM field. This
 * register is reset on Chip POR not VLLS and by reset types that trigger Chip
 * POR not VLLS. It is unaffected by reset types that do not trigger Chip POR not
 * VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire SMC_STOPCTRL register
 */
/*@{*/
#define SMC_RD_STOPCTRL(base)    (SMC_STOPCTRL_REG(base))
#define SMC_WR_STOPCTRL(base, value) (SMC_STOPCTRL_REG(base) = (value))
#define SMC_RMW_STOPCTRL(base, mask, value) (SMC_WR_STOPCTRL(base, (SMC_RD_STOPCTRL(base) & ~(mask)) | (value)))
#define SMC_SET_STOPCTRL(base, value) (BME_OR8(&SMC_STOPCTRL_REG(base), (uint8_t)(value)))
#define SMC_CLR_STOPCTRL(base, value) (BME_AND8(&SMC_STOPCTRL_REG(base), (uint8_t)(~(value))))
#define SMC_TOG_STOPCTRL(base, value) (BME_XOR8(&SMC_STOPCTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SMC_STOPCTRL bitfields
 */

/*!
 * @name Register SMC_STOPCTRL, field LLSM[2:0] (RW)
 *
 * This field controls which LLS orVLLS sub-mode to enter if STOPM = LLSx
 * orVLLSx.
 *
 * Values:
 * - 0b000 - VLLS0 if PMCTRL[STOPM]=VLLSx, reserved if PMCTRL[STOPM]=LLSx
 * - 0b001 - VLLS1 if PMCTRL[STOPM]=VLLSx, reserved if PMCTRL[STOPM]=LLSx
 * - 0b010 - VLLS2 if PMCTRL[STOPM]=VLLSx, LLS2 if PMCTRL[STOPM]=LLSx
 * - 0b011 - VLLS3 if PMCTRL[STOPM]=VLLSx, LLS3 if PMCTRL[STOPM]=LLSx
 * - 0b100 - Reserved
 * - 0b101 - Reserved
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_LLSM field. */
#define SMC_RD_STOPCTRL_LLSM(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_LLSM_MASK) >> SMC_STOPCTRL_LLSM_SHIFT)
#define SMC_BRD_STOPCTRL_LLSM(base) (BME_UBFX8(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_LLSM_SHIFT, SMC_STOPCTRL_LLSM_WIDTH))

/*! @brief Set the LLSM field to a new value. */
#define SMC_WR_STOPCTRL_LLSM(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_LLSM_MASK, SMC_STOPCTRL_LLSM(value)))
#define SMC_BWR_STOPCTRL_LLSM(base, value) (BME_BFI8(&SMC_STOPCTRL_REG(base), ((uint8_t)(value) << SMC_STOPCTRL_LLSM_SHIFT), SMC_STOPCTRL_LLSM_SHIFT, SMC_STOPCTRL_LLSM_WIDTH))
/*@}*/

/*!
 * @name Register SMC_STOPCTRL, field PORPO[5] (RW)
 *
 * This bit controls whether the POR detect circuit is enabled in VLLS0 mode.
 *
 * Values:
 * - 0b0 - POR detect circuit is enabled in VLLS0
 * - 0b1 - POR detect circuit is disabled in VLLS0
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_PORPO field. */
#define SMC_RD_STOPCTRL_PORPO(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_PORPO_MASK) >> SMC_STOPCTRL_PORPO_SHIFT)
#define SMC_BRD_STOPCTRL_PORPO(base) (BME_UBFX8(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_PORPO_SHIFT, SMC_STOPCTRL_PORPO_WIDTH))

/*! @brief Set the PORPO field to a new value. */
#define SMC_WR_STOPCTRL_PORPO(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_PORPO_MASK, SMC_STOPCTRL_PORPO(value)))
#define SMC_BWR_STOPCTRL_PORPO(base, value) (BME_BFI8(&SMC_STOPCTRL_REG(base), ((uint8_t)(value) << SMC_STOPCTRL_PORPO_SHIFT), SMC_STOPCTRL_PORPO_SHIFT, SMC_STOPCTRL_PORPO_WIDTH))
/*@}*/

/*!
 * @name Register SMC_STOPCTRL, field PSTOPO[7:6] (RW)
 *
 * These bits control whether a Partial Stop mode is entered when STOPM=STOP.
 * When entering a Partial Stop mode from RUN (or VLPR) mode, the PMC, MCG and
 * flash remain fully powered, allowing the device to wakeup almost instantaneously
 * at the expense of higher power consumption. In PSTOP2, only system clocks are
 * gated allowing peripherals running on bus clock to remain fully functional. In
 * PSTOP1, both system and bus clocks are gated.
 *
 * Values:
 * - 0b00 - STOP - Normal Stop mode
 * - 0b01 - PSTOP1 - Partial Stop with both system and bus clocks disabled
 * - 0b10 - PSTOP2 - Partial Stop with system clock disabled and bus clock
 *     enabled
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_PSTOPO field. */
#define SMC_RD_STOPCTRL_PSTOPO(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_PSTOPO_MASK) >> SMC_STOPCTRL_PSTOPO_SHIFT)
#define SMC_BRD_STOPCTRL_PSTOPO(base) (BME_UBFX8(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_PSTOPO_SHIFT, SMC_STOPCTRL_PSTOPO_WIDTH))

/*! @brief Set the PSTOPO field to a new value. */
#define SMC_WR_STOPCTRL_PSTOPO(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_PSTOPO_MASK, SMC_STOPCTRL_PSTOPO(value)))
#define SMC_BWR_STOPCTRL_PSTOPO(base, value) (BME_BFI8(&SMC_STOPCTRL_REG(base), ((uint8_t)(value) << SMC_STOPCTRL_PSTOPO_SHIFT), SMC_STOPCTRL_PSTOPO_SHIFT, SMC_STOPCTRL_PSTOPO_WIDTH))
/*@}*/

/*******************************************************************************
 * SMC_PMSTAT - Power Mode Status register
 ******************************************************************************/

/*!
 * @brief SMC_PMSTAT - Power Mode Status register (RO)
 *
 * Reset value: 0x01U
 *
 * PMSTAT is a read-only, one-hot register which indicates the current power
 * mode of the system. This register is reset on Chip POR not VLLS and by reset
 * types that trigger Chip POR not VLLS. It is unaffected by reset types that do not
 * trigger Chip POR not VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire SMC_PMSTAT register
 */
/*@{*/
#define SMC_RD_PMSTAT(base)      (SMC_PMSTAT_REG(base))
/*@}*/

/*
 * MKW40Z4 SPI
 *
 * Serial Peripheral Interface
 *
 * Registers defined in this header file:
 * - SPI_MCR - Module Configuration Register
 * - SPI_TCR - Transfer Count Register
 * - SPI_CTAR - Clock and Transfer Attributes Register (In Master Mode)
 * - SPI_CTAR_SLAVE - Clock and Transfer Attributes Register (In Slave Mode)
 * - SPI_SR - Status Register
 * - SPI_RSER - DMA/Interrupt Request Select and Enable Register
 * - SPI_PUSHR - PUSH TX FIFO Register In Master Mode
 * - SPI_PUSHR_SLAVE - PUSH TX FIFO Register In Slave Mode
 * - SPI_POPR - POP RX FIFO Register
 * - SPI_TXFR0 - Transmit FIFO Registers
 * - SPI_TXFR1 - Transmit FIFO Registers
 * - SPI_TXFR2 - Transmit FIFO Registers
 * - SPI_TXFR3 - Transmit FIFO Registers
 * - SPI_RXFR0 - Receive FIFO Registers
 * - SPI_RXFR1 - Receive FIFO Registers
 * - SPI_RXFR2 - Receive FIFO Registers
 * - SPI_RXFR3 - Receive FIFO Registers
 */

#define SPI_INSTANCE_COUNT (2U) /*!< Number of instances of the SPI module. */
#define SPI0_IDX (0U) /*!< Instance number for SPI0. */
#define SPI1_IDX (1U) /*!< Instance number for SPI1. */

/*******************************************************************************
 * SPI_MCR - Module Configuration Register
 ******************************************************************************/

/*!
 * @brief SPI_MCR - Module Configuration Register (RW)
 *
 * Reset value: 0x00004001U
 *
 * Contains bits to configure various attributes associated with the module
 * operations. The HALT and MDIS bits can be changed at any time, but the effect
 * takes place only on the next frame boundary. Only the HALT and MDIS bits in the
 * MCR can be changed, while the module is in the Running state.
 */
/*!
 * @name Constants and macros for entire SPI_MCR register
 */
/*@{*/
#define SPI_RD_MCR(base)         (SPI_MCR_REG(base))
#define SPI_WR_MCR(base, value)  (SPI_MCR_REG(base) = (value))
#define SPI_RMW_MCR(base, mask, value) (SPI_WR_MCR(base, (SPI_RD_MCR(base) & ~(mask)) | (value)))
#define SPI_SET_MCR(base, value) (BME_OR32(&SPI_MCR_REG(base), (uint32_t)(value)))
#define SPI_CLR_MCR(base, value) (BME_AND32(&SPI_MCR_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_MCR(base, value) (BME_XOR32(&SPI_MCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_MCR bitfields
 */

/*!
 * @name Register SPI_MCR, field HALT[0] (RW)
 *
 * The HALT bit starts and stops frame transfers. See Start and Stop of Module
 * transfers
 *
 * Values:
 * - 0b0 - Start transfers.
 * - 0b1 - Stop transfers.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_HALT field. */
#define SPI_RD_MCR_HALT(base) ((SPI_MCR_REG(base) & SPI_MCR_HALT_MASK) >> SPI_MCR_HALT_SHIFT)
#define SPI_BRD_MCR_HALT(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_HALT_SHIFT, SPI_MCR_HALT_WIDTH))

/*! @brief Set the HALT field to a new value. */
#define SPI_WR_MCR_HALT(base, value) (SPI_RMW_MCR(base, SPI_MCR_HALT_MASK, SPI_MCR_HALT(value)))
#define SPI_BWR_MCR_HALT(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_HALT_SHIFT), SPI_MCR_HALT_SHIFT, SPI_MCR_HALT_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field SMPL_PT[9:8] (RW)
 *
 * Controls when the module master samples SIN in Modified Transfer Format. This
 * field is valid only when CPHA bit in CTARn[CPHA] is 0.
 *
 * Values:
 * - 0b00 - 0 protocol clock cycles between SCK edge and SIN sample
 * - 0b01 - 1 protocol clock cycle between SCK edge and SIN sample
 * - 0b10 - 2 protocol clock cycles between SCK edge and SIN sample
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_SMPL_PT field. */
#define SPI_RD_MCR_SMPL_PT(base) ((SPI_MCR_REG(base) & SPI_MCR_SMPL_PT_MASK) >> SPI_MCR_SMPL_PT_SHIFT)
#define SPI_BRD_MCR_SMPL_PT(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_SMPL_PT_SHIFT, SPI_MCR_SMPL_PT_WIDTH))

/*! @brief Set the SMPL_PT field to a new value. */
#define SPI_WR_MCR_SMPL_PT(base, value) (SPI_RMW_MCR(base, SPI_MCR_SMPL_PT_MASK, SPI_MCR_SMPL_PT(value)))
#define SPI_BWR_MCR_SMPL_PT(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_SMPL_PT_SHIFT), SPI_MCR_SMPL_PT_SHIFT, SPI_MCR_SMPL_PT_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field CLR_RXF[10] (WORZ)
 *
 * Flushes the RX FIFO. Writing a 1 to CLR_RXF clears the RX Counter. The
 * CLR_RXF bit is always read as zero.
 *
 * Values:
 * - 0b0 - Do not clear the RX FIFO counter.
 * - 0b1 - Clear the RX FIFO counter.
 */
/*@{*/
/*! @brief Set the CLR_RXF field to a new value. */
#define SPI_WR_MCR_CLR_RXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_CLR_RXF_MASK, SPI_MCR_CLR_RXF(value)))
#define SPI_BWR_MCR_CLR_RXF(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_CLR_RXF_SHIFT), SPI_MCR_CLR_RXF_SHIFT, SPI_MCR_CLR_RXF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field CLR_TXF[11] (WORZ)
 *
 * Flushes the TX FIFO. Writing a 1 to CLR_TXF clears the TX FIFO Counter. The
 * CLR_TXF bit is always read as zero.
 *
 * Values:
 * - 0b0 - Do not clear the TX FIFO counter.
 * - 0b1 - Clear the TX FIFO counter.
 */
/*@{*/
/*! @brief Set the CLR_TXF field to a new value. */
#define SPI_WR_MCR_CLR_TXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_CLR_TXF_MASK, SPI_MCR_CLR_TXF(value)))
#define SPI_BWR_MCR_CLR_TXF(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_CLR_TXF_SHIFT), SPI_MCR_CLR_TXF_SHIFT, SPI_MCR_CLR_TXF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field DIS_RXF[12] (RW)
 *
 * When the RX FIFO is disabled, the receive part of the module operates as a
 * simplified double-buffered SPI. This bit can only be written when the MDIS bit
 * is cleared.
 *
 * Values:
 * - 0b0 - RX FIFO is enabled.
 * - 0b1 - RX FIFO is disabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DIS_RXF field. */
#define SPI_RD_MCR_DIS_RXF(base) ((SPI_MCR_REG(base) & SPI_MCR_DIS_RXF_MASK) >> SPI_MCR_DIS_RXF_SHIFT)
#define SPI_BRD_MCR_DIS_RXF(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_DIS_RXF_SHIFT, SPI_MCR_DIS_RXF_WIDTH))

/*! @brief Set the DIS_RXF field to a new value. */
#define SPI_WR_MCR_DIS_RXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_DIS_RXF_MASK, SPI_MCR_DIS_RXF(value)))
#define SPI_BWR_MCR_DIS_RXF(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_DIS_RXF_SHIFT), SPI_MCR_DIS_RXF_SHIFT, SPI_MCR_DIS_RXF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field DIS_TXF[13] (RW)
 *
 * When the TX FIFO is disabled, the transmit part of the module operates as a
 * simplified double-buffered SPI. This bit can be written only when the MDIS bit
 * is cleared.
 *
 * Values:
 * - 0b0 - TX FIFO is enabled.
 * - 0b1 - TX FIFO is disabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DIS_TXF field. */
#define SPI_RD_MCR_DIS_TXF(base) ((SPI_MCR_REG(base) & SPI_MCR_DIS_TXF_MASK) >> SPI_MCR_DIS_TXF_SHIFT)
#define SPI_BRD_MCR_DIS_TXF(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_DIS_TXF_SHIFT, SPI_MCR_DIS_TXF_WIDTH))

/*! @brief Set the DIS_TXF field to a new value. */
#define SPI_WR_MCR_DIS_TXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_DIS_TXF_MASK, SPI_MCR_DIS_TXF(value)))
#define SPI_BWR_MCR_DIS_TXF(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_DIS_TXF_SHIFT), SPI_MCR_DIS_TXF_SHIFT, SPI_MCR_DIS_TXF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field MDIS[14] (RW)
 *
 * Allows the clock to be stopped to the non-memory mapped logic in the module
 * effectively putting it in a software-controlled power-saving state. The reset
 * value of the MDIS bit is parameterized, with a default reset value of 0. When
 * the module is used in Slave Mode, it is recommended to leave this bit 0,
 * because a slave doesn't have control over master transactions.
 *
 * Values:
 * - 0b0 - Enables the module clocks.
 * - 0b1 - Allows external logic to disable the module clocks.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_MDIS field. */
#define SPI_RD_MCR_MDIS(base) ((SPI_MCR_REG(base) & SPI_MCR_MDIS_MASK) >> SPI_MCR_MDIS_SHIFT)
#define SPI_BRD_MCR_MDIS(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_MDIS_SHIFT, SPI_MCR_MDIS_WIDTH))

/*! @brief Set the MDIS field to a new value. */
#define SPI_WR_MCR_MDIS(base, value) (SPI_RMW_MCR(base, SPI_MCR_MDIS_MASK, SPI_MCR_MDIS(value)))
#define SPI_BWR_MCR_MDIS(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_MDIS_SHIFT), SPI_MCR_MDIS_SHIFT, SPI_MCR_MDIS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field DOZE[15] (RW)
 *
 * Provides support for an externally controlled Doze mode power-saving
 * mechanism.
 *
 * Values:
 * - 0b0 - Doze mode has no effect on the module.
 * - 0b1 - Doze mode disables the module.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DOZE field. */
#define SPI_RD_MCR_DOZE(base) ((SPI_MCR_REG(base) & SPI_MCR_DOZE_MASK) >> SPI_MCR_DOZE_SHIFT)
#define SPI_BRD_MCR_DOZE(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_DOZE_SHIFT, SPI_MCR_DOZE_WIDTH))

/*! @brief Set the DOZE field to a new value. */
#define SPI_WR_MCR_DOZE(base, value) (SPI_RMW_MCR(base, SPI_MCR_DOZE_MASK, SPI_MCR_DOZE(value)))
#define SPI_BWR_MCR_DOZE(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_DOZE_SHIFT), SPI_MCR_DOZE_SHIFT, SPI_MCR_DOZE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field PCSIS[19:16] (RW)
 *
 * Determines the inactive state of PCSx. Refer to the chip-specific SPI
 * information for the number of PCS signals used in this MCU.
 *
 * Values:
 * - 0b0000 - The inactive state of PCSx is low.
 * - 0b0001 - The inactive state of PCSx is high.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_PCSIS field. */
#define SPI_RD_MCR_PCSIS(base) ((SPI_MCR_REG(base) & SPI_MCR_PCSIS_MASK) >> SPI_MCR_PCSIS_SHIFT)
#define SPI_BRD_MCR_PCSIS(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_PCSIS_SHIFT, SPI_MCR_PCSIS_WIDTH))

/*! @brief Set the PCSIS field to a new value. */
#define SPI_WR_MCR_PCSIS(base, value) (SPI_RMW_MCR(base, SPI_MCR_PCSIS_MASK, SPI_MCR_PCSIS(value)))
#define SPI_BWR_MCR_PCSIS(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_PCSIS_SHIFT), SPI_MCR_PCSIS_SHIFT, SPI_MCR_PCSIS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field ROOE[24] (RW)
 *
 * In the RX FIFO overflow condition, configures the module to ignore the
 * incoming serial data or overwrite existing data. If the RX FIFO is full and new data
 * is received, the data from the transfer, generating the overflow, is ignored
 * or shifted into the shift register.
 *
 * Values:
 * - 0b0 - Incoming data is ignored.
 * - 0b1 - Incoming data is shifted into the shift register.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_ROOE field. */
#define SPI_RD_MCR_ROOE(base) ((SPI_MCR_REG(base) & SPI_MCR_ROOE_MASK) >> SPI_MCR_ROOE_SHIFT)
#define SPI_BRD_MCR_ROOE(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_ROOE_SHIFT, SPI_MCR_ROOE_WIDTH))

/*! @brief Set the ROOE field to a new value. */
#define SPI_WR_MCR_ROOE(base, value) (SPI_RMW_MCR(base, SPI_MCR_ROOE_MASK, SPI_MCR_ROOE(value)))
#define SPI_BWR_MCR_ROOE(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_ROOE_SHIFT), SPI_MCR_ROOE_SHIFT, SPI_MCR_ROOE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field MTFE[26] (RW)
 *
 * Enables a modified transfer format to be used.
 *
 * Values:
 * - 0b0 - Modified SPI transfer format disabled.
 * - 0b1 - Modified SPI transfer format enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_MTFE field. */
#define SPI_RD_MCR_MTFE(base) ((SPI_MCR_REG(base) & SPI_MCR_MTFE_MASK) >> SPI_MCR_MTFE_SHIFT)
#define SPI_BRD_MCR_MTFE(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_MTFE_SHIFT, SPI_MCR_MTFE_WIDTH))

/*! @brief Set the MTFE field to a new value. */
#define SPI_WR_MCR_MTFE(base, value) (SPI_RMW_MCR(base, SPI_MCR_MTFE_MASK, SPI_MCR_MTFE(value)))
#define SPI_BWR_MCR_MTFE(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_MTFE_SHIFT), SPI_MCR_MTFE_SHIFT, SPI_MCR_MTFE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field FRZ[27] (RW)
 *
 * Enables transfers to be stopped on the next frame boundary when the device
 * enters Debug mode.
 *
 * Values:
 * - 0b0 - Do not halt serial transfers in Debug mode.
 * - 0b1 - Halt serial transfers in Debug mode.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_FRZ field. */
#define SPI_RD_MCR_FRZ(base) ((SPI_MCR_REG(base) & SPI_MCR_FRZ_MASK) >> SPI_MCR_FRZ_SHIFT)
#define SPI_BRD_MCR_FRZ(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_FRZ_SHIFT, SPI_MCR_FRZ_WIDTH))

/*! @brief Set the FRZ field to a new value. */
#define SPI_WR_MCR_FRZ(base, value) (SPI_RMW_MCR(base, SPI_MCR_FRZ_MASK, SPI_MCR_FRZ(value)))
#define SPI_BWR_MCR_FRZ(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_FRZ_SHIFT), SPI_MCR_FRZ_SHIFT, SPI_MCR_FRZ_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field DCONF[29:28] (RO)
 *
 * Selects among the different configurations of the module.
 *
 * Values:
 * - 0b00 - SPI
 * - 0b01 - Reserved
 * - 0b10 - Reserved
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DCONF field. */
#define SPI_RD_MCR_DCONF(base) ((SPI_MCR_REG(base) & SPI_MCR_DCONF_MASK) >> SPI_MCR_DCONF_SHIFT)
#define SPI_BRD_MCR_DCONF(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_DCONF_SHIFT, SPI_MCR_DCONF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field CONT_SCKE[30] (RW)
 *
 * Enables the Serial Communication Clock (SCK) to run continuously.
 *
 * Values:
 * - 0b0 - Continuous SCK disabled.
 * - 0b1 - Continuous SCK enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_CONT_SCKE field. */
#define SPI_RD_MCR_CONT_SCKE(base) ((SPI_MCR_REG(base) & SPI_MCR_CONT_SCKE_MASK) >> SPI_MCR_CONT_SCKE_SHIFT)
#define SPI_BRD_MCR_CONT_SCKE(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_CONT_SCKE_SHIFT, SPI_MCR_CONT_SCKE_WIDTH))

/*! @brief Set the CONT_SCKE field to a new value. */
#define SPI_WR_MCR_CONT_SCKE(base, value) (SPI_RMW_MCR(base, SPI_MCR_CONT_SCKE_MASK, SPI_MCR_CONT_SCKE(value)))
#define SPI_BWR_MCR_CONT_SCKE(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_CONT_SCKE_SHIFT), SPI_MCR_CONT_SCKE_SHIFT, SPI_MCR_CONT_SCKE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field MSTR[31] (RW)
 *
 * Enables either Master mode (if supported) or Slave mode (if supported)
 * operation.
 *
 * Values:
 * - 0b0 - Enables Slave mode
 * - 0b1 - Enables Master mode
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_MSTR field. */
#define SPI_RD_MCR_MSTR(base) ((SPI_MCR_REG(base) & SPI_MCR_MSTR_MASK) >> SPI_MCR_MSTR_SHIFT)
#define SPI_BRD_MCR_MSTR(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_MSTR_SHIFT, SPI_MCR_MSTR_WIDTH))

/*! @brief Set the MSTR field to a new value. */
#define SPI_WR_MCR_MSTR(base, value) (SPI_RMW_MCR(base, SPI_MCR_MSTR_MASK, SPI_MCR_MSTR(value)))
#define SPI_BWR_MCR_MSTR(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_MSTR_SHIFT), SPI_MCR_MSTR_SHIFT, SPI_MCR_MSTR_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_TCR - Transfer Count Register
 ******************************************************************************/

/*!
 * @brief SPI_TCR - Transfer Count Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TCR contains a counter that indicates the number of SPI transfers made. The
 * transfer counter is intended to assist in queue management. Do not write the
 * TCR when the module is in the Running state.
 */
/*!
 * @name Constants and macros for entire SPI_TCR register
 */
/*@{*/
#define SPI_RD_TCR(base)         (SPI_TCR_REG(base))
#define SPI_WR_TCR(base, value)  (SPI_TCR_REG(base) = (value))
#define SPI_RMW_TCR(base, mask, value) (SPI_WR_TCR(base, (SPI_RD_TCR(base) & ~(mask)) | (value)))
#define SPI_SET_TCR(base, value) (BME_OR32(&SPI_TCR_REG(base), (uint32_t)(value)))
#define SPI_CLR_TCR(base, value) (BME_AND32(&SPI_TCR_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_TCR(base, value) (BME_XOR32(&SPI_TCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_TCR bitfields
 */

/*!
 * @name Register SPI_TCR, field SPI_TCNT[31:16] (RW)
 *
 * Counts the number of SPI transfers the module makes. The SPI_TCNT field
 * increments every time the last bit of an SPI frame is transmitted. A value written
 * to SPI_TCNT presets the counter to that value. SPI_TCNT is reset to zero at
 * the beginning of the frame when the CTCNT field is set in the executing SPI
 * command. The Transfer Counter wraps around; incrementing the counter past 65535
 * resets the counter to zero.
 */
/*@{*/
/*! @brief Read current value of the SPI_TCR_SPI_TCNT field. */
#define SPI_RD_TCR_SPI_TCNT(base) ((SPI_TCR_REG(base) & SPI_TCR_SPI_TCNT_MASK) >> SPI_TCR_SPI_TCNT_SHIFT)
#define SPI_BRD_TCR_SPI_TCNT(base) (BME_UBFX32(&SPI_TCR_REG(base), SPI_TCR_SPI_TCNT_SHIFT, SPI_TCR_SPI_TCNT_WIDTH))

/*! @brief Set the SPI_TCNT field to a new value. */
#define SPI_WR_TCR_SPI_TCNT(base, value) (SPI_RMW_TCR(base, SPI_TCR_SPI_TCNT_MASK, SPI_TCR_SPI_TCNT(value)))
#define SPI_BWR_TCR_SPI_TCNT(base, value) (BME_BFI32(&SPI_TCR_REG(base), ((uint32_t)(value) << SPI_TCR_SPI_TCNT_SHIFT), SPI_TCR_SPI_TCNT_SHIFT, SPI_TCR_SPI_TCNT_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_CTAR_SLAVE - Clock and Transfer Attributes Register (In Slave Mode)
 ******************************************************************************/

/*!
 * @brief SPI_CTAR_SLAVE - Clock and Transfer Attributes Register (In Slave Mode) (RW)
 *
 * Reset value: 0x78000000U
 *
 * When the module is configured as an SPI bus slave, the CTAR0 register is used.
 */
/*!
 * @name Constants and macros for entire SPI_CTAR_SLAVE register
 */
/*@{*/
#define SPI_RD_CTAR_SLAVE(base, index) (SPI_CTAR_SLAVE_REG(base, index))
#define SPI_WR_CTAR_SLAVE(base, index, value) (SPI_CTAR_SLAVE_REG(base, index) = (value))
#define SPI_RMW_CTAR_SLAVE(base, index, mask, value) (SPI_WR_CTAR_SLAVE(base, index, (SPI_RD_CTAR_SLAVE(base, index) & ~(mask)) | (value)))
#define SPI_SET_CTAR_SLAVE(base, index, value) (BME_OR32(&SPI_CTAR_SLAVE_REG(base, index), (uint32_t)(value)))
#define SPI_CLR_CTAR_SLAVE(base, index, value) (BME_AND32(&SPI_CTAR_SLAVE_REG(base, index), (uint32_t)(~(value))))
#define SPI_TOG_CTAR_SLAVE(base, index, value) (BME_XOR32(&SPI_CTAR_SLAVE_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_CTAR_SLAVE bitfields
 */

/*!
 * @name Register SPI_CTAR_SLAVE, field CPHA[25] (RW)
 *
 * Selects which edge of SCK causes data to change and which edge causes data to
 * be captured. This bit is used in both master and slave mode. For successful
 * communication between serial devices, the devices must have identical clock
 * phase settings. In Continuous SCK mode, the bit value is ignored and the
 * transfers are done as if the CPHA bit is set to 1.
 *
 * Values:
 * - 0b0 - Data is captured on the leading edge of SCK and changed on the
 *     following edge.
 * - 0b1 - Data is changed on the leading edge of SCK and captured on the
 *     following edge.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_SLAVE_CPHA field. */
#define SPI_RD_CTAR_SLAVE_CPHA(base, index) ((SPI_CTAR_SLAVE_REG(base, index) & SPI_CTAR_SLAVE_CPHA_MASK) >> SPI_CTAR_SLAVE_CPHA_SHIFT)
#define SPI_BRD_CTAR_SLAVE_CPHA(base, index) (BME_UBFX32(&SPI_CTAR_SLAVE_REG(base, index), SPI_CTAR_SLAVE_CPHA_SHIFT, SPI_CTAR_SLAVE_CPHA_WIDTH))

/*! @brief Set the CPHA field to a new value. */
#define SPI_WR_CTAR_SLAVE_CPHA(base, index, value) (SPI_RMW_CTAR_SLAVE(base, index, SPI_CTAR_SLAVE_CPHA_MASK, SPI_CTAR_SLAVE_CPHA(value)))
#define SPI_BWR_CTAR_SLAVE_CPHA(base, index, value) (BME_BFI32(&SPI_CTAR_SLAVE_REG(base, index), ((uint32_t)(value) << SPI_CTAR_SLAVE_CPHA_SHIFT), SPI_CTAR_SLAVE_CPHA_SHIFT, SPI_CTAR_SLAVE_CPHA_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR_SLAVE, field CPOL[26] (RW)
 *
 * Selects the inactive state of the Serial Communications Clock (SCK). In case
 * of Continuous SCK mode, when the module goes in low power mode(disabled),
 * inactive state of SCK is not guaranted.
 *
 * Values:
 * - 0b0 - The inactive state value of SCK is low.
 * - 0b1 - The inactive state value of SCK is high.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_SLAVE_CPOL field. */
#define SPI_RD_CTAR_SLAVE_CPOL(base, index) ((SPI_CTAR_SLAVE_REG(base, index) & SPI_CTAR_SLAVE_CPOL_MASK) >> SPI_CTAR_SLAVE_CPOL_SHIFT)
#define SPI_BRD_CTAR_SLAVE_CPOL(base, index) (BME_UBFX32(&SPI_CTAR_SLAVE_REG(base, index), SPI_CTAR_SLAVE_CPOL_SHIFT, SPI_CTAR_SLAVE_CPOL_WIDTH))

/*! @brief Set the CPOL field to a new value. */
#define SPI_WR_CTAR_SLAVE_CPOL(base, index, value) (SPI_RMW_CTAR_SLAVE(base, index, SPI_CTAR_SLAVE_CPOL_MASK, SPI_CTAR_SLAVE_CPOL(value)))
#define SPI_BWR_CTAR_SLAVE_CPOL(base, index, value) (BME_BFI32(&SPI_CTAR_SLAVE_REG(base, index), ((uint32_t)(value) << SPI_CTAR_SLAVE_CPOL_SHIFT), SPI_CTAR_SLAVE_CPOL_SHIFT, SPI_CTAR_SLAVE_CPOL_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR_SLAVE, field FMSZ[30:27] (RW)
 *
 * The number of bits transfered per frame is equal to the FMSZ field value plus
 * 1. Note that the minimum valid value of frame size is 4.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_SLAVE_FMSZ field. */
#define SPI_RD_CTAR_SLAVE_FMSZ(base, index) ((SPI_CTAR_SLAVE_REG(base, index) & SPI_CTAR_SLAVE_FMSZ_MASK) >> SPI_CTAR_SLAVE_FMSZ_SHIFT)
#define SPI_BRD_CTAR_SLAVE_FMSZ(base, index) (BME_UBFX32(&SPI_CTAR_SLAVE_REG(base, index), SPI_CTAR_SLAVE_FMSZ_SHIFT, SPI_CTAR_SLAVE_FMSZ_WIDTH))

/*! @brief Set the FMSZ field to a new value. */
#define SPI_WR_CTAR_SLAVE_FMSZ(base, index, value) (SPI_RMW_CTAR_SLAVE(base, index, SPI_CTAR_SLAVE_FMSZ_MASK, SPI_CTAR_SLAVE_FMSZ(value)))
#define SPI_BWR_CTAR_SLAVE_FMSZ(base, index, value) (BME_BFI32(&SPI_CTAR_SLAVE_REG(base, index), ((uint32_t)(value) << SPI_CTAR_SLAVE_FMSZ_SHIFT), SPI_CTAR_SLAVE_FMSZ_SHIFT, SPI_CTAR_SLAVE_FMSZ_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_CTAR - Clock and Transfer Attributes Register (In Master Mode)
 ******************************************************************************/

/*!
 * @brief SPI_CTAR - Clock and Transfer Attributes Register (In Master Mode) (RW)
 *
 * Reset value: 0x78000000U
 *
 * CTAR registers are used to define different transfer attributes. The number
 * of CTAR registers is parameterized in the RTL and can be from two to eight
 * registers. Do not write to the CTAR registers while the module is in the Running
 * state. In Master mode, the CTAR registers define combinations of transfer
 * attributes such as frame size, clock phase and polarity, data bit ordering, baud
 * rate, and various delays. In slave mode, a subset of the bitfields in CTAR0 are
 * used to set the slave transfer attributes. When the module is configured as an
 * SPI master, the CTAS field in the command portion of the TX FIFO entry
 * selects which of the CTAR registers is used. When the module is configured as an SPI
 * bus slave, it uses the CTAR0 register.
 */
/*!
 * @name Constants and macros for entire SPI_CTAR register
 */
/*@{*/
#define SPI_RD_CTAR(base, index) (SPI_CTAR_REG(base, index))
#define SPI_WR_CTAR(base, index, value) (SPI_CTAR_REG(base, index) = (value))
#define SPI_RMW_CTAR(base, index, mask, value) (SPI_WR_CTAR(base, index, (SPI_RD_CTAR(base, index) & ~(mask)) | (value)))
#define SPI_SET_CTAR(base, index, value) (BME_OR32(&SPI_CTAR_REG(base, index), (uint32_t)(value)))
#define SPI_CLR_CTAR(base, index, value) (BME_AND32(&SPI_CTAR_REG(base, index), (uint32_t)(~(value))))
#define SPI_TOG_CTAR(base, index, value) (BME_XOR32(&SPI_CTAR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_CTAR bitfields
 */

/*!
 * @name Register SPI_CTAR, field BR[3:0] (RW)
 *
 * Selects the scaler value for the baud rate. This field is used only in master
 * mode. The prescaled protocol clock is divided by the Baud Rate Scaler to
 * generate the frequency of the SCK. The baud rate is computed according to the
 * following equation: SCK baud rate = (fP /PBR) x [(1+DBR)/BR] The following table
 * lists the baud rate scaler values. Baud Rate Scaler CTARn[BR] Baud Rate Scaler
 * Value 0000 2 0001 4 0010 6 0011 8 0100 16 0101 32 0110 64 0111 128 1000 256
 * 1001 512 1010 1024 1011 2048 1100 4096 1101 8192 1110 16384 1111 32768
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_BR field. */
#define SPI_RD_CTAR_BR(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_BR_MASK) >> SPI_CTAR_BR_SHIFT)
#define SPI_BRD_CTAR_BR(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_BR_SHIFT, SPI_CTAR_BR_WIDTH))

/*! @brief Set the BR field to a new value. */
#define SPI_WR_CTAR_BR(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_BR_MASK, SPI_CTAR_BR(value)))
#define SPI_BWR_CTAR_BR(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_BR_SHIFT), SPI_CTAR_BR_SHIFT, SPI_CTAR_BR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field DT[7:4] (RW)
 *
 * Selects the Delay after Transfer Scaler. This field is used only in master
 * mode. The Delay after Transfer is the time between the negation of the PCS
 * signal at the end of a frame and the assertion of PCS at the beginning of the next
 * frame. In the Continuous Serial Communications Clock operation, the DT value
 * is fixed to one SCK clock period, The Delay after Transfer is a multiple of the
 * protocol clock period, and it is computed according to the following
 * equation: tDT = (1/fP ) x PDT x DT See Delay Scaler Encoding table in CTARn[CSSCK] bit
 * field description for scaler values.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_DT field. */
#define SPI_RD_CTAR_DT(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_DT_MASK) >> SPI_CTAR_DT_SHIFT)
#define SPI_BRD_CTAR_DT(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_DT_SHIFT, SPI_CTAR_DT_WIDTH))

/*! @brief Set the DT field to a new value. */
#define SPI_WR_CTAR_DT(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_DT_MASK, SPI_CTAR_DT(value)))
#define SPI_BWR_CTAR_DT(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_DT_SHIFT), SPI_CTAR_DT_SHIFT, SPI_CTAR_DT_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field ASC[11:8] (RW)
 *
 * Selects the scaler value for the After SCK Delay. This field is used only in
 * master mode. The After SCK Delay is the delay between the last edge of SCK and
 * the negation of PCS. The delay is a multiple of the protocol clock period,
 * and it is computed according to the following equation: t ASC = (1/fP) x PASC x
 * ASC See Delay Scaler Encoding table in CTARn[CSSCK] bit field description for
 * scaler values. Refer After SCK Delay (tASC ) for more details.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_ASC field. */
#define SPI_RD_CTAR_ASC(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_ASC_MASK) >> SPI_CTAR_ASC_SHIFT)
#define SPI_BRD_CTAR_ASC(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_ASC_SHIFT, SPI_CTAR_ASC_WIDTH))

/*! @brief Set the ASC field to a new value. */
#define SPI_WR_CTAR_ASC(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_ASC_MASK, SPI_CTAR_ASC(value)))
#define SPI_BWR_CTAR_ASC(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_ASC_SHIFT), SPI_CTAR_ASC_SHIFT, SPI_CTAR_ASC_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field CSSCK[15:12] (RW)
 *
 * Selects the scaler value for the PCS to SCK delay. This field is used only in
 * master mode. The PCS to SCK Delay is the delay between the assertion of PCS
 * and the first edge of the SCK. The delay is a multiple of the protocol clock
 * period, and it is computed according to the following equation: t CSC = (1/fP )
 * x PCSSCK x CSSCK. The following table lists the delay scaler values. Delay
 * Scaler Encoding Field Value Delay Scaler Value 0000 2 0001 4 0010 8 0011 16 0100
 * 32 0101 64 0110 128 0111 256 1000 512 1001 1024 1010 2048 1011 4096 1100 8192
 * 1101 16384 1110 32768 1111 65536 Refer PCS to SCK Delay (tCSC ) for more
 * details.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_CSSCK field. */
#define SPI_RD_CTAR_CSSCK(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_CSSCK_MASK) >> SPI_CTAR_CSSCK_SHIFT)
#define SPI_BRD_CTAR_CSSCK(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_CSSCK_SHIFT, SPI_CTAR_CSSCK_WIDTH))

/*! @brief Set the CSSCK field to a new value. */
#define SPI_WR_CTAR_CSSCK(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_CSSCK_MASK, SPI_CTAR_CSSCK(value)))
#define SPI_BWR_CTAR_CSSCK(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_CSSCK_SHIFT), SPI_CTAR_CSSCK_SHIFT, SPI_CTAR_CSSCK_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PBR[17:16] (RW)
 *
 * Selects the prescaler value for the baud rate. This field is used only in
 * master mode. The baud rate is the frequency of the SCK. The protocol clock is
 * divided by the prescaler value before the baud rate selection takes place. See
 * the BR field description for details on how to compute the baud rate.
 *
 * Values:
 * - 0b00 - Baud Rate Prescaler value is 2.
 * - 0b01 - Baud Rate Prescaler value is 3.
 * - 0b10 - Baud Rate Prescaler value is 5.
 * - 0b11 - Baud Rate Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PBR field. */
#define SPI_RD_CTAR_PBR(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PBR_MASK) >> SPI_CTAR_PBR_SHIFT)
#define SPI_BRD_CTAR_PBR(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_PBR_SHIFT, SPI_CTAR_PBR_WIDTH))

/*! @brief Set the PBR field to a new value. */
#define SPI_WR_CTAR_PBR(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PBR_MASK, SPI_CTAR_PBR(value)))
#define SPI_BWR_CTAR_PBR(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_PBR_SHIFT), SPI_CTAR_PBR_SHIFT, SPI_CTAR_PBR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PDT[19:18] (RW)
 *
 * Selects the prescaler value for the delay between the negation of the PCS
 * signal at the end of a frame and the assertion of PCS at the beginning of the
 * next frame. The PDT field is only used in master mode. See the DT field
 * description for details on how to compute the Delay after Transfer. Refer Delay after
 * Transfer (tDT ) for more details.
 *
 * Values:
 * - 0b00 - Delay after Transfer Prescaler value is 1.
 * - 0b01 - Delay after Transfer Prescaler value is 3.
 * - 0b10 - Delay after Transfer Prescaler value is 5.
 * - 0b11 - Delay after Transfer Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PDT field. */
#define SPI_RD_CTAR_PDT(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PDT_MASK) >> SPI_CTAR_PDT_SHIFT)
#define SPI_BRD_CTAR_PDT(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_PDT_SHIFT, SPI_CTAR_PDT_WIDTH))

/*! @brief Set the PDT field to a new value. */
#define SPI_WR_CTAR_PDT(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PDT_MASK, SPI_CTAR_PDT(value)))
#define SPI_BWR_CTAR_PDT(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_PDT_SHIFT), SPI_CTAR_PDT_SHIFT, SPI_CTAR_PDT_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PASC[21:20] (RW)
 *
 * Selects the prescaler value for the delay between the last edge of SCK and
 * the negation of PCS. See the ASC field description for information on how to
 * compute the After SCK Delay. Refer After SCK Delay (tASC ) for more details.
 *
 * Values:
 * - 0b00 - Delay after Transfer Prescaler value is 1.
 * - 0b01 - Delay after Transfer Prescaler value is 3.
 * - 0b10 - Delay after Transfer Prescaler value is 5.
 * - 0b11 - Delay after Transfer Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PASC field. */
#define SPI_RD_CTAR_PASC(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PASC_MASK) >> SPI_CTAR_PASC_SHIFT)
#define SPI_BRD_CTAR_PASC(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_PASC_SHIFT, SPI_CTAR_PASC_WIDTH))

/*! @brief Set the PASC field to a new value. */
#define SPI_WR_CTAR_PASC(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PASC_MASK, SPI_CTAR_PASC(value)))
#define SPI_BWR_CTAR_PASC(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_PASC_SHIFT), SPI_CTAR_PASC_SHIFT, SPI_CTAR_PASC_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PCSSCK[23:22] (RW)
 *
 * Selects the prescaler value for the delay between assertion of PCS and the
 * first edge of the SCK. See the CSSCK field description for information on how to
 * compute the PCS to SCK Delay. Refer PCS to SCK Delay (tCSC ) for more details.
 *
 * Values:
 * - 0b00 - PCS to SCK Prescaler value is 1.
 * - 0b01 - PCS to SCK Prescaler value is 3.
 * - 0b10 - PCS to SCK Prescaler value is 5.
 * - 0b11 - PCS to SCK Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PCSSCK field. */
#define SPI_RD_CTAR_PCSSCK(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PCSSCK_MASK) >> SPI_CTAR_PCSSCK_SHIFT)
#define SPI_BRD_CTAR_PCSSCK(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_PCSSCK_SHIFT, SPI_CTAR_PCSSCK_WIDTH))

/*! @brief Set the PCSSCK field to a new value. */
#define SPI_WR_CTAR_PCSSCK(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PCSSCK_MASK, SPI_CTAR_PCSSCK(value)))
#define SPI_BWR_CTAR_PCSSCK(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_PCSSCK_SHIFT), SPI_CTAR_PCSSCK_SHIFT, SPI_CTAR_PCSSCK_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field LSBFE[24] (RW)
 *
 * Specifies whether the LSB or MSB of the frame is transferred first.
 *
 * Values:
 * - 0b0 - Data is transferred MSB first.
 * - 0b1 - Data is transferred LSB first.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_LSBFE field. */
#define SPI_RD_CTAR_LSBFE(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_LSBFE_MASK) >> SPI_CTAR_LSBFE_SHIFT)
#define SPI_BRD_CTAR_LSBFE(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_LSBFE_SHIFT, SPI_CTAR_LSBFE_WIDTH))

/*! @brief Set the LSBFE field to a new value. */
#define SPI_WR_CTAR_LSBFE(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_LSBFE_MASK, SPI_CTAR_LSBFE(value)))
#define SPI_BWR_CTAR_LSBFE(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_LSBFE_SHIFT), SPI_CTAR_LSBFE_SHIFT, SPI_CTAR_LSBFE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field CPHA[25] (RW)
 *
 * Selects which edge of SCK causes data to change and which edge causes data to
 * be captured. This bit is used in both master and slave mode. For successful
 * communication between serial devices, the devices must have identical clock
 * phase settings. In Continuous SCK mode, the bit value is ignored and the
 * transfers are done as if the CPHA bit is set to 1.
 *
 * Values:
 * - 0b0 - Data is captured on the leading edge of SCK and changed on the
 *     following edge.
 * - 0b1 - Data is changed on the leading edge of SCK and captured on the
 *     following edge.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_CPHA field. */
#define SPI_RD_CTAR_CPHA(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_CPHA_MASK) >> SPI_CTAR_CPHA_SHIFT)
#define SPI_BRD_CTAR_CPHA(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_CPHA_SHIFT, SPI_CTAR_CPHA_WIDTH))

/*! @brief Set the CPHA field to a new value. */
#define SPI_WR_CTAR_CPHA(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_CPHA_MASK, SPI_CTAR_CPHA(value)))
#define SPI_BWR_CTAR_CPHA(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_CPHA_SHIFT), SPI_CTAR_CPHA_SHIFT, SPI_CTAR_CPHA_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field CPOL[26] (RW)
 *
 * Selects the inactive state of the Serial Communications Clock (SCK). This bit
 * is used in both master and slave mode. For successful communication between
 * serial devices, the devices must have identical clock polarities. When the
 * Continuous Selection Format is selected, switching between clock polarities
 * without stopping the module can cause errors in the transfer due to the peripheral
 * device interpreting the switch of clock polarity as a valid clock edge. In case
 * of Continuous SCK mode, when the module goes in low power mode(disabled),
 * inactive state of SCK is not guaranted.
 *
 * Values:
 * - 0b0 - The inactive state value of SCK is low.
 * - 0b1 - The inactive state value of SCK is high.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_CPOL field. */
#define SPI_RD_CTAR_CPOL(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_CPOL_MASK) >> SPI_CTAR_CPOL_SHIFT)
#define SPI_BRD_CTAR_CPOL(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_CPOL_SHIFT, SPI_CTAR_CPOL_WIDTH))

/*! @brief Set the CPOL field to a new value. */
#define SPI_WR_CTAR_CPOL(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_CPOL_MASK, SPI_CTAR_CPOL(value)))
#define SPI_BWR_CTAR_CPOL(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_CPOL_SHIFT), SPI_CTAR_CPOL_SHIFT, SPI_CTAR_CPOL_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field FMSZ[30:27] (RW)
 *
 * The number of bits transferred per frame is equal to the FMSZ value plus 1.
 * Regardless of the transmission mode, the minimum valid frame size value is 4.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_FMSZ field. */
#define SPI_RD_CTAR_FMSZ(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_FMSZ_MASK) >> SPI_CTAR_FMSZ_SHIFT)
#define SPI_BRD_CTAR_FMSZ(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_FMSZ_SHIFT, SPI_CTAR_FMSZ_WIDTH))

/*! @brief Set the FMSZ field to a new value. */
#define SPI_WR_CTAR_FMSZ(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_FMSZ_MASK, SPI_CTAR_FMSZ(value)))
#define SPI_BWR_CTAR_FMSZ(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_FMSZ_SHIFT), SPI_CTAR_FMSZ_SHIFT, SPI_CTAR_FMSZ_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field DBR[31] (RW)
 *
 * Doubles the effective baud rate of the Serial Communications Clock (SCK).
 * This field is used only in master mode. It effectively halves the Baud Rate
 * division ratio, supporting faster frequencies, and odd division ratios for the
 * Serial Communications Clock (SCK). When the DBR bit is set, the duty cycle of the
 * Serial Communications Clock (SCK) depends on the value in the Baud Rate
 * Prescaler and the Clock Phase bit as listed in the following table. See the BR field
 * description for details on how to compute the baud rate. SPI SCK Duty Cycle
 * DBR CPHA PBR SCK Duty Cycle 0 any any 50/50 1 0 00 50/50 1 0 01 33/66 1 0 10
 * 40/60 1 0 11 43/57 1 1 00 50/50 1 1 01 66/33 1 1 10 60/40 1 1 11 57/43
 *
 * Values:
 * - 0b0 - The baud rate is computed normally with a 50/50 duty cycle.
 * - 0b1 - The baud rate is doubled with the duty cycle depending on the Baud
 *     Rate Prescaler.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_DBR field. */
#define SPI_RD_CTAR_DBR(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_DBR_MASK) >> SPI_CTAR_DBR_SHIFT)
#define SPI_BRD_CTAR_DBR(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_DBR_SHIFT, SPI_CTAR_DBR_WIDTH))

/*! @brief Set the DBR field to a new value. */
#define SPI_WR_CTAR_DBR(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_DBR_MASK, SPI_CTAR_DBR(value)))
#define SPI_BWR_CTAR_DBR(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_DBR_SHIFT), SPI_CTAR_DBR_SHIFT, SPI_CTAR_DBR_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_SR - Status Register
 ******************************************************************************/

/*!
 * @brief SPI_SR - Status Register (RW)
 *
 * Reset value: 0x02000000U
 *
 * SR contains status and flag bits. The bits reflect the status of the module
 * and indicate the occurrence of events that can generate interrupt or DMA
 * requests. Software can clear flag bits in the SR by writing a 1 to them. Writing a 0
 * to a flag bit has no effect. This register may not be writable in Module
 * Disable mode due to the use of power saving mechanisms.
 */
/*!
 * @name Constants and macros for entire SPI_SR register
 */
/*@{*/
#define SPI_RD_SR(base)          (SPI_SR_REG(base))
#define SPI_WR_SR(base, value)   (SPI_SR_REG(base) = (value))
#define SPI_RMW_SR(base, mask, value) (SPI_WR_SR(base, (SPI_RD_SR(base) & ~(mask)) | (value)))
#define SPI_SET_SR(base, value)  (BME_OR32(&SPI_SR_REG(base), (uint32_t)(value)))
#define SPI_CLR_SR(base, value)  (BME_AND32(&SPI_SR_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_SR(base, value)  (BME_XOR32(&SPI_SR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_SR bitfields
 */

/*!
 * @name Register SPI_SR, field POPNXTPTR[3:0] (RO)
 *
 * Contains a pointer to the RX FIFO entry to be returned when the POPR is read.
 * The POPNXTPTR is updated when the POPR is read.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_POPNXTPTR field. */
#define SPI_RD_SR_POPNXTPTR(base) ((SPI_SR_REG(base) & SPI_SR_POPNXTPTR_MASK) >> SPI_SR_POPNXTPTR_SHIFT)
#define SPI_BRD_SR_POPNXTPTR(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_POPNXTPTR_SHIFT, SPI_SR_POPNXTPTR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field RXCTR[7:4] (RO)
 *
 * Indicates the number of entries in the RX FIFO. The RXCTR is decremented
 * every time the POPR is read. The RXCTR is incremented every time data is
 * transferred from the shift register to the RX FIFO.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_RXCTR field. */
#define SPI_RD_SR_RXCTR(base) ((SPI_SR_REG(base) & SPI_SR_RXCTR_MASK) >> SPI_SR_RXCTR_SHIFT)
#define SPI_BRD_SR_RXCTR(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_RXCTR_SHIFT, SPI_SR_RXCTR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field TXNXTPTR[11:8] (RO)
 *
 * Indicates which TX FIFO entry is transmitted during the next transfer. The
 * TXNXTPTR field is updated every time SPI data is transferred from the TX FIFO to
 * the shift register.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TXNXTPTR field. */
#define SPI_RD_SR_TXNXTPTR(base) ((SPI_SR_REG(base) & SPI_SR_TXNXTPTR_MASK) >> SPI_SR_TXNXTPTR_SHIFT)
#define SPI_BRD_SR_TXNXTPTR(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_TXNXTPTR_SHIFT, SPI_SR_TXNXTPTR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field TXCTR[15:12] (RO)
 *
 * Indicates the number of valid entries in the TX FIFO. The TXCTR is
 * incremented every time the PUSHR is written. The TXCTR is decremented every time an SPI
 * command is executed and the SPI data is transferred to the shift register.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TXCTR field. */
#define SPI_RD_SR_TXCTR(base) ((SPI_SR_REG(base) & SPI_SR_TXCTR_MASK) >> SPI_SR_TXCTR_SHIFT)
#define SPI_BRD_SR_TXCTR(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_TXCTR_SHIFT, SPI_SR_TXCTR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field RFDF[17] (W1C)
 *
 * Provides a method for the module to request that entries be removed from the
 * RX FIFO. The bit is set while the RX FIFO is not empty. The RFDF bit can be
 * cleared by writing 1 to it or by acknowledgement from the DMA controller when
 * the RX FIFO is empty.
 *
 * Values:
 * - 0b0 - RX FIFO is empty.
 * - 0b1 - RX FIFO is not empty.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_RFDF field. */
#define SPI_RD_SR_RFDF(base) ((SPI_SR_REG(base) & SPI_SR_RFDF_MASK) >> SPI_SR_RFDF_SHIFT)
#define SPI_BRD_SR_RFDF(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_RFDF_SHIFT, SPI_SR_RFDF_WIDTH))

/*! @brief Set the RFDF field to a new value. */
#define SPI_WR_SR_RFDF(base, value) (SPI_RMW_SR(base, (SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_RFDF(value)))
#define SPI_BWR_SR_RFDF(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_RFDF_SHIFT), SPI_SR_RFDF_SHIFT, SPI_SR_RFDF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field RFOF[19] (W1C)
 *
 * Indicates an overflow condition in the RX FIFO. The field is set when the RX
 * FIFO and shift register are full and a transfer is initiated. The bit remains
 * set until it is cleared by writing a 1 to it.
 *
 * Values:
 * - 0b0 - No Rx FIFO overflow.
 * - 0b1 - Rx FIFO overflow has occurred.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_RFOF field. */
#define SPI_RD_SR_RFOF(base) ((SPI_SR_REG(base) & SPI_SR_RFOF_MASK) >> SPI_SR_RFOF_SHIFT)
#define SPI_BRD_SR_RFOF(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_RFOF_SHIFT, SPI_SR_RFOF_WIDTH))

/*! @brief Set the RFOF field to a new value. */
#define SPI_WR_SR_RFOF(base, value) (SPI_RMW_SR(base, (SPI_SR_RFOF_MASK | SPI_SR_RFDF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_RFOF(value)))
#define SPI_BWR_SR_RFOF(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_RFOF_SHIFT), SPI_SR_RFOF_SHIFT, SPI_SR_RFOF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field TFFF[25] (W1C)
 *
 * Provides a method for the module to request more entries to be added to the
 * TX FIFO. The TFFF bit is set while the TX FIFO is not full. The TFFF bit can be
 * cleared by writing 1 to it or by acknowledgement from the DMA controller to
 * the TX FIFO full request.
 *
 * Values:
 * - 0b0 - TX FIFO is full.
 * - 0b1 - TX FIFO is not full.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TFFF field. */
#define SPI_RD_SR_TFFF(base) ((SPI_SR_REG(base) & SPI_SR_TFFF_MASK) >> SPI_SR_TFFF_SHIFT)
#define SPI_BRD_SR_TFFF(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_TFFF_SHIFT, SPI_SR_TFFF_WIDTH))

/*! @brief Set the TFFF field to a new value. */
#define SPI_WR_SR_TFFF(base, value) (SPI_RMW_SR(base, (SPI_SR_TFFF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_TFFF(value)))
#define SPI_BWR_SR_TFFF(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_TFFF_SHIFT), SPI_SR_TFFF_SHIFT, SPI_SR_TFFF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field TFUF[27] (W1C)
 *
 * Indicates an underflow condition in the TX FIFO. The transmit underflow
 * condition is detected only for SPI blocks operating in Slave mode and SPI
 * configuration. TFUF is set when the TX FIFO of the module operating in SPI Slave mode
 * is empty and an external SPI master initiates a transfer. The TFUF bit remains
 * set until cleared by writing 1 to it.
 *
 * Values:
 * - 0b0 - No TX FIFO underflow.
 * - 0b1 - TX FIFO underflow has occurred.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TFUF field. */
#define SPI_RD_SR_TFUF(base) ((SPI_SR_REG(base) & SPI_SR_TFUF_MASK) >> SPI_SR_TFUF_SHIFT)
#define SPI_BRD_SR_TFUF(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_TFUF_SHIFT, SPI_SR_TFUF_WIDTH))

/*! @brief Set the TFUF field to a new value. */
#define SPI_WR_SR_TFUF(base, value) (SPI_RMW_SR(base, (SPI_SR_TFUF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_TFUF(value)))
#define SPI_BWR_SR_TFUF(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_TFUF_SHIFT), SPI_SR_TFUF_SHIFT, SPI_SR_TFUF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field EOQF[28] (W1C)
 *
 * Indicates that the last entry in a queue has been transmitted when the module
 * is in Master mode. The EOQF bit is set when the TX FIFO entry has the EOQ bit
 * set in the command halfword and the end of the transfer is reached. The EOQF
 * bit remains set until cleared by writing a 1 to it. When the EOQF bit is set,
 * the TXRXS bit is automatically cleared.
 *
 * Values:
 * - 0b0 - EOQ is not set in the executing command.
 * - 0b1 - EOQ is set in the executing SPI command.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_EOQF field. */
#define SPI_RD_SR_EOQF(base) ((SPI_SR_REG(base) & SPI_SR_EOQF_MASK) >> SPI_SR_EOQF_SHIFT)
#define SPI_BRD_SR_EOQF(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_EOQF_SHIFT, SPI_SR_EOQF_WIDTH))

/*! @brief Set the EOQF field to a new value. */
#define SPI_WR_SR_EOQF(base, value) (SPI_RMW_SR(base, (SPI_SR_EOQF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_EOQF(value)))
#define SPI_BWR_SR_EOQF(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_EOQF_SHIFT), SPI_SR_EOQF_SHIFT, SPI_SR_EOQF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field TXRXS[30] (W1C)
 *
 * Reflects the run status of the module.
 *
 * Values:
 * - 0b0 - Transmit and receive operations are disabled (The module is in
 *     Stopped state).
 * - 0b1 - Transmit and receive operations are enabled (The module is in Running
 *     state).
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TXRXS field. */
#define SPI_RD_SR_TXRXS(base) ((SPI_SR_REG(base) & SPI_SR_TXRXS_MASK) >> SPI_SR_TXRXS_SHIFT)
#define SPI_BRD_SR_TXRXS(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_TXRXS_SHIFT, SPI_SR_TXRXS_WIDTH))

/*! @brief Set the TXRXS field to a new value. */
#define SPI_WR_SR_TXRXS(base, value) (SPI_RMW_SR(base, (SPI_SR_TXRXS_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TCF_MASK), SPI_SR_TXRXS(value)))
#define SPI_BWR_SR_TXRXS(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_TXRXS_SHIFT), SPI_SR_TXRXS_SHIFT, SPI_SR_TXRXS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field TCF[31] (W1C)
 *
 * Indicates that all bits in a frame have been shifted out. TCF remains set
 * until it is cleared by writing a 1 to it.
 *
 * Values:
 * - 0b0 - Transfer not complete.
 * - 0b1 - Transfer complete.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TCF field. */
#define SPI_RD_SR_TCF(base)  ((SPI_SR_REG(base) & SPI_SR_TCF_MASK) >> SPI_SR_TCF_SHIFT)
#define SPI_BRD_SR_TCF(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_TCF_SHIFT, SPI_SR_TCF_WIDTH))

/*! @brief Set the TCF field to a new value. */
#define SPI_WR_SR_TCF(base, value) (SPI_RMW_SR(base, (SPI_SR_TCF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK), SPI_SR_TCF(value)))
#define SPI_BWR_SR_TCF(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_TCF_SHIFT), SPI_SR_TCF_SHIFT, SPI_SR_TCF_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_RSER - DMA/Interrupt Request Select and Enable Register
 ******************************************************************************/

/*!
 * @brief SPI_RSER - DMA/Interrupt Request Select and Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * RSER controls DMA and interrupt requests. Do not write to the RSER while the
 * module is in the Running state.
 */
/*!
 * @name Constants and macros for entire SPI_RSER register
 */
/*@{*/
#define SPI_RD_RSER(base)        (SPI_RSER_REG(base))
#define SPI_WR_RSER(base, value) (SPI_RSER_REG(base) = (value))
#define SPI_RMW_RSER(base, mask, value) (SPI_WR_RSER(base, (SPI_RD_RSER(base) & ~(mask)) | (value)))
#define SPI_SET_RSER(base, value) (BME_OR32(&SPI_RSER_REG(base), (uint32_t)(value)))
#define SPI_CLR_RSER(base, value) (BME_AND32(&SPI_RSER_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_RSER(base, value) (BME_XOR32(&SPI_RSER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_RSER bitfields
 */

/*!
 * @name Register SPI_RSER, field RFDF_DIRS[16] (RW)
 *
 * Selects between generating a DMA request or an interrupt request. When the
 * RFDF flag bit in the SR is set, and the RFDF_RE bit in the RSER is set, the
 * RFDF_DIRS bit selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0b0 - Interrupt request.
 * - 0b1 - DMA request.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_RFDF_DIRS field. */
#define SPI_RD_RSER_RFDF_DIRS(base) ((SPI_RSER_REG(base) & SPI_RSER_RFDF_DIRS_MASK) >> SPI_RSER_RFDF_DIRS_SHIFT)
#define SPI_BRD_RSER_RFDF_DIRS(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_RFDF_DIRS_SHIFT, SPI_RSER_RFDF_DIRS_WIDTH))

/*! @brief Set the RFDF_DIRS field to a new value. */
#define SPI_WR_RSER_RFDF_DIRS(base, value) (SPI_RMW_RSER(base, SPI_RSER_RFDF_DIRS_MASK, SPI_RSER_RFDF_DIRS(value)))
#define SPI_BWR_RSER_RFDF_DIRS(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_RFDF_DIRS_SHIFT), SPI_RSER_RFDF_DIRS_SHIFT, SPI_RSER_RFDF_DIRS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field RFDF_RE[17] (RW)
 *
 * Enables the RFDF flag in the SR to generate a request. The RFDF_DIRS bit
 * selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0b0 - RFDF interrupt or DMA requests are disabled.
 * - 0b1 - RFDF interrupt or DMA requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_RFDF_RE field. */
#define SPI_RD_RSER_RFDF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_RFDF_RE_MASK) >> SPI_RSER_RFDF_RE_SHIFT)
#define SPI_BRD_RSER_RFDF_RE(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_RFDF_RE_SHIFT, SPI_RSER_RFDF_RE_WIDTH))

/*! @brief Set the RFDF_RE field to a new value. */
#define SPI_WR_RSER_RFDF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_RFDF_RE_MASK, SPI_RSER_RFDF_RE(value)))
#define SPI_BWR_RSER_RFDF_RE(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_RFDF_RE_SHIFT), SPI_RSER_RFDF_RE_SHIFT, SPI_RSER_RFDF_RE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field RFOF_RE[19] (RW)
 *
 * Enables the RFOF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0b0 - RFOF interrupt requests are disabled.
 * - 0b1 - RFOF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_RFOF_RE field. */
#define SPI_RD_RSER_RFOF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_RFOF_RE_MASK) >> SPI_RSER_RFOF_RE_SHIFT)
#define SPI_BRD_RSER_RFOF_RE(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_RFOF_RE_SHIFT, SPI_RSER_RFOF_RE_WIDTH))

/*! @brief Set the RFOF_RE field to a new value. */
#define SPI_WR_RSER_RFOF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_RFOF_RE_MASK, SPI_RSER_RFOF_RE(value)))
#define SPI_BWR_RSER_RFOF_RE(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_RFOF_RE_SHIFT), SPI_RSER_RFOF_RE_SHIFT, SPI_RSER_RFOF_RE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field TFFF_DIRS[24] (RW)
 *
 * Selects between generating a DMA request or an interrupt request. When
 * SR[TFFF] and RSER[TFFF_RE] are set, this field selects between generating an
 * interrupt request or a DMA request.
 *
 * Values:
 * - 0b0 - TFFF flag generates interrupt requests.
 * - 0b1 - TFFF flag generates DMA requests.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TFFF_DIRS field. */
#define SPI_RD_RSER_TFFF_DIRS(base) ((SPI_RSER_REG(base) & SPI_RSER_TFFF_DIRS_MASK) >> SPI_RSER_TFFF_DIRS_SHIFT)
#define SPI_BRD_RSER_TFFF_DIRS(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_TFFF_DIRS_SHIFT, SPI_RSER_TFFF_DIRS_WIDTH))

/*! @brief Set the TFFF_DIRS field to a new value. */
#define SPI_WR_RSER_TFFF_DIRS(base, value) (SPI_RMW_RSER(base, SPI_RSER_TFFF_DIRS_MASK, SPI_RSER_TFFF_DIRS(value)))
#define SPI_BWR_RSER_TFFF_DIRS(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_TFFF_DIRS_SHIFT), SPI_RSER_TFFF_DIRS_SHIFT, SPI_RSER_TFFF_DIRS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field TFFF_RE[25] (RW)
 *
 * Enables the TFFF flag in the SR to generate a request. The TFFF_DIRS bit
 * selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0b0 - TFFF interrupts or DMA requests are disabled.
 * - 0b1 - TFFF interrupts or DMA requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TFFF_RE field. */
#define SPI_RD_RSER_TFFF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_TFFF_RE_MASK) >> SPI_RSER_TFFF_RE_SHIFT)
#define SPI_BRD_RSER_TFFF_RE(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_TFFF_RE_SHIFT, SPI_RSER_TFFF_RE_WIDTH))

/*! @brief Set the TFFF_RE field to a new value. */
#define SPI_WR_RSER_TFFF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_TFFF_RE_MASK, SPI_RSER_TFFF_RE(value)))
#define SPI_BWR_RSER_TFFF_RE(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_TFFF_RE_SHIFT), SPI_RSER_TFFF_RE_SHIFT, SPI_RSER_TFFF_RE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field TFUF_RE[27] (RW)
 *
 * Enables the TFUF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0b0 - TFUF interrupt requests are disabled.
 * - 0b1 - TFUF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TFUF_RE field. */
#define SPI_RD_RSER_TFUF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_TFUF_RE_MASK) >> SPI_RSER_TFUF_RE_SHIFT)
#define SPI_BRD_RSER_TFUF_RE(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_TFUF_RE_SHIFT, SPI_RSER_TFUF_RE_WIDTH))

/*! @brief Set the TFUF_RE field to a new value. */
#define SPI_WR_RSER_TFUF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_TFUF_RE_MASK, SPI_RSER_TFUF_RE(value)))
#define SPI_BWR_RSER_TFUF_RE(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_TFUF_RE_SHIFT), SPI_RSER_TFUF_RE_SHIFT, SPI_RSER_TFUF_RE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field EOQF_RE[28] (RW)
 *
 * Enables the EOQF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0b0 - EOQF interrupt requests are disabled.
 * - 0b1 - EOQF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_EOQF_RE field. */
#define SPI_RD_RSER_EOQF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_EOQF_RE_MASK) >> SPI_RSER_EOQF_RE_SHIFT)
#define SPI_BRD_RSER_EOQF_RE(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_EOQF_RE_SHIFT, SPI_RSER_EOQF_RE_WIDTH))

/*! @brief Set the EOQF_RE field to a new value. */
#define SPI_WR_RSER_EOQF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_EOQF_RE_MASK, SPI_RSER_EOQF_RE(value)))
#define SPI_BWR_RSER_EOQF_RE(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_EOQF_RE_SHIFT), SPI_RSER_EOQF_RE_SHIFT, SPI_RSER_EOQF_RE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field TCF_RE[31] (RW)
 *
 * Enables TCF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0b0 - TCF interrupt requests are disabled.
 * - 0b1 - TCF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TCF_RE field. */
#define SPI_RD_RSER_TCF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_TCF_RE_MASK) >> SPI_RSER_TCF_RE_SHIFT)
#define SPI_BRD_RSER_TCF_RE(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_TCF_RE_SHIFT, SPI_RSER_TCF_RE_WIDTH))

/*! @brief Set the TCF_RE field to a new value. */
#define SPI_WR_RSER_TCF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_TCF_RE_MASK, SPI_RSER_TCF_RE(value)))
#define SPI_BWR_RSER_TCF_RE(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_TCF_RE_SHIFT), SPI_RSER_TCF_RE_SHIFT, SPI_RSER_TCF_RE_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_PUSHR - PUSH TX FIFO Register In Master Mode
 ******************************************************************************/

/*!
 * @brief SPI_PUSHR - PUSH TX FIFO Register In Master Mode (RW)
 *
 * Reset value: 0x00000000U
 *
 * Specifies data to be transferred to the TX FIFO. An 8- or 16-bit write access
 * transfers all 32 bits to the TX FIFO. In Master mode, the register transfers
 * 16 bits of data and 16 bits of command information. In Slave mode, all 32 bits
 * can be used as data, supporting up to 32-bit frame operation. A read access
 * of PUSHR returns the topmost TX FIFO entry. When the module is disabled,
 * writing to this register does not update the FIFO. Therefore, any reads performed
 * while the module is disabled return the last PUSHR write performed while the
 * module was still enabled.
 */
/*!
 * @name Constants and macros for entire SPI_PUSHR register
 */
/*@{*/
#define SPI_RD_PUSHR(base)       (SPI_PUSHR_REG(base))
#define SPI_WR_PUSHR(base, value) (SPI_PUSHR_REG(base) = (value))
#define SPI_RMW_PUSHR(base, mask, value) (SPI_WR_PUSHR(base, (SPI_RD_PUSHR(base) & ~(mask)) | (value)))
#define SPI_SET_PUSHR(base, value) (BME_OR32(&SPI_PUSHR_REG(base), (uint32_t)(value)))
#define SPI_CLR_PUSHR(base, value) (BME_AND32(&SPI_PUSHR_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_PUSHR(base, value) (BME_XOR32(&SPI_PUSHR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_PUSHR bitfields
 */

/*!
 * @name Register SPI_PUSHR, field TXDATA[15:0] (RW)
 *
 * Holds SPI data to be transferred according to the associated SPI command.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_TXDATA field. */
#define SPI_RD_PUSHR_TXDATA(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_TXDATA_MASK) >> SPI_PUSHR_TXDATA_SHIFT)
#define SPI_BRD_PUSHR_TXDATA(base) (BME_UBFX32(&SPI_PUSHR_REG(base), SPI_PUSHR_TXDATA_SHIFT, SPI_PUSHR_TXDATA_WIDTH))

/*! @brief Set the TXDATA field to a new value. */
#define SPI_WR_PUSHR_TXDATA(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_TXDATA_MASK, SPI_PUSHR_TXDATA(value)))
#define SPI_BWR_PUSHR_TXDATA(base, value) (BME_BFI32(&SPI_PUSHR_REG(base), ((uint32_t)(value) << SPI_PUSHR_TXDATA_SHIFT), SPI_PUSHR_TXDATA_SHIFT, SPI_PUSHR_TXDATA_WIDTH))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field PCS[19:16] (RW)
 *
 * Select which PCS signals are to be asserted for the transfer. Refer to the
 * chip-specific SPI information for the number of PCS signals used in this MCU.
 *
 * Values:
 * - 0b0000 - Negate the PCS[x] signal
 * - 0b0001 - Assert the PCS[x] signal.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_PCS field. */
#define SPI_RD_PUSHR_PCS(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_PCS_MASK) >> SPI_PUSHR_PCS_SHIFT)
#define SPI_BRD_PUSHR_PCS(base) (BME_UBFX32(&SPI_PUSHR_REG(base), SPI_PUSHR_PCS_SHIFT, SPI_PUSHR_PCS_WIDTH))

/*! @brief Set the PCS field to a new value. */
#define SPI_WR_PUSHR_PCS(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_PCS_MASK, SPI_PUSHR_PCS(value)))
#define SPI_BWR_PUSHR_PCS(base, value) (BME_BFI32(&SPI_PUSHR_REG(base), ((uint32_t)(value) << SPI_PUSHR_PCS_SHIFT), SPI_PUSHR_PCS_SHIFT, SPI_PUSHR_PCS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field CTCNT[26] (RW)
 *
 * Clears the TCNT field in the TCR register. The TCNT field is cleared before
 * the module starts transmitting the current SPI frame.
 *
 * Values:
 * - 0b0 - Do not clear the TCR[TCNT] field.
 * - 0b1 - Clear the TCR[TCNT] field.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_CTCNT field. */
#define SPI_RD_PUSHR_CTCNT(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_CTCNT_MASK) >> SPI_PUSHR_CTCNT_SHIFT)
#define SPI_BRD_PUSHR_CTCNT(base) (BME_UBFX32(&SPI_PUSHR_REG(base), SPI_PUSHR_CTCNT_SHIFT, SPI_PUSHR_CTCNT_WIDTH))

/*! @brief Set the CTCNT field to a new value. */
#define SPI_WR_PUSHR_CTCNT(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_CTCNT_MASK, SPI_PUSHR_CTCNT(value)))
#define SPI_BWR_PUSHR_CTCNT(base, value) (BME_BFI32(&SPI_PUSHR_REG(base), ((uint32_t)(value) << SPI_PUSHR_CTCNT_SHIFT), SPI_PUSHR_CTCNT_SHIFT, SPI_PUSHR_CTCNT_WIDTH))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field EOQ[27] (RW)
 *
 * Host software uses this bit to signal to the module that the current SPI
 * transfer is the last in a queue. At the end of the transfer, the EOQF bit in the
 * SR is set.
 *
 * Values:
 * - 0b0 - The SPI data is not the last data to transfer.
 * - 0b1 - The SPI data is the last data to transfer.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_EOQ field. */
#define SPI_RD_PUSHR_EOQ(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_EOQ_MASK) >> SPI_PUSHR_EOQ_SHIFT)
#define SPI_BRD_PUSHR_EOQ(base) (BME_UBFX32(&SPI_PUSHR_REG(base), SPI_PUSHR_EOQ_SHIFT, SPI_PUSHR_EOQ_WIDTH))

/*! @brief Set the EOQ field to a new value. */
#define SPI_WR_PUSHR_EOQ(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_EOQ_MASK, SPI_PUSHR_EOQ(value)))
#define SPI_BWR_PUSHR_EOQ(base, value) (BME_BFI32(&SPI_PUSHR_REG(base), ((uint32_t)(value) << SPI_PUSHR_EOQ_SHIFT), SPI_PUSHR_EOQ_SHIFT, SPI_PUSHR_EOQ_WIDTH))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field CTAS[30:28] (RW)
 *
 * Selects which CTAR to use in master mode to specify the transfer attributes
 * for the associated SPI frame. In SPI Slave mode, CTAR0 is used. See the chip
 * configuration details to determine how many CTARs this device has. You should
 * not program a value in this field for a register that is not present.
 *
 * Values:
 * - 0b000 - CTAR0
 * - 0b001 - CTAR1
 * - 0b010 - Reserved
 * - 0b011 - Reserved
 * - 0b100 - Reserved
 * - 0b101 - Reserved
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_CTAS field. */
#define SPI_RD_PUSHR_CTAS(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_CTAS_MASK) >> SPI_PUSHR_CTAS_SHIFT)
#define SPI_BRD_PUSHR_CTAS(base) (BME_UBFX32(&SPI_PUSHR_REG(base), SPI_PUSHR_CTAS_SHIFT, SPI_PUSHR_CTAS_WIDTH))

/*! @brief Set the CTAS field to a new value. */
#define SPI_WR_PUSHR_CTAS(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_CTAS_MASK, SPI_PUSHR_CTAS(value)))
#define SPI_BWR_PUSHR_CTAS(base, value) (BME_BFI32(&SPI_PUSHR_REG(base), ((uint32_t)(value) << SPI_PUSHR_CTAS_SHIFT), SPI_PUSHR_CTAS_SHIFT, SPI_PUSHR_CTAS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field CONT[31] (RW)
 *
 * Selects a continuous selection format. The bit is used in SPI Master mode.
 * The bit enables the selected PCS signals to remain asserted between transfers.
 *
 * Values:
 * - 0b0 - Return PCSn signals to their inactive state between transfers.
 * - 0b1 - Keep PCSn signals asserted between transfers.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_CONT field. */
#define SPI_RD_PUSHR_CONT(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_CONT_MASK) >> SPI_PUSHR_CONT_SHIFT)
#define SPI_BRD_PUSHR_CONT(base) (BME_UBFX32(&SPI_PUSHR_REG(base), SPI_PUSHR_CONT_SHIFT, SPI_PUSHR_CONT_WIDTH))

/*! @brief Set the CONT field to a new value. */
#define SPI_WR_PUSHR_CONT(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_CONT_MASK, SPI_PUSHR_CONT(value)))
#define SPI_BWR_PUSHR_CONT(base, value) (BME_BFI32(&SPI_PUSHR_REG(base), ((uint32_t)(value) << SPI_PUSHR_CONT_SHIFT), SPI_PUSHR_CONT_SHIFT, SPI_PUSHR_CONT_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_PUSHR_SLAVE - PUSH TX FIFO Register In Slave Mode
 ******************************************************************************/

/*!
 * @brief SPI_PUSHR_SLAVE - PUSH TX FIFO Register In Slave Mode (RW)
 *
 * Reset value: 0x00000000U
 *
 * Specifies data to be transferred to the TX FIFO. An 8- or 16-bit write access
 * to PUSHR transfers all 32 bits to the TX FIFO. In master mode, the register
 * transfers 16 bits of data and 16 bits of command information to the TX FIFO. In
 * slave mode, all 32 register bits can be used as data, supporting up to 32-bit
 * SPI Frame operation.
 */
/*!
 * @name Constants and macros for entire SPI_PUSHR_SLAVE register
 */
/*@{*/
#define SPI_RD_PUSHR_SLAVE(base) (SPI_PUSHR_SLAVE_REG(base))
#define SPI_WR_PUSHR_SLAVE(base, value) (SPI_PUSHR_SLAVE_REG(base) = (value))
#define SPI_RMW_PUSHR_SLAVE(base, mask, value) (SPI_WR_PUSHR_SLAVE(base, (SPI_RD_PUSHR_SLAVE(base) & ~(mask)) | (value)))
#define SPI_SET_PUSHR_SLAVE(base, value) (BME_OR32(&SPI_PUSHR_SLAVE_REG(base), (uint32_t)(value)))
#define SPI_CLR_PUSHR_SLAVE(base, value) (BME_AND32(&SPI_PUSHR_SLAVE_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_PUSHR_SLAVE(base, value) (BME_XOR32(&SPI_PUSHR_SLAVE_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * SPI_POPR - POP RX FIFO Register
 ******************************************************************************/

/*!
 * @brief SPI_POPR - POP RX FIFO Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * POPR is used to read the RX FIFO. Eight- or sixteen-bit read accesses to the
 * POPR have the same effect on the RX FIFO as 32-bit read accesses. A write to
 * this register will generate a Transfer Error.
 */
/*!
 * @name Constants and macros for entire SPI_POPR register
 */
/*@{*/
#define SPI_RD_POPR(base)        (SPI_POPR_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_TXFR0 - Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR0 - Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn registers provide visibility into the TX FIFO for debugging purposes.
 * Each register is an entry in the TX FIFO. The registers are read-only and
 * cannot be modified. Reading the TXFRx registers does not alter the state of the TX
 * FIFO. The number of registers used to implement the TX FIFO is
 * device-specific. If a four-entry TX FIFO is implemented, TXFR0-TXFR3 are accessible.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR0 register
 */
/*@{*/
#define SPI_RD_TXFR0(base)       (SPI_TXFR0_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR0 bitfields
 */

/*!
 * @name Register SPI_TXFR0, field TXDATA[15:0] (RO)
 *
 * Contains the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR0_TXDATA field. */
#define SPI_RD_TXFR0_TXDATA(base) ((SPI_TXFR0_REG(base) & SPI_TXFR0_TXDATA_MASK) >> SPI_TXFR0_TXDATA_SHIFT)
#define SPI_BRD_TXFR0_TXDATA(base) (BME_UBFX32(&SPI_TXFR0_REG(base), SPI_TXFR0_TXDATA_SHIFT, SPI_TXFR0_TXDATA_WIDTH))
/*@}*/

/*!
 * @name Register SPI_TXFR0, field TXCMD_TXDATA[31:16] (RO)
 *
 * In Master mode the TXCMD field contains the command that sets the transfer
 * attributes for the SPI data. In Slave mode, the TXDATA contains 16 MSB bits of
 * the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR0_TXCMD_TXDATA field. */
#define SPI_RD_TXFR0_TXCMD_TXDATA(base) ((SPI_TXFR0_REG(base) & SPI_TXFR0_TXCMD_TXDATA_MASK) >> SPI_TXFR0_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR0_TXCMD_TXDATA(base) (BME_UBFX32(&SPI_TXFR0_REG(base), SPI_TXFR0_TXCMD_TXDATA_SHIFT, SPI_TXFR0_TXCMD_TXDATA_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_TXFR1 - Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR1 - Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn registers provide visibility into the TX FIFO for debugging purposes.
 * Each register is an entry in the TX FIFO. The registers are read-only and
 * cannot be modified. Reading the TXFRx registers does not alter the state of the TX
 * FIFO. The number of registers used to implement the TX FIFO is
 * device-specific. If a four-entry TX FIFO is implemented, TXFR0-TXFR3 are accessible.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR1 register
 */
/*@{*/
#define SPI_RD_TXFR1(base)       (SPI_TXFR1_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR1 bitfields
 */

/*!
 * @name Register SPI_TXFR1, field TXDATA[15:0] (RO)
 *
 * Contains the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR1_TXDATA field. */
#define SPI_RD_TXFR1_TXDATA(base) ((SPI_TXFR1_REG(base) & SPI_TXFR1_TXDATA_MASK) >> SPI_TXFR1_TXDATA_SHIFT)
#define SPI_BRD_TXFR1_TXDATA(base) (BME_UBFX32(&SPI_TXFR1_REG(base), SPI_TXFR1_TXDATA_SHIFT, SPI_TXFR1_TXDATA_WIDTH))
/*@}*/

/*!
 * @name Register SPI_TXFR1, field TXCMD_TXDATA[31:16] (RO)
 *
 * In Master mode the TXCMD field contains the command that sets the transfer
 * attributes for the SPI data. In Slave mode, the TXDATA contains 16 MSB bits of
 * the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR1_TXCMD_TXDATA field. */
#define SPI_RD_TXFR1_TXCMD_TXDATA(base) ((SPI_TXFR1_REG(base) & SPI_TXFR1_TXCMD_TXDATA_MASK) >> SPI_TXFR1_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR1_TXCMD_TXDATA(base) (BME_UBFX32(&SPI_TXFR1_REG(base), SPI_TXFR1_TXCMD_TXDATA_SHIFT, SPI_TXFR1_TXCMD_TXDATA_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_TXFR2 - Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR2 - Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn registers provide visibility into the TX FIFO for debugging purposes.
 * Each register is an entry in the TX FIFO. The registers are read-only and
 * cannot be modified. Reading the TXFRx registers does not alter the state of the TX
 * FIFO. The number of registers used to implement the TX FIFO is
 * device-specific. If a four-entry TX FIFO is implemented, TXFR0-TXFR3 are accessible.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR2 register
 */
/*@{*/
#define SPI_RD_TXFR2(base)       (SPI_TXFR2_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR2 bitfields
 */

/*!
 * @name Register SPI_TXFR2, field TXDATA[15:0] (RO)
 *
 * Contains the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR2_TXDATA field. */
#define SPI_RD_TXFR2_TXDATA(base) ((SPI_TXFR2_REG(base) & SPI_TXFR2_TXDATA_MASK) >> SPI_TXFR2_TXDATA_SHIFT)
#define SPI_BRD_TXFR2_TXDATA(base) (BME_UBFX32(&SPI_TXFR2_REG(base), SPI_TXFR2_TXDATA_SHIFT, SPI_TXFR2_TXDATA_WIDTH))
/*@}*/

/*!
 * @name Register SPI_TXFR2, field TXCMD_TXDATA[31:16] (RO)
 *
 * In Master mode the TXCMD field contains the command that sets the transfer
 * attributes for the SPI data. In Slave mode, the TXDATA contains 16 MSB bits of
 * the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR2_TXCMD_TXDATA field. */
#define SPI_RD_TXFR2_TXCMD_TXDATA(base) ((SPI_TXFR2_REG(base) & SPI_TXFR2_TXCMD_TXDATA_MASK) >> SPI_TXFR2_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR2_TXCMD_TXDATA(base) (BME_UBFX32(&SPI_TXFR2_REG(base), SPI_TXFR2_TXCMD_TXDATA_SHIFT, SPI_TXFR2_TXCMD_TXDATA_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_TXFR3 - Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR3 - Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn registers provide visibility into the TX FIFO for debugging purposes.
 * Each register is an entry in the TX FIFO. The registers are read-only and
 * cannot be modified. Reading the TXFRx registers does not alter the state of the TX
 * FIFO. The number of registers used to implement the TX FIFO is
 * device-specific. If a four-entry TX FIFO is implemented, TXFR0-TXFR3 are accessible.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR3 register
 */
/*@{*/
#define SPI_RD_TXFR3(base)       (SPI_TXFR3_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR3 bitfields
 */

/*!
 * @name Register SPI_TXFR3, field TXDATA[15:0] (RO)
 *
 * Contains the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR3_TXDATA field. */
#define SPI_RD_TXFR3_TXDATA(base) ((SPI_TXFR3_REG(base) & SPI_TXFR3_TXDATA_MASK) >> SPI_TXFR3_TXDATA_SHIFT)
#define SPI_BRD_TXFR3_TXDATA(base) (BME_UBFX32(&SPI_TXFR3_REG(base), SPI_TXFR3_TXDATA_SHIFT, SPI_TXFR3_TXDATA_WIDTH))
/*@}*/

/*!
 * @name Register SPI_TXFR3, field TXCMD_TXDATA[31:16] (RO)
 *
 * In Master mode the TXCMD field contains the command that sets the transfer
 * attributes for the SPI data. In Slave mode, the TXDATA contains 16 MSB bits of
 * the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR3_TXCMD_TXDATA field. */
#define SPI_RD_TXFR3_TXCMD_TXDATA(base) ((SPI_TXFR3_REG(base) & SPI_TXFR3_TXCMD_TXDATA_MASK) >> SPI_TXFR3_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR3_TXCMD_TXDATA(base) (BME_UBFX32(&SPI_TXFR3_REG(base), SPI_TXFR3_TXCMD_TXDATA_SHIFT, SPI_TXFR3_TXCMD_TXDATA_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_RXFR0 - Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR0 - Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO. The number of
 * registers used to implement the RX FIFO is device-specific. For example, if a
 * four-entry RX FIFO is implemented, RXFR0-RXFR3 are used.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR0 register
 */
/*@{*/
#define SPI_RD_RXFR0(base)       (SPI_RXFR0_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_RXFR1 - Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR1 - Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO. The number of
 * registers used to implement the RX FIFO is device-specific. For example, if a
 * four-entry RX FIFO is implemented, RXFR0-RXFR3 are used.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR1 register
 */
/*@{*/
#define SPI_RD_RXFR1(base)       (SPI_RXFR1_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_RXFR2 - Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR2 - Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO. The number of
 * registers used to implement the RX FIFO is device-specific. For example, if a
 * four-entry RX FIFO is implemented, RXFR0-RXFR3 are used.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR2 register
 */
/*@{*/
#define SPI_RD_RXFR2(base)       (SPI_RXFR2_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_RXFR3 - Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR3 - Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO. The number of
 * registers used to implement the RX FIFO is device-specific. For example, if a
 * four-entry RX FIFO is implemented, RXFR0-RXFR3 are used.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR3 register
 */
/*@{*/
#define SPI_RD_RXFR3(base)       (SPI_RXFR3_REG(base))
/*@}*/

/*
 * MKW40Z4 TPM
 *
 * Timer/PWM Module
 *
 * Registers defined in this header file:
 * - TPM_SC - Status and Control
 * - TPM_CNT - Counter
 * - TPM_MOD - Modulo
 * - TPM_CnSC - Channel (n) Status and Control
 * - TPM_CnV - Channel (n) Value
 * - TPM_STATUS - Capture and Compare Status
 * - TPM_COMBINE - Combine Channel Register
 * - TPM_FILTER - Filter Control
 * - TPM_QDCTRL - Quadrature Decoder Control and Status
 * - TPM_CONF - Configuration
 */

#define TPM_INSTANCE_COUNT (3U) /*!< Number of instances of the TPM module. */
#define TPM0_IDX (0U) /*!< Instance number for TPM0. */
#define TPM1_IDX (1U) /*!< Instance number for TPM1. */
#define TPM2_IDX (2U) /*!< Instance number for TPM2. */

/*******************************************************************************
 * TPM_SC - Status and Control
 ******************************************************************************/

/*!
 * @brief TPM_SC - Status and Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * SC contains the overflow status flag and control bits used to configure the
 * interrupt enable, module configuration and prescaler factor. These controls
 * relate to all channels within this module.
 */
/*!
 * @name Constants and macros for entire TPM_SC register
 */
/*@{*/
#define TPM_RD_SC(base)          (TPM_SC_REG(base))
#define TPM_WR_SC(base, value)   (TPM_SC_REG(base) = (value))
#define TPM_RMW_SC(base, mask, value) (TPM_WR_SC(base, (TPM_RD_SC(base) & ~(mask)) | (value)))
#define TPM_SET_SC(base, value)  (BME_OR32(&TPM_SC_REG(base), (uint32_t)(value)))
#define TPM_CLR_SC(base, value)  (BME_AND32(&TPM_SC_REG(base), (uint32_t)(~(value))))
#define TPM_TOG_SC(base, value)  (BME_XOR32(&TPM_SC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_SC bitfields
 */

/*!
 * @name Register TPM_SC, field PS[2:0] (RW)
 *
 * Selects one of 8 division factors for the clock mode selected by CMOD. This
 * field is write protected. It can be written only when the counter is disabled.
 *
 * Values:
 * - 0b000 - Divide by 1
 * - 0b001 - Divide by 2
 * - 0b010 - Divide by 4
 * - 0b011 - Divide by 8
 * - 0b100 - Divide by 16
 * - 0b101 - Divide by 32
 * - 0b110 - Divide by 64
 * - 0b111 - Divide by 128
 */
/*@{*/
/*! @brief Read current value of the TPM_SC_PS field. */
#define TPM_RD_SC_PS(base)   ((TPM_SC_REG(base) & TPM_SC_PS_MASK) >> TPM_SC_PS_SHIFT)
#define TPM_BRD_SC_PS(base)  (BME_UBFX32(&TPM_SC_REG(base), TPM_SC_PS_SHIFT, TPM_SC_PS_WIDTH))

/*! @brief Set the PS field to a new value. */
#define TPM_WR_SC_PS(base, value) (TPM_RMW_SC(base, (TPM_SC_PS_MASK | TPM_SC_TOF_MASK), TPM_SC_PS(value)))
#define TPM_BWR_SC_PS(base, value) (BME_BFI32(&TPM_SC_REG(base), ((uint32_t)(value) << TPM_SC_PS_SHIFT), TPM_SC_PS_SHIFT, TPM_SC_PS_WIDTH))
/*@}*/

/*!
 * @name Register TPM_SC, field CMOD[4:3] (RW)
 *
 * Selects the TPM counter clock modes. When disabling the counter, this field
 * remain set until acknolwedged in the TPM clock domain.
 *
 * Values:
 * - 0b00 - TPM counter is disabled
 * - 0b01 - TPM counter increments on every TPM counter clock
 * - 0b10 - TPM counter increments on rising edge of TPM_EXTCLK synchronized to
 *     the TPM counter clock
 * - 0b11 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the TPM_SC_CMOD field. */
#define TPM_RD_SC_CMOD(base) ((TPM_SC_REG(base) & TPM_SC_CMOD_MASK) >> TPM_SC_CMOD_SHIFT)
#define TPM_BRD_SC_CMOD(base) (BME_UBFX32(&TPM_SC_REG(base), TPM_SC_CMOD_SHIFT, TPM_SC_CMOD_WIDTH))

/*! @brief Set the CMOD field to a new value. */
#define TPM_WR_SC_CMOD(base, value) (TPM_RMW_SC(base, (TPM_SC_CMOD_MASK | TPM_SC_TOF_MASK), TPM_SC_CMOD(value)))
#define TPM_BWR_SC_CMOD(base, value) (BME_BFI32(&TPM_SC_REG(base), ((uint32_t)(value) << TPM_SC_CMOD_SHIFT), TPM_SC_CMOD_SHIFT, TPM_SC_CMOD_WIDTH))
/*@}*/

/*!
 * @name Register TPM_SC, field CPWMS[5] (RW)
 *
 * Selects CPWM mode. This mode configures the TPM to operate in up-down
 * counting mode. This field is write protected. It can be written only when the counter
 * is disabled.
 *
 * Values:
 * - 0b0 - TPM counter operates in up counting mode.
 * - 0b1 - TPM counter operates in up-down counting mode.
 */
/*@{*/
/*! @brief Read current value of the TPM_SC_CPWMS field. */
#define TPM_RD_SC_CPWMS(base) ((TPM_SC_REG(base) & TPM_SC_CPWMS_MASK) >> TPM_SC_CPWMS_SHIFT)
#define TPM_BRD_SC_CPWMS(base) (BME_UBFX32(&TPM_SC_REG(base), TPM_SC_CPWMS_SHIFT, TPM_SC_CPWMS_WIDTH))

/*! @brief Set the CPWMS field to a new value. */
#define TPM_WR_SC_CPWMS(base, value) (TPM_RMW_SC(base, (TPM_SC_CPWMS_MASK | TPM_SC_TOF_MASK), TPM_SC_CPWMS(value)))
#define TPM_BWR_SC_CPWMS(base, value) (BME_BFI32(&TPM_SC_REG(base), ((uint32_t)(value) << TPM_SC_CPWMS_SHIFT), TPM_SC_CPWMS_SHIFT, TPM_SC_CPWMS_WIDTH))
/*@}*/

/*!
 * @name Register TPM_SC, field TOIE[6] (RW)
 *
 * Enables TPM overflow interrupts.
 *
 * Values:
 * - 0b0 - Disable TOF interrupts. Use software polling or DMA request.
 * - 0b1 - Enable TOF interrupts. An interrupt is generated when TOF equals one.
 */
/*@{*/
/*! @brief Read current value of the TPM_SC_TOIE field. */
#define TPM_RD_SC_TOIE(base) ((TPM_SC_REG(base) & TPM_SC_TOIE_MASK) >> TPM_SC_TOIE_SHIFT)
#define TPM_BRD_SC_TOIE(base) (BME_UBFX32(&TPM_SC_REG(base), TPM_SC_TOIE_SHIFT, TPM_SC_TOIE_WIDTH))

/*! @brief Set the TOIE field to a new value. */
#define TPM_WR_SC_TOIE(base, value) (TPM_RMW_SC(base, (TPM_SC_TOIE_MASK | TPM_SC_TOF_MASK), TPM_SC_TOIE(value)))
#define TPM_BWR_SC_TOIE(base, value) (BME_BFI32(&TPM_SC_REG(base), ((uint32_t)(value) << TPM_SC_TOIE_SHIFT), TPM_SC_TOIE_SHIFT, TPM_SC_TOIE_WIDTH))
/*@}*/

/*!
 * @name Register TPM_SC, field TOF[7] (W1C)
 *
 * Set by hardware when the TPM counter equals the value in the MOD register and
 * increments. Writing a 1 to TOF clears it. Writing a 0 to TOF has no effect.
 * If another TPM overflow occurs between the flag setting and the flag clearing,
 * the write operation has no effect; therefore, TOF remains set indicating
 * another overflow has occurred. In this case a TOF interrupt request is not lost due
 * to a delay in clearing the previous TOF.
 *
 * Values:
 * - 0b0 - TPM counter has not overflowed.
 * - 0b1 - TPM counter has overflowed.
 */
/*@{*/
/*! @brief Read current value of the TPM_SC_TOF field. */
#define TPM_RD_SC_TOF(base)  ((TPM_SC_REG(base) & TPM_SC_TOF_MASK) >> TPM_SC_TOF_SHIFT)
#define TPM_BRD_SC_TOF(base) (BME_UBFX32(&TPM_SC_REG(base), TPM_SC_TOF_SHIFT, TPM_SC_TOF_WIDTH))

/*! @brief Set the TOF field to a new value. */
#define TPM_WR_SC_TOF(base, value) (TPM_RMW_SC(base, TPM_SC_TOF_MASK, TPM_SC_TOF(value)))
#define TPM_BWR_SC_TOF(base, value) (BME_BFI32(&TPM_SC_REG(base), ((uint32_t)(value) << TPM_SC_TOF_SHIFT), TPM_SC_TOF_SHIFT, TPM_SC_TOF_WIDTH))
/*@}*/

/*!
 * @name Register TPM_SC, field DMA[8] (RW)
 *
 * Enables DMA transfers for the overflow flag.
 *
 * Values:
 * - 0b0 - Disables DMA transfers.
 * - 0b1 - Enables DMA transfers.
 */
/*@{*/
/*! @brief Read current value of the TPM_SC_DMA field. */
#define TPM_RD_SC_DMA(base)  ((TPM_SC_REG(base) & TPM_SC_DMA_MASK) >> TPM_SC_DMA_SHIFT)
#define TPM_BRD_SC_DMA(base) (BME_UBFX32(&TPM_SC_REG(base), TPM_SC_DMA_SHIFT, TPM_SC_DMA_WIDTH))

/*! @brief Set the DMA field to a new value. */
#define TPM_WR_SC_DMA(base, value) (TPM_RMW_SC(base, (TPM_SC_DMA_MASK | TPM_SC_TOF_MASK), TPM_SC_DMA(value)))
#define TPM_BWR_SC_DMA(base, value) (BME_BFI32(&TPM_SC_REG(base), ((uint32_t)(value) << TPM_SC_DMA_SHIFT), TPM_SC_DMA_SHIFT, TPM_SC_DMA_WIDTH))
/*@}*/

/*******************************************************************************
 * TPM_CNT - Counter
 ******************************************************************************/

/*!
 * @brief TPM_CNT - Counter (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CNT register contains the TPM counter value. Reset clears the CNT
 * register. Writing any value to COUNT also clears the counter. When debug is active,
 * the TPM counter does not increment unless configured otherwise. Reading the CNT
 * register adds two wait states to the register access due to synchronization
 * delays.
 */
/*!
 * @name Constants and macros for entire TPM_CNT register
 */
/*@{*/
#define TPM_RD_CNT(base)         (TPM_CNT_REG(base))
#define TPM_WR_CNT(base, value)  (TPM_CNT_REG(base) = (value))
#define TPM_RMW_CNT(base, mask, value) (TPM_WR_CNT(base, (TPM_RD_CNT(base) & ~(mask)) | (value)))
#define TPM_SET_CNT(base, value) (BME_OR32(&TPM_CNT_REG(base), (uint32_t)(value)))
#define TPM_CLR_CNT(base, value) (BME_AND32(&TPM_CNT_REG(base), (uint32_t)(~(value))))
#define TPM_TOG_CNT(base, value) (BME_XOR32(&TPM_CNT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_CNT bitfields
 */

/*!
 * @name Register TPM_CNT, field COUNT[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the TPM_CNT_COUNT field. */
#define TPM_RD_CNT_COUNT(base) ((TPM_CNT_REG(base) & TPM_CNT_COUNT_MASK) >> TPM_CNT_COUNT_SHIFT)
#define TPM_BRD_CNT_COUNT(base) (BME_UBFX32(&TPM_CNT_REG(base), TPM_CNT_COUNT_SHIFT, TPM_CNT_COUNT_WIDTH))

/*! @brief Set the COUNT field to a new value. */
#define TPM_WR_CNT_COUNT(base, value) (TPM_RMW_CNT(base, TPM_CNT_COUNT_MASK, TPM_CNT_COUNT(value)))
#define TPM_BWR_CNT_COUNT(base, value) (BME_BFI32(&TPM_CNT_REG(base), ((uint32_t)(value) << TPM_CNT_COUNT_SHIFT), TPM_CNT_COUNT_SHIFT, TPM_CNT_COUNT_WIDTH))
/*@}*/

/*******************************************************************************
 * TPM_MOD - Modulo
 ******************************************************************************/

/*!
 * @brief TPM_MOD - Modulo (RW)
 *
 * Reset value: 0x0000FFFFU
 *
 * The Modulo register contains the modulo value for the TPM counter. When the
 * TPM counter reaches the modulo value and increments, the overflow flag (TOF) is
 * set and the next value of TPM counter depends on the selected counting method
 * (see CounterThe TPM has a 16-bit counter that is used by the channels either
 * for input or output modes. ). Writing to the MOD register latches the value
 * into a buffer. The MOD register is updated with the value of its write buffer
 * according to MOD Register Update . Additional writes to the MOD write buffer are
 * ignored until the register has been updated. It is recommended to initialize
 * the TPM counter (write to CNT) before writing to the MOD register to avoid
 * confusion about when the first counter overflow will occur.
 */
/*!
 * @name Constants and macros for entire TPM_MOD register
 */
/*@{*/
#define TPM_RD_MOD(base)         (TPM_MOD_REG(base))
#define TPM_WR_MOD(base, value)  (TPM_MOD_REG(base) = (value))
#define TPM_RMW_MOD(base, mask, value) (TPM_WR_MOD(base, (TPM_RD_MOD(base) & ~(mask)) | (value)))
#define TPM_SET_MOD(base, value) (BME_OR32(&TPM_MOD_REG(base), (uint32_t)(value)))
#define TPM_CLR_MOD(base, value) (BME_AND32(&TPM_MOD_REG(base), (uint32_t)(~(value))))
#define TPM_TOG_MOD(base, value) (BME_XOR32(&TPM_MOD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_MOD bitfields
 */

/*!
 * @name Register TPM_MOD, field MOD[15:0] (RW)
 *
 * This field must be written with single 16-bit or 32-bit access.
 */
/*@{*/
/*! @brief Read current value of the TPM_MOD_MOD field. */
#define TPM_RD_MOD_MOD(base) ((TPM_MOD_REG(base) & TPM_MOD_MOD_MASK) >> TPM_MOD_MOD_SHIFT)
#define TPM_BRD_MOD_MOD(base) (BME_UBFX32(&TPM_MOD_REG(base), TPM_MOD_MOD_SHIFT, TPM_MOD_MOD_WIDTH))

/*! @brief Set the MOD field to a new value. */
#define TPM_WR_MOD_MOD(base, value) (TPM_RMW_MOD(base, TPM_MOD_MOD_MASK, TPM_MOD_MOD(value)))
#define TPM_BWR_MOD_MOD(base, value) (BME_BFI32(&TPM_MOD_REG(base), ((uint32_t)(value) << TPM_MOD_MOD_SHIFT), TPM_MOD_MOD_SHIFT, TPM_MOD_MOD_WIDTH))
/*@}*/

/*******************************************************************************
 * TPM_CnSC - Channel (n) Status and Control
 ******************************************************************************/

/*!
 * @brief TPM_CnSC - Channel (n) Status and Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * CnSC contains the channel-interrupt-status flag and control bits used to
 * configure the interrupt enable, channel configuration, and pin function. When
 * switching from one channel mode to a different channel mode, the channel must
 * first be disabled and this must be acknowledged in the TPM counter clock domain.
 * Mode, Edge, and Level Selection CPWMS MSnB:MSnA ELSnB:ELSnA Mode Configuration
 * X 00 00 None Channel disabled X 01 00 Software compare Pin not used for TPM 0
 * 00 01 Input capture Capture on Rising Edge Only 10 Capture on Falling Edge
 * Only 11 Capture on Rising or Falling Edge 01 01 Output compare Toggle Output on
 * match 10 Clear Output on match 11 Set Output on match 10 10 Edge-aligned PWM
 * High-true pulses (clear Output on match, set Output on reload) X1 Low-true
 * pulses (set Output on match, clear Output on reload) 11 10 Output compare Pulse
 * Output low on match 01 Pulse Output high on match 1 10 10 Center-aligned PWM
 * High-true pulses (clear Output on match-up, set Output on match-down) 01 Low-true
 * pulses (set Output on match-up, clear Output on match-down)
 */
/*!
 * @name Constants and macros for entire TPM_CnSC register
 */
/*@{*/
#define TPM_RD_CnSC(base, index) (TPM_CnSC_REG(base, index))
#define TPM_WR_CnSC(base, index, value) (TPM_CnSC_REG(base, index) = (value))
#define TPM_RMW_CnSC(base, index, mask, value) (TPM_WR_CnSC(base, index, (TPM_RD_CnSC(base, index) & ~(mask)) | (value)))
#define TPM_SET_CnSC(base, index, value) (BME_OR32(&TPM_CnSC_REG(base, index), (uint32_t)(value)))
#define TPM_CLR_CnSC(base, index, value) (BME_AND32(&TPM_CnSC_REG(base, index), (uint32_t)(~(value))))
#define TPM_TOG_CnSC(base, index, value) (BME_XOR32(&TPM_CnSC_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_CnSC bitfields
 */

/*!
 * @name Register TPM_CnSC, field DMA[0] (RW)
 *
 * Enables DMA transfers for the channel.
 *
 * Values:
 * - 0b0 - Disable DMA transfers.
 * - 0b1 - Enable DMA transfers.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_DMA field. */
#define TPM_RD_CnSC_DMA(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_DMA_MASK) >> TPM_CnSC_DMA_SHIFT)
#define TPM_BRD_CnSC_DMA(base, index) (BME_UBFX32(&TPM_CnSC_REG(base, index), TPM_CnSC_DMA_SHIFT, TPM_CnSC_DMA_WIDTH))

/*! @brief Set the DMA field to a new value. */
#define TPM_WR_CnSC_DMA(base, index, value) (TPM_RMW_CnSC(base, index, (TPM_CnSC_DMA_MASK | TPM_CnSC_CHF_MASK), TPM_CnSC_DMA(value)))
#define TPM_BWR_CnSC_DMA(base, index, value) (BME_BFI32(&TPM_CnSC_REG(base, index), ((uint32_t)(value) << TPM_CnSC_DMA_SHIFT), TPM_CnSC_DMA_SHIFT, TPM_CnSC_DMA_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CnSC, field ELSA[2] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. When a
 * channel is disabled, this field will not change state until acknowledged in the TPM
 * counter clock domain.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_ELSA field. */
#define TPM_RD_CnSC_ELSA(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_ELSA_MASK) >> TPM_CnSC_ELSA_SHIFT)
#define TPM_BRD_CnSC_ELSA(base, index) (BME_UBFX32(&TPM_CnSC_REG(base, index), TPM_CnSC_ELSA_SHIFT, TPM_CnSC_ELSA_WIDTH))

/*! @brief Set the ELSA field to a new value. */
#define TPM_WR_CnSC_ELSA(base, index, value) (TPM_RMW_CnSC(base, index, (TPM_CnSC_ELSA_MASK | TPM_CnSC_CHF_MASK), TPM_CnSC_ELSA(value)))
#define TPM_BWR_CnSC_ELSA(base, index, value) (BME_BFI32(&TPM_CnSC_REG(base, index), ((uint32_t)(value) << TPM_CnSC_ELSA_SHIFT), TPM_CnSC_ELSA_SHIFT, TPM_CnSC_ELSA_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CnSC, field ELSB[3] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. When a
 * channel is disabled, this field will not change state until acknowledged in the TPM
 * counter clock domain.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_ELSB field. */
#define TPM_RD_CnSC_ELSB(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_ELSB_MASK) >> TPM_CnSC_ELSB_SHIFT)
#define TPM_BRD_CnSC_ELSB(base, index) (BME_UBFX32(&TPM_CnSC_REG(base, index), TPM_CnSC_ELSB_SHIFT, TPM_CnSC_ELSB_WIDTH))

/*! @brief Set the ELSB field to a new value. */
#define TPM_WR_CnSC_ELSB(base, index, value) (TPM_RMW_CnSC(base, index, (TPM_CnSC_ELSB_MASK | TPM_CnSC_CHF_MASK), TPM_CnSC_ELSB(value)))
#define TPM_BWR_CnSC_ELSB(base, index, value) (BME_BFI32(&TPM_CnSC_REG(base, index), ((uint32_t)(value) << TPM_CnSC_ELSB_SHIFT), TPM_CnSC_ELSB_SHIFT, TPM_CnSC_ELSB_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CnSC, field MSA[4] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. When a channel is disabled, this field will not
 * change state until acknowledged in the TPM counter clock domain.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_MSA field. */
#define TPM_RD_CnSC_MSA(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_MSA_MASK) >> TPM_CnSC_MSA_SHIFT)
#define TPM_BRD_CnSC_MSA(base, index) (BME_UBFX32(&TPM_CnSC_REG(base, index), TPM_CnSC_MSA_SHIFT, TPM_CnSC_MSA_WIDTH))

/*! @brief Set the MSA field to a new value. */
#define TPM_WR_CnSC_MSA(base, index, value) (TPM_RMW_CnSC(base, index, (TPM_CnSC_MSA_MASK | TPM_CnSC_CHF_MASK), TPM_CnSC_MSA(value)))
#define TPM_BWR_CnSC_MSA(base, index, value) (BME_BFI32(&TPM_CnSC_REG(base, index), ((uint32_t)(value) << TPM_CnSC_MSA_SHIFT), TPM_CnSC_MSA_SHIFT, TPM_CnSC_MSA_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CnSC, field MSB[5] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. When a channel is disabled, this field will not
 * change state until acknowledged in the TPM counter clock domain.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_MSB field. */
#define TPM_RD_CnSC_MSB(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_MSB_MASK) >> TPM_CnSC_MSB_SHIFT)
#define TPM_BRD_CnSC_MSB(base, index) (BME_UBFX32(&TPM_CnSC_REG(base, index), TPM_CnSC_MSB_SHIFT, TPM_CnSC_MSB_WIDTH))

/*! @brief Set the MSB field to a new value. */
#define TPM_WR_CnSC_MSB(base, index, value) (TPM_RMW_CnSC(base, index, (TPM_CnSC_MSB_MASK | TPM_CnSC_CHF_MASK), TPM_CnSC_MSB(value)))
#define TPM_BWR_CnSC_MSB(base, index, value) (BME_BFI32(&TPM_CnSC_REG(base, index), ((uint32_t)(value) << TPM_CnSC_MSB_SHIFT), TPM_CnSC_MSB_SHIFT, TPM_CnSC_MSB_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CnSC, field CHIE[6] (RW)
 *
 * Enables channel interrupts.
 *
 * Values:
 * - 0b0 - Disable channel interrupts.
 * - 0b1 - Enable channel interrupts.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_CHIE field. */
#define TPM_RD_CnSC_CHIE(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_CHIE_MASK) >> TPM_CnSC_CHIE_SHIFT)
#define TPM_BRD_CnSC_CHIE(base, index) (BME_UBFX32(&TPM_CnSC_REG(base, index), TPM_CnSC_CHIE_SHIFT, TPM_CnSC_CHIE_WIDTH))

/*! @brief Set the CHIE field to a new value. */
#define TPM_WR_CnSC_CHIE(base, index, value) (TPM_RMW_CnSC(base, index, (TPM_CnSC_CHIE_MASK | TPM_CnSC_CHF_MASK), TPM_CnSC_CHIE(value)))
#define TPM_BWR_CnSC_CHIE(base, index, value) (BME_BFI32(&TPM_CnSC_REG(base, index), ((uint32_t)(value) << TPM_CnSC_CHIE_SHIFT), TPM_CnSC_CHIE_SHIFT, TPM_CnSC_CHIE_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CnSC, field CHF[7] (W1C)
 *
 * Set by hardware when an event occurs on the channel. CHF is cleared by
 * writing a 1 to the CHF bit. Writing a 0 to CHF has no effect. If another event
 * occurs between the CHF sets and the write operation, the write operation has no
 * effect; therefore, CHF remains set indicating another event has occurred. In this
 * case a CHF interrupt request is not lost due to the delay in clearing the
 * previous CHF.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_CHF field. */
#define TPM_RD_CnSC_CHF(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_CHF_MASK) >> TPM_CnSC_CHF_SHIFT)
#define TPM_BRD_CnSC_CHF(base, index) (BME_UBFX32(&TPM_CnSC_REG(base, index), TPM_CnSC_CHF_SHIFT, TPM_CnSC_CHF_WIDTH))

/*! @brief Set the CHF field to a new value. */
#define TPM_WR_CnSC_CHF(base, index, value) (TPM_RMW_CnSC(base, index, TPM_CnSC_CHF_MASK, TPM_CnSC_CHF(value)))
#define TPM_BWR_CnSC_CHF(base, index, value) (BME_BFI32(&TPM_CnSC_REG(base, index), ((uint32_t)(value) << TPM_CnSC_CHF_SHIFT), TPM_CnSC_CHF_SHIFT, TPM_CnSC_CHF_WIDTH))
/*@}*/

/*******************************************************************************
 * TPM_CnV - Channel (n) Value
 ******************************************************************************/

/*!
 * @brief TPM_CnV - Channel (n) Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the captured TPM counter value for the input modes or
 * the match value for the output modes. In input capture mode, any write to a
 * CnV register is ignored. In compare modes, writing to a CnV register latches
 * the value into a buffer. A CnV register is updated with the value of its write
 * buffer according to CnV Register Update . Additional writes to the CnV write
 * buffer are ignored until the register has been updated.
 */
/*!
 * @name Constants and macros for entire TPM_CnV register
 */
/*@{*/
#define TPM_RD_CnV(base, index)  (TPM_CnV_REG(base, index))
#define TPM_WR_CnV(base, index, value) (TPM_CnV_REG(base, index) = (value))
#define TPM_RMW_CnV(base, index, mask, value) (TPM_WR_CnV(base, index, (TPM_RD_CnV(base, index) & ~(mask)) | (value)))
#define TPM_SET_CnV(base, index, value) (BME_OR32(&TPM_CnV_REG(base, index), (uint32_t)(value)))
#define TPM_CLR_CnV(base, index, value) (BME_AND32(&TPM_CnV_REG(base, index), (uint32_t)(~(value))))
#define TPM_TOG_CnV(base, index, value) (BME_XOR32(&TPM_CnV_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_CnV bitfields
 */

/*!
 * @name Register TPM_CnV, field VAL[15:0] (RW)
 *
 * Captured TPM counter value of the input modes or the match value for the
 * output modes. This field must be written with single 16-bit or 32-bit access.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnV_VAL field. */
#define TPM_RD_CnV_VAL(base, index) ((TPM_CnV_REG(base, index) & TPM_CnV_VAL_MASK) >> TPM_CnV_VAL_SHIFT)
#define TPM_BRD_CnV_VAL(base, index) (BME_UBFX32(&TPM_CnV_REG(base, index), TPM_CnV_VAL_SHIFT, TPM_CnV_VAL_WIDTH))

/*! @brief Set the VAL field to a new value. */
#define TPM_WR_CnV_VAL(base, index, value) (TPM_RMW_CnV(base, index, TPM_CnV_VAL_MASK, TPM_CnV_VAL(value)))
#define TPM_BWR_CnV_VAL(base, index, value) (BME_BFI32(&TPM_CnV_REG(base, index), ((uint32_t)(value) << TPM_CnV_VAL_SHIFT), TPM_CnV_VAL_SHIFT, TPM_CnV_VAL_WIDTH))
/*@}*/

/*******************************************************************************
 * TPM_STATUS - Capture and Compare Status
 ******************************************************************************/

/*!
 * @brief TPM_STATUS - Capture and Compare Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * The STATUS register contains a copy of the status flag, CnSC[CHnF] for each
 * TPM channel, as well as SC[TOF], for software convenience. Each CHnF bit in
 * STATUS is a mirror of CHnF bit in CnSC. All CHnF bits can be checked using only
 * one read of STATUS. All CHnF bits can be cleared by writing all ones to STATUS.
 * Hardware sets the individual channel flags when an event occurs on the
 * channel. Writing a 1 to CHF clears it. Writing a 0 to CHF has no effect. If another
 * event occurs between the flag setting and the write operation, the write
 * operation has no effect; therefore, CHF remains set indicating another event has
 * occurred. In this case a CHF interrupt request is not lost due to the clearing
 * sequence for a previous CHF.
 */
/*!
 * @name Constants and macros for entire TPM_STATUS register
 */
/*@{*/
#define TPM_RD_STATUS(base)      (TPM_STATUS_REG(base))
#define TPM_WR_STATUS(base, value) (TPM_STATUS_REG(base) = (value))
#define TPM_RMW_STATUS(base, mask, value) (TPM_WR_STATUS(base, (TPM_RD_STATUS(base) & ~(mask)) | (value)))
#define TPM_SET_STATUS(base, value) (BME_OR32(&TPM_STATUS_REG(base), (uint32_t)(value)))
#define TPM_CLR_STATUS(base, value) (BME_AND32(&TPM_STATUS_REG(base), (uint32_t)(~(value))))
#define TPM_TOG_STATUS(base, value) (BME_XOR32(&TPM_STATUS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_STATUS bitfields
 */

/*!
 * @name Register TPM_STATUS, field CH0F[0] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_CH0F field. */
#define TPM_RD_STATUS_CH0F(base) ((TPM_STATUS_REG(base) & TPM_STATUS_CH0F_MASK) >> TPM_STATUS_CH0F_SHIFT)
#define TPM_BRD_STATUS_CH0F(base) (BME_UBFX32(&TPM_STATUS_REG(base), TPM_STATUS_CH0F_SHIFT, TPM_STATUS_CH0F_WIDTH))

/*! @brief Set the CH0F field to a new value. */
#define TPM_WR_STATUS_CH0F(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_CH0F_MASK | TPM_STATUS_CH1F_MASK | TPM_STATUS_CH2F_MASK | TPM_STATUS_CH3F_MASK | TPM_STATUS_TOF_MASK), TPM_STATUS_CH0F(value)))
#define TPM_BWR_STATUS_CH0F(base, value) (BME_BFI32(&TPM_STATUS_REG(base), ((uint32_t)(value) << TPM_STATUS_CH0F_SHIFT), TPM_STATUS_CH0F_SHIFT, TPM_STATUS_CH0F_WIDTH))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH1F[1] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_CH1F field. */
#define TPM_RD_STATUS_CH1F(base) ((TPM_STATUS_REG(base) & TPM_STATUS_CH1F_MASK) >> TPM_STATUS_CH1F_SHIFT)
#define TPM_BRD_STATUS_CH1F(base) (BME_UBFX32(&TPM_STATUS_REG(base), TPM_STATUS_CH1F_SHIFT, TPM_STATUS_CH1F_WIDTH))

/*! @brief Set the CH1F field to a new value. */
#define TPM_WR_STATUS_CH1F(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_CH1F_MASK | TPM_STATUS_CH0F_MASK | TPM_STATUS_CH2F_MASK | TPM_STATUS_CH3F_MASK | TPM_STATUS_TOF_MASK), TPM_STATUS_CH1F(value)))
#define TPM_BWR_STATUS_CH1F(base, value) (BME_BFI32(&TPM_STATUS_REG(base), ((uint32_t)(value) << TPM_STATUS_CH1F_SHIFT), TPM_STATUS_CH1F_SHIFT, TPM_STATUS_CH1F_WIDTH))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH2F[2] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_CH2F field. */
#define TPM_RD_STATUS_CH2F(base) ((TPM_STATUS_REG(base) & TPM_STATUS_CH2F_MASK) >> TPM_STATUS_CH2F_SHIFT)
#define TPM_BRD_STATUS_CH2F(base) (BME_UBFX32(&TPM_STATUS_REG(base), TPM_STATUS_CH2F_SHIFT, TPM_STATUS_CH2F_WIDTH))

/*! @brief Set the CH2F field to a new value. */
#define TPM_WR_STATUS_CH2F(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_CH2F_MASK | TPM_STATUS_CH0F_MASK | TPM_STATUS_CH1F_MASK | TPM_STATUS_CH3F_MASK | TPM_STATUS_TOF_MASK), TPM_STATUS_CH2F(value)))
#define TPM_BWR_STATUS_CH2F(base, value) (BME_BFI32(&TPM_STATUS_REG(base), ((uint32_t)(value) << TPM_STATUS_CH2F_SHIFT), TPM_STATUS_CH2F_SHIFT, TPM_STATUS_CH2F_WIDTH))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH3F[3] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_CH3F field. */
#define TPM_RD_STATUS_CH3F(base) ((TPM_STATUS_REG(base) & TPM_STATUS_CH3F_MASK) >> TPM_STATUS_CH3F_SHIFT)
#define TPM_BRD_STATUS_CH3F(base) (BME_UBFX32(&TPM_STATUS_REG(base), TPM_STATUS_CH3F_SHIFT, TPM_STATUS_CH3F_WIDTH))

/*! @brief Set the CH3F field to a new value. */
#define TPM_WR_STATUS_CH3F(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_CH3F_MASK | TPM_STATUS_CH0F_MASK | TPM_STATUS_CH1F_MASK | TPM_STATUS_CH2F_MASK | TPM_STATUS_TOF_MASK), TPM_STATUS_CH3F(value)))
#define TPM_BWR_STATUS_CH3F(base, value) (BME_BFI32(&TPM_STATUS_REG(base), ((uint32_t)(value) << TPM_STATUS_CH3F_SHIFT), TPM_STATUS_CH3F_SHIFT, TPM_STATUS_CH3F_WIDTH))
/*@}*/

/*!
 * @name Register TPM_STATUS, field TOF[8] (W1C)
 *
 * See register description
 *
 * Values:
 * - 0b0 - TPM counter has not overflowed.
 * - 0b1 - TPM counter has overflowed.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_TOF field. */
#define TPM_RD_STATUS_TOF(base) ((TPM_STATUS_REG(base) & TPM_STATUS_TOF_MASK) >> TPM_STATUS_TOF_SHIFT)
#define TPM_BRD_STATUS_TOF(base) (BME_UBFX32(&TPM_STATUS_REG(base), TPM_STATUS_TOF_SHIFT, TPM_STATUS_TOF_WIDTH))

/*! @brief Set the TOF field to a new value. */
#define TPM_WR_STATUS_TOF(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_TOF_MASK | TPM_STATUS_CH0F_MASK | TPM_STATUS_CH1F_MASK | TPM_STATUS_CH2F_MASK | TPM_STATUS_CH3F_MASK), TPM_STATUS_TOF(value)))
#define TPM_BWR_STATUS_TOF(base, value) (BME_BFI32(&TPM_STATUS_REG(base), ((uint32_t)(value) << TPM_STATUS_TOF_SHIFT), TPM_STATUS_TOF_SHIFT, TPM_STATUS_TOF_WIDTH))
/*@}*/

/*******************************************************************************
 * TPM_COMBINE - Combine Channel Register
 ******************************************************************************/

/*!
 * @brief TPM_COMBINE - Combine Channel Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the control bits used to configure the combine channel
 * modes for each pair of channels (n) and (n+1), where n is all the even
 * numbered channels.
 */
/*!
 * @name Constants and macros for entire TPM_COMBINE register
 */
/*@{*/
#define TPM_RD_COMBINE(base)     (TPM_COMBINE_REG(base))
#define TPM_WR_COMBINE(base, value) (TPM_COMBINE_REG(base) = (value))
#define TPM_RMW_COMBINE(base, mask, value) (TPM_WR_COMBINE(base, (TPM_RD_COMBINE(base) & ~(mask)) | (value)))
#define TPM_SET_COMBINE(base, value) (BME_OR32(&TPM_COMBINE_REG(base), (uint32_t)(value)))
#define TPM_CLR_COMBINE(base, value) (BME_AND32(&TPM_COMBINE_REG(base), (uint32_t)(~(value))))
#define TPM_TOG_COMBINE(base, value) (BME_XOR32(&TPM_COMBINE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_COMBINE bitfields
 */

/*!
 * @name Register TPM_COMBINE, field COMBINE0[0] (RW)
 *
 * Enables the combine feature for channels 0 and 1. In input capture mode, the
 * combined channels use the even channel input. In software compare modes, the
 * even channel match asserts the output trigger and the odd channel match negates
 * the output trigger. In PWM modes, the even channel match is used for the 1st
 * compare and odd channel match for the 2nd compare.
 *
 * Values:
 * - 0b0 - Channels 0 and 1 are independent.
 * - 0b1 - Channels 0 and 1 are combined.
 */
/*@{*/
/*! @brief Read current value of the TPM_COMBINE_COMBINE0 field. */
#define TPM_RD_COMBINE_COMBINE0(base) ((TPM_COMBINE_REG(base) & TPM_COMBINE_COMBINE0_MASK) >> TPM_COMBINE_COMBINE0_SHIFT)
#define TPM_BRD_COMBINE_COMBINE0(base) (BME_UBFX32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMBINE0_SHIFT, TPM_COMBINE_COMBINE0_WIDTH))

/*! @brief Set the COMBINE0 field to a new value. */
#define TPM_WR_COMBINE_COMBINE0(base, value) (TPM_RMW_COMBINE(base, TPM_COMBINE_COMBINE0_MASK, TPM_COMBINE_COMBINE0(value)))
#define TPM_BWR_COMBINE_COMBINE0(base, value) (BME_BFI32(&TPM_COMBINE_REG(base), ((uint32_t)(value) << TPM_COMBINE_COMBINE0_SHIFT), TPM_COMBINE_COMBINE0_SHIFT, TPM_COMBINE_COMBINE0_WIDTH))
/*@}*/

/*!
 * @name Register TPM_COMBINE, field COMSWAP0[1] (RW)
 *
 * When set in combine mode, the even channel is used for the input capture and
 * 1st compare, the odd channel is used for the 2nd compare.
 *
 * Values:
 * - 0b0 - Even channel is used for input capture and 1st compare.
 * - 0b1 - Odd channel is used for input capture and 1st compare.
 */
/*@{*/
/*! @brief Read current value of the TPM_COMBINE_COMSWAP0 field. */
#define TPM_RD_COMBINE_COMSWAP0(base) ((TPM_COMBINE_REG(base) & TPM_COMBINE_COMSWAP0_MASK) >> TPM_COMBINE_COMSWAP0_SHIFT)
#define TPM_BRD_COMBINE_COMSWAP0(base) (BME_UBFX32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMSWAP0_SHIFT, TPM_COMBINE_COMSWAP0_WIDTH))

/*! @brief Set the COMSWAP0 field to a new value. */
#define TPM_WR_COMBINE_COMSWAP0(base, value) (TPM_RMW_COMBINE(base, TPM_COMBINE_COMSWAP0_MASK, TPM_COMBINE_COMSWAP0(value)))
#define TPM_BWR_COMBINE_COMSWAP0(base, value) (BME_BFI32(&TPM_COMBINE_REG(base), ((uint32_t)(value) << TPM_COMBINE_COMSWAP0_SHIFT), TPM_COMBINE_COMSWAP0_SHIFT, TPM_COMBINE_COMSWAP0_WIDTH))
/*@}*/

/*!
 * @name Register TPM_COMBINE, field COMBINE1[8] (RW)
 *
 * Enables the combine feature for channels 2 and 3. In input capture mode, the
 * combined channels use the even channel input. In software compare modes, the
 * even channel match asserts the output trigger and the odd channel match negates
 * the output trigger. In PWM modes, the even channel match is used for the 1st
 * compare and odd channel match for the 2nd compare.
 *
 * Values:
 * - 0b0 - Channels 2 and 3 are independent.
 * - 0b1 - Channels 2 and 3 are combined.
 */
/*@{*/
/*! @brief Read current value of the TPM_COMBINE_COMBINE1 field. */
#define TPM_RD_COMBINE_COMBINE1(base) ((TPM_COMBINE_REG(base) & TPM_COMBINE_COMBINE1_MASK) >> TPM_COMBINE_COMBINE1_SHIFT)
#define TPM_BRD_COMBINE_COMBINE1(base) (BME_UBFX32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMBINE1_SHIFT, TPM_COMBINE_COMBINE1_WIDTH))

/*! @brief Set the COMBINE1 field to a new value. */
#define TPM_WR_COMBINE_COMBINE1(base, value) (TPM_RMW_COMBINE(base, TPM_COMBINE_COMBINE1_MASK, TPM_COMBINE_COMBINE1(value)))
#define TPM_BWR_COMBINE_COMBINE1(base, value) (BME_BFI32(&TPM_COMBINE_REG(base), ((uint32_t)(value) << TPM_COMBINE_COMBINE1_SHIFT), TPM_COMBINE_COMBINE1_SHIFT, TPM_COMBINE_COMBINE1_WIDTH))
/*@}*/

/*!
 * @name Register TPM_COMBINE, field COMSWAP1[9] (RW)
 *
 * When set in combine mode, the odd channel is used for the input capture and
 * 1st compare, the even channel is used for the 2nd compare.
 *
 * Values:
 * - 0b0 - Even channel is used for input capture and 1st compare.
 * - 0b1 - Odd channel is used for input capture and 1st compare.
 */
/*@{*/
/*! @brief Read current value of the TPM_COMBINE_COMSWAP1 field. */
#define TPM_RD_COMBINE_COMSWAP1(base) ((TPM_COMBINE_REG(base) & TPM_COMBINE_COMSWAP1_MASK) >> TPM_COMBINE_COMSWAP1_SHIFT)
#define TPM_BRD_COMBINE_COMSWAP1(base) (BME_UBFX32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMSWAP1_SHIFT, TPM_COMBINE_COMSWAP1_WIDTH))

/*! @brief Set the COMSWAP1 field to a new value. */
#define TPM_WR_COMBINE_COMSWAP1(base, value) (TPM_RMW_COMBINE(base, TPM_COMBINE_COMSWAP1_MASK, TPM_COMBINE_COMSWAP1(value)))
#define TPM_BWR_COMBINE_COMSWAP1(base, value) (BME_BFI32(&TPM_COMBINE_REG(base), ((uint32_t)(value) << TPM_COMBINE_COMSWAP1_SHIFT), TPM_COMBINE_COMSWAP1_SHIFT, TPM_COMBINE_COMSWAP1_WIDTH))
/*@}*/

/*******************************************************************************
 * TPM_FILTER - Filter Control
 ******************************************************************************/

/*!
 * @brief TPM_FILTER - Filter Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the filter value of the channel inputs, and an
 * additional output delay value for the channel outputs. In PWM combine modes, the
 * filter can effectively implements deadtime insertion.
 */
/*!
 * @name Constants and macros for entire TPM_FILTER register
 */
/*@{*/
#define TPM_RD_FILTER(base)      (TPM_FILTER_REG(base))
#define TPM_WR_FILTER(base, value) (TPM_FILTER_REG(base) = (value))
#define TPM_RMW_FILTER(base, mask, value) (TPM_WR_FILTER(base, (TPM_RD_FILTER(base) & ~(mask)) | (value)))
#define TPM_SET_FILTER(base, value) (BME_OR32(&TPM_FILTER_REG(base), (uint32_t)(value)))
#define TPM_CLR_FILTER(base, value) (BME_AND32(&TPM_FILTER_REG(base), (uint32_t)(~(value))))
#define TPM_TOG_FILTER(base, value) (BME_XOR32(&TPM_FILTER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_FILTER bitfields
 */

/*!
 * @name Register TPM_FILTER, field CH0FVAL[3:0] (RW)
 *
 * Selects the filter value for the channel input and the delay value for the
 * channel output. The filter/delay is disabled when the value is zero, otherwise
 * the filter/delay is configured as (CH0FVAL * 4) clock cycles.
 */
/*@{*/
/*! @brief Read current value of the TPM_FILTER_CH0FVAL field. */
#define TPM_RD_FILTER_CH0FVAL(base) ((TPM_FILTER_REG(base) & TPM_FILTER_CH0FVAL_MASK) >> TPM_FILTER_CH0FVAL_SHIFT)
#define TPM_BRD_FILTER_CH0FVAL(base) (BME_UBFX32(&TPM_FILTER_REG(base), TPM_FILTER_CH0FVAL_SHIFT, TPM_FILTER_CH0FVAL_WIDTH))

/*! @brief Set the CH0FVAL field to a new value. */
#define TPM_WR_FILTER_CH0FVAL(base, value) (TPM_RMW_FILTER(base, TPM_FILTER_CH0FVAL_MASK, TPM_FILTER_CH0FVAL(value)))
#define TPM_BWR_FILTER_CH0FVAL(base, value) (BME_BFI32(&TPM_FILTER_REG(base), ((uint32_t)(value) << TPM_FILTER_CH0FVAL_SHIFT), TPM_FILTER_CH0FVAL_SHIFT, TPM_FILTER_CH0FVAL_WIDTH))
/*@}*/

/*!
 * @name Register TPM_FILTER, field CH1FVAL[7:4] (RW)
 *
 * Selects the filter value for the channel input and the delay value for the
 * channel output. The filter/delay is disabled when the value is zero, otherwise
 * the filter/delay is configured as (CH1FVAL * 4) clock cycles.
 */
/*@{*/
/*! @brief Read current value of the TPM_FILTER_CH1FVAL field. */
#define TPM_RD_FILTER_CH1FVAL(base) ((TPM_FILTER_REG(base) & TPM_FILTER_CH1FVAL_MASK) >> TPM_FILTER_CH1FVAL_SHIFT)
#define TPM_BRD_FILTER_CH1FVAL(base) (BME_UBFX32(&TPM_FILTER_REG(base), TPM_FILTER_CH1FVAL_SHIFT, TPM_FILTER_CH1FVAL_WIDTH))

/*! @brief Set the CH1FVAL field to a new value. */
#define TPM_WR_FILTER_CH1FVAL(base, value) (TPM_RMW_FILTER(base, TPM_FILTER_CH1FVAL_MASK, TPM_FILTER_CH1FVAL(value)))
#define TPM_BWR_FILTER_CH1FVAL(base, value) (BME_BFI32(&TPM_FILTER_REG(base), ((uint32_t)(value) << TPM_FILTER_CH1FVAL_SHIFT), TPM_FILTER_CH1FVAL_SHIFT, TPM_FILTER_CH1FVAL_WIDTH))
/*@}*/

/*!
 * @name Register TPM_FILTER, field CH2FVAL[11:8] (RW)
 *
 * Selects the filter value for the channel input and the delay value for the
 * channel output. The filter/delay is disabled when the value is zero, otherwise
 * the filter/delay is configured as (CH2FVAL * 4) clock cycles.
 */
/*@{*/
/*! @brief Read current value of the TPM_FILTER_CH2FVAL field. */
#define TPM_RD_FILTER_CH2FVAL(base) ((TPM_FILTER_REG(base) & TPM_FILTER_CH2FVAL_MASK) >> TPM_FILTER_CH2FVAL_SHIFT)
#define TPM_BRD_FILTER_CH2FVAL(base) (BME_UBFX32(&TPM_FILTER_REG(base), TPM_FILTER_CH2FVAL_SHIFT, TPM_FILTER_CH2FVAL_WIDTH))

/*! @brief Set the CH2FVAL field to a new value. */
#define TPM_WR_FILTER_CH2FVAL(base, value) (TPM_RMW_FILTER(base, TPM_FILTER_CH2FVAL_MASK, TPM_FILTER_CH2FVAL(value)))
#define TPM_BWR_FILTER_CH2FVAL(base, value) (BME_BFI32(&TPM_FILTER_REG(base), ((uint32_t)(value) << TPM_FILTER_CH2FVAL_SHIFT), TPM_FILTER_CH2FVAL_SHIFT, TPM_FILTER_CH2FVAL_WIDTH))
/*@}*/

/*!
 * @name Register TPM_FILTER, field CH3FVAL[15:12] (RW)
 *
 * Selects the filter value for the channel input and the delay value for the
 * channel output. The filter/delay is disabled when the value is zero, otherwise
 * the filter/delay is configured as (CH3FVAL * 4) clock cycles.
 */
/*@{*/
/*! @brief Read current value of the TPM_FILTER_CH3FVAL field. */
#define TPM_RD_FILTER_CH3FVAL(base) ((TPM_FILTER_REG(base) & TPM_FILTER_CH3FVAL_MASK) >> TPM_FILTER_CH3FVAL_SHIFT)
#define TPM_BRD_FILTER_CH3FVAL(base) (BME_UBFX32(&TPM_FILTER_REG(base), TPM_FILTER_CH3FVAL_SHIFT, TPM_FILTER_CH3FVAL_WIDTH))

/*! @brief Set the CH3FVAL field to a new value. */
#define TPM_WR_FILTER_CH3FVAL(base, value) (TPM_RMW_FILTER(base, TPM_FILTER_CH3FVAL_MASK, TPM_FILTER_CH3FVAL(value)))
#define TPM_BWR_FILTER_CH3FVAL(base, value) (BME_BFI32(&TPM_FILTER_REG(base), ((uint32_t)(value) << TPM_FILTER_CH3FVAL_SHIFT), TPM_FILTER_CH3FVAL_SHIFT, TPM_FILTER_CH3FVAL_WIDTH))
/*@}*/

/*******************************************************************************
 * TPM_QDCTRL - Quadrature Decoder Control and Status
 ******************************************************************************/

/*!
 * @brief TPM_QDCTRL - Quadrature Decoder Control and Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register has the control and status bits for the quadrature decoder mode.
 */
/*!
 * @name Constants and macros for entire TPM_QDCTRL register
 */
/*@{*/
#define TPM_RD_QDCTRL(base)      (TPM_QDCTRL_REG(base))
#define TPM_WR_QDCTRL(base, value) (TPM_QDCTRL_REG(base) = (value))
#define TPM_RMW_QDCTRL(base, mask, value) (TPM_WR_QDCTRL(base, (TPM_RD_QDCTRL(base) & ~(mask)) | (value)))
#define TPM_SET_QDCTRL(base, value) (BME_OR32(&TPM_QDCTRL_REG(base), (uint32_t)(value)))
#define TPM_CLR_QDCTRL(base, value) (BME_AND32(&TPM_QDCTRL_REG(base), (uint32_t)(~(value))))
#define TPM_TOG_QDCTRL(base, value) (BME_XOR32(&TPM_QDCTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_QDCTRL bitfields
 */

/*!
 * @name Register TPM_QDCTRL, field QUADEN[0] (RW)
 *
 * Enables the quadrature decoder mode. In this mode, the channel 0 and channel
 * 1 inputs control the TPM counter direction and can only be used for software
 * compare. The quadrature decoder mode has precedence over the other modes.
 *
 * Values:
 * - 0b0 - Quadrature decoder mode is disabled.
 * - 0b1 - Quadrature decoder mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the TPM_QDCTRL_QUADEN field. */
#define TPM_RD_QDCTRL_QUADEN(base) ((TPM_QDCTRL_REG(base) & TPM_QDCTRL_QUADEN_MASK) >> TPM_QDCTRL_QUADEN_SHIFT)
#define TPM_BRD_QDCTRL_QUADEN(base) (BME_UBFX32(&TPM_QDCTRL_REG(base), TPM_QDCTRL_QUADEN_SHIFT, TPM_QDCTRL_QUADEN_WIDTH))

/*! @brief Set the QUADEN field to a new value. */
#define TPM_WR_QDCTRL_QUADEN(base, value) (TPM_RMW_QDCTRL(base, TPM_QDCTRL_QUADEN_MASK, TPM_QDCTRL_QUADEN(value)))
#define TPM_BWR_QDCTRL_QUADEN(base, value) (BME_BFI32(&TPM_QDCTRL_REG(base), ((uint32_t)(value) << TPM_QDCTRL_QUADEN_SHIFT), TPM_QDCTRL_QUADEN_SHIFT, TPM_QDCTRL_QUADEN_WIDTH))
/*@}*/

/*!
 * @name Register TPM_QDCTRL, field TOFDIR[1] (RO)
 *
 * Indicates if the TOF bit was set on the top or the bottom of counting.
 *
 * Values:
 * - 0b0 - TOF bit was set on the bottom of counting. There was an FTM counter
 *     decrement and FTM counter changes from its minimum value (zero) to its
 *     maximum value (MOD register).
 * - 0b1 - TOF bit was set on the top of counting. There was an FTM counter
 *     increment and FTM counter changes from its maximum value (MOD register) to its
 *     minimum value (zero).
 */
/*@{*/
/*! @brief Read current value of the TPM_QDCTRL_TOFDIR field. */
#define TPM_RD_QDCTRL_TOFDIR(base) ((TPM_QDCTRL_REG(base) & TPM_QDCTRL_TOFDIR_MASK) >> TPM_QDCTRL_TOFDIR_SHIFT)
#define TPM_BRD_QDCTRL_TOFDIR(base) (BME_UBFX32(&TPM_QDCTRL_REG(base), TPM_QDCTRL_TOFDIR_SHIFT, TPM_QDCTRL_TOFDIR_WIDTH))
/*@}*/

/*!
 * @name Register TPM_QDCTRL, field QUADIR[2] (RO)
 *
 * Indicates the counting direction.
 *
 * Values:
 * - 0b0 - Counter direction is decreasing (counter decrement).
 * - 0b1 - Counter direction is increasing (counter increment).
 */
/*@{*/
/*! @brief Read current value of the TPM_QDCTRL_QUADIR field. */
#define TPM_RD_QDCTRL_QUADIR(base) ((TPM_QDCTRL_REG(base) & TPM_QDCTRL_QUADIR_MASK) >> TPM_QDCTRL_QUADIR_SHIFT)
#define TPM_BRD_QDCTRL_QUADIR(base) (BME_UBFX32(&TPM_QDCTRL_REG(base), TPM_QDCTRL_QUADIR_SHIFT, TPM_QDCTRL_QUADIR_WIDTH))
/*@}*/

/*!
 * @name Register TPM_QDCTRL, field QUADMODE[3] (RW)
 *
 * Selects the encoding mode used in the quadrature decoder mode.
 *
 * Values:
 * - 0b0 - Phase encoding mode.
 * - 0b1 - Count and direction encoding mode.
 */
/*@{*/
/*! @brief Read current value of the TPM_QDCTRL_QUADMODE field. */
#define TPM_RD_QDCTRL_QUADMODE(base) ((TPM_QDCTRL_REG(base) & TPM_QDCTRL_QUADMODE_MASK) >> TPM_QDCTRL_QUADMODE_SHIFT)
#define TPM_BRD_QDCTRL_QUADMODE(base) (BME_UBFX32(&TPM_QDCTRL_REG(base), TPM_QDCTRL_QUADMODE_SHIFT, TPM_QDCTRL_QUADMODE_WIDTH))

/*! @brief Set the QUADMODE field to a new value. */
#define TPM_WR_QDCTRL_QUADMODE(base, value) (TPM_RMW_QDCTRL(base, TPM_QDCTRL_QUADMODE_MASK, TPM_QDCTRL_QUADMODE(value)))
#define TPM_BWR_QDCTRL_QUADMODE(base, value) (BME_BFI32(&TPM_QDCTRL_REG(base), ((uint32_t)(value) << TPM_QDCTRL_QUADMODE_SHIFT), TPM_QDCTRL_QUADMODE_SHIFT, TPM_QDCTRL_QUADMODE_WIDTH))
/*@}*/

/*******************************************************************************
 * TPM_CONF - Configuration
 ******************************************************************************/

/*!
 * @brief TPM_CONF - Configuration (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the behavior in debug and wait modes and the use of an
 * external global time base.
 */
/*!
 * @name Constants and macros for entire TPM_CONF register
 */
/*@{*/
#define TPM_RD_CONF(base)        (TPM_CONF_REG(base))
#define TPM_WR_CONF(base, value) (TPM_CONF_REG(base) = (value))
#define TPM_RMW_CONF(base, mask, value) (TPM_WR_CONF(base, (TPM_RD_CONF(base) & ~(mask)) | (value)))
#define TPM_SET_CONF(base, value) (BME_OR32(&TPM_CONF_REG(base), (uint32_t)(value)))
#define TPM_CLR_CONF(base, value) (BME_AND32(&TPM_CONF_REG(base), (uint32_t)(~(value))))
#define TPM_TOG_CONF(base, value) (BME_XOR32(&TPM_CONF_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_CONF bitfields
 */

/*!
 * @name Register TPM_CONF, field DOZEEN[5] (RW)
 *
 * Configures the TPM behavior in wait mode.
 *
 * Values:
 * - 0b0 - Internal TPM counter continues in Doze mode.
 * - 0b1 - Internal TPM counter is paused and does not increment during Doze
 *     mode. Trigger inputs and input capture events are also ignored.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_DOZEEN field. */
#define TPM_RD_CONF_DOZEEN(base) ((TPM_CONF_REG(base) & TPM_CONF_DOZEEN_MASK) >> TPM_CONF_DOZEEN_SHIFT)
#define TPM_BRD_CONF_DOZEEN(base) (BME_UBFX32(&TPM_CONF_REG(base), TPM_CONF_DOZEEN_SHIFT, TPM_CONF_DOZEEN_WIDTH))

/*! @brief Set the DOZEEN field to a new value. */
#define TPM_WR_CONF_DOZEEN(base, value) (TPM_RMW_CONF(base, TPM_CONF_DOZEEN_MASK, TPM_CONF_DOZEEN(value)))
#define TPM_BWR_CONF_DOZEEN(base, value) (BME_BFI32(&TPM_CONF_REG(base), ((uint32_t)(value) << TPM_CONF_DOZEEN_SHIFT), TPM_CONF_DOZEEN_SHIFT, TPM_CONF_DOZEEN_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CONF, field DBGMODE[7:6] (RW)
 *
 * Configures the TPM behavior in debug mode. All other configurations are
 * reserved.
 *
 * Values:
 * - 0b00 - TPM counter is paused and does not increment during debug mode.
 *     Trigger inputs and input capture events are also ignored.
 * - 0b11 - TPM counter continues in debug mode.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_DBGMODE field. */
#define TPM_RD_CONF_DBGMODE(base) ((TPM_CONF_REG(base) & TPM_CONF_DBGMODE_MASK) >> TPM_CONF_DBGMODE_SHIFT)
#define TPM_BRD_CONF_DBGMODE(base) (BME_UBFX32(&TPM_CONF_REG(base), TPM_CONF_DBGMODE_SHIFT, TPM_CONF_DBGMODE_WIDTH))

/*! @brief Set the DBGMODE field to a new value. */
#define TPM_WR_CONF_DBGMODE(base, value) (TPM_RMW_CONF(base, TPM_CONF_DBGMODE_MASK, TPM_CONF_DBGMODE(value)))
#define TPM_BWR_CONF_DBGMODE(base, value) (BME_BFI32(&TPM_CONF_REG(base), ((uint32_t)(value) << TPM_CONF_DBGMODE_SHIFT), TPM_CONF_DBGMODE_SHIFT, TPM_CONF_DBGMODE_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CONF, field GTBEEN[9] (RW)
 *
 * Configures the TPM to use an externally generated global time base counter.
 * When an externally generated timebase is used, the internal TPM counter is not
 * used by the channels but can be used to generate a periodic interruptor DMA
 * request using the Modulo register and timer overflow flag.
 *
 * Values:
 * - 0b0 - All channels use the internally generated TPM counter as their
 *     timebase
 * - 0b1 - All channels use an externally generated global timebase as their
 *     timebase
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_GTBEEN field. */
#define TPM_RD_CONF_GTBEEN(base) ((TPM_CONF_REG(base) & TPM_CONF_GTBEEN_MASK) >> TPM_CONF_GTBEEN_SHIFT)
#define TPM_BRD_CONF_GTBEEN(base) (BME_UBFX32(&TPM_CONF_REG(base), TPM_CONF_GTBEEN_SHIFT, TPM_CONF_GTBEEN_WIDTH))

/*! @brief Set the GTBEEN field to a new value. */
#define TPM_WR_CONF_GTBEEN(base, value) (TPM_RMW_CONF(base, TPM_CONF_GTBEEN_MASK, TPM_CONF_GTBEEN(value)))
#define TPM_BWR_CONF_GTBEEN(base, value) (BME_BFI32(&TPM_CONF_REG(base), ((uint32_t)(value) << TPM_CONF_GTBEEN_SHIFT), TPM_CONF_GTBEEN_SHIFT, TPM_CONF_GTBEEN_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CONF, field CSOT[16] (RW)
 *
 * When set, the TPM counter will not start incrementing after it is enabled
 * until a rising edge on the selected trigger input is detected. If the TPM counter
 * is stopped due to an overflow, a rising edge on the selected trigger input
 * will also cause the TPM counter to start incrementing again. The trigger input
 * is ignored if the TPM counter is paused during debug mode or doze mode. This
 * field should only be changed when the TPM counter is disabled.
 *
 * Values:
 * - 0b0 - TPM counter starts to increment immediately, once it is enabled.
 * - 0b1 - TPM counter only starts to increment when it a rising edge on the
 *     selected input trigger is detected, after it has been enabled or after it has
 *     stopped due to overflow.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_CSOT field. */
#define TPM_RD_CONF_CSOT(base) ((TPM_CONF_REG(base) & TPM_CONF_CSOT_MASK) >> TPM_CONF_CSOT_SHIFT)
#define TPM_BRD_CONF_CSOT(base) (BME_UBFX32(&TPM_CONF_REG(base), TPM_CONF_CSOT_SHIFT, TPM_CONF_CSOT_WIDTH))

/*! @brief Set the CSOT field to a new value. */
#define TPM_WR_CONF_CSOT(base, value) (TPM_RMW_CONF(base, TPM_CONF_CSOT_MASK, TPM_CONF_CSOT(value)))
#define TPM_BWR_CONF_CSOT(base, value) (BME_BFI32(&TPM_CONF_REG(base), ((uint32_t)(value) << TPM_CONF_CSOT_SHIFT), TPM_CONF_CSOT_SHIFT, TPM_CONF_CSOT_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CONF, field CSOO[17] (RW)
 *
 * When set, the TPM counter will stop incrementing once the counter equals the
 * MOD value and incremented (this also sets the TOF). Reloading the counter with
 * 0 due to writing to the counter register or due to a trigger input does not
 * cause the counter to stop incrementing. Once the counter has stopped
 * incrementing, the counter will not start incrementing unless it is disabled and then
 * enabled again, or a rising edge on the selected trigger input is detected when
 * CSOT set. This field should only be changed when the TPM counter is disabled.
 *
 * Values:
 * - 0b0 - TPM counter continues incrementing or decrementing after overflow
 * - 0b1 - TPM counter stops incrementing or decrementing after overflow.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_CSOO field. */
#define TPM_RD_CONF_CSOO(base) ((TPM_CONF_REG(base) & TPM_CONF_CSOO_MASK) >> TPM_CONF_CSOO_SHIFT)
#define TPM_BRD_CONF_CSOO(base) (BME_UBFX32(&TPM_CONF_REG(base), TPM_CONF_CSOO_SHIFT, TPM_CONF_CSOO_WIDTH))

/*! @brief Set the CSOO field to a new value. */
#define TPM_WR_CONF_CSOO(base, value) (TPM_RMW_CONF(base, TPM_CONF_CSOO_MASK, TPM_CONF_CSOO(value)))
#define TPM_BWR_CONF_CSOO(base, value) (BME_BFI32(&TPM_CONF_REG(base), ((uint32_t)(value) << TPM_CONF_CSOO_SHIFT), TPM_CONF_CSOO_SHIFT, TPM_CONF_CSOO_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CONF, field CROT[18] (RW)
 *
 * When set, the TPM counter will reload with 0 (and initialize PWM outputs to
 * their default value) when a rising edge is detected on the selected trigger
 * input. The trigger input is ignored if the TPM counter is paused during debug
 * mode or doze mode. This field should only be changed when the TPM counter is
 * disabled.
 *
 * Values:
 * - 0b0 - Counter is not reloaded due to a rising edge on the selected input
 *     trigger
 * - 0b1 - Counter is reloaded when a rising edge is detected on the selected
 *     input trigger
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_CROT field. */
#define TPM_RD_CONF_CROT(base) ((TPM_CONF_REG(base) & TPM_CONF_CROT_MASK) >> TPM_CONF_CROT_SHIFT)
#define TPM_BRD_CONF_CROT(base) (BME_UBFX32(&TPM_CONF_REG(base), TPM_CONF_CROT_SHIFT, TPM_CONF_CROT_WIDTH))

/*! @brief Set the CROT field to a new value. */
#define TPM_WR_CONF_CROT(base, value) (TPM_RMW_CONF(base, TPM_CONF_CROT_MASK, TPM_CONF_CROT(value)))
#define TPM_BWR_CONF_CROT(base, value) (BME_BFI32(&TPM_CONF_REG(base), ((uint32_t)(value) << TPM_CONF_CROT_SHIFT), TPM_CONF_CROT_SHIFT, TPM_CONF_CROT_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CONF, field TRGSEL[27:24] (RW)
 *
 * Selects the input trigger to use for starting the counter and/or reloading
 * the counter. This field should only be changed when the TPM counter is disabled.
 * See Chip configuration section for available options.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_TRGSEL field. */
#define TPM_RD_CONF_TRGSEL(base) ((TPM_CONF_REG(base) & TPM_CONF_TRGSEL_MASK) >> TPM_CONF_TRGSEL_SHIFT)
#define TPM_BRD_CONF_TRGSEL(base) (BME_UBFX32(&TPM_CONF_REG(base), TPM_CONF_TRGSEL_SHIFT, TPM_CONF_TRGSEL_WIDTH))

/*! @brief Set the TRGSEL field to a new value. */
#define TPM_WR_CONF_TRGSEL(base, value) (TPM_RMW_CONF(base, TPM_CONF_TRGSEL_MASK, TPM_CONF_TRGSEL(value)))
#define TPM_BWR_CONF_TRGSEL(base, value) (BME_BFI32(&TPM_CONF_REG(base), ((uint32_t)(value) << TPM_CONF_TRGSEL_SHIFT), TPM_CONF_TRGSEL_SHIFT, TPM_CONF_TRGSEL_WIDTH))
/*@}*/

/*
 * MKW40Z4 TRNG
 *
 * RNG
 *
 * Registers defined in this header file:
 * - TRNG_MCTL - RNG Miscellaneous Control Register
 * - TRNG_SCMISC - RNG Statistical Check Miscellaneous Register
 * - TRNG_PKRRNG - RNG Poker Range Register
 * - TRNG_PKRMAX - RNG Poker Maximum Limit Register
 * - TRNG_PKRSQ - RNG Poker Square Calculation Result Register
 * - TRNG_SDCTL - RNG Seed Control Register
 * - TRNG_SBLIM - RNG Sparse Bit Limit Register
 * - TRNG_TOTSAM - RNG Total Samples Register
 * - TRNG_FRQMIN - RNG Frequency Count Minimum Limit Register
 * - TRNG_FRQCNT - RNG Frequency Count Register
 * - TRNG_FRQMAX - RNG Frequency Count Maximum Limit Register
 * - TRNG_SCMC - RNG Statistical Check Monobit Count Register
 * - TRNG_SCML - RNG Statistical Check Monobit Limit Register
 * - TRNG_SCR1C - RNG Statistical Check Run Length 1 Count Register
 * - TRNG_SCR1L - RNG Statistical Check Run Length 1 Limit Register
 * - TRNG_SCR2C - RNG Statistical Check Run Length 2 Count Register
 * - TRNG_SCR2L - RNG Statistical Check Run Length 2 Limit Register
 * - TRNG_SCR3C - RNG Statistical Check Run Length 3 Count Register
 * - TRNG_SCR3L - RNG Statistical Check Run Length 3 Limit Register
 * - TRNG_SCR4C - RNG Statistical Check Run Length 4 Count Register
 * - TRNG_SCR4L - RNG Statistical Check Run Length 4 Limit Register
 * - TRNG_SCR5C - RNG Statistical Check Run Length 5 Count Register
 * - TRNG_SCR5L - RNG Statistical Check Run Length 5 Limit Register
 * - TRNG_SCR6PC - RNG Statistical Check Run Length 6+ Count Register
 * - TRNG_SCR6PL - RNG Statistical Check Run Length 6+ Limit Register
 * - TRNG_STATUS - RNG Status Register
 * - TRNG_ENT - RNG TRNG Entropy Read Register
 * - TRNG_PKRCNT10 - RNG Statistical Check Poker Count 1 and 0 Register
 * - TRNG_PKRCNT32 - RNG Statistical Check Poker Count 3 and 2 Register
 * - TRNG_PKRCNT54 - RNG Statistical Check Poker Count 5 and 4 Register
 * - TRNG_PKRCNT76 - RNG Statistical Check Poker Count 7 and 6 Register
 * - TRNG_PKRCNT98 - RNG Statistical Check Poker Count 9 and 8 Register
 * - TRNG_PKRCNTBA - RNG Statistical Check Poker Count B and A Register
 * - TRNG_PKRCNTDC - RNG Statistical Check Poker Count D and C Register
 * - TRNG_PKRCNTFE - RNG Statistical Check Poker Count F and E Register
 * - TRNG_SEC_CFG - RNG Security Configuration Register
 * - TRNG_INT_CTRL - RNG Interrupt Control Register
 * - TRNG_INT_MASK - RNG Mask Register
 * - TRNG_INT_STATUS - RNG Interrupt Status Register
 * - TRNG_VID1 - RNG Version ID Register (MS)
 * - TRNG_VID2 - RNG Version ID Register (LS)
 */

#define TRNG_INSTANCE_COUNT (1U) /*!< Number of instances of the TRNG module. */
#define TRNG0_IDX (0U) /*!< Instance number for TRNG0. */

/*******************************************************************************
 * TRNG_MCTL - RNG Miscellaneous Control Register
 ******************************************************************************/

/*!
 * @brief TRNG_MCTL - RNG Miscellaneous Control Register (RW)
 *
 * Reset value: 0x00012001U
 *
 * This register is intended to be used for programming, configuring and testing
 * the RNG. It is the main register to read/write, in order to enable Entropy
 * generation, to stop entropy generation and to block access to entropy registers.
 * This is done via the special TRNG_ACC and PRGM bits below. The RNG
 * Miscellaneous Control Register is a read/write register used to control the RNG's True
 * Random Number Generator (TRNG) access, operation and test. Note that in many
 * cases two RNG registers share the same address, and a particular register at the
 * shared address is selected based upon the value in the PRGM field of the MCTL
 * register.
 */
/*!
 * @name Constants and macros for entire TRNG_MCTL register
 */
/*@{*/
#define TRNG_RD_MCTL(base)       (TRNG_MCTL_REG(base))
#define TRNG_WR_MCTL(base, value) (TRNG_MCTL_REG(base) = (value))
#define TRNG_RMW_MCTL(base, mask, value) (TRNG_WR_MCTL(base, (TRNG_RD_MCTL(base) & ~(mask)) | (value)))
#define TRNG_SET_MCTL(base, value) (BME_OR32(&TRNG_MCTL_REG(base), (uint32_t)(value)))
#define TRNG_CLR_MCTL(base, value) (BME_AND32(&TRNG_MCTL_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_MCTL(base, value) (BME_XOR32(&TRNG_MCTL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_MCTL bitfields
 */

/*!
 * @name Register TRNG_MCTL, field SAMP_MODE[1:0] (RW)
 *
 * Sample Mode. Determines the method of sampling the ring oscillator while
 * generating the Entropy value:This field is writable only if PRGM bit is 1, or PRGM
 * bit is being written to 1 simultaneously with writing this field. This field
 * is cleared to 01 by writing the RST_DEF bit to 1.
 *
 * Values:
 * - 0b00 - use Von Neumann data into both Entropy shifter and Statistical
 *     Checker
 * - 0b01 - use raw data into both Entropy shifter and Statistical Checker
 * - 0b10 - use Von Neumann data into Entropy shifter. Use raw data into
 *     Statistical Checker
 * - 0b11 - reserved.
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_SAMP_MODE field. */
#define TRNG_RD_MCTL_SAMP_MODE(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_SAMP_MODE_MASK) >> TRNG_MCTL_SAMP_MODE_SHIFT)
#define TRNG_BRD_MCTL_SAMP_MODE(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_SAMP_MODE_SHIFT, TRNG_MCTL_SAMP_MODE_WIDTH))

/*! @brief Set the SAMP_MODE field to a new value. */
#define TRNG_WR_MCTL_SAMP_MODE(base, value) (TRNG_RMW_MCTL(base, (TRNG_MCTL_SAMP_MODE_MASK | TRNG_MCTL_ERR_MASK), TRNG_MCTL_SAMP_MODE(value)))
#define TRNG_BWR_MCTL_SAMP_MODE(base, value) (BME_BFI32(&TRNG_MCTL_REG(base), ((uint32_t)(value) << TRNG_MCTL_SAMP_MODE_SHIFT), TRNG_MCTL_SAMP_MODE_SHIFT, TRNG_MCTL_SAMP_MODE_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field OSC_DIV[3:2] (RW)
 *
 * Oscillator Divide. Determines the amount of dividing done to the ring
 * oscillator before it is used by the TRNG.This field is writable only if PRGM bit is
 * 1, or PRGM bit is being written to 1 simultaneously to writing this field. This
 * field is cleared to 00 by writing the RST_DEF bit to 1.
 *
 * Values:
 * - 0b00 - use ring oscillator with no divide
 * - 0b01 - use ring oscillator divided-by-2
 * - 0b10 - use ring oscillator divided-by-4
 * - 0b11 - use ring oscillator divided-by-8
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_OSC_DIV field. */
#define TRNG_RD_MCTL_OSC_DIV(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_OSC_DIV_MASK) >> TRNG_MCTL_OSC_DIV_SHIFT)
#define TRNG_BRD_MCTL_OSC_DIV(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_OSC_DIV_SHIFT, TRNG_MCTL_OSC_DIV_WIDTH))

/*! @brief Set the OSC_DIV field to a new value. */
#define TRNG_WR_MCTL_OSC_DIV(base, value) (TRNG_RMW_MCTL(base, (TRNG_MCTL_OSC_DIV_MASK | TRNG_MCTL_ERR_MASK), TRNG_MCTL_OSC_DIV(value)))
#define TRNG_BWR_MCTL_OSC_DIV(base, value) (BME_BFI32(&TRNG_MCTL_REG(base), ((uint32_t)(value) << TRNG_MCTL_OSC_DIV_SHIFT), TRNG_MCTL_OSC_DIV_SHIFT, TRNG_MCTL_OSC_DIV_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field UNUSED[4] (RW)
 *
 * This bit is unused but write-able. Must be left as zero.
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_UNUSED field. */
#define TRNG_RD_MCTL_UNUSED(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_UNUSED_MASK) >> TRNG_MCTL_UNUSED_SHIFT)
#define TRNG_BRD_MCTL_UNUSED(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_UNUSED_SHIFT, TRNG_MCTL_UNUSED_WIDTH))

/*! @brief Set the UNUSED field to a new value. */
#define TRNG_WR_MCTL_UNUSED(base, value) (TRNG_RMW_MCTL(base, (TRNG_MCTL_UNUSED_MASK | TRNG_MCTL_ERR_MASK), TRNG_MCTL_UNUSED(value)))
#define TRNG_BWR_MCTL_UNUSED(base, value) (BME_BFI32(&TRNG_MCTL_REG(base), ((uint32_t)(value) << TRNG_MCTL_UNUSED_SHIFT), TRNG_MCTL_UNUSED_SHIFT, TRNG_MCTL_UNUSED_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field TRNG_ACC[5] (RW)
 *
 * TRNG Access Mode. If this bit is set to 1, the TRNG will generate an Entropy
 * value that can be read via the ENT0-ENT15 registers. The Entropy value may be
 * read once the ENT VAL bit is asserted. Also see ENTa register descriptions
 * (For a = 0 to 15).
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_TRNG_ACC field. */
#define TRNG_RD_MCTL_TRNG_ACC(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_TRNG_ACC_MASK) >> TRNG_MCTL_TRNG_ACC_SHIFT)
#define TRNG_BRD_MCTL_TRNG_ACC(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_TRNG_ACC_SHIFT, TRNG_MCTL_TRNG_ACC_WIDTH))

/*! @brief Set the TRNG_ACC field to a new value. */
#define TRNG_WR_MCTL_TRNG_ACC(base, value) (TRNG_RMW_MCTL(base, (TRNG_MCTL_TRNG_ACC_MASK | TRNG_MCTL_ERR_MASK), TRNG_MCTL_TRNG_ACC(value)))
#define TRNG_BWR_MCTL_TRNG_ACC(base, value) (BME_BFI32(&TRNG_MCTL_REG(base), ((uint32_t)(value) << TRNG_MCTL_TRNG_ACC_SHIFT), TRNG_MCTL_TRNG_ACC_SHIFT, TRNG_MCTL_TRNG_ACC_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field RST_DEF[6] (WO)
 *
 * Reset Defaults. Writing a 1 to this bit clears various TRNG registers, and
 * bits within registers, to their default state. This bit is writable only if PRGM
 * bit is 1, or PRGM bit is being written to 1 simultaneously to writing this
 * bit. Reading this bit always produces a 0.
 */
/*@{*/
/*! @brief Set the RST_DEF field to a new value. */
#define TRNG_WR_MCTL_RST_DEF(base, value) (TRNG_RMW_MCTL(base, (TRNG_MCTL_RST_DEF_MASK | TRNG_MCTL_ERR_MASK), TRNG_MCTL_RST_DEF(value)))
#define TRNG_BWR_MCTL_RST_DEF(base, value) (TRNG_WR_MCTL_RST_DEF(base, value))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field FOR_SCLK[7] (RW)
 *
 * Force System Clock. If set, the system clock is used to operate the TRNG,
 * instead of the ring oscillator. This is for test use only, and indeterminate
 * results may occur. This bit is writable only if PRGM bit is 1, or PRGM bit is
 * being written to 1 simultaneously to writing this bit. This bit is cleared by
 * writing the RST_DEF bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_FOR_SCLK field. */
#define TRNG_RD_MCTL_FOR_SCLK(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_FOR_SCLK_MASK) >> TRNG_MCTL_FOR_SCLK_SHIFT)
#define TRNG_BRD_MCTL_FOR_SCLK(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_FOR_SCLK_SHIFT, TRNG_MCTL_FOR_SCLK_WIDTH))

/*! @brief Set the FOR_SCLK field to a new value. */
#define TRNG_WR_MCTL_FOR_SCLK(base, value) (TRNG_RMW_MCTL(base, (TRNG_MCTL_FOR_SCLK_MASK | TRNG_MCTL_ERR_MASK), TRNG_MCTL_FOR_SCLK(value)))
#define TRNG_BWR_MCTL_FOR_SCLK(base, value) (BME_BFI32(&TRNG_MCTL_REG(base), ((uint32_t)(value) << TRNG_MCTL_FOR_SCLK_SHIFT), TRNG_MCTL_FOR_SCLK_SHIFT, TRNG_MCTL_FOR_SCLK_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field FCT_FAIL[8] (RO)
 *
 * Read only: Frequency Count Fail. The frequency counter has detected a
 * failure. This may be due to improper programming of the FRQMAX and/or FRQMIN
 * registers, or a hardware failure in the ring oscillator. This error may be cleared by
 * writing a 1 to the ERR bit.
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_FCT_FAIL field. */
#define TRNG_RD_MCTL_FCT_FAIL(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_FCT_FAIL_MASK) >> TRNG_MCTL_FCT_FAIL_SHIFT)
#define TRNG_BRD_MCTL_FCT_FAIL(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_FCT_FAIL_SHIFT, TRNG_MCTL_FCT_FAIL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field FCT_VAL[9] (RO)
 *
 * Read only: Frequency Count Valid. Indicates that a valid frequency count may
 * be read from FRQCNT.
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_FCT_VAL field. */
#define TRNG_RD_MCTL_FCT_VAL(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_FCT_VAL_MASK) >> TRNG_MCTL_FCT_VAL_SHIFT)
#define TRNG_BRD_MCTL_FCT_VAL(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_FCT_VAL_SHIFT, TRNG_MCTL_FCT_VAL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field ENT_VAL[10] (RO)
 *
 * Read only: Entropy Valid. Will assert only if TRNG ACC bit is set, and then
 * after an entropy value is generated. Will be cleared when ENT15 is read. (ENT0
 * through ENT14 should be read before reading ENT15).
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_ENT_VAL field. */
#define TRNG_RD_MCTL_ENT_VAL(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_ENT_VAL_MASK) >> TRNG_MCTL_ENT_VAL_SHIFT)
#define TRNG_BRD_MCTL_ENT_VAL(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_ENT_VAL_SHIFT, TRNG_MCTL_ENT_VAL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field TST_OUT[11] (RO)
 *
 * Read only: Test point inside ring oscillator.
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_TST_OUT field. */
#define TRNG_RD_MCTL_TST_OUT(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_TST_OUT_MASK) >> TRNG_MCTL_TST_OUT_SHIFT)
#define TRNG_BRD_MCTL_TST_OUT(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_TST_OUT_SHIFT, TRNG_MCTL_TST_OUT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field ERR[12] (W1C)
 *
 * Read: Error status. 1 = error detected. 0 = no error.Write: Write 1 to clear
 * errors. Writing 0 has no effect.
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_ERR field. */
#define TRNG_RD_MCTL_ERR(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_ERR_MASK) >> TRNG_MCTL_ERR_SHIFT)
#define TRNG_BRD_MCTL_ERR(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_ERR_SHIFT, TRNG_MCTL_ERR_WIDTH))

/*! @brief Set the ERR field to a new value. */
#define TRNG_WR_MCTL_ERR(base, value) (TRNG_RMW_MCTL(base, TRNG_MCTL_ERR_MASK, TRNG_MCTL_ERR(value)))
#define TRNG_BWR_MCTL_ERR(base, value) (BME_BFI32(&TRNG_MCTL_REG(base), ((uint32_t)(value) << TRNG_MCTL_ERR_SHIFT), TRNG_MCTL_ERR_SHIFT, TRNG_MCTL_ERR_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field TSTOP_OK[13] (RO)
 *
 * TRNG_OK_TO_STOP. Software should check that this bit is a 1 before
 * transitioning RNG to low power mode (RNG clock stopped). RNG turns on the TRNG
 * free-running ring oscillator whenever new entropy is being generated and turns off the
 * ring oscillator when entropy generation is complete. If the RNG clock is
 * stopped while the TRNG ring oscillator is running, the oscillator will continue
 * running even though the RNG clock is stopped. TSTOP_OK is asserted when the TRNG
 * ring oscillator is not running. and therefore it is ok to stop the RNG clock.
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_TSTOP_OK field. */
#define TRNG_RD_MCTL_TSTOP_OK(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_TSTOP_OK_MASK) >> TRNG_MCTL_TSTOP_OK_SHIFT)
#define TRNG_BRD_MCTL_TSTOP_OK(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_TSTOP_OK_SHIFT, TRNG_MCTL_TSTOP_OK_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field PRGM[16] (RW)
 *
 * Programming Mode Select. When this bit is 1, the TRNG is in Program Mode,
 * otherwise it is in Run Mode. No Entropy value will be generated while the TRNG is
 * in Program Mode. Note that different RNG registers are accessible at the same
 * address depending on whether PRGM is set to 1 or 0. This is noted in the RNG
 * register descriptions.
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_PRGM field. */
#define TRNG_RD_MCTL_PRGM(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_PRGM_MASK) >> TRNG_MCTL_PRGM_SHIFT)
#define TRNG_BRD_MCTL_PRGM(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_PRGM_SHIFT, TRNG_MCTL_PRGM_WIDTH))

/*! @brief Set the PRGM field to a new value. */
#define TRNG_WR_MCTL_PRGM(base, value) (TRNG_RMW_MCTL(base, (TRNG_MCTL_PRGM_MASK | TRNG_MCTL_ERR_MASK), TRNG_MCTL_PRGM(value)))
#define TRNG_BWR_MCTL_PRGM(base, value) (BME_BFI32(&TRNG_MCTL_REG(base), ((uint32_t)(value) << TRNG_MCTL_PRGM_SHIFT), TRNG_MCTL_PRGM_SHIFT, TRNG_MCTL_PRGM_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SCMISC - RNG Statistical Check Miscellaneous Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCMISC - RNG Statistical Check Miscellaneous Register (RW)
 *
 * Reset value: 0x0001001FU
 *
 * The RNG Statistical Check Miscellaneous Register contains the Long Run
 * Maximum Limit value and the Retry Count value. This register is accessible only when
 * the MCTL[PRGM] bit is 1, otherwise this register will read zeroes, and cannot
 * be written.
 */
/*!
 * @name Constants and macros for entire TRNG_SCMISC register
 */
/*@{*/
#define TRNG_RD_SCMISC(base)     (TRNG_SCMISC_REG(base))
#define TRNG_WR_SCMISC(base, value) (TRNG_SCMISC_REG(base) = (value))
#define TRNG_RMW_SCMISC(base, mask, value) (TRNG_WR_SCMISC(base, (TRNG_RD_SCMISC(base) & ~(mask)) | (value)))
#define TRNG_SET_SCMISC(base, value) (BME_OR32(&TRNG_SCMISC_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SCMISC(base, value) (BME_AND32(&TRNG_SCMISC_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SCMISC(base, value) (BME_XOR32(&TRNG_SCMISC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCMISC bitfields
 */

/*!
 * @name Register TRNG_SCMISC, field LRUN_MAX[7:0] (RW)
 *
 * LONG RUN MAX LIMIT. This value is the largest allowable number of consecutive
 * samples of all 1, or all 0, that is allowed during the Entropy generation.
 * This field is writable only if MCTL[PRGM] bit is 1. This field will read zeroes
 * if MCTL[PRGM] = 0. This field is cleared to 22h by writing the MCTL[RST_DEF]
 * bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCMISC_LRUN_MAX field. */
#define TRNG_RD_SCMISC_LRUN_MAX(base) ((TRNG_SCMISC_REG(base) & TRNG_SCMISC_LRUN_MAX_MASK) >> TRNG_SCMISC_LRUN_MAX_SHIFT)
#define TRNG_BRD_SCMISC_LRUN_MAX(base) (BME_UBFX32(&TRNG_SCMISC_REG(base), TRNG_SCMISC_LRUN_MAX_SHIFT, TRNG_SCMISC_LRUN_MAX_WIDTH))

/*! @brief Set the LRUN_MAX field to a new value. */
#define TRNG_WR_SCMISC_LRUN_MAX(base, value) (TRNG_RMW_SCMISC(base, TRNG_SCMISC_LRUN_MAX_MASK, TRNG_SCMISC_LRUN_MAX(value)))
#define TRNG_BWR_SCMISC_LRUN_MAX(base, value) (BME_BFI32(&TRNG_SCMISC_REG(base), ((uint32_t)(value) << TRNG_SCMISC_LRUN_MAX_SHIFT), TRNG_SCMISC_LRUN_MAX_SHIFT, TRNG_SCMISC_LRUN_MAX_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SCMISC, field RTY_CT[19:16] (RW)
 *
 * RETRY COUNT. If a statistical check fails during the TRNG Entropy Generation,
 * the RTY_CT value indicates the number of times a retry should occur before
 * generating an error. This field is writable only if MCTL[PRGM] bit is 1. This
 * field will read zeroes if MCTL[PRGM] = 0. This field is cleared to 1h by writing
 * the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCMISC_RTY_CT field. */
#define TRNG_RD_SCMISC_RTY_CT(base) ((TRNG_SCMISC_REG(base) & TRNG_SCMISC_RTY_CT_MASK) >> TRNG_SCMISC_RTY_CT_SHIFT)
#define TRNG_BRD_SCMISC_RTY_CT(base) (BME_UBFX32(&TRNG_SCMISC_REG(base), TRNG_SCMISC_RTY_CT_SHIFT, TRNG_SCMISC_RTY_CT_WIDTH))

/*! @brief Set the RTY_CT field to a new value. */
#define TRNG_WR_SCMISC_RTY_CT(base, value) (TRNG_RMW_SCMISC(base, TRNG_SCMISC_RTY_CT_MASK, TRNG_SCMISC_RTY_CT(value)))
#define TRNG_BWR_SCMISC_RTY_CT(base, value) (BME_BFI32(&TRNG_SCMISC_REG(base), ((uint32_t)(value) << TRNG_SCMISC_RTY_CT_SHIFT), TRNG_SCMISC_RTY_CT_SHIFT, TRNG_SCMISC_RTY_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_PKRRNG - RNG Poker Range Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRRNG - RNG Poker Range Register (RW)
 *
 * Reset value: 0x000009A3U
 *
 * The RNG Poker Range Register defines the difference between the TRNG Poker
 * Maximum Limit and the minimum limit. These limits are used during the TRNG
 * Statistical Check Poker Test.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRRNG register
 */
/*@{*/
#define TRNG_RD_PKRRNG(base)     (TRNG_PKRRNG_REG(base))
#define TRNG_WR_PKRRNG(base, value) (TRNG_PKRRNG_REG(base) = (value))
#define TRNG_RMW_PKRRNG(base, mask, value) (TRNG_WR_PKRRNG(base, (TRNG_RD_PKRRNG(base) & ~(mask)) | (value)))
#define TRNG_SET_PKRRNG(base, value) (BME_OR32(&TRNG_PKRRNG_REG(base), (uint32_t)(value)))
#define TRNG_CLR_PKRRNG(base, value) (BME_AND32(&TRNG_PKRRNG_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_PKRRNG(base, value) (BME_XOR32(&TRNG_PKRRNG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRRNG bitfields
 */

/*!
 * @name Register TRNG_PKRRNG, field PKR_RNG[15:0] (RW)
 *
 * Poker Range. During the TRNG Statistical Checks, a "Poker Test" is run which
 * requires a maximum and minimum limit. The maximum is programmed in the
 * RTPKRMAX[PKR_MAX] register, and the minimum is derived by subtracting the PKR_RNG
 * value from the programmed maximum value. This field is writable only if
 * MCTL[PRGM] bit is 1. This field will read zeroes if MCTL[PRGM] = 0. This field is
 * cleared to 09A3h (decimal 2467) by writing the MCTL[RST_DEF] bit to 1. Note that
 * the minimum allowable Poker result is PKR_MAX - PKR_RNG + 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRRNG_PKR_RNG field. */
#define TRNG_RD_PKRRNG_PKR_RNG(base) ((TRNG_PKRRNG_REG(base) & TRNG_PKRRNG_PKR_RNG_MASK) >> TRNG_PKRRNG_PKR_RNG_SHIFT)
#define TRNG_BRD_PKRRNG_PKR_RNG(base) (BME_UBFX32(&TRNG_PKRRNG_REG(base), TRNG_PKRRNG_PKR_RNG_SHIFT, TRNG_PKRRNG_PKR_RNG_WIDTH))

/*! @brief Set the PKR_RNG field to a new value. */
#define TRNG_WR_PKRRNG_PKR_RNG(base, value) (TRNG_RMW_PKRRNG(base, TRNG_PKRRNG_PKR_RNG_MASK, TRNG_PKRRNG_PKR_RNG(value)))
#define TRNG_BWR_PKRRNG_PKR_RNG(base, value) (BME_BFI32(&TRNG_PKRRNG_REG(base), ((uint32_t)(value) << TRNG_PKRRNG_PKR_RNG_SHIFT), TRNG_PKRRNG_PKR_RNG_SHIFT, TRNG_PKRRNG_PKR_RNG_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_PKRMAX - RNG Poker Maximum Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRMAX - RNG Poker Maximum Limit Register (RW)
 *
 * Reset value: 0x00006920U
 *
 * The RNG Poker Maximum Limit Register defines Maximum Limit allowable during
 * the TRNG Statistical Check Poker Test. Note that this offset (0xBASE_060C) is
 * used as PKRMAX only if MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this offset is used
 * as the PKRSQ readback register.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRMAX register
 */
/*@{*/
#define TRNG_RD_PKRMAX(base)     (TRNG_PKRMAX_REG(base))
#define TRNG_WR_PKRMAX(base, value) (TRNG_PKRMAX_REG(base) = (value))
#define TRNG_RMW_PKRMAX(base, mask, value) (TRNG_WR_PKRMAX(base, (TRNG_RD_PKRMAX(base) & ~(mask)) | (value)))
#define TRNG_SET_PKRMAX(base, value) (BME_OR32(&TRNG_PKRMAX_REG(base), (uint32_t)(value)))
#define TRNG_CLR_PKRMAX(base, value) (BME_AND32(&TRNG_PKRMAX_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_PKRMAX(base, value) (BME_XOR32(&TRNG_PKRMAX_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRMAX bitfields
 */

/*!
 * @name Register TRNG_PKRMAX, field PKR_MAX[23:0] (RW)
 *
 * Poker Maximum Limit. During the TRNG Statistical Checks, a "Poker Test" is
 * run which requires a maximum and minimum limit. The maximum allowable result is
 * programmed in the PKRMAX[PKR_MAX] register. This field is writable only if
 * MCTL[PRGM] bit is 1. This register is cleared to 006920h (decimal 26912) by
 * writing the MCTL[RST_DEF] bit to 1. Note that the PKRMAX and PKRRNG registers
 * combined are used to define the minimum allowable Poker result, which is PKR_MAX -
 * PKR_RNG + 1. Note that if MCTL[PRGM] bit is 0, this register address is used
 * to read the Poker Test Square Calculation result in register PKRSQ, as defined
 * in the following section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRMAX_PKR_MAX field. */
#define TRNG_RD_PKRMAX_PKR_MAX(base) ((TRNG_PKRMAX_REG(base) & TRNG_PKRMAX_PKR_MAX_MASK) >> TRNG_PKRMAX_PKR_MAX_SHIFT)
#define TRNG_BRD_PKRMAX_PKR_MAX(base) (TRNG_RD_PKRMAX_PKR_MAX(base))

/*! @brief Set the PKR_MAX field to a new value. */
#define TRNG_WR_PKRMAX_PKR_MAX(base, value) (TRNG_RMW_PKRMAX(base, TRNG_PKRMAX_PKR_MAX_MASK, TRNG_PKRMAX_PKR_MAX(value)))
#define TRNG_BWR_PKRMAX_PKR_MAX(base, value) (TRNG_WR_PKRMAX_PKR_MAX(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_PKRSQ - RNG Poker Square Calculation Result Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRSQ - RNG Poker Square Calculation Result Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Poker Square Calculation Result Register is a read-only register used
 * to read the result of the TRNG Statistical Check Poker Test's Square
 * Calculation. This test starts with the PKRMAX value and decreases towards a final
 * result, which is read here. For the Poker Test to pass, this final result must be
 * less than the programmed PKRRNG value. Note that this offset (0xBASE_060C) is
 * used as PKRMAX if MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this offset is used as
 * PKRSQ readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRSQ register
 */
/*@{*/
#define TRNG_RD_PKRSQ(base)      (TRNG_PKRSQ_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRSQ bitfields
 */

/*!
 * @name Register TRNG_PKRSQ, field PKR_SQ[23:0] (RO)
 *
 * Poker Square Calculation Result. During the TRNG Statistical Checks, a "Poker
 * Test" is run which starts with the value PKRMAX[PKR_MAX]. This value
 * decreases according to a "sum of squares" algorithm, and must remain greater than
 * zero, but less than the PKRRNG[PKR_RNG] limit. The resulting value may be read
 * through this register, if MCTL[PRGM] bit is 0. Note that if MCTL[PRGM] bit is 1,
 * this register address is used to access the Poker Test Maximum Limit in
 * register PKRMAX, as defined in the previous section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRSQ_PKR_SQ field. */
#define TRNG_RD_PKRSQ_PKR_SQ(base) ((TRNG_PKRSQ_REG(base) & TRNG_PKRSQ_PKR_SQ_MASK) >> TRNG_PKRSQ_PKR_SQ_SHIFT)
#define TRNG_BRD_PKRSQ_PKR_SQ(base) (TRNG_RD_PKRSQ_PKR_SQ(base))
/*@}*/

/*******************************************************************************
 * TRNG_SDCTL - RNG Seed Control Register
 ******************************************************************************/

/*!
 * @brief TRNG_SDCTL - RNG Seed Control Register (RW)
 *
 * Reset value: 0x0C8009C4U
 *
 * The RNG Seed Control Register contains two fields. One field defines the
 * length (in system clocks) of each Entropy sample (ENT_DLY), and the other field
 * indicates the number of samples that will taken during each TRNG Entropy
 * generation (SAMP_SIZE).
 */
/*!
 * @name Constants and macros for entire TRNG_SDCTL register
 */
/*@{*/
#define TRNG_RD_SDCTL(base)      (TRNG_SDCTL_REG(base))
#define TRNG_WR_SDCTL(base, value) (TRNG_SDCTL_REG(base) = (value))
#define TRNG_RMW_SDCTL(base, mask, value) (TRNG_WR_SDCTL(base, (TRNG_RD_SDCTL(base) & ~(mask)) | (value)))
#define TRNG_SET_SDCTL(base, value) (BME_OR32(&TRNG_SDCTL_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SDCTL(base, value) (BME_AND32(&TRNG_SDCTL_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SDCTL(base, value) (BME_XOR32(&TRNG_SDCTL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SDCTL bitfields
 */

/*!
 * @name Register TRNG_SDCTL, field SAMP_SIZE[15:0] (RW)
 *
 * Sample Size. Defines the total number of Entropy samples that will be taken
 * during Entropy generation. This field is writable only if MCTL[PRGM] bit is 1.
 * This field will read zeroes if MCTL[PRGM] = 0. This field is cleared to 09C4h
 * (decimal 2500) by writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SDCTL_SAMP_SIZE field. */
#define TRNG_RD_SDCTL_SAMP_SIZE(base) ((TRNG_SDCTL_REG(base) & TRNG_SDCTL_SAMP_SIZE_MASK) >> TRNG_SDCTL_SAMP_SIZE_SHIFT)
#define TRNG_BRD_SDCTL_SAMP_SIZE(base) (BME_UBFX32(&TRNG_SDCTL_REG(base), TRNG_SDCTL_SAMP_SIZE_SHIFT, TRNG_SDCTL_SAMP_SIZE_WIDTH))

/*! @brief Set the SAMP_SIZE field to a new value. */
#define TRNG_WR_SDCTL_SAMP_SIZE(base, value) (TRNG_RMW_SDCTL(base, TRNG_SDCTL_SAMP_SIZE_MASK, TRNG_SDCTL_SAMP_SIZE(value)))
#define TRNG_BWR_SDCTL_SAMP_SIZE(base, value) (BME_BFI32(&TRNG_SDCTL_REG(base), ((uint32_t)(value) << TRNG_SDCTL_SAMP_SIZE_SHIFT), TRNG_SDCTL_SAMP_SIZE_SHIFT, TRNG_SDCTL_SAMP_SIZE_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SDCTL, field ENT_DLY[31:16] (RW)
 *
 * Entropy Delay. Defines the length (in system clocks) of each Entropy sample
 * taken. This field is writable only if MCTL[PRGM] bit is 1. This field will read
 * zeroes if MCTL[PRGM] = 0. This field is cleared to 0C80h (decimal 3200) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SDCTL_ENT_DLY field. */
#define TRNG_RD_SDCTL_ENT_DLY(base) ((TRNG_SDCTL_REG(base) & TRNG_SDCTL_ENT_DLY_MASK) >> TRNG_SDCTL_ENT_DLY_SHIFT)
#define TRNG_BRD_SDCTL_ENT_DLY(base) (BME_UBFX32(&TRNG_SDCTL_REG(base), TRNG_SDCTL_ENT_DLY_SHIFT, TRNG_SDCTL_ENT_DLY_WIDTH))

/*! @brief Set the ENT_DLY field to a new value. */
#define TRNG_WR_SDCTL_ENT_DLY(base, value) (TRNG_RMW_SDCTL(base, TRNG_SDCTL_ENT_DLY_MASK, TRNG_SDCTL_ENT_DLY(value)))
#define TRNG_BWR_SDCTL_ENT_DLY(base, value) (BME_BFI32(&TRNG_SDCTL_REG(base), ((uint32_t)(value) << TRNG_SDCTL_ENT_DLY_SHIFT), TRNG_SDCTL_ENT_DLY_SHIFT, TRNG_SDCTL_ENT_DLY_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SBLIM - RNG Sparse Bit Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_SBLIM - RNG Sparse Bit Limit Register (RW)
 *
 * Reset value: 0x0000003FU
 *
 * The RNG Sparse Bit Limit Register is used when Von Neumann sampling is
 * selected during Entropy Generation. It defines the maximum number of consecutive Von
 * Neumann samples which may be discarded before an error is generated. Note
 * that this address (0xBASE_0614) is used as SBLIM only if MCTL[PRGM] is 1. If
 * MCTL[PRGM] is 0, this address is used as TOTSAM readback register.
 */
/*!
 * @name Constants and macros for entire TRNG_SBLIM register
 */
/*@{*/
#define TRNG_RD_SBLIM(base)      (TRNG_SBLIM_REG(base))
#define TRNG_WR_SBLIM(base, value) (TRNG_SBLIM_REG(base) = (value))
#define TRNG_RMW_SBLIM(base, mask, value) (TRNG_WR_SBLIM(base, (TRNG_RD_SBLIM(base) & ~(mask)) | (value)))
#define TRNG_SET_SBLIM(base, value) (BME_OR32(&TRNG_SBLIM_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SBLIM(base, value) (BME_AND32(&TRNG_SBLIM_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SBLIM(base, value) (BME_XOR32(&TRNG_SBLIM_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SBLIM bitfields
 */

/*!
 * @name Register TRNG_SBLIM, field SB_LIM[9:0] (RW)
 *
 * Sparse Bit Limit. During Von Neumann sampling (if enabled by MCTL[SAMP_MODE],
 * samples are discarded if two consecutive raw samples are both 0 or both 1. If
 * this discarding occurs for a long period of time, it indicates that there is
 * insufficient Entropy. The Sparse Bit Limit defines the maximum number of
 * consecutive samples that may be discarded before an error is generated. This field
 * is writable only if MCTL[PRGM] bit is 1. This register is cleared to 03hF by
 * writing the MCTL[RST_DEF] bit to 1. Note that if MCTL[PRGM] bit is 0, this
 * register address is used to read the Total Samples count in register TOTSAM, as
 * defined in the following section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SBLIM_SB_LIM field. */
#define TRNG_RD_SBLIM_SB_LIM(base) ((TRNG_SBLIM_REG(base) & TRNG_SBLIM_SB_LIM_MASK) >> TRNG_SBLIM_SB_LIM_SHIFT)
#define TRNG_BRD_SBLIM_SB_LIM(base) (BME_UBFX32(&TRNG_SBLIM_REG(base), TRNG_SBLIM_SB_LIM_SHIFT, TRNG_SBLIM_SB_LIM_WIDTH))

/*! @brief Set the SB_LIM field to a new value. */
#define TRNG_WR_SBLIM_SB_LIM(base, value) (TRNG_RMW_SBLIM(base, TRNG_SBLIM_SB_LIM_MASK, TRNG_SBLIM_SB_LIM(value)))
#define TRNG_BWR_SBLIM_SB_LIM(base, value) (BME_BFI32(&TRNG_SBLIM_REG(base), ((uint32_t)(value) << TRNG_SBLIM_SB_LIM_SHIFT), TRNG_SBLIM_SB_LIM_SHIFT, TRNG_SBLIM_SB_LIM_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_TOTSAM - RNG Total Samples Register
 ******************************************************************************/

/*!
 * @brief TRNG_TOTSAM - RNG Total Samples Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Total Samples Register is a read-only register used to read the total
 * number of samples taken during Entropy generation. It is used to give an
 * indication of how often a sample is actually used during Von Neumann sampling.
 * Note that this offset (0xBASE_0614) is used as SBLIM if MCTL[PRGM] is 1. If
 * MCTL[PRGM] is 0, this offset is used as TOTSAM readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_TOTSAM register
 */
/*@{*/
#define TRNG_RD_TOTSAM(base)     (TRNG_TOTSAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_TOTSAM bitfields
 */

/*!
 * @name Register TRNG_TOTSAM, field TOT_SAM[19:0] (RO)
 *
 * Total Samples. During Entropy generation, the total number of raw samples is
 * counted. This count is useful in determining how often a sample is used during
 * Von Neumann sampling. The count may be read through this register, if
 * MCTL[PRGM] bit is 0. Note that if MCTL[PRGM] bit is 1, this register address is used
 * to access the Sparse Bit Limit in register SBLIM, as defined in the previous
 * section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_TOTSAM_TOT_SAM field. */
#define TRNG_RD_TOTSAM_TOT_SAM(base) ((TRNG_TOTSAM_REG(base) & TRNG_TOTSAM_TOT_SAM_MASK) >> TRNG_TOTSAM_TOT_SAM_SHIFT)
#define TRNG_BRD_TOTSAM_TOT_SAM(base) (TRNG_RD_TOTSAM_TOT_SAM(base))
/*@}*/

/*******************************************************************************
 * TRNG_FRQMIN - RNG Frequency Count Minimum Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_FRQMIN - RNG Frequency Count Minimum Limit Register (RW)
 *
 * Reset value: 0x00000640U
 *
 * The RNG Frequency Count Minimum Limit Register defines the minimum allowable
 * count taken by the Entropy sample counter during each Entropy sample. During
 * any sample period, if the count is less than this programmed minimum, a
 * Frequency Count Fail is flagged in MCTL[FCT_FAIL] and an error is generated.
 */
/*!
 * @name Constants and macros for entire TRNG_FRQMIN register
 */
/*@{*/
#define TRNG_RD_FRQMIN(base)     (TRNG_FRQMIN_REG(base))
#define TRNG_WR_FRQMIN(base, value) (TRNG_FRQMIN_REG(base) = (value))
#define TRNG_RMW_FRQMIN(base, mask, value) (TRNG_WR_FRQMIN(base, (TRNG_RD_FRQMIN(base) & ~(mask)) | (value)))
#define TRNG_SET_FRQMIN(base, value) (BME_OR32(&TRNG_FRQMIN_REG(base), (uint32_t)(value)))
#define TRNG_CLR_FRQMIN(base, value) (BME_AND32(&TRNG_FRQMIN_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_FRQMIN(base, value) (BME_XOR32(&TRNG_FRQMIN_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_FRQMIN bitfields
 */

/*!
 * @name Register TRNG_FRQMIN, field FRQ_MIN[21:0] (RW)
 *
 * Frequency Count Minimum Limit. Defines the minimum allowable count taken
 * during each entropy sample. This field is writable only if MCTL[PRGM] bit is 1.
 * This field will read zeroes if MCTL[PRGM] = 0. This field is cleared to 0000h64
 * by writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_FRQMIN_FRQ_MIN field. */
#define TRNG_RD_FRQMIN_FRQ_MIN(base) ((TRNG_FRQMIN_REG(base) & TRNG_FRQMIN_FRQ_MIN_MASK) >> TRNG_FRQMIN_FRQ_MIN_SHIFT)
#define TRNG_BRD_FRQMIN_FRQ_MIN(base) (TRNG_RD_FRQMIN_FRQ_MIN(base))

/*! @brief Set the FRQ_MIN field to a new value. */
#define TRNG_WR_FRQMIN_FRQ_MIN(base, value) (TRNG_RMW_FRQMIN(base, TRNG_FRQMIN_FRQ_MIN_MASK, TRNG_FRQMIN_FRQ_MIN(value)))
#define TRNG_BWR_FRQMIN_FRQ_MIN(base, value) (TRNG_WR_FRQMIN_FRQ_MIN(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_FRQMAX - RNG Frequency Count Maximum Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_FRQMAX - RNG Frequency Count Maximum Limit Register (RW)
 *
 * Reset value: 0x00006400U
 *
 * The RNG Frequency Count Maximum Limit Register defines the maximum allowable
 * count taken by the Entropy sample counter during each Entropy sample. During
 * any sample period, if the count is greater than this programmed maximum, a
 * Frequency Count Fail is flagged in MCTL[FCT_FAIL] and an error is generated. Note
 * that this address (061C) is used as FRQMAX only if MCTL[PRGM] is 1. If
 * MCTL[PRGM] is 0, this address is used as FRQCNT readback register.
 */
/*!
 * @name Constants and macros for entire TRNG_FRQMAX register
 */
/*@{*/
#define TRNG_RD_FRQMAX(base)     (TRNG_FRQMAX_REG(base))
#define TRNG_WR_FRQMAX(base, value) (TRNG_FRQMAX_REG(base) = (value))
#define TRNG_RMW_FRQMAX(base, mask, value) (TRNG_WR_FRQMAX(base, (TRNG_RD_FRQMAX(base) & ~(mask)) | (value)))
#define TRNG_SET_FRQMAX(base, value) (BME_OR32(&TRNG_FRQMAX_REG(base), (uint32_t)(value)))
#define TRNG_CLR_FRQMAX(base, value) (BME_AND32(&TRNG_FRQMAX_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_FRQMAX(base, value) (BME_XOR32(&TRNG_FRQMAX_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_FRQMAX bitfields
 */

/*!
 * @name Register TRNG_FRQMAX, field FRQ_MAX[21:0] (RW)
 *
 * Frequency Counter Maximum Limit. Defines the maximum allowable count taken
 * during each entropy sample. This field is writable only if MCTL[PRGM] bit is 1.
 * This register is cleared to 000640h by writing the MCTL[RST_DEF] bit to 1.
 * Note that if MCTL[PRGM] bit is 0, this register address is used to read the
 * Frequency Count result in register FRQCNT, as defined in the following section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_FRQMAX_FRQ_MAX field. */
#define TRNG_RD_FRQMAX_FRQ_MAX(base) ((TRNG_FRQMAX_REG(base) & TRNG_FRQMAX_FRQ_MAX_MASK) >> TRNG_FRQMAX_FRQ_MAX_SHIFT)
#define TRNG_BRD_FRQMAX_FRQ_MAX(base) (TRNG_RD_FRQMAX_FRQ_MAX(base))

/*! @brief Set the FRQ_MAX field to a new value. */
#define TRNG_WR_FRQMAX_FRQ_MAX(base, value) (TRNG_RMW_FRQMAX(base, TRNG_FRQMAX_FRQ_MAX_MASK, TRNG_FRQMAX_FRQ_MAX(value)))
#define TRNG_BWR_FRQMAX_FRQ_MAX(base, value) (TRNG_WR_FRQMAX_FRQ_MAX(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_FRQCNT - RNG Frequency Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_FRQCNT - RNG Frequency Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Frequency Count Register is a read-only register used to read the
 * frequency counter within the TRNG entropy generator. It will read all zeroes
 * unless MCTL[TRNG_ACC] = 1. Note that this offset (0xBASE_061C) is used as FRQMAX
 * if MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this offset is used as FRQCNT readback
 * register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_FRQCNT register
 */
/*@{*/
#define TRNG_RD_FRQCNT(base)     (TRNG_FRQCNT_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_FRQCNT bitfields
 */

/*!
 * @name Register TRNG_FRQCNT, field FRQ_CT[21:0] (RO)
 *
 * Frequency Count. If MCTL[TRNG_ACC] = 1, reads a sample frequency count taken
 * during entropy generation. Requires MCTL[PRGM] = 0. Note that if MCTL[PRGM]
 * bit is 1, this register address is used to access the Poker Test Maximum Limit
 * in register PKRMAX, as defined in the previous section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_FRQCNT_FRQ_CT field. */
#define TRNG_RD_FRQCNT_FRQ_CT(base) ((TRNG_FRQCNT_REG(base) & TRNG_FRQCNT_FRQ_CT_MASK) >> TRNG_FRQCNT_FRQ_CT_SHIFT)
#define TRNG_BRD_FRQCNT_FRQ_CT(base) (TRNG_RD_FRQCNT_FRQ_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_SCMC - RNG Statistical Check Monobit Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCMC - RNG Statistical Check Monobit Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Monobit Count Register is a read-only register used
 * to read the final monobit count after entropy generation. This counter starts
 * with the value in SCML[MONO_MAX], and is decremented each time a one is
 * sampled. Note that this offset (0xBASE_0620) is used as SCML if MCTL[PRGM] is 1. If
 * MCTL[PRGM] is 0, this offset is used as SCMC readback register, as described
 * here.
 */
/*!
 * @name Constants and macros for entire TRNG_SCMC register
 */
/*@{*/
#define TRNG_RD_SCMC(base)       (TRNG_SCMC_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCMC bitfields
 */

/*!
 * @name Register TRNG_SCMC, field MONO_CT[15:0] (RO)
 *
 * Monobit Count. Reads the final Monobit count after entropy generation.
 * Requires MCTL[PRGM] = 0. Note that if MCTL[PRGM] bit is 1, this register address is
 * used to access the Statistical Check Monobit Limit in register SCML, as
 * defined in the previous section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCMC_MONO_CT field. */
#define TRNG_RD_SCMC_MONO_CT(base) ((TRNG_SCMC_REG(base) & TRNG_SCMC_MONO_CT_MASK) >> TRNG_SCMC_MONO_CT_SHIFT)
#define TRNG_BRD_SCMC_MONO_CT(base) (BME_UBFX32(&TRNG_SCMC_REG(base), TRNG_SCMC_MONO_CT_SHIFT, TRNG_SCMC_MONO_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SCML - RNG Statistical Check Monobit Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCML - RNG Statistical Check Monobit Limit Register (RW)
 *
 * Reset value: 0x010C0568U
 *
 * The RNG Statistical Check Monobit Limit Register defines the allowable
 * maximum and minimum number of ones/zero detected during entropy generation. To pass
 * the test, the number of ones/zeroes generated must be less than the programmed
 * maximum value, and the number of ones/zeroes generated must be greater than
 * (maximum - range). If this test fails, the Retry Counter in SCMISC will be
 * decremented, and a retry will occur if the Retry Count has not reached zero. If
 * the Retry Count has reached zero, an error will be generated. Note that this
 * offset (0xBASE_0620) is used as SCML only if MCTL[PRGM] is 1. If MCTL[PRGM] is 0,
 * this offset is used as SCMC readback register.
 */
/*!
 * @name Constants and macros for entire TRNG_SCML register
 */
/*@{*/
#define TRNG_RD_SCML(base)       (TRNG_SCML_REG(base))
#define TRNG_WR_SCML(base, value) (TRNG_SCML_REG(base) = (value))
#define TRNG_RMW_SCML(base, mask, value) (TRNG_WR_SCML(base, (TRNG_RD_SCML(base) & ~(mask)) | (value)))
#define TRNG_SET_SCML(base, value) (BME_OR32(&TRNG_SCML_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SCML(base, value) (BME_AND32(&TRNG_SCML_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SCML(base, value) (BME_XOR32(&TRNG_SCML_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCML bitfields
 */

/*!
 * @name Register TRNG_SCML, field MONO_MAX[15:0] (RW)
 *
 * Monobit Maximum Limit. Defines the maximum allowable count taken during
 * entropy generation. The number of ones/zeroes detected during entropy generation
 * must be less than MONO_MAX, else a retry or error will occur. This register is
 * cleared to 00056Bh (decimal 1387) by writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCML_MONO_MAX field. */
#define TRNG_RD_SCML_MONO_MAX(base) ((TRNG_SCML_REG(base) & TRNG_SCML_MONO_MAX_MASK) >> TRNG_SCML_MONO_MAX_SHIFT)
#define TRNG_BRD_SCML_MONO_MAX(base) (BME_UBFX32(&TRNG_SCML_REG(base), TRNG_SCML_MONO_MAX_SHIFT, TRNG_SCML_MONO_MAX_WIDTH))

/*! @brief Set the MONO_MAX field to a new value. */
#define TRNG_WR_SCML_MONO_MAX(base, value) (TRNG_RMW_SCML(base, TRNG_SCML_MONO_MAX_MASK, TRNG_SCML_MONO_MAX(value)))
#define TRNG_BWR_SCML_MONO_MAX(base, value) (BME_BFI32(&TRNG_SCML_REG(base), ((uint32_t)(value) << TRNG_SCML_MONO_MAX_SHIFT), TRNG_SCML_MONO_MAX_SHIFT, TRNG_SCML_MONO_MAX_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SCML, field MONO_RNG[31:16] (RW)
 *
 * Monobit Range. The number of ones/zeroes detected during entropy generation
 * must be greater than MONO_MAX - MONO_RNG, else a retry or error will occur.
 * This register is cleared to 000112h (decimal 274) by writing the MCTL[RST_DEF]
 * bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCML_MONO_RNG field. */
#define TRNG_RD_SCML_MONO_RNG(base) ((TRNG_SCML_REG(base) & TRNG_SCML_MONO_RNG_MASK) >> TRNG_SCML_MONO_RNG_SHIFT)
#define TRNG_BRD_SCML_MONO_RNG(base) (BME_UBFX32(&TRNG_SCML_REG(base), TRNG_SCML_MONO_RNG_SHIFT, TRNG_SCML_MONO_RNG_WIDTH))

/*! @brief Set the MONO_RNG field to a new value. */
#define TRNG_WR_SCML_MONO_RNG(base, value) (TRNG_RMW_SCML(base, TRNG_SCML_MONO_RNG_MASK, TRNG_SCML_MONO_RNG(value)))
#define TRNG_BWR_SCML_MONO_RNG(base, value) (BME_BFI32(&TRNG_SCML_REG(base), ((uint32_t)(value) << TRNG_SCML_MONO_RNG_SHIFT), TRNG_SCML_MONO_RNG_SHIFT, TRNG_SCML_MONO_RNG_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SCR1L - RNG Statistical Check Run Length 1 Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR1L - RNG Statistical Check Run Length 1 Limit Register (RW)
 *
 * Reset value: 0x00B20195U
 *
 * The RNG Statistical Check Run Length 1 Limit Register defines the allowable
 * maximum and minimum number of runs of length 1 detected during entropy
 * generation. To pass the test, the number of runs of length 1 (for samples of both 0
 * and 1) must be less than the programmed maximum value, and the number of runs of
 * length 1 must be greater than (maximum - range). If this test fails, the
 * Retry Counter in SCMISC will be decremented, and a retry will occur if the Retry
 * Count has not reached zero. If the Retry Count has reached zero, an error will
 * be generated. Note that this address (0xBASE_0624) is used as SCR1L only if
 * MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this address is used as SCR1C readback
 * register.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR1L register
 */
/*@{*/
#define TRNG_RD_SCR1L(base)      (TRNG_SCR1L_REG(base))
#define TRNG_WR_SCR1L(base, value) (TRNG_SCR1L_REG(base) = (value))
#define TRNG_RMW_SCR1L(base, mask, value) (TRNG_WR_SCR1L(base, (TRNG_RD_SCR1L(base) & ~(mask)) | (value)))
#define TRNG_SET_SCR1L(base, value) (BME_OR32(&TRNG_SCR1L_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SCR1L(base, value) (BME_AND32(&TRNG_SCR1L_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SCR1L(base, value) (BME_XOR32(&TRNG_SCR1L_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR1L bitfields
 */

/*!
 * @name Register TRNG_SCR1L, field RUN1_MAX[14:0] (RW)
 *
 * Run Length 1 Maximum Limit. Defines the maximum allowable runs of length 1
 * (for both 0 and 1) detected during entropy generation. The number of runs of
 * length 1 detected during entropy generation must be less than RUN1_MAX, else a
 * retry or error will occur. This register is cleared to 01E5h (decimal 485) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR1L_RUN1_MAX field. */
#define TRNG_RD_SCR1L_RUN1_MAX(base) ((TRNG_SCR1L_REG(base) & TRNG_SCR1L_RUN1_MAX_MASK) >> TRNG_SCR1L_RUN1_MAX_SHIFT)
#define TRNG_BRD_SCR1L_RUN1_MAX(base) (BME_UBFX32(&TRNG_SCR1L_REG(base), TRNG_SCR1L_RUN1_MAX_SHIFT, TRNG_SCR1L_RUN1_MAX_WIDTH))

/*! @brief Set the RUN1_MAX field to a new value. */
#define TRNG_WR_SCR1L_RUN1_MAX(base, value) (TRNG_RMW_SCR1L(base, TRNG_SCR1L_RUN1_MAX_MASK, TRNG_SCR1L_RUN1_MAX(value)))
#define TRNG_BWR_SCR1L_RUN1_MAX(base, value) (BME_BFI32(&TRNG_SCR1L_REG(base), ((uint32_t)(value) << TRNG_SCR1L_RUN1_MAX_SHIFT), TRNG_SCR1L_RUN1_MAX_SHIFT, TRNG_SCR1L_RUN1_MAX_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SCR1L, field RUN1_RNG[30:16] (RW)
 *
 * Run Length 1 Range. The number of runs of length 1 (for both 0 and 1)
 * detected during entropy generation must be greater than RUN1_MAX - RUN1_RNG, else a
 * retry or error will occur. This register is cleared to 0102h (decimal 258) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR1L_RUN1_RNG field. */
#define TRNG_RD_SCR1L_RUN1_RNG(base) ((TRNG_SCR1L_REG(base) & TRNG_SCR1L_RUN1_RNG_MASK) >> TRNG_SCR1L_RUN1_RNG_SHIFT)
#define TRNG_BRD_SCR1L_RUN1_RNG(base) (BME_UBFX32(&TRNG_SCR1L_REG(base), TRNG_SCR1L_RUN1_RNG_SHIFT, TRNG_SCR1L_RUN1_RNG_WIDTH))

/*! @brief Set the RUN1_RNG field to a new value. */
#define TRNG_WR_SCR1L_RUN1_RNG(base, value) (TRNG_RMW_SCR1L(base, TRNG_SCR1L_RUN1_RNG_MASK, TRNG_SCR1L_RUN1_RNG(value)))
#define TRNG_BWR_SCR1L_RUN1_RNG(base, value) (BME_BFI32(&TRNG_SCR1L_REG(base), ((uint32_t)(value) << TRNG_SCR1L_RUN1_RNG_SHIFT), TRNG_SCR1L_RUN1_RNG_SHIFT, TRNG_SCR1L_RUN1_RNG_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SCR1C - RNG Statistical Check Run Length 1 Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR1C - RNG Statistical Check Run Length 1 Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Run Length 1 Counters Register is a read-only
 * register used to read the final Run Length 1 counts after entropy generation. These
 * counters start with the value in SCR1L[RUN1_MAX]. The R1_1_CT decrements each
 * time a single one is sampled (preceded by a zero and followed by a zero). The
 * R1_0_CT decrements each time a single zero is sampled (preceded by a one and
 * followed by a one). Note that this offset (0xBASE_0624) is used as SCR1L if
 * MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this offset is used as SCR1C readback
 * register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR1C register
 */
/*@{*/
#define TRNG_RD_SCR1C(base)      (TRNG_SCR1C_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR1C bitfields
 */

/*!
 * @name Register TRNG_SCR1C, field R1_0_CT[14:0] (RO)
 *
 * Runs of Zero, Length 1 Count. Reads the final Runs of Zeroes, length 1 count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR1C_R1_0_CT field. */
#define TRNG_RD_SCR1C_R1_0_CT(base) ((TRNG_SCR1C_REG(base) & TRNG_SCR1C_R1_0_CT_MASK) >> TRNG_SCR1C_R1_0_CT_SHIFT)
#define TRNG_BRD_SCR1C_R1_0_CT(base) (BME_UBFX32(&TRNG_SCR1C_REG(base), TRNG_SCR1C_R1_0_CT_SHIFT, TRNG_SCR1C_R1_0_CT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SCR1C, field R1_1_CT[30:16] (RO)
 *
 * Runs of One, Length 1 Count. Reads the final Runs of Ones, length 1 count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR1C_R1_1_CT field. */
#define TRNG_RD_SCR1C_R1_1_CT(base) ((TRNG_SCR1C_REG(base) & TRNG_SCR1C_R1_1_CT_MASK) >> TRNG_SCR1C_R1_1_CT_SHIFT)
#define TRNG_BRD_SCR1C_R1_1_CT(base) (BME_UBFX32(&TRNG_SCR1C_REG(base), TRNG_SCR1C_R1_1_CT_SHIFT, TRNG_SCR1C_R1_1_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SCR2L - RNG Statistical Check Run Length 2 Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR2L - RNG Statistical Check Run Length 2 Limit Register (RW)
 *
 * Reset value: 0x007A00DCU
 *
 * The RNG Statistical Check Run Length 2 Limit Register defines the allowable
 * maximum and minimum number of runs of length 2 detected during entropy
 * generation. To pass the test, the number of runs of length 2 (for samples of both 0
 * and 1) must be less than the programmed maximum value, and the number of runs of
 * length 2 must be greater than (maximum - range). If this test fails, the
 * Retry Counter in SCMISC will be decremented, and a retry will occur if the Retry
 * Count has not reached zero. If the Retry Count has reached zero, an error will
 * be generated. Note that this address (0xBASE_0628) is used as SCR2L only if
 * MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this address is used as SCR2C readback
 * register.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR2L register
 */
/*@{*/
#define TRNG_RD_SCR2L(base)      (TRNG_SCR2L_REG(base))
#define TRNG_WR_SCR2L(base, value) (TRNG_SCR2L_REG(base) = (value))
#define TRNG_RMW_SCR2L(base, mask, value) (TRNG_WR_SCR2L(base, (TRNG_RD_SCR2L(base) & ~(mask)) | (value)))
#define TRNG_SET_SCR2L(base, value) (BME_OR32(&TRNG_SCR2L_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SCR2L(base, value) (BME_AND32(&TRNG_SCR2L_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SCR2L(base, value) (BME_XOR32(&TRNG_SCR2L_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR2L bitfields
 */

/*!
 * @name Register TRNG_SCR2L, field RUN2_MAX[13:0] (RW)
 *
 * Run Length 2 Maximum Limit. Defines the maximum allowable runs of length 2
 * (for both 0 and 1) detected during entropy generation. The number of runs of
 * length 2 detected during entropy generation must be less than RUN2_MAX, else a
 * retry or error will occur. This register is cleared to 00DCh (decimal 220) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR2L_RUN2_MAX field. */
#define TRNG_RD_SCR2L_RUN2_MAX(base) ((TRNG_SCR2L_REG(base) & TRNG_SCR2L_RUN2_MAX_MASK) >> TRNG_SCR2L_RUN2_MAX_SHIFT)
#define TRNG_BRD_SCR2L_RUN2_MAX(base) (BME_UBFX32(&TRNG_SCR2L_REG(base), TRNG_SCR2L_RUN2_MAX_SHIFT, TRNG_SCR2L_RUN2_MAX_WIDTH))

/*! @brief Set the RUN2_MAX field to a new value. */
#define TRNG_WR_SCR2L_RUN2_MAX(base, value) (TRNG_RMW_SCR2L(base, TRNG_SCR2L_RUN2_MAX_MASK, TRNG_SCR2L_RUN2_MAX(value)))
#define TRNG_BWR_SCR2L_RUN2_MAX(base, value) (BME_BFI32(&TRNG_SCR2L_REG(base), ((uint32_t)(value) << TRNG_SCR2L_RUN2_MAX_SHIFT), TRNG_SCR2L_RUN2_MAX_SHIFT, TRNG_SCR2L_RUN2_MAX_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SCR2L, field RUN2_RNG[29:16] (RW)
 *
 * Run Length 2 Range. The number of runs of length 2 (for both 0 and 1)
 * detected during entropy generation must be greater than RUN2_MAX - RUN2_RNG, else a
 * retry or error will occur. This register is cleared to 007Ah (decimal 122) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR2L_RUN2_RNG field. */
#define TRNG_RD_SCR2L_RUN2_RNG(base) ((TRNG_SCR2L_REG(base) & TRNG_SCR2L_RUN2_RNG_MASK) >> TRNG_SCR2L_RUN2_RNG_SHIFT)
#define TRNG_BRD_SCR2L_RUN2_RNG(base) (BME_UBFX32(&TRNG_SCR2L_REG(base), TRNG_SCR2L_RUN2_RNG_SHIFT, TRNG_SCR2L_RUN2_RNG_WIDTH))

/*! @brief Set the RUN2_RNG field to a new value. */
#define TRNG_WR_SCR2L_RUN2_RNG(base, value) (TRNG_RMW_SCR2L(base, TRNG_SCR2L_RUN2_RNG_MASK, TRNG_SCR2L_RUN2_RNG(value)))
#define TRNG_BWR_SCR2L_RUN2_RNG(base, value) (BME_BFI32(&TRNG_SCR2L_REG(base), ((uint32_t)(value) << TRNG_SCR2L_RUN2_RNG_SHIFT), TRNG_SCR2L_RUN2_RNG_SHIFT, TRNG_SCR2L_RUN2_RNG_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SCR2C - RNG Statistical Check Run Length 2 Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR2C - RNG Statistical Check Run Length 2 Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Run Length 2 Counters Register is a read-only
 * register used to read the final Run Length 2 counts after entropy generation. These
 * counters start with the value in SCR2L[RUN2_MAX]. The R2_1_CT decrements each
 * time two consecutive ones are sampled (preceded by a zero and followed by a
 * zero). The R2_0_CT decrements each time two consecutive zeroes are sampled
 * (preceded by a one and followed by a one). Note that this offset (0xBASE_0628) is
 * used as SCR2L if MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this offset is used as
 * SCR2C readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR2C register
 */
/*@{*/
#define TRNG_RD_SCR2C(base)      (TRNG_SCR2C_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR2C bitfields
 */

/*!
 * @name Register TRNG_SCR2C, field R2_0_CT[13:0] (RO)
 *
 * Runs of Zero, Length 2 Count. Reads the final Runs of Zeroes, length 2 count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR2C_R2_0_CT field. */
#define TRNG_RD_SCR2C_R2_0_CT(base) ((TRNG_SCR2C_REG(base) & TRNG_SCR2C_R2_0_CT_MASK) >> TRNG_SCR2C_R2_0_CT_SHIFT)
#define TRNG_BRD_SCR2C_R2_0_CT(base) (BME_UBFX32(&TRNG_SCR2C_REG(base), TRNG_SCR2C_R2_0_CT_SHIFT, TRNG_SCR2C_R2_0_CT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SCR2C, field R2_1_CT[29:16] (RO)
 *
 * Runs of One, Length 2 Count. Reads the final Runs of Ones, length 2 count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR2C_R2_1_CT field. */
#define TRNG_RD_SCR2C_R2_1_CT(base) ((TRNG_SCR2C_REG(base) & TRNG_SCR2C_R2_1_CT_MASK) >> TRNG_SCR2C_R2_1_CT_SHIFT)
#define TRNG_BRD_SCR2C_R2_1_CT(base) (BME_UBFX32(&TRNG_SCR2C_REG(base), TRNG_SCR2C_R2_1_CT_SHIFT, TRNG_SCR2C_R2_1_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SCR3C - RNG Statistical Check Run Length 3 Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR3C - RNG Statistical Check Run Length 3 Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Run Length 3 Counters Register is a read-only
 * register used to read the final Run Length 3 counts after entropy generation. These
 * counters start with the value in SCR3L[RUN3_MAX]. The R3_1_CT decrements each
 * time three consecutive ones are sampled (preceded by a zero and followed by a
 * zero). The R3_0_CT decrements each time three consecutive zeroes are sampled
 * (preceded by a one and followed by a one). Note that this offset (0xBASE_062C)
 * is used as SCR3L if MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this offset is used
 * as SCR3C readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR3C register
 */
/*@{*/
#define TRNG_RD_SCR3C(base)      (TRNG_SCR3C_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR3C bitfields
 */

/*!
 * @name Register TRNG_SCR3C, field R3_0_CT[12:0] (RO)
 *
 * Runs of Zeroes, Length 3 Count. Reads the final Runs of Zeroes, length 3
 * count after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR3C_R3_0_CT field. */
#define TRNG_RD_SCR3C_R3_0_CT(base) ((TRNG_SCR3C_REG(base) & TRNG_SCR3C_R3_0_CT_MASK) >> TRNG_SCR3C_R3_0_CT_SHIFT)
#define TRNG_BRD_SCR3C_R3_0_CT(base) (BME_UBFX32(&TRNG_SCR3C_REG(base), TRNG_SCR3C_R3_0_CT_SHIFT, TRNG_SCR3C_R3_0_CT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SCR3C, field R3_1_CT[28:16] (RO)
 *
 * Runs of Ones, Length 3 Count. Reads the final Runs of Ones, length 3 count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR3C_R3_1_CT field. */
#define TRNG_RD_SCR3C_R3_1_CT(base) ((TRNG_SCR3C_REG(base) & TRNG_SCR3C_R3_1_CT_MASK) >> TRNG_SCR3C_R3_1_CT_SHIFT)
#define TRNG_BRD_SCR3C_R3_1_CT(base) (BME_UBFX32(&TRNG_SCR3C_REG(base), TRNG_SCR3C_R3_1_CT_SHIFT, TRNG_SCR3C_R3_1_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SCR3L - RNG Statistical Check Run Length 3 Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR3L - RNG Statistical Check Run Length 3 Limit Register (RW)
 *
 * Reset value: 0x0058007DU
 *
 * The RNG Statistical Check Run Length 3 Limit Register defines the allowable
 * maximum and minimum number of runs of length 3 detected during entropy
 * generation. To pass the test, the number of runs of length 3 (for samples of both 0
 * and 1) must be less than the programmed maximum value, and the number of runs of
 * length 3 must be greater than (maximum - range). If this test fails, the
 * Retry Counter in SCMISC will be decremented, and a retry will occur if the Retry
 * Count has not reached zero. If the Retry Count has reached zero, an error will
 * be generated. Note that this address (0xBASE_062C) is used as SCR3L only if
 * MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this address is used as SCR3C readback
 * register.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR3L register
 */
/*@{*/
#define TRNG_RD_SCR3L(base)      (TRNG_SCR3L_REG(base))
#define TRNG_WR_SCR3L(base, value) (TRNG_SCR3L_REG(base) = (value))
#define TRNG_RMW_SCR3L(base, mask, value) (TRNG_WR_SCR3L(base, (TRNG_RD_SCR3L(base) & ~(mask)) | (value)))
#define TRNG_SET_SCR3L(base, value) (BME_OR32(&TRNG_SCR3L_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SCR3L(base, value) (BME_AND32(&TRNG_SCR3L_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SCR3L(base, value) (BME_XOR32(&TRNG_SCR3L_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR3L bitfields
 */

/*!
 * @name Register TRNG_SCR3L, field RUN3_MAX[12:0] (RW)
 *
 * Run Length 3 Maximum Limit. Defines the maximum allowable runs of length 3
 * (for both 0 and 1) detected during entropy generation. The number of runs of
 * length 3 detected during entropy generation must be less than RUN3_MAX, else a
 * retry or error will occur. This register is cleared to 007Dh (decimal 125) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR3L_RUN3_MAX field. */
#define TRNG_RD_SCR3L_RUN3_MAX(base) ((TRNG_SCR3L_REG(base) & TRNG_SCR3L_RUN3_MAX_MASK) >> TRNG_SCR3L_RUN3_MAX_SHIFT)
#define TRNG_BRD_SCR3L_RUN3_MAX(base) (BME_UBFX32(&TRNG_SCR3L_REG(base), TRNG_SCR3L_RUN3_MAX_SHIFT, TRNG_SCR3L_RUN3_MAX_WIDTH))

/*! @brief Set the RUN3_MAX field to a new value. */
#define TRNG_WR_SCR3L_RUN3_MAX(base, value) (TRNG_RMW_SCR3L(base, TRNG_SCR3L_RUN3_MAX_MASK, TRNG_SCR3L_RUN3_MAX(value)))
#define TRNG_BWR_SCR3L_RUN3_MAX(base, value) (BME_BFI32(&TRNG_SCR3L_REG(base), ((uint32_t)(value) << TRNG_SCR3L_RUN3_MAX_SHIFT), TRNG_SCR3L_RUN3_MAX_SHIFT, TRNG_SCR3L_RUN3_MAX_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SCR3L, field RUN3_RNG[28:16] (RW)
 *
 * Run Length 3 Range. The number of runs of length 3 (for both 0 and 1)
 * detected during entropy generation must be greater than RUN3_MAX - RUN3_RNG, else a
 * retry or error will occur. This register is cleared to 0058h (decimal 88) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR3L_RUN3_RNG field. */
#define TRNG_RD_SCR3L_RUN3_RNG(base) ((TRNG_SCR3L_REG(base) & TRNG_SCR3L_RUN3_RNG_MASK) >> TRNG_SCR3L_RUN3_RNG_SHIFT)
#define TRNG_BRD_SCR3L_RUN3_RNG(base) (BME_UBFX32(&TRNG_SCR3L_REG(base), TRNG_SCR3L_RUN3_RNG_SHIFT, TRNG_SCR3L_RUN3_RNG_WIDTH))

/*! @brief Set the RUN3_RNG field to a new value. */
#define TRNG_WR_SCR3L_RUN3_RNG(base, value) (TRNG_RMW_SCR3L(base, TRNG_SCR3L_RUN3_RNG_MASK, TRNG_SCR3L_RUN3_RNG(value)))
#define TRNG_BWR_SCR3L_RUN3_RNG(base, value) (BME_BFI32(&TRNG_SCR3L_REG(base), ((uint32_t)(value) << TRNG_SCR3L_RUN3_RNG_SHIFT), TRNG_SCR3L_RUN3_RNG_SHIFT, TRNG_SCR3L_RUN3_RNG_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SCR4C - RNG Statistical Check Run Length 4 Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR4C - RNG Statistical Check Run Length 4 Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Run Length 4 Counters Register is a read-only
 * register used to read the final Run Length 4 counts after entropy generation. These
 * counters start with the value in SCR4L[RUN4_MAX]. The R4_1_CT decrements each
 * time four consecutive ones are sampled (preceded by a zero and followed by a
 * zero). The R4_0_CT decrements each time four consecutive zeroes are sampled
 * (preceded by a one and followed by a one). Note that this offset (0xBASE_0630)
 * is used as SCR4L if MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this offset is used as
 * SCR4C readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR4C register
 */
/*@{*/
#define TRNG_RD_SCR4C(base)      (TRNG_SCR4C_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR4C bitfields
 */

/*!
 * @name Register TRNG_SCR4C, field R4_0_CT[11:0] (RO)
 *
 * Runs of Zero, Length 4 Count. Reads the final Runs of Ones, length 4 count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR4C_R4_0_CT field. */
#define TRNG_RD_SCR4C_R4_0_CT(base) ((TRNG_SCR4C_REG(base) & TRNG_SCR4C_R4_0_CT_MASK) >> TRNG_SCR4C_R4_0_CT_SHIFT)
#define TRNG_BRD_SCR4C_R4_0_CT(base) (BME_UBFX32(&TRNG_SCR4C_REG(base), TRNG_SCR4C_R4_0_CT_SHIFT, TRNG_SCR4C_R4_0_CT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SCR4C, field R4_1_CT[27:16] (RO)
 *
 * Runs of One, Length 4 Count. Reads the final Runs of Ones, length 4 count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR4C_R4_1_CT field. */
#define TRNG_RD_SCR4C_R4_1_CT(base) ((TRNG_SCR4C_REG(base) & TRNG_SCR4C_R4_1_CT_MASK) >> TRNG_SCR4C_R4_1_CT_SHIFT)
#define TRNG_BRD_SCR4C_R4_1_CT(base) (BME_UBFX32(&TRNG_SCR4C_REG(base), TRNG_SCR4C_R4_1_CT_SHIFT, TRNG_SCR4C_R4_1_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SCR4L - RNG Statistical Check Run Length 4 Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR4L - RNG Statistical Check Run Length 4 Limit Register (RW)
 *
 * Reset value: 0x0040004BU
 *
 * The RNG Statistical Check Run Length 4 Limit Register defines the allowable
 * maximum and minimum number of runs of length 4 detected during entropy
 * generation. To pass the test, the number of runs of length 4 (for samples of both 0
 * and 1) must be less than the programmed maximum value, and the number of runs of
 * length 4 must be greater than (maximum - range). If this test fails, the
 * Retry Counter in SCMISC will be decremented, and a retry will occur if the Retry
 * Count has not reached zero. If the Retry Count has reached zero, an error will
 * be generated. Note that this address (0xBASE_0630) is used as SCR4L only if
 * MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this address is used as SCR4C readback
 * register.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR4L register
 */
/*@{*/
#define TRNG_RD_SCR4L(base)      (TRNG_SCR4L_REG(base))
#define TRNG_WR_SCR4L(base, value) (TRNG_SCR4L_REG(base) = (value))
#define TRNG_RMW_SCR4L(base, mask, value) (TRNG_WR_SCR4L(base, (TRNG_RD_SCR4L(base) & ~(mask)) | (value)))
#define TRNG_SET_SCR4L(base, value) (BME_OR32(&TRNG_SCR4L_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SCR4L(base, value) (BME_AND32(&TRNG_SCR4L_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SCR4L(base, value) (BME_XOR32(&TRNG_SCR4L_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR4L bitfields
 */

/*!
 * @name Register TRNG_SCR4L, field RUN4_MAX[11:0] (RW)
 *
 * Run Length 4 Maximum Limit. Defines the maximum allowable runs of length 4
 * (for both 0 and 1) detected during entropy generation. The number of runs of
 * length 4 detected during entropy generation must be less than RUN4_MAX, else a
 * retry or error will occur. This register is cleared to 004Bh (decimal 75) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR4L_RUN4_MAX field. */
#define TRNG_RD_SCR4L_RUN4_MAX(base) ((TRNG_SCR4L_REG(base) & TRNG_SCR4L_RUN4_MAX_MASK) >> TRNG_SCR4L_RUN4_MAX_SHIFT)
#define TRNG_BRD_SCR4L_RUN4_MAX(base) (BME_UBFX32(&TRNG_SCR4L_REG(base), TRNG_SCR4L_RUN4_MAX_SHIFT, TRNG_SCR4L_RUN4_MAX_WIDTH))

/*! @brief Set the RUN4_MAX field to a new value. */
#define TRNG_WR_SCR4L_RUN4_MAX(base, value) (TRNG_RMW_SCR4L(base, TRNG_SCR4L_RUN4_MAX_MASK, TRNG_SCR4L_RUN4_MAX(value)))
#define TRNG_BWR_SCR4L_RUN4_MAX(base, value) (BME_BFI32(&TRNG_SCR4L_REG(base), ((uint32_t)(value) << TRNG_SCR4L_RUN4_MAX_SHIFT), TRNG_SCR4L_RUN4_MAX_SHIFT, TRNG_SCR4L_RUN4_MAX_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SCR4L, field RUN4_RNG[27:16] (RW)
 *
 * Run Length 4 Range. The number of runs of length 4 (for both 0 and 1)
 * detected during entropy generation must be greater than RUN4_MAX - RUN4_RNG, else a
 * retry or error will occur. This register is cleared to 0040h (decimal 64) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR4L_RUN4_RNG field. */
#define TRNG_RD_SCR4L_RUN4_RNG(base) ((TRNG_SCR4L_REG(base) & TRNG_SCR4L_RUN4_RNG_MASK) >> TRNG_SCR4L_RUN4_RNG_SHIFT)
#define TRNG_BRD_SCR4L_RUN4_RNG(base) (BME_UBFX32(&TRNG_SCR4L_REG(base), TRNG_SCR4L_RUN4_RNG_SHIFT, TRNG_SCR4L_RUN4_RNG_WIDTH))

/*! @brief Set the RUN4_RNG field to a new value. */
#define TRNG_WR_SCR4L_RUN4_RNG(base, value) (TRNG_RMW_SCR4L(base, TRNG_SCR4L_RUN4_RNG_MASK, TRNG_SCR4L_RUN4_RNG(value)))
#define TRNG_BWR_SCR4L_RUN4_RNG(base, value) (BME_BFI32(&TRNG_SCR4L_REG(base), ((uint32_t)(value) << TRNG_SCR4L_RUN4_RNG_SHIFT), TRNG_SCR4L_RUN4_RNG_SHIFT, TRNG_SCR4L_RUN4_RNG_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SCR5L - RNG Statistical Check Run Length 5 Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR5L - RNG Statistical Check Run Length 5 Limit Register (RW)
 *
 * Reset value: 0x002E002FU
 *
 * The RNG Statistical Check Run Length 5 Limit Register defines the allowable
 * maximum and minimum number of runs of length 5 detected during entropy
 * generation. To pass the test, the number of runs of length 5 (for samples of both 0
 * and 1) must be less than the programmed maximum value, and the number of runs of
 * length 5 must be greater than (maximum - range). If this test fails, the
 * Retry Counter in SCMISC will be decremented, and a retry will occur if the Retry
 * Count has not reached zero. If the Retry Count has reached zero, an error will
 * be generated. Note that this address (0xBASE_0634) is used as SCR5L only if
 * MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this address is used as SCR5C readback
 * register.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR5L register
 */
/*@{*/
#define TRNG_RD_SCR5L(base)      (TRNG_SCR5L_REG(base))
#define TRNG_WR_SCR5L(base, value) (TRNG_SCR5L_REG(base) = (value))
#define TRNG_RMW_SCR5L(base, mask, value) (TRNG_WR_SCR5L(base, (TRNG_RD_SCR5L(base) & ~(mask)) | (value)))
#define TRNG_SET_SCR5L(base, value) (BME_OR32(&TRNG_SCR5L_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SCR5L(base, value) (BME_AND32(&TRNG_SCR5L_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SCR5L(base, value) (BME_XOR32(&TRNG_SCR5L_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR5L bitfields
 */

/*!
 * @name Register TRNG_SCR5L, field RUN5_MAX[10:0] (RW)
 *
 * Run Length 5 Maximum Limit. Defines the maximum allowable runs of length 5
 * (for both 0 and 1) detected during entropy generation. The number of runs of
 * length 5 detected during entropy generation must be less than RUN5_MAX, else a
 * retry or error will occur. This register is cleared to 002Fh (decimal 47) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR5L_RUN5_MAX field. */
#define TRNG_RD_SCR5L_RUN5_MAX(base) ((TRNG_SCR5L_REG(base) & TRNG_SCR5L_RUN5_MAX_MASK) >> TRNG_SCR5L_RUN5_MAX_SHIFT)
#define TRNG_BRD_SCR5L_RUN5_MAX(base) (BME_UBFX32(&TRNG_SCR5L_REG(base), TRNG_SCR5L_RUN5_MAX_SHIFT, TRNG_SCR5L_RUN5_MAX_WIDTH))

/*! @brief Set the RUN5_MAX field to a new value. */
#define TRNG_WR_SCR5L_RUN5_MAX(base, value) (TRNG_RMW_SCR5L(base, TRNG_SCR5L_RUN5_MAX_MASK, TRNG_SCR5L_RUN5_MAX(value)))
#define TRNG_BWR_SCR5L_RUN5_MAX(base, value) (BME_BFI32(&TRNG_SCR5L_REG(base), ((uint32_t)(value) << TRNG_SCR5L_RUN5_MAX_SHIFT), TRNG_SCR5L_RUN5_MAX_SHIFT, TRNG_SCR5L_RUN5_MAX_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SCR5L, field RUN5_RNG[26:16] (RW)
 *
 * Run Length 5 Range. The number of runs of length 5 (for both 0 and 1)
 * detected during entropy generation must be greater than RUN5_MAX - RUN5_RNG, else a
 * retry or error will occur. This register is cleared to 002Eh (decimal 46) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR5L_RUN5_RNG field. */
#define TRNG_RD_SCR5L_RUN5_RNG(base) ((TRNG_SCR5L_REG(base) & TRNG_SCR5L_RUN5_RNG_MASK) >> TRNG_SCR5L_RUN5_RNG_SHIFT)
#define TRNG_BRD_SCR5L_RUN5_RNG(base) (BME_UBFX32(&TRNG_SCR5L_REG(base), TRNG_SCR5L_RUN5_RNG_SHIFT, TRNG_SCR5L_RUN5_RNG_WIDTH))

/*! @brief Set the RUN5_RNG field to a new value. */
#define TRNG_WR_SCR5L_RUN5_RNG(base, value) (TRNG_RMW_SCR5L(base, TRNG_SCR5L_RUN5_RNG_MASK, TRNG_SCR5L_RUN5_RNG(value)))
#define TRNG_BWR_SCR5L_RUN5_RNG(base, value) (BME_BFI32(&TRNG_SCR5L_REG(base), ((uint32_t)(value) << TRNG_SCR5L_RUN5_RNG_SHIFT), TRNG_SCR5L_RUN5_RNG_SHIFT, TRNG_SCR5L_RUN5_RNG_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SCR5C - RNG Statistical Check Run Length 5 Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR5C - RNG Statistical Check Run Length 5 Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Run Length 5 Counters Register is a read-only
 * register used to read the final Run Length 5 counts after entropy generation. These
 * counters start with the value in SCR5L[RUN5_MAX]. The R5_1_CT decrements each
 * time five consecutive ones are sampled (preceded by a zero and followed by a
 * zero). The R5_0_CT decrements each time five consecutive zeroes are sampled
 * (preceded by a one and followed by a one). Note that this offset (0xBASE_0634)
 * is used as SCR5L if MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this offset is used as
 * SCR5C readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR5C register
 */
/*@{*/
#define TRNG_RD_SCR5C(base)      (TRNG_SCR5C_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR5C bitfields
 */

/*!
 * @name Register TRNG_SCR5C, field R5_0_CT[10:0] (RO)
 *
 * Runs of Zero, Length 5 Count. Reads the final Runs of Ones, length 5 count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR5C_R5_0_CT field. */
#define TRNG_RD_SCR5C_R5_0_CT(base) ((TRNG_SCR5C_REG(base) & TRNG_SCR5C_R5_0_CT_MASK) >> TRNG_SCR5C_R5_0_CT_SHIFT)
#define TRNG_BRD_SCR5C_R5_0_CT(base) (BME_UBFX32(&TRNG_SCR5C_REG(base), TRNG_SCR5C_R5_0_CT_SHIFT, TRNG_SCR5C_R5_0_CT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SCR5C, field R5_1_CT[26:16] (RO)
 *
 * Runs of One, Length 5 Count. Reads the final Runs of Ones, length 5 count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR5C_R5_1_CT field. */
#define TRNG_RD_SCR5C_R5_1_CT(base) ((TRNG_SCR5C_REG(base) & TRNG_SCR5C_R5_1_CT_MASK) >> TRNG_SCR5C_R5_1_CT_SHIFT)
#define TRNG_BRD_SCR5C_R5_1_CT(base) (BME_UBFX32(&TRNG_SCR5C_REG(base), TRNG_SCR5C_R5_1_CT_SHIFT, TRNG_SCR5C_R5_1_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SCR6PL - RNG Statistical Check Run Length 6+ Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR6PL - RNG Statistical Check Run Length 6+ Limit Register (RW)
 *
 * Reset value: 0x002E002FU
 *
 * The RNG Statistical Check Run Length 6+ Limit Register defines the allowable
 * maximum and minimum number of runs of length 6 or more detected during entropy
 * generation. To pass the test, the number of runs of length 6 or more (for
 * samples of both 0 and 1) must be less than the programmed maximum value, and the
 * number of runs of length 6 or more must be greater than (maximum - range). If
 * this test fails, the Retry Counter in SCMISC will be decremented, and a retry
 * will occur if the Retry Count has not reached zero. If the Retry Count has
 * reached zero, an error will be generated. Note that this offset (0xBASE_0638) is
 * used as SCR6PL only if MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this offset is
 * used as SCR6PC readback register.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR6PL register
 */
/*@{*/
#define TRNG_RD_SCR6PL(base)     (TRNG_SCR6PL_REG(base))
#define TRNG_WR_SCR6PL(base, value) (TRNG_SCR6PL_REG(base) = (value))
#define TRNG_RMW_SCR6PL(base, mask, value) (TRNG_WR_SCR6PL(base, (TRNG_RD_SCR6PL(base) & ~(mask)) | (value)))
#define TRNG_SET_SCR6PL(base, value) (BME_OR32(&TRNG_SCR6PL_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SCR6PL(base, value) (BME_AND32(&TRNG_SCR6PL_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SCR6PL(base, value) (BME_XOR32(&TRNG_SCR6PL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR6PL bitfields
 */

/*!
 * @name Register TRNG_SCR6PL, field RUN6P_MAX[10:0] (RW)
 *
 * Run Length 6+ Maximum Limit. Defines the maximum allowable runs of length 6
 * or more (for both 0 and 1) detected during entropy generation. The number of
 * runs of length 6 or more detected during entropy generation must be less than
 * RUN6P_MAX, else a retry or error will occur. This register is cleared to 002Fh
 * (decimal 47) by writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR6PL_RUN6P_MAX field. */
#define TRNG_RD_SCR6PL_RUN6P_MAX(base) ((TRNG_SCR6PL_REG(base) & TRNG_SCR6PL_RUN6P_MAX_MASK) >> TRNG_SCR6PL_RUN6P_MAX_SHIFT)
#define TRNG_BRD_SCR6PL_RUN6P_MAX(base) (BME_UBFX32(&TRNG_SCR6PL_REG(base), TRNG_SCR6PL_RUN6P_MAX_SHIFT, TRNG_SCR6PL_RUN6P_MAX_WIDTH))

/*! @brief Set the RUN6P_MAX field to a new value. */
#define TRNG_WR_SCR6PL_RUN6P_MAX(base, value) (TRNG_RMW_SCR6PL(base, TRNG_SCR6PL_RUN6P_MAX_MASK, TRNG_SCR6PL_RUN6P_MAX(value)))
#define TRNG_BWR_SCR6PL_RUN6P_MAX(base, value) (BME_BFI32(&TRNG_SCR6PL_REG(base), ((uint32_t)(value) << TRNG_SCR6PL_RUN6P_MAX_SHIFT), TRNG_SCR6PL_RUN6P_MAX_SHIFT, TRNG_SCR6PL_RUN6P_MAX_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SCR6PL, field RUN6P_RNG[26:16] (RW)
 *
 * Run Length 6+ Range. The number of runs of length 6 or more (for both 0 and
 * 1) detected during entropy generation must be greater than RUN6P_MAX -
 * RUN6P_RNG, else a retry or error will occur. This register is cleared to 002Eh
 * (decimal 46) by writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR6PL_RUN6P_RNG field. */
#define TRNG_RD_SCR6PL_RUN6P_RNG(base) ((TRNG_SCR6PL_REG(base) & TRNG_SCR6PL_RUN6P_RNG_MASK) >> TRNG_SCR6PL_RUN6P_RNG_SHIFT)
#define TRNG_BRD_SCR6PL_RUN6P_RNG(base) (BME_UBFX32(&TRNG_SCR6PL_REG(base), TRNG_SCR6PL_RUN6P_RNG_SHIFT, TRNG_SCR6PL_RUN6P_RNG_WIDTH))

/*! @brief Set the RUN6P_RNG field to a new value. */
#define TRNG_WR_SCR6PL_RUN6P_RNG(base, value) (TRNG_RMW_SCR6PL(base, TRNG_SCR6PL_RUN6P_RNG_MASK, TRNG_SCR6PL_RUN6P_RNG(value)))
#define TRNG_BWR_SCR6PL_RUN6P_RNG(base, value) (BME_BFI32(&TRNG_SCR6PL_REG(base), ((uint32_t)(value) << TRNG_SCR6PL_RUN6P_RNG_SHIFT), TRNG_SCR6PL_RUN6P_RNG_SHIFT, TRNG_SCR6PL_RUN6P_RNG_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SCR6PC - RNG Statistical Check Run Length 6+ Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR6PC - RNG Statistical Check Run Length 6+ Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Run Length 6+ Counters Register is a read-only
 * register used to read the final Run Length 6+ counts after entropy generation.
 * These counters start with the value in SCR6PL[RUN6P_MAX]. The R6P_1_CT decrements
 * each time six or more consecutive ones are sampled (preceded by a zero and
 * followed by a zero). The R6P_0_CT decrements each time six or more consecutive
 * zeroes are sampled (preceded by a one and followed by a one). Note that this
 * offset (0xBASE_0638) is used as SCR6PL if MCTL[PRGM] is 1. If MCTL[PRGM] is 0,
 * this offset is used as SCR6PC readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR6PC register
 */
/*@{*/
#define TRNG_RD_SCR6PC(base)     (TRNG_SCR6PC_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR6PC bitfields
 */

/*!
 * @name Register TRNG_SCR6PC, field R6P_0_CT[10:0] (RO)
 *
 * Runs of Zero, Length 6+ Count. Reads the final Runs of Ones, length 6+ count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR6PC_R6P_0_CT field. */
#define TRNG_RD_SCR6PC_R6P_0_CT(base) ((TRNG_SCR6PC_REG(base) & TRNG_SCR6PC_R6P_0_CT_MASK) >> TRNG_SCR6PC_R6P_0_CT_SHIFT)
#define TRNG_BRD_SCR6PC_R6P_0_CT(base) (BME_UBFX32(&TRNG_SCR6PC_REG(base), TRNG_SCR6PC_R6P_0_CT_SHIFT, TRNG_SCR6PC_R6P_0_CT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SCR6PC, field R6P_1_CT[26:16] (RO)
 *
 * Runs of One, Length 6+ Count. Reads the final Runs of Ones, length 6+ count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR6PC_R6P_1_CT field. */
#define TRNG_RD_SCR6PC_R6P_1_CT(base) ((TRNG_SCR6PC_REG(base) & TRNG_SCR6PC_R6P_1_CT_MASK) >> TRNG_SCR6PC_R6P_1_CT_SHIFT)
#define TRNG_BRD_SCR6PC_R6P_1_CT(base) (BME_UBFX32(&TRNG_SCR6PC_REG(base), TRNG_SCR6PC_R6P_1_CT_SHIFT, TRNG_SCR6PC_R6P_1_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_STATUS - RNG Status Register
 ******************************************************************************/

/*!
 * @brief TRNG_STATUS - RNG Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Various statistical tests are run as a normal part of the TRNG's entropy
 * generation process. The least-significant 16 bits of the STATUS register reflect
 * the result of each of these tests. The status of these bits will be valid when
 * the TRNG has finished its entropy generation process. Software can determine
 * when this occurs by polling the ENT_VAL bit in the RNG Miscellaneous Control
 * Register. Note that there is a very small probability that a statistical test
 * will fail even though the TRNG is operating properly. If this happens the TRNG
 * will automatically retry the entire entropy generation process, including
 * running all the statistical tests. The value in RETRY_CT is decremented each time
 * an entropy generation retry occurs. If a statistical check fails when the retry
 * count is nonzero, a retry is initiated. But if a statistical check fails when
 * the retry count is zero, an error is generated by the RNG. By default
 * RETRY_CT is initialized to 1, but software can increase the retry count by writing to
 * the RTY_CT field in the SCMISC register. All 0s will be returned if this
 * register address is read while the RNG is in Program Mode (see PRGM field in MCTL
 * register. If this register is read while the RNG is in Run Mode the value
 * returned will be formatted as follows.
 */
/*!
 * @name Constants and macros for entire TRNG_STATUS register
 */
/*@{*/
#define TRNG_RD_STATUS(base)     (TRNG_STATUS_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_STATUS bitfields
 */

/*!
 * @name Register TRNG_STATUS, field TF1BR0[0] (RO)
 *
 * Test Fail, 1-Bit Run, Sampling 0s. If TF1BR0=1, the 1-Bit Run, Sampling 0s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF1BR0 field. */
#define TRNG_RD_STATUS_TF1BR0(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF1BR0_MASK) >> TRNG_STATUS_TF1BR0_SHIFT)
#define TRNG_BRD_STATUS_TF1BR0(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF1BR0_SHIFT, TRNG_STATUS_TF1BR0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF1BR1[1] (RO)
 *
 * Test Fail, 1-Bit Run, Sampling 1s. If TF1BR1=1, the 1-Bit Run, Sampling 1s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF1BR1 field. */
#define TRNG_RD_STATUS_TF1BR1(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF1BR1_MASK) >> TRNG_STATUS_TF1BR1_SHIFT)
#define TRNG_BRD_STATUS_TF1BR1(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF1BR1_SHIFT, TRNG_STATUS_TF1BR1_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF2BR0[2] (RO)
 *
 * Test Fail, 2-Bit Run, Sampling 0s. If TF2BR0=1, the 2-Bit Run, Sampling 0s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF2BR0 field. */
#define TRNG_RD_STATUS_TF2BR0(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF2BR0_MASK) >> TRNG_STATUS_TF2BR0_SHIFT)
#define TRNG_BRD_STATUS_TF2BR0(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF2BR0_SHIFT, TRNG_STATUS_TF2BR0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF2BR1[3] (RO)
 *
 * Test Fail, 2-Bit Run, Sampling 1s. If TF2BR1=1, the 2-Bit Run, Sampling 1s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF2BR1 field. */
#define TRNG_RD_STATUS_TF2BR1(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF2BR1_MASK) >> TRNG_STATUS_TF2BR1_SHIFT)
#define TRNG_BRD_STATUS_TF2BR1(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF2BR1_SHIFT, TRNG_STATUS_TF2BR1_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF3BR0[4] (RO)
 *
 * Test Fail, 3-Bit Run, Sampling 0s. If TF3BR0=1, the 3-Bit Run, Sampling 0s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF3BR0 field. */
#define TRNG_RD_STATUS_TF3BR0(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF3BR0_MASK) >> TRNG_STATUS_TF3BR0_SHIFT)
#define TRNG_BRD_STATUS_TF3BR0(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF3BR0_SHIFT, TRNG_STATUS_TF3BR0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF3BR1[5] (RO)
 *
 * Test Fail, 3-Bit Run, Sampling 1s. If TF3BR1=1, the 3-Bit Run, Sampling 1s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF3BR1 field. */
#define TRNG_RD_STATUS_TF3BR1(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF3BR1_MASK) >> TRNG_STATUS_TF3BR1_SHIFT)
#define TRNG_BRD_STATUS_TF3BR1(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF3BR1_SHIFT, TRNG_STATUS_TF3BR1_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF4BR0[6] (RO)
 *
 * Test Fail, 4-Bit Run, Sampling 0s. If TF4BR0=1, the 4-Bit Run, Sampling 0s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF4BR0 field. */
#define TRNG_RD_STATUS_TF4BR0(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF4BR0_MASK) >> TRNG_STATUS_TF4BR0_SHIFT)
#define TRNG_BRD_STATUS_TF4BR0(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF4BR0_SHIFT, TRNG_STATUS_TF4BR0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF4BR1[7] (RO)
 *
 * Test Fail, 4-Bit Run, Sampling 1s. If TF4BR1=1, the 4-Bit Run, Sampling 1s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF4BR1 field. */
#define TRNG_RD_STATUS_TF4BR1(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF4BR1_MASK) >> TRNG_STATUS_TF4BR1_SHIFT)
#define TRNG_BRD_STATUS_TF4BR1(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF4BR1_SHIFT, TRNG_STATUS_TF4BR1_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF5BR0[8] (RO)
 *
 * Test Fail, 5-Bit Run, Sampling 0s. If TF5BR0=1, the 5-Bit Run, Sampling 0s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF5BR0 field. */
#define TRNG_RD_STATUS_TF5BR0(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF5BR0_MASK) >> TRNG_STATUS_TF5BR0_SHIFT)
#define TRNG_BRD_STATUS_TF5BR0(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF5BR0_SHIFT, TRNG_STATUS_TF5BR0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF5BR1[9] (RO)
 *
 * Test Fail, 5-Bit Run, Sampling 1s. If TF5BR1=1, the 5-Bit Run, Sampling 1s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF5BR1 field. */
#define TRNG_RD_STATUS_TF5BR1(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF5BR1_MASK) >> TRNG_STATUS_TF5BR1_SHIFT)
#define TRNG_BRD_STATUS_TF5BR1(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF5BR1_SHIFT, TRNG_STATUS_TF5BR1_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF6PBR0[10] (RO)
 *
 * Test Fail, 6 Plus Bit Run, Sampling 0s. If TF6PBR0=1, the 6 Plus Bit Run,
 * Sampling 0s Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF6PBR0 field. */
#define TRNG_RD_STATUS_TF6PBR0(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF6PBR0_MASK) >> TRNG_STATUS_TF6PBR0_SHIFT)
#define TRNG_BRD_STATUS_TF6PBR0(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF6PBR0_SHIFT, TRNG_STATUS_TF6PBR0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF6PBR1[11] (RO)
 *
 * Test Fail, 6 Plus Bit Run, Sampling 1s. If TF6PBR1=1, the 6 Plus Bit Run,
 * Sampling 1s Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF6PBR1 field. */
#define TRNG_RD_STATUS_TF6PBR1(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF6PBR1_MASK) >> TRNG_STATUS_TF6PBR1_SHIFT)
#define TRNG_BRD_STATUS_TF6PBR1(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF6PBR1_SHIFT, TRNG_STATUS_TF6PBR1_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TFSB[12] (RO)
 *
 * Test Fail, Sparse Bit. If TFSB=1, the Sparse Bit Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TFSB field. */
#define TRNG_RD_STATUS_TFSB(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TFSB_MASK) >> TRNG_STATUS_TFSB_SHIFT)
#define TRNG_BRD_STATUS_TFSB(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TFSB_SHIFT, TRNG_STATUS_TFSB_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TFLR[13] (RO)
 *
 * Test Fail, Long Run. If TFLR=1, the Long Run Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TFLR field. */
#define TRNG_RD_STATUS_TFLR(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TFLR_MASK) >> TRNG_STATUS_TFLR_SHIFT)
#define TRNG_BRD_STATUS_TFLR(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TFLR_SHIFT, TRNG_STATUS_TFLR_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TFP[14] (RO)
 *
 * Test Fail, Poker. If TFP=1, the Poker Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TFP field. */
#define TRNG_RD_STATUS_TFP(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TFP_MASK) >> TRNG_STATUS_TFP_SHIFT)
#define TRNG_BRD_STATUS_TFP(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TFP_SHIFT, TRNG_STATUS_TFP_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TFMB[15] (RO)
 *
 * Test Fail, Mono Bit. If TFMB=1, the Mono Bit Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TFMB field. */
#define TRNG_RD_STATUS_TFMB(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TFMB_MASK) >> TRNG_STATUS_TFMB_SHIFT)
#define TRNG_BRD_STATUS_TFMB(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TFMB_SHIFT, TRNG_STATUS_TFMB_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field RETRY_CT[19:16] (RO)
 *
 * RETRY COUNT. This represents the current number of entropy generation retries
 * left before a statistical text failure will cause the RNG to generate an
 * error condition.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_RETRY_CT field. */
#define TRNG_RD_STATUS_RETRY_CT(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_RETRY_CT_MASK) >> TRNG_STATUS_RETRY_CT_SHIFT)
#define TRNG_BRD_STATUS_RETRY_CT(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_RETRY_CT_SHIFT, TRNG_STATUS_RETRY_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_ENT - RNG TRNG Entropy Read Register
 ******************************************************************************/

/*!
 * @brief TRNG_ENT - RNG TRNG Entropy Read Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG TRNG can be programmed to generate an entropy value that is readable
 * via the SkyBlue bus. To do this, set the MCTL[TRNG_ACC] bit to 1. Once the
 * entropy value has been generated, the MCTL[ENT_VAL] bit will be set to 1. At this
 * point, ENT0 through ENT15 may be read to retrieve the 512-bit entropy value.
 * Note that once ENT15 is read, the entropy value will be cleared and a new
 * value will begin generation, so it is important that ENT15 be read last. These
 * registers are readable only when MCTL[PRGM] = 0 (Run Mode), MCTL[TRNG_ACC] = 1
 * (TRNG access mode) and MCTL[ENT_VAL] = 1, otherwise zeroes will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_ENT register
 */
/*@{*/
#define TRNG_RD_ENT(base, index) (TRNG_ENT_REG(base, index))
/*@}*/

/*******************************************************************************
 * TRNG_PKRCNT10 - RNG Statistical Check Poker Count 1 and 0 Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRCNT10 - RNG Statistical Check Poker Count 1 and 0 Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count 1 and 0 Register is a read-only
 * register used to read the final Poker test counts of 1h and 0h patterns. The Poker 0h
 * Count increments each time a nibble of sample data is found to be 0h. The
 * Poker 1h Count increments each time a nibble of sample data is found to be 1h.
 * Note that this register is readable only if MCTL[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRCNT10 register
 */
/*@{*/
#define TRNG_RD_PKRCNT10(base)   (TRNG_PKRCNT10_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRCNT10 bitfields
 */

/*!
 * @name Register TRNG_PKRCNT10, field PKR_0_CT[15:0] (RO)
 *
 * Poker 0h Count. Total number of nibbles of sample data which were found to be
 * 0h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT10_PKR_0_CT field. */
#define TRNG_RD_PKRCNT10_PKR_0_CT(base) ((TRNG_PKRCNT10_REG(base) & TRNG_PKRCNT10_PKR_0_CT_MASK) >> TRNG_PKRCNT10_PKR_0_CT_SHIFT)
#define TRNG_BRD_PKRCNT10_PKR_0_CT(base) (BME_UBFX32(&TRNG_PKRCNT10_REG(base), TRNG_PKRCNT10_PKR_0_CT_SHIFT, TRNG_PKRCNT10_PKR_0_CT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_PKRCNT10, field PKR_1_CT[31:16] (RO)
 *
 * Poker 1h Count. Total number of nibbles of sample data which were found to be
 * 1h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT10_PKR_1_CT field. */
#define TRNG_RD_PKRCNT10_PKR_1_CT(base) ((TRNG_PKRCNT10_REG(base) & TRNG_PKRCNT10_PKR_1_CT_MASK) >> TRNG_PKRCNT10_PKR_1_CT_SHIFT)
#define TRNG_BRD_PKRCNT10_PKR_1_CT(base) (BME_UBFX32(&TRNG_PKRCNT10_REG(base), TRNG_PKRCNT10_PKR_1_CT_SHIFT, TRNG_PKRCNT10_PKR_1_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_PKRCNT32 - RNG Statistical Check Poker Count 3 and 2 Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRCNT32 - RNG Statistical Check Poker Count 3 and 2 Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count 3 and 2 Register is a read-only
 * register used to read the final Poker test counts of 3h and 2h patterns. The Poker 2h
 * Count increments each time a nibble of sample data is found to be 2h. The
 * Poker 3h Count increments each time a nibble of sample data is found to be 3h.
 * Note that this register is readable only if MCTL[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRCNT32 register
 */
/*@{*/
#define TRNG_RD_PKRCNT32(base)   (TRNG_PKRCNT32_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRCNT32 bitfields
 */

/*!
 * @name Register TRNG_PKRCNT32, field PKR_2_CT[15:0] (RO)
 *
 * Poker 2h Count. Total number of nibbles of sample data which were found to be
 * 2h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT32_PKR_2_CT field. */
#define TRNG_RD_PKRCNT32_PKR_2_CT(base) ((TRNG_PKRCNT32_REG(base) & TRNG_PKRCNT32_PKR_2_CT_MASK) >> TRNG_PKRCNT32_PKR_2_CT_SHIFT)
#define TRNG_BRD_PKRCNT32_PKR_2_CT(base) (BME_UBFX32(&TRNG_PKRCNT32_REG(base), TRNG_PKRCNT32_PKR_2_CT_SHIFT, TRNG_PKRCNT32_PKR_2_CT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_PKRCNT32, field PKR_3_CT[31:16] (RO)
 *
 * Poker 3h Count. Total number of nibbles of sample data which were found to be
 * 3h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT32_PKR_3_CT field. */
#define TRNG_RD_PKRCNT32_PKR_3_CT(base) ((TRNG_PKRCNT32_REG(base) & TRNG_PKRCNT32_PKR_3_CT_MASK) >> TRNG_PKRCNT32_PKR_3_CT_SHIFT)
#define TRNG_BRD_PKRCNT32_PKR_3_CT(base) (BME_UBFX32(&TRNG_PKRCNT32_REG(base), TRNG_PKRCNT32_PKR_3_CT_SHIFT, TRNG_PKRCNT32_PKR_3_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_PKRCNT54 - RNG Statistical Check Poker Count 5 and 4 Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRCNT54 - RNG Statistical Check Poker Count 5 and 4 Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count 5 and 4 Register is a read-only
 * register used to read the final Poker test counts of 5h and 4h patterns. The Poker 4h
 * Count increments each time a nibble of sample data is found to be 4h. The
 * Poker 5h Count increments each time a nibble of sample data is found to be 5h.
 * Note that this register is readable only if MCTL[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRCNT54 register
 */
/*@{*/
#define TRNG_RD_PKRCNT54(base)   (TRNG_PKRCNT54_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRCNT54 bitfields
 */

/*!
 * @name Register TRNG_PKRCNT54, field PKR_4_CT[15:0] (RO)
 *
 * Poker 4h Count. Total number of nibbles of sample data which were found to be
 * 4h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT54_PKR_4_CT field. */
#define TRNG_RD_PKRCNT54_PKR_4_CT(base) ((TRNG_PKRCNT54_REG(base) & TRNG_PKRCNT54_PKR_4_CT_MASK) >> TRNG_PKRCNT54_PKR_4_CT_SHIFT)
#define TRNG_BRD_PKRCNT54_PKR_4_CT(base) (BME_UBFX32(&TRNG_PKRCNT54_REG(base), TRNG_PKRCNT54_PKR_4_CT_SHIFT, TRNG_PKRCNT54_PKR_4_CT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_PKRCNT54, field PKR_5_CT[31:16] (RO)
 *
 * Poker 5h Count. Total number of nibbles of sample data which were found to be
 * 5h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT54_PKR_5_CT field. */
#define TRNG_RD_PKRCNT54_PKR_5_CT(base) ((TRNG_PKRCNT54_REG(base) & TRNG_PKRCNT54_PKR_5_CT_MASK) >> TRNG_PKRCNT54_PKR_5_CT_SHIFT)
#define TRNG_BRD_PKRCNT54_PKR_5_CT(base) (BME_UBFX32(&TRNG_PKRCNT54_REG(base), TRNG_PKRCNT54_PKR_5_CT_SHIFT, TRNG_PKRCNT54_PKR_5_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_PKRCNT76 - RNG Statistical Check Poker Count 7 and 6 Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRCNT76 - RNG Statistical Check Poker Count 7 and 6 Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count 7 and 6 Register is a read-only
 * register used to read the final Poker test counts of 7h and 6h patterns. The Poker 6h
 * Count increments each time a nibble of sample data is found to be 6h. The
 * Poker 7h Count increments each time a nibble of sample data is found to be 7h.
 * Note that this register is readable only if MCTL[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRCNT76 register
 */
/*@{*/
#define TRNG_RD_PKRCNT76(base)   (TRNG_PKRCNT76_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRCNT76 bitfields
 */

/*!
 * @name Register TRNG_PKRCNT76, field PKR_6_CT[15:0] (RO)
 *
 * Poker 6h Count. Total number of nibbles of sample data which were found to be
 * 6h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT76_PKR_6_CT field. */
#define TRNG_RD_PKRCNT76_PKR_6_CT(base) ((TRNG_PKRCNT76_REG(base) & TRNG_PKRCNT76_PKR_6_CT_MASK) >> TRNG_PKRCNT76_PKR_6_CT_SHIFT)
#define TRNG_BRD_PKRCNT76_PKR_6_CT(base) (BME_UBFX32(&TRNG_PKRCNT76_REG(base), TRNG_PKRCNT76_PKR_6_CT_SHIFT, TRNG_PKRCNT76_PKR_6_CT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_PKRCNT76, field PKR_7_CT[31:16] (RO)
 *
 * Poker 7h Count. Total number of nibbles of sample data which were found to be
 * 7h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT76_PKR_7_CT field. */
#define TRNG_RD_PKRCNT76_PKR_7_CT(base) ((TRNG_PKRCNT76_REG(base) & TRNG_PKRCNT76_PKR_7_CT_MASK) >> TRNG_PKRCNT76_PKR_7_CT_SHIFT)
#define TRNG_BRD_PKRCNT76_PKR_7_CT(base) (BME_UBFX32(&TRNG_PKRCNT76_REG(base), TRNG_PKRCNT76_PKR_7_CT_SHIFT, TRNG_PKRCNT76_PKR_7_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_PKRCNT98 - RNG Statistical Check Poker Count 9 and 8 Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRCNT98 - RNG Statistical Check Poker Count 9 and 8 Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count 9 and 8 Register is a read-only
 * register used to read the final Poker test counts of 9h and 8h patterns. The Poker 8h
 * Count increments each time a nibble of sample data is found to be 8h. The
 * Poker 9h Count increments each time a nibble of sample data is found to be 9h.
 * Note that this register is readable only if MCTL[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRCNT98 register
 */
/*@{*/
#define TRNG_RD_PKRCNT98(base)   (TRNG_PKRCNT98_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRCNT98 bitfields
 */

/*!
 * @name Register TRNG_PKRCNT98, field PKR_8_CT[15:0] (RO)
 *
 * Poker 8h Count. Total number of nibbles of sample data which were found to be
 * 8h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT98_PKR_8_CT field. */
#define TRNG_RD_PKRCNT98_PKR_8_CT(base) ((TRNG_PKRCNT98_REG(base) & TRNG_PKRCNT98_PKR_8_CT_MASK) >> TRNG_PKRCNT98_PKR_8_CT_SHIFT)
#define TRNG_BRD_PKRCNT98_PKR_8_CT(base) (BME_UBFX32(&TRNG_PKRCNT98_REG(base), TRNG_PKRCNT98_PKR_8_CT_SHIFT, TRNG_PKRCNT98_PKR_8_CT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_PKRCNT98, field PKR_9_CT[31:16] (RO)
 *
 * Poker 9h Count. Total number of nibbles of sample data which were found to be
 * 9h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT98_PKR_9_CT field. */
#define TRNG_RD_PKRCNT98_PKR_9_CT(base) ((TRNG_PKRCNT98_REG(base) & TRNG_PKRCNT98_PKR_9_CT_MASK) >> TRNG_PKRCNT98_PKR_9_CT_SHIFT)
#define TRNG_BRD_PKRCNT98_PKR_9_CT(base) (BME_UBFX32(&TRNG_PKRCNT98_REG(base), TRNG_PKRCNT98_PKR_9_CT_SHIFT, TRNG_PKRCNT98_PKR_9_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_PKRCNTBA - RNG Statistical Check Poker Count B and A Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRCNTBA - RNG Statistical Check Poker Count B and A Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count B and A Register is a read-only
 * register used to read the final Poker test counts of Bh and Ah patterns. The Poker Ah
 * Count increments each time a nibble of sample data is found to be Ah. The
 * Poker Bh Count increments each time a nibble of sample data is found to be Bh.
 * Note that this register is readable only if MCTL[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRCNTBA register
 */
/*@{*/
#define TRNG_RD_PKRCNTBA(base)   (TRNG_PKRCNTBA_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRCNTBA bitfields
 */

/*!
 * @name Register TRNG_PKRCNTBA, field PKR_A_CT[15:0] (RO)
 *
 * Poker Ah Count. Total number of nibbles of sample data which were found to be
 * Ah. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNTBA_PKR_A_CT field. */
#define TRNG_RD_PKRCNTBA_PKR_A_CT(base) ((TRNG_PKRCNTBA_REG(base) & TRNG_PKRCNTBA_PKR_A_CT_MASK) >> TRNG_PKRCNTBA_PKR_A_CT_SHIFT)
#define TRNG_BRD_PKRCNTBA_PKR_A_CT(base) (BME_UBFX32(&TRNG_PKRCNTBA_REG(base), TRNG_PKRCNTBA_PKR_A_CT_SHIFT, TRNG_PKRCNTBA_PKR_A_CT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_PKRCNTBA, field PKR_B_CT[31:16] (RO)
 *
 * Poker Bh Count. Total number of nibbles of sample data which were found to be
 * Bh. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNTBA_PKR_B_CT field. */
#define TRNG_RD_PKRCNTBA_PKR_B_CT(base) ((TRNG_PKRCNTBA_REG(base) & TRNG_PKRCNTBA_PKR_B_CT_MASK) >> TRNG_PKRCNTBA_PKR_B_CT_SHIFT)
#define TRNG_BRD_PKRCNTBA_PKR_B_CT(base) (BME_UBFX32(&TRNG_PKRCNTBA_REG(base), TRNG_PKRCNTBA_PKR_B_CT_SHIFT, TRNG_PKRCNTBA_PKR_B_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_PKRCNTDC - RNG Statistical Check Poker Count D and C Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRCNTDC - RNG Statistical Check Poker Count D and C Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count D and C Register is a read-only
 * register used to read the final Poker test counts of Dh and Ch patterns. The Poker Ch
 * Count increments each time a nibble of sample data is found to be Ch. The
 * Poker Dh Count increments each time a nibble of sample data is found to be Dh.
 * Note that this register is readable only if MCTL[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRCNTDC register
 */
/*@{*/
#define TRNG_RD_PKRCNTDC(base)   (TRNG_PKRCNTDC_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRCNTDC bitfields
 */

/*!
 * @name Register TRNG_PKRCNTDC, field PKR_C_CT[15:0] (RO)
 *
 * Poker Ch Count. Total number of nibbles of sample data which were found to be
 * Ch. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNTDC_PKR_C_CT field. */
#define TRNG_RD_PKRCNTDC_PKR_C_CT(base) ((TRNG_PKRCNTDC_REG(base) & TRNG_PKRCNTDC_PKR_C_CT_MASK) >> TRNG_PKRCNTDC_PKR_C_CT_SHIFT)
#define TRNG_BRD_PKRCNTDC_PKR_C_CT(base) (BME_UBFX32(&TRNG_PKRCNTDC_REG(base), TRNG_PKRCNTDC_PKR_C_CT_SHIFT, TRNG_PKRCNTDC_PKR_C_CT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_PKRCNTDC, field PKR_D_CT[31:16] (RO)
 *
 * Poker Dh Count. Total number of nibbles of sample data which were found to be
 * Dh. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNTDC_PKR_D_CT field. */
#define TRNG_RD_PKRCNTDC_PKR_D_CT(base) ((TRNG_PKRCNTDC_REG(base) & TRNG_PKRCNTDC_PKR_D_CT_MASK) >> TRNG_PKRCNTDC_PKR_D_CT_SHIFT)
#define TRNG_BRD_PKRCNTDC_PKR_D_CT(base) (BME_UBFX32(&TRNG_PKRCNTDC_REG(base), TRNG_PKRCNTDC_PKR_D_CT_SHIFT, TRNG_PKRCNTDC_PKR_D_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_PKRCNTFE - RNG Statistical Check Poker Count F and E Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRCNTFE - RNG Statistical Check Poker Count F and E Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count F and E Register is a read-only
 * register used to read the final Poker test counts of Fh and Eh patterns. The Poker Eh
 * Count increments each time a nibble of sample data is found to be Eh. The
 * Poker Fh Count increments each time a nibble of sample data is found to be Fh.
 * Note that this register is readable only if MCTL[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRCNTFE register
 */
/*@{*/
#define TRNG_RD_PKRCNTFE(base)   (TRNG_PKRCNTFE_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRCNTFE bitfields
 */

/*!
 * @name Register TRNG_PKRCNTFE, field PKR_E_CT[15:0] (RO)
 *
 * Poker Eh Count. Total number of nibbles of sample data which were found to be
 * Eh. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNTFE_PKR_E_CT field. */
#define TRNG_RD_PKRCNTFE_PKR_E_CT(base) ((TRNG_PKRCNTFE_REG(base) & TRNG_PKRCNTFE_PKR_E_CT_MASK) >> TRNG_PKRCNTFE_PKR_E_CT_SHIFT)
#define TRNG_BRD_PKRCNTFE_PKR_E_CT(base) (BME_UBFX32(&TRNG_PKRCNTFE_REG(base), TRNG_PKRCNTFE_PKR_E_CT_SHIFT, TRNG_PKRCNTFE_PKR_E_CT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_PKRCNTFE, field PKR_F_CT[31:16] (RO)
 *
 * Poker Fh Count. Total number of nibbles of sample data which were found to be
 * Fh. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNTFE_PKR_F_CT field. */
#define TRNG_RD_PKRCNTFE_PKR_F_CT(base) ((TRNG_PKRCNTFE_REG(base) & TRNG_PKRCNTFE_PKR_F_CT_MASK) >> TRNG_PKRCNTFE_PKR_F_CT_SHIFT)
#define TRNG_BRD_PKRCNTFE_PKR_F_CT(base) (BME_UBFX32(&TRNG_PKRCNTFE_REG(base), TRNG_PKRCNTFE_PKR_F_CT_SHIFT, TRNG_PKRCNTFE_PKR_F_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SEC_CFG - RNG Security Configuration Register
 ******************************************************************************/

/*!
 * @brief TRNG_SEC_CFG - RNG Security Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Security Configuration Register is a read/write register used to
 * control the test mode, programmability and state modes of the RNG. Many bits are
 * place holders for this version. More configurability will be added here. Clears
 * on asynchronous reset. For SA-TRNG releases before 2014/July/01, offsets 0xA0
 * to 0xAC used to be 0xB0 to 0xBC respectively. So, update newer tests that use
 * these registers, if hard coded.
 */
/*!
 * @name Constants and macros for entire TRNG_SEC_CFG register
 */
/*@{*/
#define TRNG_RD_SEC_CFG(base)    (TRNG_SEC_CFG_REG(base))
#define TRNG_WR_SEC_CFG(base, value) (TRNG_SEC_CFG_REG(base) = (value))
#define TRNG_RMW_SEC_CFG(base, mask, value) (TRNG_WR_SEC_CFG(base, (TRNG_RD_SEC_CFG(base) & ~(mask)) | (value)))
#define TRNG_SET_SEC_CFG(base, value) (BME_OR32(&TRNG_SEC_CFG_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SEC_CFG(base, value) (BME_AND32(&TRNG_SEC_CFG_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SEC_CFG(base, value) (BME_XOR32(&TRNG_SEC_CFG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SEC_CFG bitfields
 */

/*!
 * @name Register TRNG_SEC_CFG, field SH0[0] (RW)
 *
 * Reserved. DRNG specific, not applicable to this version.
 *
 * Values:
 * - 0b0 - See DRNG version.
 * - 0b1 - See DRNG version.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SEC_CFG_SH0 field. */
#define TRNG_RD_SEC_CFG_SH0(base) ((TRNG_SEC_CFG_REG(base) & TRNG_SEC_CFG_SH0_MASK) >> TRNG_SEC_CFG_SH0_SHIFT)
#define TRNG_BRD_SEC_CFG_SH0(base) (BME_UBFX32(&TRNG_SEC_CFG_REG(base), TRNG_SEC_CFG_SH0_SHIFT, TRNG_SEC_CFG_SH0_WIDTH))

/*! @brief Set the SH0 field to a new value. */
#define TRNG_WR_SEC_CFG_SH0(base, value) (TRNG_RMW_SEC_CFG(base, TRNG_SEC_CFG_SH0_MASK, TRNG_SEC_CFG_SH0(value)))
#define TRNG_BWR_SEC_CFG_SH0(base, value) (BME_BFI32(&TRNG_SEC_CFG_REG(base), ((uint32_t)(value) << TRNG_SEC_CFG_SH0_SHIFT), TRNG_SEC_CFG_SH0_SHIFT, TRNG_SEC_CFG_SH0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SEC_CFG, field NO_PRGM[1] (RW)
 *
 * If set the TRNG registers cannot be programmed. That is, regardless of the
 * TRNG access mode in the SA-TRNG Miscellaneous Control Register.
 *
 * Values:
 * - 0b0 - Programability of registers controlled only by the RNG Miscellaneous
 *     Control Register's access mode bit.
 * - 0b1 - Overides RNG Miscellaneous Control Register access mode and prevents
 *     TRNG register programming.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SEC_CFG_NO_PRGM field. */
#define TRNG_RD_SEC_CFG_NO_PRGM(base) ((TRNG_SEC_CFG_REG(base) & TRNG_SEC_CFG_NO_PRGM_MASK) >> TRNG_SEC_CFG_NO_PRGM_SHIFT)
#define TRNG_BRD_SEC_CFG_NO_PRGM(base) (BME_UBFX32(&TRNG_SEC_CFG_REG(base), TRNG_SEC_CFG_NO_PRGM_SHIFT, TRNG_SEC_CFG_NO_PRGM_WIDTH))

/*! @brief Set the NO_PRGM field to a new value. */
#define TRNG_WR_SEC_CFG_NO_PRGM(base, value) (TRNG_RMW_SEC_CFG(base, TRNG_SEC_CFG_NO_PRGM_MASK, TRNG_SEC_CFG_NO_PRGM(value)))
#define TRNG_BWR_SEC_CFG_NO_PRGM(base, value) (BME_BFI32(&TRNG_SEC_CFG_REG(base), ((uint32_t)(value) << TRNG_SEC_CFG_NO_PRGM_SHIFT), TRNG_SEC_CFG_NO_PRGM_SHIFT, TRNG_SEC_CFG_NO_PRGM_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SEC_CFG, field SK_VAL[2] (RW)
 *
 * Reserved. DRNG-specific, not applicable to this version.
 *
 * Values:
 * - 0b0 - See DRNG version.
 * - 0b1 - See DRNG version.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SEC_CFG_SK_VAL field. */
#define TRNG_RD_SEC_CFG_SK_VAL(base) ((TRNG_SEC_CFG_REG(base) & TRNG_SEC_CFG_SK_VAL_MASK) >> TRNG_SEC_CFG_SK_VAL_SHIFT)
#define TRNG_BRD_SEC_CFG_SK_VAL(base) (BME_UBFX32(&TRNG_SEC_CFG_REG(base), TRNG_SEC_CFG_SK_VAL_SHIFT, TRNG_SEC_CFG_SK_VAL_WIDTH))

/*! @brief Set the SK_VAL field to a new value. */
#define TRNG_WR_SEC_CFG_SK_VAL(base, value) (TRNG_RMW_SEC_CFG(base, TRNG_SEC_CFG_SK_VAL_MASK, TRNG_SEC_CFG_SK_VAL(value)))
#define TRNG_BWR_SEC_CFG_SK_VAL(base, value) (BME_BFI32(&TRNG_SEC_CFG_REG(base), ((uint32_t)(value) << TRNG_SEC_CFG_SK_VAL_SHIFT), TRNG_SEC_CFG_SK_VAL_SHIFT, TRNG_SEC_CFG_SK_VAL_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_INT_CTRL - RNG Interrupt Control Register
 ******************************************************************************/

/*!
 * @brief TRNG_INT_CTRL - RNG Interrupt Control Register (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * The RNG Interrupt Control Register is a read/write register used to control
 * the status for the (currently) three important interrupts that are generated by
 * the TRNG. See INT_STATUS register description above. Each interrupt can be
 * cleared by de-asserting the corresponding bit in the INT_CTRL register. Only a
 * new interrupt will reassert the corresponding bit in the status register. Even
 * if the interrupt is cleared or masked, interrupt status information can be
 * read from the MCTL register.
 */
/*!
 * @name Constants and macros for entire TRNG_INT_CTRL register
 */
/*@{*/
#define TRNG_RD_INT_CTRL(base)   (TRNG_INT_CTRL_REG(base))
#define TRNG_WR_INT_CTRL(base, value) (TRNG_INT_CTRL_REG(base) = (value))
#define TRNG_RMW_INT_CTRL(base, mask, value) (TRNG_WR_INT_CTRL(base, (TRNG_RD_INT_CTRL(base) & ~(mask)) | (value)))
#define TRNG_SET_INT_CTRL(base, value) (BME_OR32(&TRNG_INT_CTRL_REG(base), (uint32_t)(value)))
#define TRNG_CLR_INT_CTRL(base, value) (BME_AND32(&TRNG_INT_CTRL_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_INT_CTRL(base, value) (BME_XOR32(&TRNG_INT_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_INT_CTRL bitfields
 */

/*!
 * @name Register TRNG_INT_CTRL, field HW_ERR[0] (RW)
 *
 * Bit position that can be cleared if corresponding bit of INT_STATUS has been
 * asserted.
 *
 * Values:
 * - 0b0 - Corresponding bit of INT_STATUS cleared.
 * - 0b1 - Corresponding bit of INT_STATUS active.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_CTRL_HW_ERR field. */
#define TRNG_RD_INT_CTRL_HW_ERR(base) ((TRNG_INT_CTRL_REG(base) & TRNG_INT_CTRL_HW_ERR_MASK) >> TRNG_INT_CTRL_HW_ERR_SHIFT)
#define TRNG_BRD_INT_CTRL_HW_ERR(base) (BME_UBFX32(&TRNG_INT_CTRL_REG(base), TRNG_INT_CTRL_HW_ERR_SHIFT, TRNG_INT_CTRL_HW_ERR_WIDTH))

/*! @brief Set the HW_ERR field to a new value. */
#define TRNG_WR_INT_CTRL_HW_ERR(base, value) (TRNG_RMW_INT_CTRL(base, TRNG_INT_CTRL_HW_ERR_MASK, TRNG_INT_CTRL_HW_ERR(value)))
#define TRNG_BWR_INT_CTRL_HW_ERR(base, value) (BME_BFI32(&TRNG_INT_CTRL_REG(base), ((uint32_t)(value) << TRNG_INT_CTRL_HW_ERR_SHIFT), TRNG_INT_CTRL_HW_ERR_SHIFT, TRNG_INT_CTRL_HW_ERR_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_INT_CTRL, field ENT_VAL[1] (RW)
 *
 * Same behavior as bit 0 above.
 *
 * Values:
 * - 0b0 - Same behavior as bit 0 above.
 * - 0b1 - Same behavior as bit 0 above.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_CTRL_ENT_VAL field. */
#define TRNG_RD_INT_CTRL_ENT_VAL(base) ((TRNG_INT_CTRL_REG(base) & TRNG_INT_CTRL_ENT_VAL_MASK) >> TRNG_INT_CTRL_ENT_VAL_SHIFT)
#define TRNG_BRD_INT_CTRL_ENT_VAL(base) (BME_UBFX32(&TRNG_INT_CTRL_REG(base), TRNG_INT_CTRL_ENT_VAL_SHIFT, TRNG_INT_CTRL_ENT_VAL_WIDTH))

/*! @brief Set the ENT_VAL field to a new value. */
#define TRNG_WR_INT_CTRL_ENT_VAL(base, value) (TRNG_RMW_INT_CTRL(base, TRNG_INT_CTRL_ENT_VAL_MASK, TRNG_INT_CTRL_ENT_VAL(value)))
#define TRNG_BWR_INT_CTRL_ENT_VAL(base, value) (BME_BFI32(&TRNG_INT_CTRL_REG(base), ((uint32_t)(value) << TRNG_INT_CTRL_ENT_VAL_SHIFT), TRNG_INT_CTRL_ENT_VAL_SHIFT, TRNG_INT_CTRL_ENT_VAL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_INT_CTRL, field FRQ_CT_FAIL[2] (RW)
 *
 * Same behavior as bit 0 above.
 *
 * Values:
 * - 0b0 - Same behavior as bit 0 above.
 * - 0b1 - Same behavior as bit 0 above.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_CTRL_FRQ_CT_FAIL field. */
#define TRNG_RD_INT_CTRL_FRQ_CT_FAIL(base) ((TRNG_INT_CTRL_REG(base) & TRNG_INT_CTRL_FRQ_CT_FAIL_MASK) >> TRNG_INT_CTRL_FRQ_CT_FAIL_SHIFT)
#define TRNG_BRD_INT_CTRL_FRQ_CT_FAIL(base) (BME_UBFX32(&TRNG_INT_CTRL_REG(base), TRNG_INT_CTRL_FRQ_CT_FAIL_SHIFT, TRNG_INT_CTRL_FRQ_CT_FAIL_WIDTH))

/*! @brief Set the FRQ_CT_FAIL field to a new value. */
#define TRNG_WR_INT_CTRL_FRQ_CT_FAIL(base, value) (TRNG_RMW_INT_CTRL(base, TRNG_INT_CTRL_FRQ_CT_FAIL_MASK, TRNG_INT_CTRL_FRQ_CT_FAIL(value)))
#define TRNG_BWR_INT_CTRL_FRQ_CT_FAIL(base, value) (BME_BFI32(&TRNG_INT_CTRL_REG(base), ((uint32_t)(value) << TRNG_INT_CTRL_FRQ_CT_FAIL_SHIFT), TRNG_INT_CTRL_FRQ_CT_FAIL_SHIFT, TRNG_INT_CTRL_FRQ_CT_FAIL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_INT_CTRL, field UNUSED[31:3] (RW)
 *
 * Reserved but writeable.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_CTRL_UNUSED field. */
#define TRNG_RD_INT_CTRL_UNUSED(base) ((TRNG_INT_CTRL_REG(base) & TRNG_INT_CTRL_UNUSED_MASK) >> TRNG_INT_CTRL_UNUSED_SHIFT)
#define TRNG_BRD_INT_CTRL_UNUSED(base) (TRNG_RD_INT_CTRL_UNUSED(base))

/*! @brief Set the UNUSED field to a new value. */
#define TRNG_WR_INT_CTRL_UNUSED(base, value) (TRNG_RMW_INT_CTRL(base, TRNG_INT_CTRL_UNUSED_MASK, TRNG_INT_CTRL_UNUSED(value)))
#define TRNG_BWR_INT_CTRL_UNUSED(base, value) (TRNG_WR_INT_CTRL_UNUSED(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_INT_MASK - RNG Mask Register
 ******************************************************************************/

/*!
 * @brief TRNG_INT_MASK - RNG Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Interrupt Mask Register is a read/write register used to disable/mask
 * the status reporting of the (currently) three important interrupts that are
 * generated by the TRNG. See INT_STATUS register description above. Each
 * interrupt can be masked/disabled by de-asserting the corresponding bit in the INT_MASK
 * register. Only setting this bit high will re-enable the interrupt in the
 * status register. Even if the interrupt is cleared or masked, interrupt status
 * information can be read from the MCTL register.
 */
/*!
 * @name Constants and macros for entire TRNG_INT_MASK register
 */
/*@{*/
#define TRNG_RD_INT_MASK(base)   (TRNG_INT_MASK_REG(base))
#define TRNG_WR_INT_MASK(base, value) (TRNG_INT_MASK_REG(base) = (value))
#define TRNG_RMW_INT_MASK(base, mask, value) (TRNG_WR_INT_MASK(base, (TRNG_RD_INT_MASK(base) & ~(mask)) | (value)))
#define TRNG_SET_INT_MASK(base, value) (BME_OR32(&TRNG_INT_MASK_REG(base), (uint32_t)(value)))
#define TRNG_CLR_INT_MASK(base, value) (BME_AND32(&TRNG_INT_MASK_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_INT_MASK(base, value) (BME_XOR32(&TRNG_INT_MASK_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_INT_MASK bitfields
 */

/*!
 * @name Register TRNG_INT_MASK, field HW_ERR[0] (RW)
 *
 * Bit position that can be cleared if corresponding bit of INT_STATUS has been
 * asserted.
 *
 * Values:
 * - 0b0 - Corresponding interrupt of INT_STATUS is masked.
 * - 0b1 - Corresponding bit of INT_STATUS is active.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_MASK_HW_ERR field. */
#define TRNG_RD_INT_MASK_HW_ERR(base) ((TRNG_INT_MASK_REG(base) & TRNG_INT_MASK_HW_ERR_MASK) >> TRNG_INT_MASK_HW_ERR_SHIFT)
#define TRNG_BRD_INT_MASK_HW_ERR(base) (BME_UBFX32(&TRNG_INT_MASK_REG(base), TRNG_INT_MASK_HW_ERR_SHIFT, TRNG_INT_MASK_HW_ERR_WIDTH))

/*! @brief Set the HW_ERR field to a new value. */
#define TRNG_WR_INT_MASK_HW_ERR(base, value) (TRNG_RMW_INT_MASK(base, TRNG_INT_MASK_HW_ERR_MASK, TRNG_INT_MASK_HW_ERR(value)))
#define TRNG_BWR_INT_MASK_HW_ERR(base, value) (BME_BFI32(&TRNG_INT_MASK_REG(base), ((uint32_t)(value) << TRNG_INT_MASK_HW_ERR_SHIFT), TRNG_INT_MASK_HW_ERR_SHIFT, TRNG_INT_MASK_HW_ERR_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_INT_MASK, field ENT_VAL[1] (RW)
 *
 * Same behavior as bit 0 above.
 *
 * Values:
 * - 0b0 - Same behavior as bit 0 above.
 * - 0b1 - Same behavior as bit 0 above.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_MASK_ENT_VAL field. */
#define TRNG_RD_INT_MASK_ENT_VAL(base) ((TRNG_INT_MASK_REG(base) & TRNG_INT_MASK_ENT_VAL_MASK) >> TRNG_INT_MASK_ENT_VAL_SHIFT)
#define TRNG_BRD_INT_MASK_ENT_VAL(base) (BME_UBFX32(&TRNG_INT_MASK_REG(base), TRNG_INT_MASK_ENT_VAL_SHIFT, TRNG_INT_MASK_ENT_VAL_WIDTH))

/*! @brief Set the ENT_VAL field to a new value. */
#define TRNG_WR_INT_MASK_ENT_VAL(base, value) (TRNG_RMW_INT_MASK(base, TRNG_INT_MASK_ENT_VAL_MASK, TRNG_INT_MASK_ENT_VAL(value)))
#define TRNG_BWR_INT_MASK_ENT_VAL(base, value) (BME_BFI32(&TRNG_INT_MASK_REG(base), ((uint32_t)(value) << TRNG_INT_MASK_ENT_VAL_SHIFT), TRNG_INT_MASK_ENT_VAL_SHIFT, TRNG_INT_MASK_ENT_VAL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_INT_MASK, field FRQ_CT_FAIL[2] (RW)
 *
 * Same behavior as bit 0 above.
 *
 * Values:
 * - 0b0 - Same behavior as bit 0 above.
 * - 0b1 - Same behavior as bit 0 above.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_MASK_FRQ_CT_FAIL field. */
#define TRNG_RD_INT_MASK_FRQ_CT_FAIL(base) ((TRNG_INT_MASK_REG(base) & TRNG_INT_MASK_FRQ_CT_FAIL_MASK) >> TRNG_INT_MASK_FRQ_CT_FAIL_SHIFT)
#define TRNG_BRD_INT_MASK_FRQ_CT_FAIL(base) (BME_UBFX32(&TRNG_INT_MASK_REG(base), TRNG_INT_MASK_FRQ_CT_FAIL_SHIFT, TRNG_INT_MASK_FRQ_CT_FAIL_WIDTH))

/*! @brief Set the FRQ_CT_FAIL field to a new value. */
#define TRNG_WR_INT_MASK_FRQ_CT_FAIL(base, value) (TRNG_RMW_INT_MASK(base, TRNG_INT_MASK_FRQ_CT_FAIL_MASK, TRNG_INT_MASK_FRQ_CT_FAIL(value)))
#define TRNG_BWR_INT_MASK_FRQ_CT_FAIL(base, value) (BME_BFI32(&TRNG_INT_MASK_REG(base), ((uint32_t)(value) << TRNG_INT_MASK_FRQ_CT_FAIL_SHIFT), TRNG_INT_MASK_FRQ_CT_FAIL_SHIFT, TRNG_INT_MASK_FRQ_CT_FAIL_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_INT_STATUS - RNG Interrupt Status Register
 ******************************************************************************/

/*!
 * @brief TRNG_INT_STATUS - RNG Interrupt Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Interrupt Status Register is a read register used to control and
 * provide status for the (currently) three important interrupts that are generated
 * by the TRNG. The ipi_rng_int_b interrupt signals that RNG has either generated
 * a Frequency Count Fail, Entropy Valid or Error Interrupt. The cause of the
 * interrupt can be decoded by checking the least significant bits of the INT_STATUS
 * register. Each interrupt can be temporarily cleared by de-asserting the
 * corresponding bit in the INT_CTRL register. To mask the interrupts, clear the
 * corresponding bits in the INT_MASK register. The description of each of the 3
 * interrupts is defined in the Block Guide under the MCTL register description. Even
 * if the interrupt is cleared or masked, interrupt status information can be
 * read from the MCTL register.
 */
/*!
 * @name Constants and macros for entire TRNG_INT_STATUS register
 */
/*@{*/
#define TRNG_RD_INT_STATUS(base) (TRNG_INT_STATUS_REG(base))
#define TRNG_WR_INT_STATUS(base, value) (TRNG_INT_STATUS_REG(base) = (value))
#define TRNG_RMW_INT_STATUS(base, mask, value) (TRNG_WR_INT_STATUS(base, (TRNG_RD_INT_STATUS(base) & ~(mask)) | (value)))
#define TRNG_SET_INT_STATUS(base, value) (BME_OR32(&TRNG_INT_STATUS_REG(base), (uint32_t)(value)))
#define TRNG_CLR_INT_STATUS(base, value) (BME_AND32(&TRNG_INT_STATUS_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_INT_STATUS(base, value) (BME_XOR32(&TRNG_INT_STATUS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_INT_STATUS bitfields
 */

/*!
 * @name Register TRNG_INT_STATUS, field HW_ERR[0] (RO)
 *
 * Read: Error status. 1 = error detected. 0 = no error. Any HW error in the
 * TRNG will trigger this interrupt.
 *
 * Values:
 * - 0b0 - no error
 * - 0b1 - error detected.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_STATUS_HW_ERR field. */
#define TRNG_RD_INT_STATUS_HW_ERR(base) ((TRNG_INT_STATUS_REG(base) & TRNG_INT_STATUS_HW_ERR_MASK) >> TRNG_INT_STATUS_HW_ERR_SHIFT)
#define TRNG_BRD_INT_STATUS_HW_ERR(base) (BME_UBFX32(&TRNG_INT_STATUS_REG(base), TRNG_INT_STATUS_HW_ERR_SHIFT, TRNG_INT_STATUS_HW_ERR_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_INT_STATUS, field ENT_VAL[1] (RO)
 *
 * Read only: Entropy Valid. Will assert only if TRNG ACC bit is set, and then
 * after an entropy value is generated. Will be cleared when ENT15 is read. (ENT0
 * through ENT14 should be read before reading ENT15).
 *
 * Values:
 * - 0b0 - Busy generation entropy. Any value read is invalid.
 * - 0b1 - TRNG can be stopped and entropy is valid if read.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_STATUS_ENT_VAL field. */
#define TRNG_RD_INT_STATUS_ENT_VAL(base) ((TRNG_INT_STATUS_REG(base) & TRNG_INT_STATUS_ENT_VAL_MASK) >> TRNG_INT_STATUS_ENT_VAL_SHIFT)
#define TRNG_BRD_INT_STATUS_ENT_VAL(base) (BME_UBFX32(&TRNG_INT_STATUS_REG(base), TRNG_INT_STATUS_ENT_VAL_SHIFT, TRNG_INT_STATUS_ENT_VAL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_INT_STATUS, field FRQ_CT_FAIL[2] (RW)
 *
 * Read only: Frequency Count Fail. The frequency counter has detected a
 * failure. This may be due to improper programming of the FRQMAX and/or FRQMIN
 * registers, or a hardware failure in the ring oscillator.
 *
 * Values:
 * - 0b0 - No hardware nor self test frequency errors.
 * - 0b1 - The frequency counter has detected a failure.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_STATUS_FRQ_CT_FAIL field. */
#define TRNG_RD_INT_STATUS_FRQ_CT_FAIL(base) ((TRNG_INT_STATUS_REG(base) & TRNG_INT_STATUS_FRQ_CT_FAIL_MASK) >> TRNG_INT_STATUS_FRQ_CT_FAIL_SHIFT)
#define TRNG_BRD_INT_STATUS_FRQ_CT_FAIL(base) (BME_UBFX32(&TRNG_INT_STATUS_REG(base), TRNG_INT_STATUS_FRQ_CT_FAIL_SHIFT, TRNG_INT_STATUS_FRQ_CT_FAIL_WIDTH))

/*! @brief Set the FRQ_CT_FAIL field to a new value. */
#define TRNG_WR_INT_STATUS_FRQ_CT_FAIL(base, value) (TRNG_RMW_INT_STATUS(base, TRNG_INT_STATUS_FRQ_CT_FAIL_MASK, TRNG_INT_STATUS_FRQ_CT_FAIL(value)))
#define TRNG_BWR_INT_STATUS_FRQ_CT_FAIL(base, value) (BME_BFI32(&TRNG_INT_STATUS_REG(base), ((uint32_t)(value) << TRNG_INT_STATUS_FRQ_CT_FAIL_SHIFT), TRNG_INT_STATUS_FRQ_CT_FAIL_SHIFT, TRNG_INT_STATUS_FRQ_CT_FAIL_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_VID1 - RNG Version ID Register (MS)
 ******************************************************************************/

/*!
 * @brief TRNG_VID1 - RNG Version ID Register (MS) (RO)
 *
 * Reset value: 0x00300100U
 *
 * The RNG Version ID Register is a read only register used to identify the
 * version of the TRNG in use. This register as well as VID2 should both be read to
 * verify the expected version.
 */
/*!
 * @name Constants and macros for entire TRNG_VID1 register
 */
/*@{*/
#define TRNG_RD_VID1(base)       (TRNG_VID1_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_VID1 bitfields
 */

/*!
 * @name Register TRNG_VID1, field RNG_MIN_REV[7:0] (RO)
 *
 * Shows the Freescale IP's Minor revision of the TRNG.
 *
 * Values:
 * - 0b00000000 - Minor revision number for TRNG.
 */
/*@{*/
/*! @brief Read current value of the TRNG_VID1_RNG_MIN_REV field. */
#define TRNG_RD_VID1_RNG_MIN_REV(base) ((TRNG_VID1_REG(base) & TRNG_VID1_RNG_MIN_REV_MASK) >> TRNG_VID1_RNG_MIN_REV_SHIFT)
#define TRNG_BRD_VID1_RNG_MIN_REV(base) (BME_UBFX32(&TRNG_VID1_REG(base), TRNG_VID1_RNG_MIN_REV_SHIFT, TRNG_VID1_RNG_MIN_REV_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_VID1, field RNG_MAJ_REV[15:8] (RO)
 *
 * Shows the Freescale IP's Major revision of the TRNG.
 *
 * Values:
 * - 0b00000001 - Major revision number for TRNG.
 */
/*@{*/
/*! @brief Read current value of the TRNG_VID1_RNG_MAJ_REV field. */
#define TRNG_RD_VID1_RNG_MAJ_REV(base) ((TRNG_VID1_REG(base) & TRNG_VID1_RNG_MAJ_REV_MASK) >> TRNG_VID1_RNG_MAJ_REV_SHIFT)
#define TRNG_BRD_VID1_RNG_MAJ_REV(base) (BME_UBFX32(&TRNG_VID1_REG(base), TRNG_VID1_RNG_MAJ_REV_SHIFT, TRNG_VID1_RNG_MAJ_REV_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_VID1, field RNG_IP_ID[31:16] (RO)
 *
 * Shows the Freescale IP ID.
 */
/*@{*/
/*! @brief Read current value of the TRNG_VID1_RNG_IP_ID field. */
#define TRNG_RD_VID1_RNG_IP_ID(base) ((TRNG_VID1_REG(base) & TRNG_VID1_RNG_IP_ID_MASK) >> TRNG_VID1_RNG_IP_ID_SHIFT)
#define TRNG_BRD_VID1_RNG_IP_ID(base) (BME_UBFX32(&TRNG_VID1_REG(base), TRNG_VID1_RNG_IP_ID_SHIFT, TRNG_VID1_RNG_IP_ID_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_VID2 - RNG Version ID Register (LS)
 ******************************************************************************/

/*!
 * @brief TRNG_VID2 - RNG Version ID Register (LS) (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Version ID Register LSB is a read only register used to identify the
 * architecture of the TRNG in use. This register as well as VID1 should both be
 * read to verify the expected version.
 */
/*!
 * @name Constants and macros for entire TRNG_VID2 register
 */
/*@{*/
#define TRNG_RD_VID2(base)       (TRNG_VID2_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_VID2 bitfields
 */

/*!
 * @name Register TRNG_VID2, field RNG_CONFIG_OPT[7:0] (RO)
 *
 * Shows the Freescale IP's Configuaration options for the TRNG.
 *
 * Values:
 * - 0b00000000 - TRNG_CONFIG_OPT for TRNG.
 */
/*@{*/
/*! @brief Read current value of the TRNG_VID2_RNG_CONFIG_OPT field. */
#define TRNG_RD_VID2_RNG_CONFIG_OPT(base) ((TRNG_VID2_REG(base) & TRNG_VID2_RNG_CONFIG_OPT_MASK) >> TRNG_VID2_RNG_CONFIG_OPT_SHIFT)
#define TRNG_BRD_VID2_RNG_CONFIG_OPT(base) (BME_UBFX32(&TRNG_VID2_REG(base), TRNG_VID2_RNG_CONFIG_OPT_SHIFT, TRNG_VID2_RNG_CONFIG_OPT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_VID2, field RNG_ECO_REV[15:8] (RO)
 *
 * Shows the Freescale IP's ECO revision of the TRNG.
 *
 * Values:
 * - 0b00000000 - TRNG_ECO_REV for TRNG.
 */
/*@{*/
/*! @brief Read current value of the TRNG_VID2_RNG_ECO_REV field. */
#define TRNG_RD_VID2_RNG_ECO_REV(base) ((TRNG_VID2_REG(base) & TRNG_VID2_RNG_ECO_REV_MASK) >> TRNG_VID2_RNG_ECO_REV_SHIFT)
#define TRNG_BRD_VID2_RNG_ECO_REV(base) (BME_UBFX32(&TRNG_VID2_REG(base), TRNG_VID2_RNG_ECO_REV_SHIFT, TRNG_VID2_RNG_ECO_REV_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_VID2, field RNG_INTG_OPT[23:16] (RO)
 *
 * Shows the Freescale integration options for the TRNG.
 *
 * Values:
 * - 0b00000000 - INTG_OPT for TRNG.
 */
/*@{*/
/*! @brief Read current value of the TRNG_VID2_RNG_INTG_OPT field. */
#define TRNG_RD_VID2_RNG_INTG_OPT(base) ((TRNG_VID2_REG(base) & TRNG_VID2_RNG_INTG_OPT_MASK) >> TRNG_VID2_RNG_INTG_OPT_SHIFT)
#define TRNG_BRD_VID2_RNG_INTG_OPT(base) (BME_UBFX32(&TRNG_VID2_REG(base), TRNG_VID2_RNG_INTG_OPT_SHIFT, TRNG_VID2_RNG_INTG_OPT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_VID2, field RNG_ERA[31:24] (RO)
 *
 * Shows the Freescale compile options for the TRNG.
 *
 * Values:
 * - 0b00000000 - COMPILE_OPT for TRNG.
 */
/*@{*/
/*! @brief Read current value of the TRNG_VID2_RNG_ERA field. */
#define TRNG_RD_VID2_RNG_ERA(base) ((TRNG_VID2_REG(base) & TRNG_VID2_RNG_ERA_MASK) >> TRNG_VID2_RNG_ERA_SHIFT)
#define TRNG_BRD_VID2_RNG_ERA(base) (BME_UBFX32(&TRNG_VID2_REG(base), TRNG_VID2_RNG_ERA_SHIFT, TRNG_VID2_RNG_ERA_WIDTH))
/*@}*/

/*
 * MKW40Z4 TSI
 *
 * Touch sense input
 *
 * Registers defined in this header file:
 * - TSI_GENCS - TSI General Control and Status Register
 * - TSI_DATA - TSI DATA Register
 * - TSI_TSHD - TSI Threshold Register
 */

#define TSI_INSTANCE_COUNT (1U) /*!< Number of instances of the TSI module. */
#define TSI0_IDX (0U) /*!< Instance number for TSI0. */

/*******************************************************************************
 * TSI_GENCS - TSI General Control and Status Register
 ******************************************************************************/

/*!
 * @brief TSI_GENCS - TSI General Control and Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This control register provides various control and configuration information
 * for the TSI module. When TSI is working, the configuration bits (GENCS[TSIEN],
 * GENCS[TSIIEN], and GENCS[STM]) must not be changed. The EOSF flag is kept
 * until the software acknowledge it.
 */
/*!
 * @name Constants and macros for entire TSI_GENCS register
 */
/*@{*/
#define TSI_RD_GENCS(base)       (TSI_GENCS_REG(base))
#define TSI_WR_GENCS(base, value) (TSI_GENCS_REG(base) = (value))
#define TSI_RMW_GENCS(base, mask, value) (TSI_WR_GENCS(base, (TSI_RD_GENCS(base) & ~(mask)) | (value)))
#define TSI_SET_GENCS(base, value) (BME_OR32(&TSI_GENCS_REG(base), (uint32_t)(value)))
#define TSI_CLR_GENCS(base, value) (BME_AND32(&TSI_GENCS_REG(base), (uint32_t)(~(value))))
#define TSI_TOG_GENCS(base, value) (BME_XOR32(&TSI_GENCS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TSI_GENCS bitfields
 */

/*!
 * @name Register TSI_GENCS, field CURSW[1] (RW)
 *
 * This bit specifies if the current sources of electrode oscillator and
 * reference oscillator are swapped.
 *
 * Values:
 * - 0b0 - The current source pair are not swapped.
 * - 0b1 - The current source pair are swapped.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_CURSW field. */
#define TSI_RD_GENCS_CURSW(base) ((TSI_GENCS_REG(base) & TSI_GENCS_CURSW_MASK) >> TSI_GENCS_CURSW_SHIFT)
#define TSI_BRD_GENCS_CURSW(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_CURSW_SHIFT, TSI_GENCS_CURSW_WIDTH))

/*! @brief Set the CURSW field to a new value. */
#define TSI_WR_GENCS_CURSW(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_CURSW_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_CURSW(value)))
#define TSI_BWR_GENCS_CURSW(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_CURSW_SHIFT), TSI_GENCS_CURSW_SHIFT, TSI_GENCS_CURSW_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field EOSF[2] (W1C)
 *
 * This flag is set when all active electrodes are finished scanning after a
 * scan trigger. Write "1" , when this flag is set, to clear it.
 *
 * Values:
 * - 0b0 - Scan not complete.
 * - 0b1 - Scan complete.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_EOSF field. */
#define TSI_RD_GENCS_EOSF(base) ((TSI_GENCS_REG(base) & TSI_GENCS_EOSF_MASK) >> TSI_GENCS_EOSF_SHIFT)
#define TSI_BRD_GENCS_EOSF(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_EOSF_SHIFT, TSI_GENCS_EOSF_WIDTH))

/*! @brief Set the EOSF field to a new value. */
#define TSI_WR_GENCS_EOSF(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_EOSF(value)))
#define TSI_BWR_GENCS_EOSF(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_EOSF_SHIFT), TSI_GENCS_EOSF_SHIFT, TSI_GENCS_EOSF_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field SCNIP[3] (RO)
 *
 * This read-only bit indicates if scan is in progress. This bit will get
 * asserted after the analog bias circuit is stable after a trigger and it changes
 * automatically by the TSI.
 *
 * Values:
 * - 0b0 - No scan in progress.
 * - 0b1 - Scan in progress.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_SCNIP field. */
#define TSI_RD_GENCS_SCNIP(base) ((TSI_GENCS_REG(base) & TSI_GENCS_SCNIP_MASK) >> TSI_GENCS_SCNIP_SHIFT)
#define TSI_BRD_GENCS_SCNIP(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_SCNIP_SHIFT, TSI_GENCS_SCNIP_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field STM[4] (RW)
 *
 * This bit specifies the trigger mode. User is allowed to change this bit when
 * TSI is not working in progress.
 *
 * Values:
 * - 0b0 - Software trigger scan.
 * - 0b1 - Hardware trigger scan.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_STM field. */
#define TSI_RD_GENCS_STM(base) ((TSI_GENCS_REG(base) & TSI_GENCS_STM_MASK) >> TSI_GENCS_STM_SHIFT)
#define TSI_BRD_GENCS_STM(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_STM_SHIFT, TSI_GENCS_STM_WIDTH))

/*! @brief Set the STM field to a new value. */
#define TSI_WR_GENCS_STM(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_STM_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_STM(value)))
#define TSI_BWR_GENCS_STM(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_STM_SHIFT), TSI_GENCS_STM_SHIFT, TSI_GENCS_STM_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field STPE[5] (RW)
 *
 * This bit enables TSI module function in low power modes (stop, VLPS, LLS and
 * VLLS{3,2,1}).
 *
 * Values:
 * - 0b0 - TSI is disabled when MCU goes into low power mode.
 * - 0b1 - Allows TSI to continue running in all low power modes.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_STPE field. */
#define TSI_RD_GENCS_STPE(base) ((TSI_GENCS_REG(base) & TSI_GENCS_STPE_MASK) >> TSI_GENCS_STPE_SHIFT)
#define TSI_BRD_GENCS_STPE(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_STPE_SHIFT, TSI_GENCS_STPE_WIDTH))

/*! @brief Set the STPE field to a new value. */
#define TSI_WR_GENCS_STPE(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_STPE_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_STPE(value)))
#define TSI_BWR_GENCS_STPE(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_STPE_SHIFT), TSI_GENCS_STPE_SHIFT, TSI_GENCS_STPE_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field TSIIEN[6] (RW)
 *
 * This bit enables TSI module interrupt request to CPU when the scan completes.
 * The interrupt will wake MCU from low power mode if this interrupt is enabled.
 *
 * Values:
 * - 0b0 - TSI interrupt is disabled.
 * - 0b1 - TSI interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_TSIIEN field. */
#define TSI_RD_GENCS_TSIIEN(base) ((TSI_GENCS_REG(base) & TSI_GENCS_TSIIEN_MASK) >> TSI_GENCS_TSIIEN_SHIFT)
#define TSI_BRD_GENCS_TSIIEN(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_TSIIEN_SHIFT, TSI_GENCS_TSIIEN_WIDTH))

/*! @brief Set the TSIIEN field to a new value. */
#define TSI_WR_GENCS_TSIIEN(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_TSIIEN_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_TSIIEN(value)))
#define TSI_BWR_GENCS_TSIIEN(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_TSIIEN_SHIFT), TSI_GENCS_TSIIEN_SHIFT, TSI_GENCS_TSIIEN_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field TSIEN[7] (RW)
 *
 * This bit enables TSI module.
 *
 * Values:
 * - 0b0 - TSI module disabled.
 * - 0b1 - TSI module enabled.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_TSIEN field. */
#define TSI_RD_GENCS_TSIEN(base) ((TSI_GENCS_REG(base) & TSI_GENCS_TSIEN_MASK) >> TSI_GENCS_TSIEN_SHIFT)
#define TSI_BRD_GENCS_TSIEN(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_TSIEN_SHIFT, TSI_GENCS_TSIEN_WIDTH))

/*! @brief Set the TSIEN field to a new value. */
#define TSI_WR_GENCS_TSIEN(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_TSIEN_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_TSIEN(value)))
#define TSI_BWR_GENCS_TSIEN(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_TSIEN_SHIFT), TSI_GENCS_TSIEN_SHIFT, TSI_GENCS_TSIEN_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field NSCN[12:8] (RW)
 *
 * These bits indicate the scan number for each electrode. The scan number is
 * equal to NSCN + 1, which allows the scan time ranges from 1 to 32. By default,
 * NSCN is configured as 0, which asserts the TSI scans once on the selected
 * eletrode channel.
 *
 * Values:
 * - 0b00000 - Once per electrode
 * - 0b00001 - Twice per electrode
 * - 0b00010 - 3 times per electrode
 * - 0b00011 - 4 times per electrode
 * - 0b00100 - 5 times per electrode
 * - 0b00101 - 6 times per electrode
 * - 0b00110 - 7 times per electrode
 * - 0b00111 - 8 times per electrode
 * - 0b01000 - 9 times per electrode
 * - 0b01001 - 10 times per electrode
 * - 0b01010 - 11 times per electrode
 * - 0b01011 - 12 times per electrode
 * - 0b01100 - 13 times per electrode
 * - 0b01101 - 14 times per electrode
 * - 0b01110 - 15 times per electrode
 * - 0b01111 - 16 times per electrode
 * - 0b10000 - 17 times per electrode
 * - 0b10001 - 18 times per electrode
 * - 0b10010 - 19 times per electrode
 * - 0b10011 - 20 times per electrode
 * - 0b10100 - 21 times per electrode
 * - 0b10101 - 22 times per electrode
 * - 0b10110 - 23 times per electrode
 * - 0b10111 - 24 times per electrode
 * - 0b11000 - 25 times per electrode
 * - 0b11001 - 26 times per electrode
 * - 0b11010 - 27 times per electrode
 * - 0b11011 - 28 times per electrode
 * - 0b11100 - 29 times per electrode
 * - 0b11101 - 30 times per electrode
 * - 0b11110 - 31 times per electrode
 * - 0b11111 - 32 times per electrode
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_NSCN field. */
#define TSI_RD_GENCS_NSCN(base) ((TSI_GENCS_REG(base) & TSI_GENCS_NSCN_MASK) >> TSI_GENCS_NSCN_SHIFT)
#define TSI_BRD_GENCS_NSCN(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_NSCN_SHIFT, TSI_GENCS_NSCN_WIDTH))

/*! @brief Set the NSCN field to a new value. */
#define TSI_WR_GENCS_NSCN(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_NSCN_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_NSCN(value)))
#define TSI_BWR_GENCS_NSCN(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_NSCN_SHIFT), TSI_GENCS_NSCN_SHIFT, TSI_GENCS_NSCN_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field PS[15:13] (RW)
 *
 * These bits indicate the prescaler of the output of electrode oscillator.
 *
 * Values:
 * - 0b000 - Electrode Oscillator Frequency divided by 1
 * - 0b001 - Electrode Oscillator Frequency divided by 2
 * - 0b010 - Electrode Oscillator Frequency divided by 4
 * - 0b011 - Electrode Oscillator Frequency divided by 8
 * - 0b100 - Electrode Oscillator Frequency divided by 16
 * - 0b101 - Electrode Oscillator Frequency divided by 32
 * - 0b110 - Electrode Oscillator Frequency divided by 64
 * - 0b111 - Electrode Oscillator Frequency divided by 128
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_PS field. */
#define TSI_RD_GENCS_PS(base) ((TSI_GENCS_REG(base) & TSI_GENCS_PS_MASK) >> TSI_GENCS_PS_SHIFT)
#define TSI_BRD_GENCS_PS(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_PS_SHIFT, TSI_GENCS_PS_WIDTH))

/*! @brief Set the PS field to a new value. */
#define TSI_WR_GENCS_PS(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_PS_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_PS(value)))
#define TSI_BWR_GENCS_PS(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_PS_SHIFT), TSI_GENCS_PS_SHIFT, TSI_GENCS_PS_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field EXTCHRG[18:16] (RW)
 *
 * These bits indicate the electrode oscillator charge and discharge current
 * value.
 *
 * Values:
 * - 0b000 - 500 nA.
 * - 0b001 - 1 uA.
 * - 0b010 - 2 uA.
 * - 0b011 - 4 uA.
 * - 0b100 - 8 uA.
 * - 0b101 - 16 uA.
 * - 0b110 - 32 uA.
 * - 0b111 - 64 uA.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_EXTCHRG field. */
#define TSI_RD_GENCS_EXTCHRG(base) ((TSI_GENCS_REG(base) & TSI_GENCS_EXTCHRG_MASK) >> TSI_GENCS_EXTCHRG_SHIFT)
#define TSI_BRD_GENCS_EXTCHRG(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_EXTCHRG_SHIFT, TSI_GENCS_EXTCHRG_WIDTH))

/*! @brief Set the EXTCHRG field to a new value. */
#define TSI_WR_GENCS_EXTCHRG(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_EXTCHRG_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_EXTCHRG(value)))
#define TSI_BWR_GENCS_EXTCHRG(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_EXTCHRG_SHIFT), TSI_GENCS_EXTCHRG_SHIFT, TSI_GENCS_EXTCHRG_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field DVOLT[20:19] (RW)
 *
 * These bits indicate the oscillator's voltage rails as below.
 *
 * Values:
 * - 0b00 - DV = 1.026 V; VP = 1.328 V; Vm = 0.302 V.
 * - 0b01 - DV = 0.592 V; VP = 1.111 V; Vm = 0.519 V.
 * - 0b10 - DV = 0.342 V; VP = 0.986 V; Vm = 0.644 V.
 * - 0b11 - DV = 0.197 V; VP = 0.914 V; Vm = 0.716 V.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_DVOLT field. */
#define TSI_RD_GENCS_DVOLT(base) ((TSI_GENCS_REG(base) & TSI_GENCS_DVOLT_MASK) >> TSI_GENCS_DVOLT_SHIFT)
#define TSI_BRD_GENCS_DVOLT(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_DVOLT_SHIFT, TSI_GENCS_DVOLT_WIDTH))

/*! @brief Set the DVOLT field to a new value. */
#define TSI_WR_GENCS_DVOLT(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_DVOLT_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_DVOLT(value)))
#define TSI_BWR_GENCS_DVOLT(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_DVOLT_SHIFT), TSI_GENCS_DVOLT_SHIFT, TSI_GENCS_DVOLT_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field REFCHRG[23:21] (RW)
 *
 * These bits indicate the reference oscillator charge and discharge current
 * value.
 *
 * Values:
 * - 0b000 - 500 nA.
 * - 0b001 - 1 uA.
 * - 0b010 - 2 uA.
 * - 0b011 - 4 uA.
 * - 0b100 - 8 uA.
 * - 0b101 - 16 uA.
 * - 0b110 - 32 uA.
 * - 0b111 - 64 uA.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_REFCHRG field. */
#define TSI_RD_GENCS_REFCHRG(base) ((TSI_GENCS_REG(base) & TSI_GENCS_REFCHRG_MASK) >> TSI_GENCS_REFCHRG_SHIFT)
#define TSI_BRD_GENCS_REFCHRG(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_REFCHRG_SHIFT, TSI_GENCS_REFCHRG_WIDTH))

/*! @brief Set the REFCHRG field to a new value. */
#define TSI_WR_GENCS_REFCHRG(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_REFCHRG_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_REFCHRG(value)))
#define TSI_BWR_GENCS_REFCHRG(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_REFCHRG_SHIFT), TSI_GENCS_REFCHRG_SHIFT, TSI_GENCS_REFCHRG_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field MODE[27:24] (RW)
 *
 * Set up TSI analog modes, especially, setting MODE[3:2] to not 2'b00 will
 * configure TSI to noise detection modes. MODE[1:0] take no effect on TSI operation
 * mode and should always write to 2'b00 for setting up. When reading this field
 * will return the analog status. Refer to chapter "Noise detection mode" for
 * details.
 *
 * Values:
 * - 0b0000 - Set TSI in capacitive sensing(non-noise detection) mode.
 * - 0b0100 - Set TSI analog to work in single threshold noise detection mode
 *     and the frequency limitation circuit is disabled.
 * - 0b1000 - Set TSI analog to work in single threshold noise detection mode
 *     and the frequency limitation circuit is enabled to work in higher
 *     frequencies operations.
 * - 0b1100 - Set TSI analog to work in automatic noise detection mode.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_MODE field. */
#define TSI_RD_GENCS_MODE(base) ((TSI_GENCS_REG(base) & TSI_GENCS_MODE_MASK) >> TSI_GENCS_MODE_SHIFT)
#define TSI_BRD_GENCS_MODE(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_MODE_SHIFT, TSI_GENCS_MODE_WIDTH))

/*! @brief Set the MODE field to a new value. */
#define TSI_WR_GENCS_MODE(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_MODE_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_MODE(value)))
#define TSI_BWR_GENCS_MODE(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_MODE_SHIFT), TSI_GENCS_MODE_SHIFT, TSI_GENCS_MODE_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field ESOR[28] (RW)
 *
 * This bit is used to select out-of-range or end-of-scan event to generate an
 * interrupt.
 *
 * Values:
 * - 0b0 - Out-of-range interrupt is allowed.
 * - 0b1 - End-of-scan interrupt is allowed.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_ESOR field. */
#define TSI_RD_GENCS_ESOR(base) ((TSI_GENCS_REG(base) & TSI_GENCS_ESOR_MASK) >> TSI_GENCS_ESOR_SHIFT)
#define TSI_BRD_GENCS_ESOR(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_ESOR_SHIFT, TSI_GENCS_ESOR_WIDTH))

/*! @brief Set the ESOR field to a new value. */
#define TSI_WR_GENCS_ESOR(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_ESOR_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_ESOR(value)))
#define TSI_BWR_GENCS_ESOR(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_ESOR_SHIFT), TSI_GENCS_ESOR_SHIFT, TSI_GENCS_ESOR_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field OUTRGF[31] (W1C)
 *
 * This flag is set if the result register of the enabled electrode is out of
 * the range defined by the TSI_THRESHOLD register. This flag is set only when TSI
 * is configured in non-noise detection mode. It can be read once the CPU wakes.
 * Write "1" , when this flag is set, to clear it.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_OUTRGF field. */
#define TSI_RD_GENCS_OUTRGF(base) ((TSI_GENCS_REG(base) & TSI_GENCS_OUTRGF_MASK) >> TSI_GENCS_OUTRGF_SHIFT)
#define TSI_BRD_GENCS_OUTRGF(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_OUTRGF_SHIFT, TSI_GENCS_OUTRGF_WIDTH))

/*! @brief Set the OUTRGF field to a new value. */
#define TSI_WR_GENCS_OUTRGF(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_OUTRGF_MASK | TSI_GENCS_EOSF_MASK), TSI_GENCS_OUTRGF(value)))
#define TSI_BWR_GENCS_OUTRGF(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_OUTRGF_SHIFT), TSI_GENCS_OUTRGF_SHIFT, TSI_GENCS_OUTRGF_WIDTH))
/*@}*/

/*******************************************************************************
 * TSI_DATA - TSI DATA Register
 ******************************************************************************/

/*!
 * @brief TSI_DATA - TSI DATA Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire TSI_DATA register
 */
/*@{*/
#define TSI_RD_DATA(base)        (TSI_DATA_REG(base))
#define TSI_WR_DATA(base, value) (TSI_DATA_REG(base) = (value))
#define TSI_RMW_DATA(base, mask, value) (TSI_WR_DATA(base, (TSI_RD_DATA(base) & ~(mask)) | (value)))
#define TSI_SET_DATA(base, value) (BME_OR32(&TSI_DATA_REG(base), (uint32_t)(value)))
#define TSI_CLR_DATA(base, value) (BME_AND32(&TSI_DATA_REG(base), (uint32_t)(~(value))))
#define TSI_TOG_DATA(base, value) (BME_XOR32(&TSI_DATA_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TSI_DATA bitfields
 */

/*!
 * @name Register TSI_DATA, field TSICNT[15:0] (RO)
 *
 * These read-only bits record the accumulated scan counter value ticked by the
 * reference oscillator.
 */
/*@{*/
/*! @brief Read current value of the TSI_DATA_TSICNT field. */
#define TSI_RD_DATA_TSICNT(base) ((TSI_DATA_REG(base) & TSI_DATA_TSICNT_MASK) >> TSI_DATA_TSICNT_SHIFT)
#define TSI_BRD_DATA_TSICNT(base) (BME_UBFX32(&TSI_DATA_REG(base), TSI_DATA_TSICNT_SHIFT, TSI_DATA_TSICNT_WIDTH))
/*@}*/

/*!
 * @name Register TSI_DATA, field SWTS[22] (WORZ)
 *
 * This write-only bit is a software start trigger. When STM bit is clear, write
 * "1" to this bit will start a scan. The electrode channel to be scanned is
 * determinated by TSI_DATA[TSICH] bits.
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Start a scan to determine which channel is specified by
 *     TSI_DATA[TSICH].
 */
/*@{*/
/*! @brief Set the SWTS field to a new value. */
#define TSI_WR_DATA_SWTS(base, value) (TSI_RMW_DATA(base, TSI_DATA_SWTS_MASK, TSI_DATA_SWTS(value)))
#define TSI_BWR_DATA_SWTS(base, value) (BME_BFI32(&TSI_DATA_REG(base), ((uint32_t)(value) << TSI_DATA_SWTS_SHIFT), TSI_DATA_SWTS_SHIFT, TSI_DATA_SWTS_WIDTH))
/*@}*/

/*!
 * @name Register TSI_DATA, field DMAEN[23] (RW)
 *
 * This bit is used together with the TSI interrupt enable bits(TSIIE, ESOR) to
 * generate a DMA transfer request instead of an interrupt.
 *
 * Values:
 * - 0b0 - Interrupt is selected when the interrupt enable bit is set and the
 *     corresponding TSI events assert.
 * - 0b1 - DMA transfer request is selected when the interrupt enable bit is set
 *     and the corresponding TSI events assert.
 */
/*@{*/
/*! @brief Read current value of the TSI_DATA_DMAEN field. */
#define TSI_RD_DATA_DMAEN(base) ((TSI_DATA_REG(base) & TSI_DATA_DMAEN_MASK) >> TSI_DATA_DMAEN_SHIFT)
#define TSI_BRD_DATA_DMAEN(base) (BME_UBFX32(&TSI_DATA_REG(base), TSI_DATA_DMAEN_SHIFT, TSI_DATA_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define TSI_WR_DATA_DMAEN(base, value) (TSI_RMW_DATA(base, TSI_DATA_DMAEN_MASK, TSI_DATA_DMAEN(value)))
#define TSI_BWR_DATA_DMAEN(base, value) (BME_BFI32(&TSI_DATA_REG(base), ((uint32_t)(value) << TSI_DATA_DMAEN_SHIFT), TSI_DATA_DMAEN_SHIFT, TSI_DATA_DMAEN_WIDTH))
/*@}*/

/*!
 * @name Register TSI_DATA, field TSICH[31:28] (RW)
 *
 * These bits specify current channel to be measured. In hardware trigger mode
 * (TSI_GENCS[STM] = 1), the scan will not start until the hardware trigger
 * occurs. In software trigger mode (TSI_GENCS[STM] = 0), the scan starts immediately
 * when TSI_DATA[SWTS] bit is written by 1.
 *
 * Values:
 * - 0b0000 - Channel 0.
 * - 0b0001 - Channel 1.
 * - 0b0010 - Channel 2.
 * - 0b0011 - Channel 3.
 * - 0b0100 - Channel 4.
 * - 0b0101 - Channel 5.
 * - 0b0110 - Channel 6.
 * - 0b0111 - Channel 7.
 * - 0b1000 - Channel 8.
 * - 0b1001 - Channel 9.
 * - 0b1010 - Channel 10.
 * - 0b1011 - Channel 11.
 * - 0b1100 - Channel 12.
 * - 0b1101 - Channel 13.
 * - 0b1110 - Channel 14.
 * - 0b1111 - Channel 15.
 */
/*@{*/
/*! @brief Read current value of the TSI_DATA_TSICH field. */
#define TSI_RD_DATA_TSICH(base) ((TSI_DATA_REG(base) & TSI_DATA_TSICH_MASK) >> TSI_DATA_TSICH_SHIFT)
#define TSI_BRD_DATA_TSICH(base) (BME_UBFX32(&TSI_DATA_REG(base), TSI_DATA_TSICH_SHIFT, TSI_DATA_TSICH_WIDTH))

/*! @brief Set the TSICH field to a new value. */
#define TSI_WR_DATA_TSICH(base, value) (TSI_RMW_DATA(base, TSI_DATA_TSICH_MASK, TSI_DATA_TSICH(value)))
#define TSI_BWR_DATA_TSICH(base, value) (BME_BFI32(&TSI_DATA_REG(base), ((uint32_t)(value) << TSI_DATA_TSICH_SHIFT), TSI_DATA_TSICH_SHIFT, TSI_DATA_TSICH_WIDTH))
/*@}*/

/*******************************************************************************
 * TSI_TSHD - TSI Threshold Register
 ******************************************************************************/

/*!
 * @brief TSI_TSHD - TSI Threshold Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire TSI_TSHD register
 */
/*@{*/
#define TSI_RD_TSHD(base)        (TSI_TSHD_REG(base))
#define TSI_WR_TSHD(base, value) (TSI_TSHD_REG(base) = (value))
#define TSI_RMW_TSHD(base, mask, value) (TSI_WR_TSHD(base, (TSI_RD_TSHD(base) & ~(mask)) | (value)))
#define TSI_SET_TSHD(base, value) (BME_OR32(&TSI_TSHD_REG(base), (uint32_t)(value)))
#define TSI_CLR_TSHD(base, value) (BME_AND32(&TSI_TSHD_REG(base), (uint32_t)(~(value))))
#define TSI_TOG_TSHD(base, value) (BME_XOR32(&TSI_TSHD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TSI_TSHD bitfields
 */

/*!
 * @name Register TSI_TSHD, field THRESL[15:0] (RW)
 *
 * This half-word specifies the low threshold of the wakeup channel.
 */
/*@{*/
/*! @brief Read current value of the TSI_TSHD_THRESL field. */
#define TSI_RD_TSHD_THRESL(base) ((TSI_TSHD_REG(base) & TSI_TSHD_THRESL_MASK) >> TSI_TSHD_THRESL_SHIFT)
#define TSI_BRD_TSHD_THRESL(base) (BME_UBFX32(&TSI_TSHD_REG(base), TSI_TSHD_THRESL_SHIFT, TSI_TSHD_THRESL_WIDTH))

/*! @brief Set the THRESL field to a new value. */
#define TSI_WR_TSHD_THRESL(base, value) (TSI_RMW_TSHD(base, TSI_TSHD_THRESL_MASK, TSI_TSHD_THRESL(value)))
#define TSI_BWR_TSHD_THRESL(base, value) (BME_BFI32(&TSI_TSHD_REG(base), ((uint32_t)(value) << TSI_TSHD_THRESL_SHIFT), TSI_TSHD_THRESL_SHIFT, TSI_TSHD_THRESL_WIDTH))
/*@}*/

/*!
 * @name Register TSI_TSHD, field THRESH[31:16] (RW)
 *
 * This half-word specifies the high threshold of the wakeup channel.
 */
/*@{*/
/*! @brief Read current value of the TSI_TSHD_THRESH field. */
#define TSI_RD_TSHD_THRESH(base) ((TSI_TSHD_REG(base) & TSI_TSHD_THRESH_MASK) >> TSI_TSHD_THRESH_SHIFT)
#define TSI_BRD_TSHD_THRESH(base) (BME_UBFX32(&TSI_TSHD_REG(base), TSI_TSHD_THRESH_SHIFT, TSI_TSHD_THRESH_WIDTH))

/*! @brief Set the THRESH field to a new value. */
#define TSI_WR_TSHD_THRESH(base, value) (TSI_RMW_TSHD(base, TSI_TSHD_THRESH_MASK, TSI_TSHD_THRESH(value)))
#define TSI_BWR_TSHD_THRESH(base, value) (BME_BFI32(&TSI_TSHD_REG(base), ((uint32_t)(value) << TSI_TSHD_THRESH_SHIFT), TSI_TSHD_THRESH_SHIFT, TSI_TSHD_THRESH_WIDTH))
/*@}*/

/*
 * MKW40Z4 XCVR
 *
 * Apache 1.0 Transceiver
 *
 * Registers defined in this header file:
 * - XCVR_RX_DIG_CTRL - RX Digital Control
 * - XCVR_AGC_CTRL_0 - AGC Control 0
 * - XCVR_AGC_CTRL_1 - AGC Control 1
 * - XCVR_AGC_CTRL_2 - AGC Control 2
 * - XCVR_AGC_CTRL_3 - AGC Control 3
 * - XCVR_AGC_STAT - AGC Status
 * - XCVR_RSSI_CTRL_0 - RSSI Control 0
 * - XCVR_RSSI_CTRL_1 - RSSI Control 1
 * - XCVR_DCOC_CTRL_0 - DCOC Control 0
 * - XCVR_DCOC_CTRL_1 - DCOC Control 1
 * - XCVR_DCOC_CTRL_2 - DCOC Control 2
 * - XCVR_DCOC_CTRL_3 - DCOC Control 3
 * - XCVR_DCOC_CTRL_4 - DCOC Control 4
 * - XCVR_DCOC_CAL_GAIN - DCOC Calibration Gain
 * - XCVR_DCOC_STAT - DCOC Status
 * - XCVR_DCOC_DC_EST - DCOC DC Estimate
 * - XCVR_DCOC_CAL_RCP - DCOC Calibration Reciprocals
 * - XCVR_IQMC_CTRL - IQMC Control
 * - XCVR_IQMC_CAL - IQMC Calibration
 * - XCVR_TCA_AGC_VAL_3_0 - TCA AGC Step Values 3..0
 * - XCVR_TCA_AGC_VAL_7_4 - TCA AGC Step Values 7..4
 * - XCVR_TCA_AGC_VAL_8 - TCA AGC Step Values 8
 * - XCVR_BBF_RES_TUNE_VAL_7_0 - BBF Resistor Tune Values 7..0
 * - XCVR_BBF_RES_TUNE_VAL_10_8 - BBF Resistor Tune Values 10..8
 * - XCVR_TCA_AGC_LIN_VAL_2_0 - TCA AGC Linear Gain Values 2..0
 * - XCVR_TCA_AGC_LIN_VAL_5_3 - TCA AGC Linear Gain Values 5..3
 * - XCVR_TCA_AGC_LIN_VAL_8_6 - TCA AGC Linear Gain Values 8..6
 * - XCVR_BBF_RES_TUNE_LIN_VAL_3_0 - BBF Resistor Tune Values 3..0
 * - XCVR_BBF_RES_TUNE_LIN_VAL_7_4 - BBF Resistor Tune Values 7..4
 * - XCVR_BBF_RES_TUNE_LIN_VAL_10_8 - BBF Resistor Tune Values 10..8
 * - XCVR_AGC_GAIN_TBL_03_00 - AGC Gain Tables Step 03..00
 * - XCVR_AGC_GAIN_TBL_07_04 - AGC Gain Tables Step 07..04
 * - XCVR_AGC_GAIN_TBL_11_08 - AGC Gain Tables Step 11..08
 * - XCVR_AGC_GAIN_TBL_15_12 - AGC Gain Tables Step 15..12
 * - XCVR_AGC_GAIN_TBL_19_16 - AGC Gain Tables Step 19..16
 * - XCVR_AGC_GAIN_TBL_23_20 - AGC Gain Tables Step 23..20
 * - XCVR_AGC_GAIN_TBL_26_24 - AGC Gain Tables Step 26..24
 * - XCVR_DCOC_OFFSET_ - DCOC Offset
 * - XCVR_DCOC_TZA_STEP_ - DCOC TZA DC step
 * - XCVR_DCOC_CAL_ALPHA - DCOC Calibration Alpha
 * - XCVR_DCOC_CAL_BETA - DCOC Calibration Beta
 * - XCVR_DCOC_CAL_GAMMA - DCOC Calibration Gamma
 * - XCVR_DCOC_CAL_IIR - DCOC Calibration IIR
 * - XCVR_DCOC_CAL - DCOC Calibration Result
 * - XCVR_RX_CHF_COEF - Receive Channel Filter Coefficient
 * - XCVR_TX_DIG_CTRL - TX Digital Control
 * - XCVR_TX_DATA_PAD_PAT - TX Data Padding Pattern
 * - XCVR_TX_GFSK_MOD_CTRL - TX GFSK Modulation Control
 * - XCVR_TX_GFSK_COEFF2 - TX GFSK Filter Coefficients 2
 * - XCVR_TX_GFSK_COEFF1 - TX GFSK Filter Coefficients 1
 * - XCVR_TX_FSK_MOD_SCALE - TX FSK Modulation Scale
 * - XCVR_TX_DFT_MOD_PAT - TX DFT Modulation Pattern
 * - XCVR_TX_DFT_TONE_0_1 - TX DFT Tones 0 and 1
 * - XCVR_TX_DFT_TONE_2_3 - TX DFT Tones 2 and 3
 * - XCVR_PLL_MOD_OVRD - PLL Modulation Overrides
 * - XCVR_PLL_CHAN_MAP - PLL Channel Mapping
 * - XCVR_PLL_LOCK_DETECT - PLL Lock Detect
 * - XCVR_PLL_HP_MOD_CTRL - PLL High Port Modulation Control
 * - XCVR_PLL_HPM_CAL_CTRL - PLL HPM Calibration Control
 * - XCVR_PLL_LD_HPM_CAL1 - PLL Cycle Slip Lock Detect Configuration and HPM Calibration 1
 * - XCVR_PLL_LD_HPM_CAL2 - PLL Cycle Slip Lock Detect Configuration and HPM Calibration 2
 * - XCVR_PLL_HPM_SDM_FRACTION - PLL HPM SDM Fraction
 * - XCVR_PLL_LP_MOD_CTRL - PLL Low Port Modulation Control
 * - XCVR_PLL_LP_SDM_CTRL1 - PLL Low Port SDM Control 1
 * - XCVR_PLL_LP_SDM_CTRL2 - PLL Low Port SDM Control 2
 * - XCVR_PLL_LP_SDM_CTRL3 - PLL Low Port SDM Control 3
 * - XCVR_PLL_LP_SDM_NUM - PLL Low Port SDM Numerator Applied
 * - XCVR_PLL_LP_SDM_DENOM - PLL Low Port SDM Denominator Applied
 * - XCVR_PLL_DELAY_MATCH - PLL Delay Matching
 * - XCVR_PLL_CTUNE_CTRL - PLL Coarse Tune Control
 * - XCVR_PLL_CTUNE_CNT6 - PLL Coarse Tune Count 6
 * - XCVR_PLL_CTUNE_CNT5_4 - PLL Coarse Tune Counts 5 and 4
 * - XCVR_PLL_CTUNE_CNT3_2 - PLL Coarse Tune Counts 3 and 2
 * - XCVR_PLL_CTUNE_CNT1_0 - PLL Coarse Tune Counts 1 and 0
 * - XCVR_PLL_CTUNE_RESULTS - PLL Coarse Tune Results
 * - XCVR_CTRL - Transceiver Control
 * - XCVR_STATUS - Transceiver Status
 * - XCVR_SOFT_RESET - Soft Reset
 * - XCVR_OVERWRITE_VER - Overwrite Version
 * - XCVR_DMA_CTRL - DMA Control
 * - XCVR_DMA_DATA - DMA Data
 * - XCVR_DTEST_CTRL - Digital Test Control
 * - XCVR_PB_CTRL - Packet Buffer Control Register
 * - XCVR_TSM_CTRL - Transceiver Sequence Manager Control
 * - XCVR_END_OF_SEQ - End of Sequence Control
 * - XCVR_TSM_OVRD0 - TSM Override 0
 * - XCVR_TSM_OVRD1 - TSM Override 1
 * - XCVR_TSM_OVRD2 - TSM Override 2
 * - XCVR_TSM_OVRD3 - TSM Override 3
 * - XCVR_PA_POWER - PA Power
 * - XCVR_PA_BIAS_TBL0 - PA Bias Table 0
 * - XCVR_PA_BIAS_TBL1 - PA Bias Table 1
 * - XCVR_RECYCLE_COUNT - Recycle Count Register
 * - XCVR_TSM_TIMING00 - TSM_TIMING00
 * - XCVR_TSM_TIMING01 - TSM_TIMING01
 * - XCVR_TSM_TIMING02 - TSM_TIMING02
 * - XCVR_TSM_TIMING03 - TSM_TIMING03
 * - XCVR_TSM_TIMING04 - TSM_TIMING04
 * - XCVR_TSM_TIMING05 - TSM_TIMING05
 * - XCVR_TSM_TIMING06 - TSM_TIMING06
 * - XCVR_TSM_TIMING07 - TSM_TIMING07
 * - XCVR_TSM_TIMING08 - TSM_TIMING08
 * - XCVR_TSM_TIMING09 - TSM_TIMING09
 * - XCVR_TSM_TIMING10 - TSM_TIMING10
 * - XCVR_TSM_TIMING11 - TSM_TIMING11
 * - XCVR_TSM_TIMING12 - TSM_TIMING12
 * - XCVR_TSM_TIMING13 - TSM_TIMING13
 * - XCVR_TSM_TIMING14 - TSM_TIMING14
 * - XCVR_TSM_TIMING15 - TSM_TIMING15
 * - XCVR_TSM_TIMING16 - TSM_TIMING16
 * - XCVR_TSM_TIMING17 - TSM_TIMING17
 * - XCVR_TSM_TIMING18 - TSM_TIMING18
 * - XCVR_TSM_TIMING19 - TSM_TIMING19
 * - XCVR_TSM_TIMING20 - TSM_TIMING20
 * - XCVR_TSM_TIMING21 - TSM_TIMING21
 * - XCVR_TSM_TIMING22 - TSM_TIMING22
 * - XCVR_TSM_TIMING23 - TSM_TIMING23
 * - XCVR_TSM_TIMING24 - TSM_TIMING24
 * - XCVR_TSM_TIMING25 - TSM_TIMING25
 * - XCVR_TSM_TIMING26 - TSM_TIMING26
 * - XCVR_TSM_TIMING27 - TSM_TIMING27
 * - XCVR_TSM_TIMING28 - TSM_TIMING28
 * - XCVR_TSM_TIMING29 - TSM_TIMING29
 * - XCVR_TSM_TIMING30 - TSM_TIMING30
 * - XCVR_TSM_TIMING31 - TSM_TIMING31
 * - XCVR_TSM_TIMING32 - TSM_TIMING32
 * - XCVR_TSM_TIMING33 - TSM_TIMING33
 * - XCVR_TSM_TIMING34 - TSM_TIMING34
 * - XCVR_TSM_TIMING35 - TSM_TIMING35
 * - XCVR_TSM_TIMING36 - TSM_TIMING36
 * - XCVR_TSM_TIMING37 - TSM_TIMING37
 * - XCVR_TSM_TIMING38 - TSM_TIMING38
 * - XCVR_TSM_TIMING39 - TSM_TIMING39
 * - XCVR_TSM_TIMING40 - TSM_TIMING40
 * - XCVR_TSM_TIMING41 - TSM_TIMING41
 * - XCVR_TSM_TIMING42 - TSM_TIMING42
 * - XCVR_TSM_TIMING43 - TSM_TIMING43
 * - XCVR_CORR_CTRL - CORR_CTRL
 * - XCVR_PN_TYPE - PN_TYPE
 * - XCVR_PN_CODE - PN_CODE
 * - XCVR_SYNC_CTRL - Sync Control
 * - XCVR_SNF_THR - SNF_THR
 * - XCVR_FAD_THR - FAD_THR
 * - XCVR_ZBDEM_AFC - ZBDEM_AFC
 * - XCVR_LPPS_CTRL - LPPS Control Register
 * - XCVR_ADC_CTRL - ADC Control
 * - XCVR_ADC_TUNE - ADC Tuning
 * - XCVR_ADC_ADJ - ADC Adjustment
 * - XCVR_ADC_REGS - ADC Regulators
 * - XCVR_ADC_TRIMS - ADC Regulator Trims
 * - XCVR_ADC_TEST_CTRL - ADC Test Control
 * - XCVR_BBF_CTRL - Baseband Filter Control
 * - XCVR_RX_ANA_CTRL - RX Analog Control
 * - XCVR_XTAL_CTRL - Crystal Oscillator Control Register 1
 * - XCVR_XTAL_CTRL2 - Crystal Oscillator Control Register 2
 * - XCVR_BGAP_CTRL - Bandgap Control
 * - XCVR_PLL_CTRL - PLL Control Register
 * - XCVR_PLL_CTRL2 - PLL Control Register 2
 * - XCVR_PLL_TEST_CTRL - PLL Test Control
 * - XCVR_QGEN_CTRL - QGEN Control
 * - XCVR_TCA_CTRL - TCA Control
 * - XCVR_TZA_CTRL - TZA Control
 * - XCVR_TX_ANA_CTRL - TX Analog Control
 * - XCVR_ANA_SPARE - Analog Spare
 */

#define XCVR_INSTANCE_COUNT (1U) /*!< Number of instances of the XCVR module. */
#define XCVR_IDX (0U) /*!< Instance number for XCVR. */

/*******************************************************************************
 * XCVR_RX_DIG_CTRL - RX Digital Control
 ******************************************************************************/

/*!
 * @brief XCVR_RX_DIG_CTRL - RX Digital Control (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_RX_DIG_CTRL register
 */
/*@{*/
#define XCVR_RD_RX_DIG_CTRL(base) (XCVR_RX_DIG_CTRL_REG(base))
#define XCVR_WR_RX_DIG_CTRL(base, value) (XCVR_RX_DIG_CTRL_REG(base) = (value))
#define XCVR_RMW_RX_DIG_CTRL(base, mask, value) (XCVR_WR_RX_DIG_CTRL(base, (XCVR_RD_RX_DIG_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_RX_DIG_CTRL(base, value) (BME_OR32(&XCVR_RX_DIG_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_RX_DIG_CTRL(base, value) (BME_AND32(&XCVR_RX_DIG_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_RX_DIG_CTRL(base, value) (BME_XOR32(&XCVR_RX_DIG_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_RX_DIG_CTRL bitfields
 */

/*!
 * @name Register XCVR_RX_DIG_CTRL, field RX_ADC_NEGEDGE[0] (RW)
 *
 * Selects which edge of the clock the ADC data is registered.
 *
 * Values:
 * - 0b0 - Register ADC data on positive edge of clock
 * - 0b1 - Register ADC data on negative edge of clock
 */
/*@{*/
/*! @brief Read current value of the XCVR_RX_DIG_CTRL_RX_ADC_NEGEDGE field. */
#define XCVR_RD_RX_DIG_CTRL_RX_ADC_NEGEDGE(base) ((XCVR_RX_DIG_CTRL_REG(base) & XCVR_RX_DIG_CTRL_RX_ADC_NEGEDGE_MASK) >> XCVR_RX_DIG_CTRL_RX_ADC_NEGEDGE_SHIFT)
#define XCVR_BRD_RX_DIG_CTRL_RX_ADC_NEGEDGE(base) (BME_UBFX32(&XCVR_RX_DIG_CTRL_REG(base), XCVR_RX_DIG_CTRL_RX_ADC_NEGEDGE_SHIFT, XCVR_RX_DIG_CTRL_RX_ADC_NEGEDGE_WIDTH))

/*! @brief Set the RX_ADC_NEGEDGE field to a new value. */
#define XCVR_WR_RX_DIG_CTRL_RX_ADC_NEGEDGE(base, value) (XCVR_RMW_RX_DIG_CTRL(base, XCVR_RX_DIG_CTRL_RX_ADC_NEGEDGE_MASK, XCVR_RX_DIG_CTRL_RX_ADC_NEGEDGE(value)))
#define XCVR_BWR_RX_DIG_CTRL_RX_ADC_NEGEDGE(base, value) (BME_BFI32(&XCVR_RX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_RX_DIG_CTRL_RX_ADC_NEGEDGE_SHIFT), XCVR_RX_DIG_CTRL_RX_ADC_NEGEDGE_SHIFT, XCVR_RX_DIG_CTRL_RX_ADC_NEGEDGE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RX_DIG_CTRL, field RX_CH_FILT_BYPASS[1] (RW)
 *
 * Selects whether to disable and bypass channel filter.
 *
 * Values:
 * - 0b0 - Channel filter is enabled.
 * - 0b1 - Disable and bypass channel filter.
 */
/*@{*/
/*! @brief Read current value of the XCVR_RX_DIG_CTRL_RX_CH_FILT_BYPASS field. */
#define XCVR_RD_RX_DIG_CTRL_RX_CH_FILT_BYPASS(base) ((XCVR_RX_DIG_CTRL_REG(base) & XCVR_RX_DIG_CTRL_RX_CH_FILT_BYPASS_MASK) >> XCVR_RX_DIG_CTRL_RX_CH_FILT_BYPASS_SHIFT)
#define XCVR_BRD_RX_DIG_CTRL_RX_CH_FILT_BYPASS(base) (BME_UBFX32(&XCVR_RX_DIG_CTRL_REG(base), XCVR_RX_DIG_CTRL_RX_CH_FILT_BYPASS_SHIFT, XCVR_RX_DIG_CTRL_RX_CH_FILT_BYPASS_WIDTH))

/*! @brief Set the RX_CH_FILT_BYPASS field to a new value. */
#define XCVR_WR_RX_DIG_CTRL_RX_CH_FILT_BYPASS(base, value) (XCVR_RMW_RX_DIG_CTRL(base, XCVR_RX_DIG_CTRL_RX_CH_FILT_BYPASS_MASK, XCVR_RX_DIG_CTRL_RX_CH_FILT_BYPASS(value)))
#define XCVR_BWR_RX_DIG_CTRL_RX_CH_FILT_BYPASS(base, value) (BME_BFI32(&XCVR_RX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_RX_DIG_CTRL_RX_CH_FILT_BYPASS_SHIFT), XCVR_RX_DIG_CTRL_RX_CH_FILT_BYPASS_SHIFT, XCVR_RX_DIG_CTRL_RX_CH_FILT_BYPASS_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RX_DIG_CTRL, field RX_ADC_RAW_EN[2] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - The decimation filter's 12bit output consists of two unfiltered 5-bit
 *     ADC samples. This is for test purposes only to observe ADC output via
 *     XCVR DMA or DTEST.
 */
/*@{*/
/*! @brief Read current value of the XCVR_RX_DIG_CTRL_RX_ADC_RAW_EN field. */
#define XCVR_RD_RX_DIG_CTRL_RX_ADC_RAW_EN(base) ((XCVR_RX_DIG_CTRL_REG(base) & XCVR_RX_DIG_CTRL_RX_ADC_RAW_EN_MASK) >> XCVR_RX_DIG_CTRL_RX_ADC_RAW_EN_SHIFT)
#define XCVR_BRD_RX_DIG_CTRL_RX_ADC_RAW_EN(base) (BME_UBFX32(&XCVR_RX_DIG_CTRL_REG(base), XCVR_RX_DIG_CTRL_RX_ADC_RAW_EN_SHIFT, XCVR_RX_DIG_CTRL_RX_ADC_RAW_EN_WIDTH))

/*! @brief Set the RX_ADC_RAW_EN field to a new value. */
#define XCVR_WR_RX_DIG_CTRL_RX_ADC_RAW_EN(base, value) (XCVR_RMW_RX_DIG_CTRL(base, XCVR_RX_DIG_CTRL_RX_ADC_RAW_EN_MASK, XCVR_RX_DIG_CTRL_RX_ADC_RAW_EN(value)))
#define XCVR_BWR_RX_DIG_CTRL_RX_ADC_RAW_EN(base, value) (BME_BFI32(&XCVR_RX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_RX_DIG_CTRL_RX_ADC_RAW_EN_SHIFT), XCVR_RX_DIG_CTRL_RX_ADC_RAW_EN_SHIFT, XCVR_RX_DIG_CTRL_RX_ADC_RAW_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RX_DIG_CTRL, field RX_DEC_FILT_OSR[6:4] (RW)
 *
 * All undocumented values are Reserved.
 *
 * Values:
 * - 0b000 - OSR 2
 * - 0b001 - OSR 4
 */
/*@{*/
/*! @brief Read current value of the XCVR_RX_DIG_CTRL_RX_DEC_FILT_OSR field. */
#define XCVR_RD_RX_DIG_CTRL_RX_DEC_FILT_OSR(base) ((XCVR_RX_DIG_CTRL_REG(base) & XCVR_RX_DIG_CTRL_RX_DEC_FILT_OSR_MASK) >> XCVR_RX_DIG_CTRL_RX_DEC_FILT_OSR_SHIFT)
#define XCVR_BRD_RX_DIG_CTRL_RX_DEC_FILT_OSR(base) (BME_UBFX32(&XCVR_RX_DIG_CTRL_REG(base), XCVR_RX_DIG_CTRL_RX_DEC_FILT_OSR_SHIFT, XCVR_RX_DIG_CTRL_RX_DEC_FILT_OSR_WIDTH))

/*! @brief Set the RX_DEC_FILT_OSR field to a new value. */
#define XCVR_WR_RX_DIG_CTRL_RX_DEC_FILT_OSR(base, value) (XCVR_RMW_RX_DIG_CTRL(base, XCVR_RX_DIG_CTRL_RX_DEC_FILT_OSR_MASK, XCVR_RX_DIG_CTRL_RX_DEC_FILT_OSR(value)))
#define XCVR_BWR_RX_DIG_CTRL_RX_DEC_FILT_OSR(base, value) (BME_BFI32(&XCVR_RX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_RX_DIG_CTRL_RX_DEC_FILT_OSR_SHIFT), XCVR_RX_DIG_CTRL_RX_DEC_FILT_OSR_SHIFT, XCVR_RX_DIG_CTRL_RX_DEC_FILT_OSR_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RX_DIG_CTRL, field RX_INTERP_EN[8] (RW)
 *
 * Values:
 * - 0b0 - Interpolator is disabled.
 * - 0b1 - Interpolator is enabled.
 */
/*@{*/
/*! @brief Read current value of the XCVR_RX_DIG_CTRL_RX_INTERP_EN field. */
#define XCVR_RD_RX_DIG_CTRL_RX_INTERP_EN(base) ((XCVR_RX_DIG_CTRL_REG(base) & XCVR_RX_DIG_CTRL_RX_INTERP_EN_MASK) >> XCVR_RX_DIG_CTRL_RX_INTERP_EN_SHIFT)
#define XCVR_BRD_RX_DIG_CTRL_RX_INTERP_EN(base) (BME_UBFX32(&XCVR_RX_DIG_CTRL_REG(base), XCVR_RX_DIG_CTRL_RX_INTERP_EN_SHIFT, XCVR_RX_DIG_CTRL_RX_INTERP_EN_WIDTH))

/*! @brief Set the RX_INTERP_EN field to a new value. */
#define XCVR_WR_RX_DIG_CTRL_RX_INTERP_EN(base, value) (XCVR_RMW_RX_DIG_CTRL(base, XCVR_RX_DIG_CTRL_RX_INTERP_EN_MASK, XCVR_RX_DIG_CTRL_RX_INTERP_EN(value)))
#define XCVR_BWR_RX_DIG_CTRL_RX_INTERP_EN(base, value) (BME_BFI32(&XCVR_RX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_RX_DIG_CTRL_RX_INTERP_EN_SHIFT), XCVR_RX_DIG_CTRL_RX_INTERP_EN_SHIFT, XCVR_RX_DIG_CTRL_RX_INTERP_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RX_DIG_CTRL, field RX_NORM_EN[9] (RW)
 *
 * Values:
 * - 0b0 - Normalizer is disabled.
 * - 0b1 - Normalizer is enabled.
 */
/*@{*/
/*! @brief Read current value of the XCVR_RX_DIG_CTRL_RX_NORM_EN field. */
#define XCVR_RD_RX_DIG_CTRL_RX_NORM_EN(base) ((XCVR_RX_DIG_CTRL_REG(base) & XCVR_RX_DIG_CTRL_RX_NORM_EN_MASK) >> XCVR_RX_DIG_CTRL_RX_NORM_EN_SHIFT)
#define XCVR_BRD_RX_DIG_CTRL_RX_NORM_EN(base) (BME_UBFX32(&XCVR_RX_DIG_CTRL_REG(base), XCVR_RX_DIG_CTRL_RX_NORM_EN_SHIFT, XCVR_RX_DIG_CTRL_RX_NORM_EN_WIDTH))

/*! @brief Set the RX_NORM_EN field to a new value. */
#define XCVR_WR_RX_DIG_CTRL_RX_NORM_EN(base, value) (XCVR_RMW_RX_DIG_CTRL(base, XCVR_RX_DIG_CTRL_RX_NORM_EN_MASK, XCVR_RX_DIG_CTRL_RX_NORM_EN(value)))
#define XCVR_BWR_RX_DIG_CTRL_RX_NORM_EN(base, value) (BME_BFI32(&XCVR_RX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_RX_DIG_CTRL_RX_NORM_EN_SHIFT), XCVR_RX_DIG_CTRL_RX_NORM_EN_SHIFT, XCVR_RX_DIG_CTRL_RX_NORM_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RX_DIG_CTRL, field RX_RSSI_EN[10] (RW)
 *
 * Values:
 * - 0b0 - RSSI measurement is disabled.
 * - 0b1 - RSSI measurement is enabled.
 */
/*@{*/
/*! @brief Read current value of the XCVR_RX_DIG_CTRL_RX_RSSI_EN field. */
#define XCVR_RD_RX_DIG_CTRL_RX_RSSI_EN(base) ((XCVR_RX_DIG_CTRL_REG(base) & XCVR_RX_DIG_CTRL_RX_RSSI_EN_MASK) >> XCVR_RX_DIG_CTRL_RX_RSSI_EN_SHIFT)
#define XCVR_BRD_RX_DIG_CTRL_RX_RSSI_EN(base) (BME_UBFX32(&XCVR_RX_DIG_CTRL_REG(base), XCVR_RX_DIG_CTRL_RX_RSSI_EN_SHIFT, XCVR_RX_DIG_CTRL_RX_RSSI_EN_WIDTH))

/*! @brief Set the RX_RSSI_EN field to a new value. */
#define XCVR_WR_RX_DIG_CTRL_RX_RSSI_EN(base, value) (XCVR_RMW_RX_DIG_CTRL(base, XCVR_RX_DIG_CTRL_RX_RSSI_EN_MASK, XCVR_RX_DIG_CTRL_RX_RSSI_EN(value)))
#define XCVR_BWR_RX_DIG_CTRL_RX_RSSI_EN(base, value) (BME_BFI32(&XCVR_RX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_RX_DIG_CTRL_RX_RSSI_EN_SHIFT), XCVR_RX_DIG_CTRL_RX_RSSI_EN_SHIFT, XCVR_RX_DIG_CTRL_RX_RSSI_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RX_DIG_CTRL, field RX_AGC_EN[11] (RW)
 *
 * Does NOT affect user gains (user gain programming has priority).
 *
 * Values:
 * - 0b0 - AGC is disabled.
 * - 0b1 - AGC is enabled.
 */
/*@{*/
/*! @brief Read current value of the XCVR_RX_DIG_CTRL_RX_AGC_EN field. */
#define XCVR_RD_RX_DIG_CTRL_RX_AGC_EN(base) ((XCVR_RX_DIG_CTRL_REG(base) & XCVR_RX_DIG_CTRL_RX_AGC_EN_MASK) >> XCVR_RX_DIG_CTRL_RX_AGC_EN_SHIFT)
#define XCVR_BRD_RX_DIG_CTRL_RX_AGC_EN(base) (BME_UBFX32(&XCVR_RX_DIG_CTRL_REG(base), XCVR_RX_DIG_CTRL_RX_AGC_EN_SHIFT, XCVR_RX_DIG_CTRL_RX_AGC_EN_WIDTH))

/*! @brief Set the RX_AGC_EN field to a new value. */
#define XCVR_WR_RX_DIG_CTRL_RX_AGC_EN(base, value) (XCVR_RMW_RX_DIG_CTRL(base, XCVR_RX_DIG_CTRL_RX_AGC_EN_MASK, XCVR_RX_DIG_CTRL_RX_AGC_EN(value)))
#define XCVR_BWR_RX_DIG_CTRL_RX_AGC_EN(base, value) (BME_BFI32(&XCVR_RX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_RX_DIG_CTRL_RX_AGC_EN_SHIFT), XCVR_RX_DIG_CTRL_RX_AGC_EN_SHIFT, XCVR_RX_DIG_CTRL_RX_AGC_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RX_DIG_CTRL, field RX_DCOC_EN[12] (RW)
 *
 * Enables DCO calculation and application of corrections.
 *
 * Values:
 * - 0b0 - DCOC is disabled.
 * - 0b1 - DCOC is enabled.
 */
/*@{*/
/*! @brief Read current value of the XCVR_RX_DIG_CTRL_RX_DCOC_EN field. */
#define XCVR_RD_RX_DIG_CTRL_RX_DCOC_EN(base) ((XCVR_RX_DIG_CTRL_REG(base) & XCVR_RX_DIG_CTRL_RX_DCOC_EN_MASK) >> XCVR_RX_DIG_CTRL_RX_DCOC_EN_SHIFT)
#define XCVR_BRD_RX_DIG_CTRL_RX_DCOC_EN(base) (BME_UBFX32(&XCVR_RX_DIG_CTRL_REG(base), XCVR_RX_DIG_CTRL_RX_DCOC_EN_SHIFT, XCVR_RX_DIG_CTRL_RX_DCOC_EN_WIDTH))

/*! @brief Set the RX_DCOC_EN field to a new value. */
#define XCVR_WR_RX_DIG_CTRL_RX_DCOC_EN(base, value) (XCVR_RMW_RX_DIG_CTRL(base, XCVR_RX_DIG_CTRL_RX_DCOC_EN_MASK, XCVR_RX_DIG_CTRL_RX_DCOC_EN(value)))
#define XCVR_BWR_RX_DIG_CTRL_RX_DCOC_EN(base, value) (BME_BFI32(&XCVR_RX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_RX_DIG_CTRL_RX_DCOC_EN_SHIFT), XCVR_RX_DIG_CTRL_RX_DCOC_EN_SHIFT, XCVR_RX_DIG_CTRL_RX_DCOC_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RX_DIG_CTRL, field RX_DCOC_CAL_EN[13] (RW)
 *
 * Enable DCOC warm-up calibration in receiver.
 *
 * Values:
 * - 0b0 - DCOC calibration is disabled.
 * - 0b1 - DCOC calibration is enabled.
 */
/*@{*/
/*! @brief Read current value of the XCVR_RX_DIG_CTRL_RX_DCOC_CAL_EN field. */
#define XCVR_RD_RX_DIG_CTRL_RX_DCOC_CAL_EN(base) ((XCVR_RX_DIG_CTRL_REG(base) & XCVR_RX_DIG_CTRL_RX_DCOC_CAL_EN_MASK) >> XCVR_RX_DIG_CTRL_RX_DCOC_CAL_EN_SHIFT)
#define XCVR_BRD_RX_DIG_CTRL_RX_DCOC_CAL_EN(base) (BME_UBFX32(&XCVR_RX_DIG_CTRL_REG(base), XCVR_RX_DIG_CTRL_RX_DCOC_CAL_EN_SHIFT, XCVR_RX_DIG_CTRL_RX_DCOC_CAL_EN_WIDTH))

/*! @brief Set the RX_DCOC_CAL_EN field to a new value. */
#define XCVR_WR_RX_DIG_CTRL_RX_DCOC_CAL_EN(base, value) (XCVR_RMW_RX_DIG_CTRL(base, XCVR_RX_DIG_CTRL_RX_DCOC_CAL_EN_MASK, XCVR_RX_DIG_CTRL_RX_DCOC_CAL_EN(value)))
#define XCVR_BWR_RX_DIG_CTRL_RX_DCOC_CAL_EN(base, value) (BME_BFI32(&XCVR_RX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_RX_DIG_CTRL_RX_DCOC_CAL_EN_SHIFT), XCVR_RX_DIG_CTRL_RX_DCOC_CAL_EN_SHIFT, XCVR_RX_DIG_CTRL_RX_DCOC_CAL_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RX_DIG_CTRL, field RX_IQ_SWAP[14] (RW)
 *
 * Enable swap of I/Q channels (does not affect ADC raw mode).
 *
 * Values:
 * - 0b0 - IQ swap is disabled.
 * - 0b1 - IQ swap is enabled.
 */
/*@{*/
/*! @brief Read current value of the XCVR_RX_DIG_CTRL_RX_IQ_SWAP field. */
#define XCVR_RD_RX_DIG_CTRL_RX_IQ_SWAP(base) ((XCVR_RX_DIG_CTRL_REG(base) & XCVR_RX_DIG_CTRL_RX_IQ_SWAP_MASK) >> XCVR_RX_DIG_CTRL_RX_IQ_SWAP_SHIFT)
#define XCVR_BRD_RX_DIG_CTRL_RX_IQ_SWAP(base) (BME_UBFX32(&XCVR_RX_DIG_CTRL_REG(base), XCVR_RX_DIG_CTRL_RX_IQ_SWAP_SHIFT, XCVR_RX_DIG_CTRL_RX_IQ_SWAP_WIDTH))

/*! @brief Set the RX_IQ_SWAP field to a new value. */
#define XCVR_WR_RX_DIG_CTRL_RX_IQ_SWAP(base, value) (XCVR_RMW_RX_DIG_CTRL(base, XCVR_RX_DIG_CTRL_RX_IQ_SWAP_MASK, XCVR_RX_DIG_CTRL_RX_IQ_SWAP(value)))
#define XCVR_BWR_RX_DIG_CTRL_RX_IQ_SWAP(base, value) (BME_BFI32(&XCVR_RX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_RX_DIG_CTRL_RX_IQ_SWAP_SHIFT), XCVR_RX_DIG_CTRL_RX_IQ_SWAP_SHIFT, XCVR_RX_DIG_CTRL_RX_IQ_SWAP_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_AGC_CTRL_0 - AGC Control 0
 ******************************************************************************/

/*!
 * @brief XCVR_AGC_CTRL_0 - AGC Control 0 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_AGC_CTRL_0 register
 */
/*@{*/
#define XCVR_RD_AGC_CTRL_0(base) (XCVR_AGC_CTRL_0_REG(base))
#define XCVR_WR_AGC_CTRL_0(base, value) (XCVR_AGC_CTRL_0_REG(base) = (value))
#define XCVR_RMW_AGC_CTRL_0(base, mask, value) (XCVR_WR_AGC_CTRL_0(base, (XCVR_RD_AGC_CTRL_0(base) & ~(mask)) | (value)))
#define XCVR_SET_AGC_CTRL_0(base, value) (BME_OR32(&XCVR_AGC_CTRL_0_REG(base), (uint32_t)(value)))
#define XCVR_CLR_AGC_CTRL_0(base, value) (BME_AND32(&XCVR_AGC_CTRL_0_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_AGC_CTRL_0(base, value) (BME_XOR32(&XCVR_AGC_CTRL_0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_AGC_CTRL_0 bitfields
 */

/*!
 * @name Register XCVR_AGC_CTRL_0, field SLOW_AGC_EN[0] (RW)
 *
 * Allow AGC to enter into slow mode.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_0_SLOW_AGC_EN field. */
#define XCVR_RD_AGC_CTRL_0_SLOW_AGC_EN(base) ((XCVR_AGC_CTRL_0_REG(base) & XCVR_AGC_CTRL_0_SLOW_AGC_EN_MASK) >> XCVR_AGC_CTRL_0_SLOW_AGC_EN_SHIFT)
#define XCVR_BRD_AGC_CTRL_0_SLOW_AGC_EN(base) (BME_UBFX32(&XCVR_AGC_CTRL_0_REG(base), XCVR_AGC_CTRL_0_SLOW_AGC_EN_SHIFT, XCVR_AGC_CTRL_0_SLOW_AGC_EN_WIDTH))

/*! @brief Set the SLOW_AGC_EN field to a new value. */
#define XCVR_WR_AGC_CTRL_0_SLOW_AGC_EN(base, value) (XCVR_RMW_AGC_CTRL_0(base, XCVR_AGC_CTRL_0_SLOW_AGC_EN_MASK, XCVR_AGC_CTRL_0_SLOW_AGC_EN(value)))
#define XCVR_BWR_AGC_CTRL_0_SLOW_AGC_EN(base, value) (BME_BFI32(&XCVR_AGC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_0_SLOW_AGC_EN_SHIFT), XCVR_AGC_CTRL_0_SLOW_AGC_EN_SHIFT, XCVR_AGC_CTRL_0_SLOW_AGC_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_0, field SLOW_AGC_SRC[2:1] (RW)
 *
 * Select trigger source for entering slow AGC.
 *
 * Values:
 * - 0b00 - BTLE Preamble Detect
 * - 0b01 - Zigbee Preamble Detect
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_0_SLOW_AGC_SRC field. */
#define XCVR_RD_AGC_CTRL_0_SLOW_AGC_SRC(base) ((XCVR_AGC_CTRL_0_REG(base) & XCVR_AGC_CTRL_0_SLOW_AGC_SRC_MASK) >> XCVR_AGC_CTRL_0_SLOW_AGC_SRC_SHIFT)
#define XCVR_BRD_AGC_CTRL_0_SLOW_AGC_SRC(base) (BME_UBFX32(&XCVR_AGC_CTRL_0_REG(base), XCVR_AGC_CTRL_0_SLOW_AGC_SRC_SHIFT, XCVR_AGC_CTRL_0_SLOW_AGC_SRC_WIDTH))

/*! @brief Set the SLOW_AGC_SRC field to a new value. */
#define XCVR_WR_AGC_CTRL_0_SLOW_AGC_SRC(base, value) (XCVR_RMW_AGC_CTRL_0(base, XCVR_AGC_CTRL_0_SLOW_AGC_SRC_MASK, XCVR_AGC_CTRL_0_SLOW_AGC_SRC(value)))
#define XCVR_BWR_AGC_CTRL_0_SLOW_AGC_SRC(base, value) (BME_BFI32(&XCVR_AGC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_0_SLOW_AGC_SRC_SHIFT), XCVR_AGC_CTRL_0_SLOW_AGC_SRC_SHIFT, XCVR_AGC_CTRL_0_SLOW_AGC_SRC_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_0, field AGC_FREEZE_EN[3] (RW)
 *
 * Allow AGC to freeze. AGC can still go to hold mode if timer expires (same as
 * fast expire) from slow mode.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_0_AGC_FREEZE_EN field. */
#define XCVR_RD_AGC_CTRL_0_AGC_FREEZE_EN(base) ((XCVR_AGC_CTRL_0_REG(base) & XCVR_AGC_CTRL_0_AGC_FREEZE_EN_MASK) >> XCVR_AGC_CTRL_0_AGC_FREEZE_EN_SHIFT)
#define XCVR_BRD_AGC_CTRL_0_AGC_FREEZE_EN(base) (BME_UBFX32(&XCVR_AGC_CTRL_0_REG(base), XCVR_AGC_CTRL_0_AGC_FREEZE_EN_SHIFT, XCVR_AGC_CTRL_0_AGC_FREEZE_EN_WIDTH))

/*! @brief Set the AGC_FREEZE_EN field to a new value. */
#define XCVR_WR_AGC_CTRL_0_AGC_FREEZE_EN(base, value) (XCVR_RMW_AGC_CTRL_0(base, XCVR_AGC_CTRL_0_AGC_FREEZE_EN_MASK, XCVR_AGC_CTRL_0_AGC_FREEZE_EN(value)))
#define XCVR_BWR_AGC_CTRL_0_AGC_FREEZE_EN(base, value) (BME_BFI32(&XCVR_AGC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_0_AGC_FREEZE_EN_SHIFT), XCVR_AGC_CTRL_0_AGC_FREEZE_EN_SHIFT, XCVR_AGC_CTRL_0_AGC_FREEZE_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_0, field FREEZE_AGC_SRC[5:4] (RW)
 *
 * Select trigger source for entering freeze AGC.
 *
 * Values:
 * - 0b00 - BTLE Preamble Detect
 * - 0b01 - Zigbee Preamble Detect
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_0_FREEZE_AGC_SRC field. */
#define XCVR_RD_AGC_CTRL_0_FREEZE_AGC_SRC(base) ((XCVR_AGC_CTRL_0_REG(base) & XCVR_AGC_CTRL_0_FREEZE_AGC_SRC_MASK) >> XCVR_AGC_CTRL_0_FREEZE_AGC_SRC_SHIFT)
#define XCVR_BRD_AGC_CTRL_0_FREEZE_AGC_SRC(base) (BME_UBFX32(&XCVR_AGC_CTRL_0_REG(base), XCVR_AGC_CTRL_0_FREEZE_AGC_SRC_SHIFT, XCVR_AGC_CTRL_0_FREEZE_AGC_SRC_WIDTH))

/*! @brief Set the FREEZE_AGC_SRC field to a new value. */
#define XCVR_WR_AGC_CTRL_0_FREEZE_AGC_SRC(base, value) (XCVR_RMW_AGC_CTRL_0(base, XCVR_AGC_CTRL_0_FREEZE_AGC_SRC_MASK, XCVR_AGC_CTRL_0_FREEZE_AGC_SRC(value)))
#define XCVR_BWR_AGC_CTRL_0_FREEZE_AGC_SRC(base, value) (BME_BFI32(&XCVR_AGC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_0_FREEZE_AGC_SRC_SHIFT), XCVR_AGC_CTRL_0_FREEZE_AGC_SRC_SHIFT, XCVR_AGC_CTRL_0_FREEZE_AGC_SRC_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_0, field AGC_UP_EN[6] (RW)
 *
 * Allow AGC to take upward steps in slow mode.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_0_AGC_UP_EN field. */
#define XCVR_RD_AGC_CTRL_0_AGC_UP_EN(base) ((XCVR_AGC_CTRL_0_REG(base) & XCVR_AGC_CTRL_0_AGC_UP_EN_MASK) >> XCVR_AGC_CTRL_0_AGC_UP_EN_SHIFT)
#define XCVR_BRD_AGC_CTRL_0_AGC_UP_EN(base) (BME_UBFX32(&XCVR_AGC_CTRL_0_REG(base), XCVR_AGC_CTRL_0_AGC_UP_EN_SHIFT, XCVR_AGC_CTRL_0_AGC_UP_EN_WIDTH))

/*! @brief Set the AGC_UP_EN field to a new value. */
#define XCVR_WR_AGC_CTRL_0_AGC_UP_EN(base, value) (XCVR_RMW_AGC_CTRL_0(base, XCVR_AGC_CTRL_0_AGC_UP_EN_MASK, XCVR_AGC_CTRL_0_AGC_UP_EN(value)))
#define XCVR_BWR_AGC_CTRL_0_AGC_UP_EN(base, value) (BME_BFI32(&XCVR_AGC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_0_AGC_UP_EN_SHIFT), XCVR_AGC_CTRL_0_AGC_UP_EN_SHIFT, XCVR_AGC_CTRL_0_AGC_UP_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_0, field AGC_UP_SRC[7] (RW)
 *
 * Criterion to use for upward AGC steps.
 *
 * Values:
 * - 0b0 - PDET LO
 * - 0b1 - RSSI
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_0_AGC_UP_SRC field. */
#define XCVR_RD_AGC_CTRL_0_AGC_UP_SRC(base) ((XCVR_AGC_CTRL_0_REG(base) & XCVR_AGC_CTRL_0_AGC_UP_SRC_MASK) >> XCVR_AGC_CTRL_0_AGC_UP_SRC_SHIFT)
#define XCVR_BRD_AGC_CTRL_0_AGC_UP_SRC(base) (BME_UBFX32(&XCVR_AGC_CTRL_0_REG(base), XCVR_AGC_CTRL_0_AGC_UP_SRC_SHIFT, XCVR_AGC_CTRL_0_AGC_UP_SRC_WIDTH))

/*! @brief Set the AGC_UP_SRC field to a new value. */
#define XCVR_WR_AGC_CTRL_0_AGC_UP_SRC(base, value) (XCVR_RMW_AGC_CTRL_0(base, XCVR_AGC_CTRL_0_AGC_UP_SRC_MASK, XCVR_AGC_CTRL_0_AGC_UP_SRC(value)))
#define XCVR_BWR_AGC_CTRL_0_AGC_UP_SRC(base, value) (BME_BFI32(&XCVR_AGC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_0_AGC_UP_SRC_SHIFT), XCVR_AGC_CTRL_0_AGC_UP_SRC_SHIFT, XCVR_AGC_CTRL_0_AGC_UP_SRC_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_0, field AGC_DOWN_BBF_STEP_SZ[11:8] (RW)
 *
 * Number of table steps for downward step (BBF) in AGC fast.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_0_AGC_DOWN_BBF_STEP_SZ field. */
#define XCVR_RD_AGC_CTRL_0_AGC_DOWN_BBF_STEP_SZ(base) ((XCVR_AGC_CTRL_0_REG(base) & XCVR_AGC_CTRL_0_AGC_DOWN_BBF_STEP_SZ_MASK) >> XCVR_AGC_CTRL_0_AGC_DOWN_BBF_STEP_SZ_SHIFT)
#define XCVR_BRD_AGC_CTRL_0_AGC_DOWN_BBF_STEP_SZ(base) (BME_UBFX32(&XCVR_AGC_CTRL_0_REG(base), XCVR_AGC_CTRL_0_AGC_DOWN_BBF_STEP_SZ_SHIFT, XCVR_AGC_CTRL_0_AGC_DOWN_BBF_STEP_SZ_WIDTH))

/*! @brief Set the AGC_DOWN_BBF_STEP_SZ field to a new value. */
#define XCVR_WR_AGC_CTRL_0_AGC_DOWN_BBF_STEP_SZ(base, value) (XCVR_RMW_AGC_CTRL_0(base, XCVR_AGC_CTRL_0_AGC_DOWN_BBF_STEP_SZ_MASK, XCVR_AGC_CTRL_0_AGC_DOWN_BBF_STEP_SZ(value)))
#define XCVR_BWR_AGC_CTRL_0_AGC_DOWN_BBF_STEP_SZ(base, value) (BME_BFI32(&XCVR_AGC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_0_AGC_DOWN_BBF_STEP_SZ_SHIFT), XCVR_AGC_CTRL_0_AGC_DOWN_BBF_STEP_SZ_SHIFT, XCVR_AGC_CTRL_0_AGC_DOWN_BBF_STEP_SZ_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_0, field AGC_DOWN_TZA_STEP_SZ[15:12] (RW)
 *
 * Number of table steps for downward step (TZA) in AGC fast.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_0_AGC_DOWN_TZA_STEP_SZ field. */
#define XCVR_RD_AGC_CTRL_0_AGC_DOWN_TZA_STEP_SZ(base) ((XCVR_AGC_CTRL_0_REG(base) & XCVR_AGC_CTRL_0_AGC_DOWN_TZA_STEP_SZ_MASK) >> XCVR_AGC_CTRL_0_AGC_DOWN_TZA_STEP_SZ_SHIFT)
#define XCVR_BRD_AGC_CTRL_0_AGC_DOWN_TZA_STEP_SZ(base) (BME_UBFX32(&XCVR_AGC_CTRL_0_REG(base), XCVR_AGC_CTRL_0_AGC_DOWN_TZA_STEP_SZ_SHIFT, XCVR_AGC_CTRL_0_AGC_DOWN_TZA_STEP_SZ_WIDTH))

/*! @brief Set the AGC_DOWN_TZA_STEP_SZ field to a new value. */
#define XCVR_WR_AGC_CTRL_0_AGC_DOWN_TZA_STEP_SZ(base, value) (XCVR_RMW_AGC_CTRL_0(base, XCVR_AGC_CTRL_0_AGC_DOWN_TZA_STEP_SZ_MASK, XCVR_AGC_CTRL_0_AGC_DOWN_TZA_STEP_SZ(value)))
#define XCVR_BWR_AGC_CTRL_0_AGC_DOWN_TZA_STEP_SZ(base, value) (BME_BFI32(&XCVR_AGC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_0_AGC_DOWN_TZA_STEP_SZ_SHIFT), XCVR_AGC_CTRL_0_AGC_DOWN_TZA_STEP_SZ_SHIFT, XCVR_AGC_CTRL_0_AGC_DOWN_TZA_STEP_SZ_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_0, field AGC_UP_RSSI_THRESH[23:16] (RW)
 *
 * ADC RSSI threshold to take upward step (AGC slow).
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_0_AGC_UP_RSSI_THRESH field. */
#define XCVR_RD_AGC_CTRL_0_AGC_UP_RSSI_THRESH(base) ((XCVR_AGC_CTRL_0_REG(base) & XCVR_AGC_CTRL_0_AGC_UP_RSSI_THRESH_MASK) >> XCVR_AGC_CTRL_0_AGC_UP_RSSI_THRESH_SHIFT)
#define XCVR_BRD_AGC_CTRL_0_AGC_UP_RSSI_THRESH(base) (BME_UBFX32(&XCVR_AGC_CTRL_0_REG(base), XCVR_AGC_CTRL_0_AGC_UP_RSSI_THRESH_SHIFT, XCVR_AGC_CTRL_0_AGC_UP_RSSI_THRESH_WIDTH))

/*! @brief Set the AGC_UP_RSSI_THRESH field to a new value. */
#define XCVR_WR_AGC_CTRL_0_AGC_UP_RSSI_THRESH(base, value) (XCVR_RMW_AGC_CTRL_0(base, XCVR_AGC_CTRL_0_AGC_UP_RSSI_THRESH_MASK, XCVR_AGC_CTRL_0_AGC_UP_RSSI_THRESH(value)))
#define XCVR_BWR_AGC_CTRL_0_AGC_UP_RSSI_THRESH(base, value) (BME_BFI32(&XCVR_AGC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_0_AGC_UP_RSSI_THRESH_SHIFT), XCVR_AGC_CTRL_0_AGC_UP_RSSI_THRESH_SHIFT, XCVR_AGC_CTRL_0_AGC_UP_RSSI_THRESH_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_0, field AGC_DOWN_RSSI_THRESH[31:24] (RW)
 *
 * ADC RSSI threshold to take downward step (AGC slow).
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_0_AGC_DOWN_RSSI_THRESH field. */
#define XCVR_RD_AGC_CTRL_0_AGC_DOWN_RSSI_THRESH(base) ((XCVR_AGC_CTRL_0_REG(base) & XCVR_AGC_CTRL_0_AGC_DOWN_RSSI_THRESH_MASK) >> XCVR_AGC_CTRL_0_AGC_DOWN_RSSI_THRESH_SHIFT)
#define XCVR_BRD_AGC_CTRL_0_AGC_DOWN_RSSI_THRESH(base) (BME_UBFX32(&XCVR_AGC_CTRL_0_REG(base), XCVR_AGC_CTRL_0_AGC_DOWN_RSSI_THRESH_SHIFT, XCVR_AGC_CTRL_0_AGC_DOWN_RSSI_THRESH_WIDTH))

/*! @brief Set the AGC_DOWN_RSSI_THRESH field to a new value. */
#define XCVR_WR_AGC_CTRL_0_AGC_DOWN_RSSI_THRESH(base, value) (XCVR_RMW_AGC_CTRL_0(base, XCVR_AGC_CTRL_0_AGC_DOWN_RSSI_THRESH_MASK, XCVR_AGC_CTRL_0_AGC_DOWN_RSSI_THRESH(value)))
#define XCVR_BWR_AGC_CTRL_0_AGC_DOWN_RSSI_THRESH(base, value) (BME_BFI32(&XCVR_AGC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_0_AGC_DOWN_RSSI_THRESH_SHIFT), XCVR_AGC_CTRL_0_AGC_DOWN_RSSI_THRESH_SHIFT, XCVR_AGC_CTRL_0_AGC_DOWN_RSSI_THRESH_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_AGC_CTRL_1 - AGC Control 1
 ******************************************************************************/

/*!
 * @brief XCVR_AGC_CTRL_1 - AGC Control 1 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_AGC_CTRL_1 register
 */
/*@{*/
#define XCVR_RD_AGC_CTRL_1(base) (XCVR_AGC_CTRL_1_REG(base))
#define XCVR_WR_AGC_CTRL_1(base, value) (XCVR_AGC_CTRL_1_REG(base) = (value))
#define XCVR_RMW_AGC_CTRL_1(base, mask, value) (XCVR_WR_AGC_CTRL_1(base, (XCVR_RD_AGC_CTRL_1(base) & ~(mask)) | (value)))
#define XCVR_SET_AGC_CTRL_1(base, value) (BME_OR32(&XCVR_AGC_CTRL_1_REG(base), (uint32_t)(value)))
#define XCVR_CLR_AGC_CTRL_1(base, value) (BME_AND32(&XCVR_AGC_CTRL_1_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_AGC_CTRL_1(base, value) (BME_XOR32(&XCVR_AGC_CTRL_1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_AGC_CTRL_1 bitfields
 */

/*!
 * @name Register XCVR_AGC_CTRL_1, field BBF_ALT_CODE[3:0] (RW)
 *
 * Alternate BBF gain code selected when bbf_gain_xx=0xF. Also used as initial
 * gain value before DCOC cal is performed.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_1_BBF_ALT_CODE field. */
#define XCVR_RD_AGC_CTRL_1_BBF_ALT_CODE(base) ((XCVR_AGC_CTRL_1_REG(base) & XCVR_AGC_CTRL_1_BBF_ALT_CODE_MASK) >> XCVR_AGC_CTRL_1_BBF_ALT_CODE_SHIFT)
#define XCVR_BRD_AGC_CTRL_1_BBF_ALT_CODE(base) (BME_UBFX32(&XCVR_AGC_CTRL_1_REG(base), XCVR_AGC_CTRL_1_BBF_ALT_CODE_SHIFT, XCVR_AGC_CTRL_1_BBF_ALT_CODE_WIDTH))

/*! @brief Set the BBF_ALT_CODE field to a new value. */
#define XCVR_WR_AGC_CTRL_1_BBF_ALT_CODE(base, value) (XCVR_RMW_AGC_CTRL_1(base, XCVR_AGC_CTRL_1_BBF_ALT_CODE_MASK, XCVR_AGC_CTRL_1_BBF_ALT_CODE(value)))
#define XCVR_BWR_AGC_CTRL_1_BBF_ALT_CODE(base, value) (BME_BFI32(&XCVR_AGC_CTRL_1_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_1_BBF_ALT_CODE_SHIFT), XCVR_AGC_CTRL_1_BBF_ALT_CODE_SHIFT, XCVR_AGC_CTRL_1_BBF_ALT_CODE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_1, field LNM_ALT_CODE[11:4] (RW)
 *
 * Alternate LNM gain code selected when lnm_gain_xx=F. Also used as initial
 * gain value before DCOC cal is performed.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_1_LNM_ALT_CODE field. */
#define XCVR_RD_AGC_CTRL_1_LNM_ALT_CODE(base) ((XCVR_AGC_CTRL_1_REG(base) & XCVR_AGC_CTRL_1_LNM_ALT_CODE_MASK) >> XCVR_AGC_CTRL_1_LNM_ALT_CODE_SHIFT)
#define XCVR_BRD_AGC_CTRL_1_LNM_ALT_CODE(base) (BME_UBFX32(&XCVR_AGC_CTRL_1_REG(base), XCVR_AGC_CTRL_1_LNM_ALT_CODE_SHIFT, XCVR_AGC_CTRL_1_LNM_ALT_CODE_WIDTH))

/*! @brief Set the LNM_ALT_CODE field to a new value. */
#define XCVR_WR_AGC_CTRL_1_LNM_ALT_CODE(base, value) (XCVR_RMW_AGC_CTRL_1(base, XCVR_AGC_CTRL_1_LNM_ALT_CODE_MASK, XCVR_AGC_CTRL_1_LNM_ALT_CODE(value)))
#define XCVR_BWR_AGC_CTRL_1_LNM_ALT_CODE(base, value) (BME_BFI32(&XCVR_AGC_CTRL_1_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_1_LNM_ALT_CODE_SHIFT), XCVR_AGC_CTRL_1_LNM_ALT_CODE_SHIFT, XCVR_AGC_CTRL_1_LNM_ALT_CODE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_1, field LNM_USER_GAIN[15:12] (RW)
 *
 * user defined lnm gain index if user_lnm_gain_en =1
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_1_LNM_USER_GAIN field. */
#define XCVR_RD_AGC_CTRL_1_LNM_USER_GAIN(base) ((XCVR_AGC_CTRL_1_REG(base) & XCVR_AGC_CTRL_1_LNM_USER_GAIN_MASK) >> XCVR_AGC_CTRL_1_LNM_USER_GAIN_SHIFT)
#define XCVR_BRD_AGC_CTRL_1_LNM_USER_GAIN(base) (BME_UBFX32(&XCVR_AGC_CTRL_1_REG(base), XCVR_AGC_CTRL_1_LNM_USER_GAIN_SHIFT, XCVR_AGC_CTRL_1_LNM_USER_GAIN_WIDTH))

/*! @brief Set the LNM_USER_GAIN field to a new value. */
#define XCVR_WR_AGC_CTRL_1_LNM_USER_GAIN(base, value) (XCVR_RMW_AGC_CTRL_1(base, XCVR_AGC_CTRL_1_LNM_USER_GAIN_MASK, XCVR_AGC_CTRL_1_LNM_USER_GAIN(value)))
#define XCVR_BWR_AGC_CTRL_1_LNM_USER_GAIN(base, value) (BME_BFI32(&XCVR_AGC_CTRL_1_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_1_LNM_USER_GAIN_SHIFT), XCVR_AGC_CTRL_1_LNM_USER_GAIN_SHIFT, XCVR_AGC_CTRL_1_LNM_USER_GAIN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_1, field BBF_USER_GAIN[19:16] (RW)
 *
 * User defined BBF gain index if user_bbf_gain_en =1
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_1_BBF_USER_GAIN field. */
#define XCVR_RD_AGC_CTRL_1_BBF_USER_GAIN(base) ((XCVR_AGC_CTRL_1_REG(base) & XCVR_AGC_CTRL_1_BBF_USER_GAIN_MASK) >> XCVR_AGC_CTRL_1_BBF_USER_GAIN_SHIFT)
#define XCVR_BRD_AGC_CTRL_1_BBF_USER_GAIN(base) (BME_UBFX32(&XCVR_AGC_CTRL_1_REG(base), XCVR_AGC_CTRL_1_BBF_USER_GAIN_SHIFT, XCVR_AGC_CTRL_1_BBF_USER_GAIN_WIDTH))

/*! @brief Set the BBF_USER_GAIN field to a new value. */
#define XCVR_WR_AGC_CTRL_1_BBF_USER_GAIN(base, value) (XCVR_RMW_AGC_CTRL_1(base, XCVR_AGC_CTRL_1_BBF_USER_GAIN_MASK, XCVR_AGC_CTRL_1_BBF_USER_GAIN(value)))
#define XCVR_BWR_AGC_CTRL_1_BBF_USER_GAIN(base, value) (BME_BFI32(&XCVR_AGC_CTRL_1_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_1_BBF_USER_GAIN_SHIFT), XCVR_AGC_CTRL_1_BBF_USER_GAIN_SHIFT, XCVR_AGC_CTRL_1_BBF_USER_GAIN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_1, field USER_LNM_GAIN_EN[20] (RW)
 *
 * Enable user defined LNM gain (no AGC).
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_1_USER_LNM_GAIN_EN field. */
#define XCVR_RD_AGC_CTRL_1_USER_LNM_GAIN_EN(base) ((XCVR_AGC_CTRL_1_REG(base) & XCVR_AGC_CTRL_1_USER_LNM_GAIN_EN_MASK) >> XCVR_AGC_CTRL_1_USER_LNM_GAIN_EN_SHIFT)
#define XCVR_BRD_AGC_CTRL_1_USER_LNM_GAIN_EN(base) (BME_UBFX32(&XCVR_AGC_CTRL_1_REG(base), XCVR_AGC_CTRL_1_USER_LNM_GAIN_EN_SHIFT, XCVR_AGC_CTRL_1_USER_LNM_GAIN_EN_WIDTH))

/*! @brief Set the USER_LNM_GAIN_EN field to a new value. */
#define XCVR_WR_AGC_CTRL_1_USER_LNM_GAIN_EN(base, value) (XCVR_RMW_AGC_CTRL_1(base, XCVR_AGC_CTRL_1_USER_LNM_GAIN_EN_MASK, XCVR_AGC_CTRL_1_USER_LNM_GAIN_EN(value)))
#define XCVR_BWR_AGC_CTRL_1_USER_LNM_GAIN_EN(base, value) (BME_BFI32(&XCVR_AGC_CTRL_1_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_1_USER_LNM_GAIN_EN_SHIFT), XCVR_AGC_CTRL_1_USER_LNM_GAIN_EN_SHIFT, XCVR_AGC_CTRL_1_USER_LNM_GAIN_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_1, field USER_BBF_GAIN_EN[21] (RW)
 *
 * Enable user defined BBF gain (no AGC).
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_1_USER_BBF_GAIN_EN field. */
#define XCVR_RD_AGC_CTRL_1_USER_BBF_GAIN_EN(base) ((XCVR_AGC_CTRL_1_REG(base) & XCVR_AGC_CTRL_1_USER_BBF_GAIN_EN_MASK) >> XCVR_AGC_CTRL_1_USER_BBF_GAIN_EN_SHIFT)
#define XCVR_BRD_AGC_CTRL_1_USER_BBF_GAIN_EN(base) (BME_UBFX32(&XCVR_AGC_CTRL_1_REG(base), XCVR_AGC_CTRL_1_USER_BBF_GAIN_EN_SHIFT, XCVR_AGC_CTRL_1_USER_BBF_GAIN_EN_WIDTH))

/*! @brief Set the USER_BBF_GAIN_EN field to a new value. */
#define XCVR_WR_AGC_CTRL_1_USER_BBF_GAIN_EN(base, value) (XCVR_RMW_AGC_CTRL_1(base, XCVR_AGC_CTRL_1_USER_BBF_GAIN_EN_MASK, XCVR_AGC_CTRL_1_USER_BBF_GAIN_EN(value)))
#define XCVR_BWR_AGC_CTRL_1_USER_BBF_GAIN_EN(base, value) (BME_BFI32(&XCVR_AGC_CTRL_1_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_1_USER_BBF_GAIN_EN_SHIFT), XCVR_AGC_CTRL_1_USER_BBF_GAIN_EN_SHIFT, XCVR_AGC_CTRL_1_USER_BBF_GAIN_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_1, field PRESLOW_EN[22] (RW)
 *
 * Enablepre-slow state.
 *
 * Values:
 * - 0b0 - Pre-slow is disabled.
 * - 0b1 - Pre-slow is enabled.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_1_PRESLOW_EN field. */
#define XCVR_RD_AGC_CTRL_1_PRESLOW_EN(base) ((XCVR_AGC_CTRL_1_REG(base) & XCVR_AGC_CTRL_1_PRESLOW_EN_MASK) >> XCVR_AGC_CTRL_1_PRESLOW_EN_SHIFT)
#define XCVR_BRD_AGC_CTRL_1_PRESLOW_EN(base) (BME_UBFX32(&XCVR_AGC_CTRL_1_REG(base), XCVR_AGC_CTRL_1_PRESLOW_EN_SHIFT, XCVR_AGC_CTRL_1_PRESLOW_EN_WIDTH))

/*! @brief Set the PRESLOW_EN field to a new value. */
#define XCVR_WR_AGC_CTRL_1_PRESLOW_EN(base, value) (XCVR_RMW_AGC_CTRL_1(base, XCVR_AGC_CTRL_1_PRESLOW_EN_MASK, XCVR_AGC_CTRL_1_PRESLOW_EN(value)))
#define XCVR_BWR_AGC_CTRL_1_PRESLOW_EN(base, value) (BME_BFI32(&XCVR_AGC_CTRL_1_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_1_PRESLOW_EN_SHIFT), XCVR_AGC_CTRL_1_PRESLOW_EN_SHIFT, XCVR_AGC_CTRL_1_PRESLOW_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_1, field TZA_GAIN_SETTLE_TIME[31:24] (RW)
 *
 * Number of clocks to assert TZA peak detector reset (for automatic control).
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_1_TZA_GAIN_SETTLE_TIME field. */
#define XCVR_RD_AGC_CTRL_1_TZA_GAIN_SETTLE_TIME(base) ((XCVR_AGC_CTRL_1_REG(base) & XCVR_AGC_CTRL_1_TZA_GAIN_SETTLE_TIME_MASK) >> XCVR_AGC_CTRL_1_TZA_GAIN_SETTLE_TIME_SHIFT)
#define XCVR_BRD_AGC_CTRL_1_TZA_GAIN_SETTLE_TIME(base) (BME_UBFX32(&XCVR_AGC_CTRL_1_REG(base), XCVR_AGC_CTRL_1_TZA_GAIN_SETTLE_TIME_SHIFT, XCVR_AGC_CTRL_1_TZA_GAIN_SETTLE_TIME_WIDTH))

/*! @brief Set the TZA_GAIN_SETTLE_TIME field to a new value. */
#define XCVR_WR_AGC_CTRL_1_TZA_GAIN_SETTLE_TIME(base, value) (XCVR_RMW_AGC_CTRL_1(base, XCVR_AGC_CTRL_1_TZA_GAIN_SETTLE_TIME_MASK, XCVR_AGC_CTRL_1_TZA_GAIN_SETTLE_TIME(value)))
#define XCVR_BWR_AGC_CTRL_1_TZA_GAIN_SETTLE_TIME(base, value) (BME_BFI32(&XCVR_AGC_CTRL_1_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_1_TZA_GAIN_SETTLE_TIME_SHIFT), XCVR_AGC_CTRL_1_TZA_GAIN_SETTLE_TIME_SHIFT, XCVR_AGC_CTRL_1_TZA_GAIN_SETTLE_TIME_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_AGC_CTRL_2 - AGC Control 2
 ******************************************************************************/

/*!
 * @brief XCVR_AGC_CTRL_2 - AGC Control 2 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_AGC_CTRL_2 register
 */
/*@{*/
#define XCVR_RD_AGC_CTRL_2(base) (XCVR_AGC_CTRL_2_REG(base))
#define XCVR_WR_AGC_CTRL_2(base, value) (XCVR_AGC_CTRL_2_REG(base) = (value))
#define XCVR_RMW_AGC_CTRL_2(base, mask, value) (XCVR_WR_AGC_CTRL_2(base, (XCVR_RD_AGC_CTRL_2(base) & ~(mask)) | (value)))
#define XCVR_SET_AGC_CTRL_2(base, value) (BME_OR32(&XCVR_AGC_CTRL_2_REG(base), (uint32_t)(value)))
#define XCVR_CLR_AGC_CTRL_2(base, value) (BME_AND32(&XCVR_AGC_CTRL_2_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_AGC_CTRL_2(base, value) (BME_XOR32(&XCVR_AGC_CTRL_2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_AGC_CTRL_2 bitfields
 */

/*!
 * @name Register XCVR_AGC_CTRL_2, field BBF_PDET_RST[0] (RW)
 *
 * BBF peak detector reset, manual control.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_2_BBF_PDET_RST field. */
#define XCVR_RD_AGC_CTRL_2_BBF_PDET_RST(base) ((XCVR_AGC_CTRL_2_REG(base) & XCVR_AGC_CTRL_2_BBF_PDET_RST_MASK) >> XCVR_AGC_CTRL_2_BBF_PDET_RST_SHIFT)
#define XCVR_BRD_AGC_CTRL_2_BBF_PDET_RST(base) (BME_UBFX32(&XCVR_AGC_CTRL_2_REG(base), XCVR_AGC_CTRL_2_BBF_PDET_RST_SHIFT, XCVR_AGC_CTRL_2_BBF_PDET_RST_WIDTH))

/*! @brief Set the BBF_PDET_RST field to a new value. */
#define XCVR_WR_AGC_CTRL_2_BBF_PDET_RST(base, value) (XCVR_RMW_AGC_CTRL_2(base, XCVR_AGC_CTRL_2_BBF_PDET_RST_MASK, XCVR_AGC_CTRL_2_BBF_PDET_RST(value)))
#define XCVR_BWR_AGC_CTRL_2_BBF_PDET_RST(base, value) (BME_BFI32(&XCVR_AGC_CTRL_2_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_2_BBF_PDET_RST_SHIFT), XCVR_AGC_CTRL_2_BBF_PDET_RST_SHIFT, XCVR_AGC_CTRL_2_BBF_PDET_RST_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_2, field TZA_PDET_RST[1] (RW)
 *
 * TZA peak detector reset, manual control.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_2_TZA_PDET_RST field. */
#define XCVR_RD_AGC_CTRL_2_TZA_PDET_RST(base) ((XCVR_AGC_CTRL_2_REG(base) & XCVR_AGC_CTRL_2_TZA_PDET_RST_MASK) >> XCVR_AGC_CTRL_2_TZA_PDET_RST_SHIFT)
#define XCVR_BRD_AGC_CTRL_2_TZA_PDET_RST(base) (BME_UBFX32(&XCVR_AGC_CTRL_2_REG(base), XCVR_AGC_CTRL_2_TZA_PDET_RST_SHIFT, XCVR_AGC_CTRL_2_TZA_PDET_RST_WIDTH))

/*! @brief Set the TZA_PDET_RST field to a new value. */
#define XCVR_WR_AGC_CTRL_2_TZA_PDET_RST(base, value) (XCVR_RMW_AGC_CTRL_2(base, XCVR_AGC_CTRL_2_TZA_PDET_RST_MASK, XCVR_AGC_CTRL_2_TZA_PDET_RST(value)))
#define XCVR_BWR_AGC_CTRL_2_TZA_PDET_RST(base, value) (BME_BFI32(&XCVR_AGC_CTRL_2_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_2_TZA_PDET_RST_SHIFT), XCVR_AGC_CTRL_2_TZA_PDET_RST_SHIFT, XCVR_AGC_CTRL_2_TZA_PDET_RST_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_2, field BBF_GAIN_SETTLE_TIME[11:4] (RW)
 *
 * Number of clocks to assert BBF peak detector reset (for automatic control).
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_2_BBF_GAIN_SETTLE_TIME field. */
#define XCVR_RD_AGC_CTRL_2_BBF_GAIN_SETTLE_TIME(base) ((XCVR_AGC_CTRL_2_REG(base) & XCVR_AGC_CTRL_2_BBF_GAIN_SETTLE_TIME_MASK) >> XCVR_AGC_CTRL_2_BBF_GAIN_SETTLE_TIME_SHIFT)
#define XCVR_BRD_AGC_CTRL_2_BBF_GAIN_SETTLE_TIME(base) (BME_UBFX32(&XCVR_AGC_CTRL_2_REG(base), XCVR_AGC_CTRL_2_BBF_GAIN_SETTLE_TIME_SHIFT, XCVR_AGC_CTRL_2_BBF_GAIN_SETTLE_TIME_WIDTH))

/*! @brief Set the BBF_GAIN_SETTLE_TIME field to a new value. */
#define XCVR_WR_AGC_CTRL_2_BBF_GAIN_SETTLE_TIME(base, value) (XCVR_RMW_AGC_CTRL_2(base, XCVR_AGC_CTRL_2_BBF_GAIN_SETTLE_TIME_MASK, XCVR_AGC_CTRL_2_BBF_GAIN_SETTLE_TIME(value)))
#define XCVR_BWR_AGC_CTRL_2_BBF_GAIN_SETTLE_TIME(base, value) (BME_BFI32(&XCVR_AGC_CTRL_2_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_2_BBF_GAIN_SETTLE_TIME_SHIFT), XCVR_AGC_CTRL_2_BBF_GAIN_SETTLE_TIME_SHIFT, XCVR_AGC_CTRL_2_BBF_GAIN_SETTLE_TIME_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_2, field BBF_PDET_THRESH_LO[14:12] (RW)
 *
 * BBF peak detect LO threshold.
 *
 * Values:
 * - 0b000 - 0.6V
 * - 0b001 - 0.675V
 * - 0b010 - 0.75V
 * - 0b011 - 0.825V
 * - 0b100 - 0.9V
 * - 0b101 - 0.975V
 * - 0b110 - 1.05V
 * - 0b111 - 1.125V
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_2_BBF_PDET_THRESH_LO field. */
#define XCVR_RD_AGC_CTRL_2_BBF_PDET_THRESH_LO(base) ((XCVR_AGC_CTRL_2_REG(base) & XCVR_AGC_CTRL_2_BBF_PDET_THRESH_LO_MASK) >> XCVR_AGC_CTRL_2_BBF_PDET_THRESH_LO_SHIFT)
#define XCVR_BRD_AGC_CTRL_2_BBF_PDET_THRESH_LO(base) (BME_UBFX32(&XCVR_AGC_CTRL_2_REG(base), XCVR_AGC_CTRL_2_BBF_PDET_THRESH_LO_SHIFT, XCVR_AGC_CTRL_2_BBF_PDET_THRESH_LO_WIDTH))

/*! @brief Set the BBF_PDET_THRESH_LO field to a new value. */
#define XCVR_WR_AGC_CTRL_2_BBF_PDET_THRESH_LO(base, value) (XCVR_RMW_AGC_CTRL_2(base, XCVR_AGC_CTRL_2_BBF_PDET_THRESH_LO_MASK, XCVR_AGC_CTRL_2_BBF_PDET_THRESH_LO(value)))
#define XCVR_BWR_AGC_CTRL_2_BBF_PDET_THRESH_LO(base, value) (BME_BFI32(&XCVR_AGC_CTRL_2_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_2_BBF_PDET_THRESH_LO_SHIFT), XCVR_AGC_CTRL_2_BBF_PDET_THRESH_LO_SHIFT, XCVR_AGC_CTRL_2_BBF_PDET_THRESH_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_2, field BBF_PDET_THRESH_HI[17:15] (RW)
 *
 * BBF peak detect HI threshold.
 *
 * Values:
 * - 0b000 - 0.6V
 * - 0b001 - 0.675V
 * - 0b010 - 0.75V
 * - 0b011 - 0.825V
 * - 0b100 - 0.9V
 * - 0b101 - 0.975V
 * - 0b110 - 1.05V
 * - 0b111 - 1.125V
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_2_BBF_PDET_THRESH_HI field. */
#define XCVR_RD_AGC_CTRL_2_BBF_PDET_THRESH_HI(base) ((XCVR_AGC_CTRL_2_REG(base) & XCVR_AGC_CTRL_2_BBF_PDET_THRESH_HI_MASK) >> XCVR_AGC_CTRL_2_BBF_PDET_THRESH_HI_SHIFT)
#define XCVR_BRD_AGC_CTRL_2_BBF_PDET_THRESH_HI(base) (BME_UBFX32(&XCVR_AGC_CTRL_2_REG(base), XCVR_AGC_CTRL_2_BBF_PDET_THRESH_HI_SHIFT, XCVR_AGC_CTRL_2_BBF_PDET_THRESH_HI_WIDTH))

/*! @brief Set the BBF_PDET_THRESH_HI field to a new value. */
#define XCVR_WR_AGC_CTRL_2_BBF_PDET_THRESH_HI(base, value) (XCVR_RMW_AGC_CTRL_2(base, XCVR_AGC_CTRL_2_BBF_PDET_THRESH_HI_MASK, XCVR_AGC_CTRL_2_BBF_PDET_THRESH_HI(value)))
#define XCVR_BWR_AGC_CTRL_2_BBF_PDET_THRESH_HI(base, value) (BME_BFI32(&XCVR_AGC_CTRL_2_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_2_BBF_PDET_THRESH_HI_SHIFT), XCVR_AGC_CTRL_2_BBF_PDET_THRESH_HI_SHIFT, XCVR_AGC_CTRL_2_BBF_PDET_THRESH_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_2, field TZA_PDET_THRESH_LO[20:18] (RW)
 *
 * TZA peak detect LO threshold.
 *
 * Values:
 * - 0b000 - 0.6V
 * - 0b001 - 0.675V
 * - 0b010 - 0.75V
 * - 0b011 - 0.825V
 * - 0b100 - 0.9V
 * - 0b101 - 0.975V
 * - 0b110 - 1.05V
 * - 0b111 - 1.125V
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_2_TZA_PDET_THRESH_LO field. */
#define XCVR_RD_AGC_CTRL_2_TZA_PDET_THRESH_LO(base) ((XCVR_AGC_CTRL_2_REG(base) & XCVR_AGC_CTRL_2_TZA_PDET_THRESH_LO_MASK) >> XCVR_AGC_CTRL_2_TZA_PDET_THRESH_LO_SHIFT)
#define XCVR_BRD_AGC_CTRL_2_TZA_PDET_THRESH_LO(base) (BME_UBFX32(&XCVR_AGC_CTRL_2_REG(base), XCVR_AGC_CTRL_2_TZA_PDET_THRESH_LO_SHIFT, XCVR_AGC_CTRL_2_TZA_PDET_THRESH_LO_WIDTH))

/*! @brief Set the TZA_PDET_THRESH_LO field to a new value. */
#define XCVR_WR_AGC_CTRL_2_TZA_PDET_THRESH_LO(base, value) (XCVR_RMW_AGC_CTRL_2(base, XCVR_AGC_CTRL_2_TZA_PDET_THRESH_LO_MASK, XCVR_AGC_CTRL_2_TZA_PDET_THRESH_LO(value)))
#define XCVR_BWR_AGC_CTRL_2_TZA_PDET_THRESH_LO(base, value) (BME_BFI32(&XCVR_AGC_CTRL_2_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_2_TZA_PDET_THRESH_LO_SHIFT), XCVR_AGC_CTRL_2_TZA_PDET_THRESH_LO_SHIFT, XCVR_AGC_CTRL_2_TZA_PDET_THRESH_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_2, field TZA_PDET_THRESH_HI[23:21] (RW)
 *
 * TZA peak detect HI threshold.
 *
 * Values:
 * - 0b000 - 0.6V
 * - 0b001 - 0.675V
 * - 0b010 - 0.75V
 * - 0b011 - 0.825V
 * - 0b100 - 0.9V
 * - 0b101 - 0.975V
 * - 0b110 - 1.05V
 * - 0b111 - 1.125V
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_2_TZA_PDET_THRESH_HI field. */
#define XCVR_RD_AGC_CTRL_2_TZA_PDET_THRESH_HI(base) ((XCVR_AGC_CTRL_2_REG(base) & XCVR_AGC_CTRL_2_TZA_PDET_THRESH_HI_MASK) >> XCVR_AGC_CTRL_2_TZA_PDET_THRESH_HI_SHIFT)
#define XCVR_BRD_AGC_CTRL_2_TZA_PDET_THRESH_HI(base) (BME_UBFX32(&XCVR_AGC_CTRL_2_REG(base), XCVR_AGC_CTRL_2_TZA_PDET_THRESH_HI_SHIFT, XCVR_AGC_CTRL_2_TZA_PDET_THRESH_HI_WIDTH))

/*! @brief Set the TZA_PDET_THRESH_HI field to a new value. */
#define XCVR_WR_AGC_CTRL_2_TZA_PDET_THRESH_HI(base, value) (XCVR_RMW_AGC_CTRL_2(base, XCVR_AGC_CTRL_2_TZA_PDET_THRESH_HI_MASK, XCVR_AGC_CTRL_2_TZA_PDET_THRESH_HI(value)))
#define XCVR_BWR_AGC_CTRL_2_TZA_PDET_THRESH_HI(base, value) (BME_BFI32(&XCVR_AGC_CTRL_2_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_2_TZA_PDET_THRESH_HI_SHIFT), XCVR_AGC_CTRL_2_TZA_PDET_THRESH_HI_SHIFT, XCVR_AGC_CTRL_2_TZA_PDET_THRESH_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_2, field AGC_FAST_EXPIRE[29:24] (RW)
 *
 * Expire time (uS) for fast AGC (1-63uS).
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_2_AGC_FAST_EXPIRE field. */
#define XCVR_RD_AGC_CTRL_2_AGC_FAST_EXPIRE(base) ((XCVR_AGC_CTRL_2_REG(base) & XCVR_AGC_CTRL_2_AGC_FAST_EXPIRE_MASK) >> XCVR_AGC_CTRL_2_AGC_FAST_EXPIRE_SHIFT)
#define XCVR_BRD_AGC_CTRL_2_AGC_FAST_EXPIRE(base) (BME_UBFX32(&XCVR_AGC_CTRL_2_REG(base), XCVR_AGC_CTRL_2_AGC_FAST_EXPIRE_SHIFT, XCVR_AGC_CTRL_2_AGC_FAST_EXPIRE_WIDTH))

/*! @brief Set the AGC_FAST_EXPIRE field to a new value. */
#define XCVR_WR_AGC_CTRL_2_AGC_FAST_EXPIRE(base, value) (XCVR_RMW_AGC_CTRL_2(base, XCVR_AGC_CTRL_2_AGC_FAST_EXPIRE_MASK, XCVR_AGC_CTRL_2_AGC_FAST_EXPIRE(value)))
#define XCVR_BWR_AGC_CTRL_2_AGC_FAST_EXPIRE(base, value) (BME_BFI32(&XCVR_AGC_CTRL_2_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_2_AGC_FAST_EXPIRE_SHIFT), XCVR_AGC_CTRL_2_AGC_FAST_EXPIRE_SHIFT, XCVR_AGC_CTRL_2_AGC_FAST_EXPIRE_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_AGC_CTRL_3 - AGC Control 3
 ******************************************************************************/

/*!
 * @brief XCVR_AGC_CTRL_3 - AGC Control 3 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_AGC_CTRL_3 register
 */
/*@{*/
#define XCVR_RD_AGC_CTRL_3(base) (XCVR_AGC_CTRL_3_REG(base))
#define XCVR_WR_AGC_CTRL_3(base, value) (XCVR_AGC_CTRL_3_REG(base) = (value))
#define XCVR_RMW_AGC_CTRL_3(base, mask, value) (XCVR_WR_AGC_CTRL_3(base, (XCVR_RD_AGC_CTRL_3(base) & ~(mask)) | (value)))
#define XCVR_SET_AGC_CTRL_3(base, value) (BME_OR32(&XCVR_AGC_CTRL_3_REG(base), (uint32_t)(value)))
#define XCVR_CLR_AGC_CTRL_3(base, value) (BME_AND32(&XCVR_AGC_CTRL_3_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_AGC_CTRL_3(base, value) (BME_XOR32(&XCVR_AGC_CTRL_3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_AGC_CTRL_3 bitfields
 */

/*!
 * @name Register XCVR_AGC_CTRL_3, field AGC_UNFREEZE_TIME[12:0] (RW)
 *
 * Time (uS) for AGC to unfreeze (1-8191uS).
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_3_AGC_UNFREEZE_TIME field. */
#define XCVR_RD_AGC_CTRL_3_AGC_UNFREEZE_TIME(base) ((XCVR_AGC_CTRL_3_REG(base) & XCVR_AGC_CTRL_3_AGC_UNFREEZE_TIME_MASK) >> XCVR_AGC_CTRL_3_AGC_UNFREEZE_TIME_SHIFT)
#define XCVR_BRD_AGC_CTRL_3_AGC_UNFREEZE_TIME(base) (BME_UBFX32(&XCVR_AGC_CTRL_3_REG(base), XCVR_AGC_CTRL_3_AGC_UNFREEZE_TIME_SHIFT, XCVR_AGC_CTRL_3_AGC_UNFREEZE_TIME_WIDTH))

/*! @brief Set the AGC_UNFREEZE_TIME field to a new value. */
#define XCVR_WR_AGC_CTRL_3_AGC_UNFREEZE_TIME(base, value) (XCVR_RMW_AGC_CTRL_3(base, XCVR_AGC_CTRL_3_AGC_UNFREEZE_TIME_MASK, XCVR_AGC_CTRL_3_AGC_UNFREEZE_TIME(value)))
#define XCVR_BWR_AGC_CTRL_3_AGC_UNFREEZE_TIME(base, value) (BME_BFI32(&XCVR_AGC_CTRL_3_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_3_AGC_UNFREEZE_TIME_SHIFT), XCVR_AGC_CTRL_3_AGC_UNFREEZE_TIME_SHIFT, XCVR_AGC_CTRL_3_AGC_UNFREEZE_TIME_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_3, field AGC_PDET_LO_DLY[15:13] (RW)
 *
 * Time (uS) to wait for pdet low to assert (1-7uS).
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_3_AGC_PDET_LO_DLY field. */
#define XCVR_RD_AGC_CTRL_3_AGC_PDET_LO_DLY(base) ((XCVR_AGC_CTRL_3_REG(base) & XCVR_AGC_CTRL_3_AGC_PDET_LO_DLY_MASK) >> XCVR_AGC_CTRL_3_AGC_PDET_LO_DLY_SHIFT)
#define XCVR_BRD_AGC_CTRL_3_AGC_PDET_LO_DLY(base) (BME_UBFX32(&XCVR_AGC_CTRL_3_REG(base), XCVR_AGC_CTRL_3_AGC_PDET_LO_DLY_SHIFT, XCVR_AGC_CTRL_3_AGC_PDET_LO_DLY_WIDTH))

/*! @brief Set the AGC_PDET_LO_DLY field to a new value. */
#define XCVR_WR_AGC_CTRL_3_AGC_PDET_LO_DLY(base, value) (XCVR_RMW_AGC_CTRL_3(base, XCVR_AGC_CTRL_3_AGC_PDET_LO_DLY_MASK, XCVR_AGC_CTRL_3_AGC_PDET_LO_DLY(value)))
#define XCVR_BWR_AGC_CTRL_3_AGC_PDET_LO_DLY(base, value) (BME_BFI32(&XCVR_AGC_CTRL_3_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_3_AGC_PDET_LO_DLY_SHIFT), XCVR_AGC_CTRL_3_AGC_PDET_LO_DLY_SHIFT, XCVR_AGC_CTRL_3_AGC_PDET_LO_DLY_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_3, field AGC_RSSI_DELT_H2S[22:16] (RW)
 *
 * RSSI delta that causes hold to slow transition.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_3_AGC_RSSI_DELT_H2S field. */
#define XCVR_RD_AGC_CTRL_3_AGC_RSSI_DELT_H2S(base) ((XCVR_AGC_CTRL_3_REG(base) & XCVR_AGC_CTRL_3_AGC_RSSI_DELT_H2S_MASK) >> XCVR_AGC_CTRL_3_AGC_RSSI_DELT_H2S_SHIFT)
#define XCVR_BRD_AGC_CTRL_3_AGC_RSSI_DELT_H2S(base) (BME_UBFX32(&XCVR_AGC_CTRL_3_REG(base), XCVR_AGC_CTRL_3_AGC_RSSI_DELT_H2S_SHIFT, XCVR_AGC_CTRL_3_AGC_RSSI_DELT_H2S_WIDTH))

/*! @brief Set the AGC_RSSI_DELT_H2S field to a new value. */
#define XCVR_WR_AGC_CTRL_3_AGC_RSSI_DELT_H2S(base, value) (XCVR_RMW_AGC_CTRL_3(base, XCVR_AGC_CTRL_3_AGC_RSSI_DELT_H2S_MASK, XCVR_AGC_CTRL_3_AGC_RSSI_DELT_H2S(value)))
#define XCVR_BWR_AGC_CTRL_3_AGC_RSSI_DELT_H2S(base, value) (BME_BFI32(&XCVR_AGC_CTRL_3_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_3_AGC_RSSI_DELT_H2S_SHIFT), XCVR_AGC_CTRL_3_AGC_RSSI_DELT_H2S_SHIFT, XCVR_AGC_CTRL_3_AGC_RSSI_DELT_H2S_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_3, field AGC_H2S_STEP_SZ[27:23] (RW)
 *
 * Step size for hold to slow jump.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_3_AGC_H2S_STEP_SZ field. */
#define XCVR_RD_AGC_CTRL_3_AGC_H2S_STEP_SZ(base) ((XCVR_AGC_CTRL_3_REG(base) & XCVR_AGC_CTRL_3_AGC_H2S_STEP_SZ_MASK) >> XCVR_AGC_CTRL_3_AGC_H2S_STEP_SZ_SHIFT)
#define XCVR_BRD_AGC_CTRL_3_AGC_H2S_STEP_SZ(base) (BME_UBFX32(&XCVR_AGC_CTRL_3_REG(base), XCVR_AGC_CTRL_3_AGC_H2S_STEP_SZ_SHIFT, XCVR_AGC_CTRL_3_AGC_H2S_STEP_SZ_WIDTH))

/*! @brief Set the AGC_H2S_STEP_SZ field to a new value. */
#define XCVR_WR_AGC_CTRL_3_AGC_H2S_STEP_SZ(base, value) (XCVR_RMW_AGC_CTRL_3(base, XCVR_AGC_CTRL_3_AGC_H2S_STEP_SZ_MASK, XCVR_AGC_CTRL_3_AGC_H2S_STEP_SZ(value)))
#define XCVR_BWR_AGC_CTRL_3_AGC_H2S_STEP_SZ(base, value) (BME_BFI32(&XCVR_AGC_CTRL_3_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_3_AGC_H2S_STEP_SZ_SHIFT), XCVR_AGC_CTRL_3_AGC_H2S_STEP_SZ_SHIFT, XCVR_AGC_CTRL_3_AGC_H2S_STEP_SZ_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_CTRL_3, field AGC_UP_STEP_SZ[31:28] (RW)
 *
 * Number of table steps for upward step
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_CTRL_3_AGC_UP_STEP_SZ field. */
#define XCVR_RD_AGC_CTRL_3_AGC_UP_STEP_SZ(base) ((XCVR_AGC_CTRL_3_REG(base) & XCVR_AGC_CTRL_3_AGC_UP_STEP_SZ_MASK) >> XCVR_AGC_CTRL_3_AGC_UP_STEP_SZ_SHIFT)
#define XCVR_BRD_AGC_CTRL_3_AGC_UP_STEP_SZ(base) (BME_UBFX32(&XCVR_AGC_CTRL_3_REG(base), XCVR_AGC_CTRL_3_AGC_UP_STEP_SZ_SHIFT, XCVR_AGC_CTRL_3_AGC_UP_STEP_SZ_WIDTH))

/*! @brief Set the AGC_UP_STEP_SZ field to a new value. */
#define XCVR_WR_AGC_CTRL_3_AGC_UP_STEP_SZ(base, value) (XCVR_RMW_AGC_CTRL_3(base, XCVR_AGC_CTRL_3_AGC_UP_STEP_SZ_MASK, XCVR_AGC_CTRL_3_AGC_UP_STEP_SZ(value)))
#define XCVR_BWR_AGC_CTRL_3_AGC_UP_STEP_SZ(base, value) (BME_BFI32(&XCVR_AGC_CTRL_3_REG(base), ((uint32_t)(value) << XCVR_AGC_CTRL_3_AGC_UP_STEP_SZ_SHIFT), XCVR_AGC_CTRL_3_AGC_UP_STEP_SZ_SHIFT, XCVR_AGC_CTRL_3_AGC_UP_STEP_SZ_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_AGC_STAT - AGC Status
 ******************************************************************************/

/*!
 * @brief XCVR_AGC_STAT - AGC Status (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_AGC_STAT register
 */
/*@{*/
#define XCVR_RD_AGC_STAT(base)   (XCVR_AGC_STAT_REG(base))
/*@}*/

/*
 * Constants & macros for individual XCVR_AGC_STAT bitfields
 */

/*!
 * @name Register XCVR_AGC_STAT, field BBF_PDET_LO_STAT[0] (RO)
 *
 * Status of BBF peak detector LO flag (1=set)
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_STAT_BBF_PDET_LO_STAT field. */
#define XCVR_RD_AGC_STAT_BBF_PDET_LO_STAT(base) ((XCVR_AGC_STAT_REG(base) & XCVR_AGC_STAT_BBF_PDET_LO_STAT_MASK) >> XCVR_AGC_STAT_BBF_PDET_LO_STAT_SHIFT)
#define XCVR_BRD_AGC_STAT_BBF_PDET_LO_STAT(base) (BME_UBFX32(&XCVR_AGC_STAT_REG(base), XCVR_AGC_STAT_BBF_PDET_LO_STAT_SHIFT, XCVR_AGC_STAT_BBF_PDET_LO_STAT_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_STAT, field BBF_PDET_HI_STAT[1] (RO)
 *
 * Status of BBF peak detector HI flag (1=set)
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_STAT_BBF_PDET_HI_STAT field. */
#define XCVR_RD_AGC_STAT_BBF_PDET_HI_STAT(base) ((XCVR_AGC_STAT_REG(base) & XCVR_AGC_STAT_BBF_PDET_HI_STAT_MASK) >> XCVR_AGC_STAT_BBF_PDET_HI_STAT_SHIFT)
#define XCVR_BRD_AGC_STAT_BBF_PDET_HI_STAT(base) (BME_UBFX32(&XCVR_AGC_STAT_REG(base), XCVR_AGC_STAT_BBF_PDET_HI_STAT_SHIFT, XCVR_AGC_STAT_BBF_PDET_HI_STAT_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_STAT, field TZA_PDET_LO_STAT[2] (RO)
 *
 * Status of TZA peak detector LO flag (1=set)
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_STAT_TZA_PDET_LO_STAT field. */
#define XCVR_RD_AGC_STAT_TZA_PDET_LO_STAT(base) ((XCVR_AGC_STAT_REG(base) & XCVR_AGC_STAT_TZA_PDET_LO_STAT_MASK) >> XCVR_AGC_STAT_TZA_PDET_LO_STAT_SHIFT)
#define XCVR_BRD_AGC_STAT_TZA_PDET_LO_STAT(base) (BME_UBFX32(&XCVR_AGC_STAT_REG(base), XCVR_AGC_STAT_TZA_PDET_LO_STAT_SHIFT, XCVR_AGC_STAT_TZA_PDET_LO_STAT_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_STAT, field TZA_PDET_HI_STAT[3] (RO)
 *
 * Status of TZA peak detector HI flag (1=set)
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_STAT_TZA_PDET_HI_STAT field. */
#define XCVR_RD_AGC_STAT_TZA_PDET_HI_STAT(base) ((XCVR_AGC_STAT_REG(base) & XCVR_AGC_STAT_TZA_PDET_HI_STAT_MASK) >> XCVR_AGC_STAT_TZA_PDET_HI_STAT_SHIFT)
#define XCVR_BRD_AGC_STAT_TZA_PDET_HI_STAT(base) (BME_UBFX32(&XCVR_AGC_STAT_REG(base), XCVR_AGC_STAT_TZA_PDET_HI_STAT_SHIFT, XCVR_AGC_STAT_TZA_PDET_HI_STAT_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_STAT, field CURR_AGC_IDX[8:4] (RO)
 *
 * Current AGC gain table index
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_STAT_CURR_AGC_IDX field. */
#define XCVR_RD_AGC_STAT_CURR_AGC_IDX(base) ((XCVR_AGC_STAT_REG(base) & XCVR_AGC_STAT_CURR_AGC_IDX_MASK) >> XCVR_AGC_STAT_CURR_AGC_IDX_SHIFT)
#define XCVR_BRD_AGC_STAT_CURR_AGC_IDX(base) (BME_UBFX32(&XCVR_AGC_STAT_REG(base), XCVR_AGC_STAT_CURR_AGC_IDX_SHIFT, XCVR_AGC_STAT_CURR_AGC_IDX_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_STAT, field AGC_FROZEN[9] (RO)
 *
 * Status of AGC freeze.
 *
 * Values:
 * - 0b0 - AGC is not frozen.
 * - 0b1 - AGC is frozen.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_STAT_AGC_FROZEN field. */
#define XCVR_RD_AGC_STAT_AGC_FROZEN(base) ((XCVR_AGC_STAT_REG(base) & XCVR_AGC_STAT_AGC_FROZEN_MASK) >> XCVR_AGC_STAT_AGC_FROZEN_SHIFT)
#define XCVR_BRD_AGC_STAT_AGC_FROZEN(base) (BME_UBFX32(&XCVR_AGC_STAT_REG(base), XCVR_AGC_STAT_AGC_FROZEN_SHIFT, XCVR_AGC_STAT_AGC_FROZEN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_STAT, field RSSI_ADC_RAW[23:16] (RO)
 *
 * Reading of ADC rssi (before adjustments)
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_STAT_RSSI_ADC_RAW field. */
#define XCVR_RD_AGC_STAT_RSSI_ADC_RAW(base) ((XCVR_AGC_STAT_REG(base) & XCVR_AGC_STAT_RSSI_ADC_RAW_MASK) >> XCVR_AGC_STAT_RSSI_ADC_RAW_SHIFT)
#define XCVR_BRD_AGC_STAT_RSSI_ADC_RAW(base) (BME_UBFX32(&XCVR_AGC_STAT_REG(base), XCVR_AGC_STAT_RSSI_ADC_RAW_SHIFT, XCVR_AGC_STAT_RSSI_ADC_RAW_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_RSSI_CTRL_0 - RSSI Control 0
 ******************************************************************************/

/*!
 * @brief XCVR_RSSI_CTRL_0 - RSSI Control 0 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_RSSI_CTRL_0 register
 */
/*@{*/
#define XCVR_RD_RSSI_CTRL_0(base) (XCVR_RSSI_CTRL_0_REG(base))
#define XCVR_WR_RSSI_CTRL_0(base, value) (XCVR_RSSI_CTRL_0_REG(base) = (value))
#define XCVR_RMW_RSSI_CTRL_0(base, mask, value) (XCVR_WR_RSSI_CTRL_0(base, (XCVR_RD_RSSI_CTRL_0(base) & ~(mask)) | (value)))
#define XCVR_SET_RSSI_CTRL_0(base, value) (BME_OR32(&XCVR_RSSI_CTRL_0_REG(base), (uint32_t)(value)))
#define XCVR_CLR_RSSI_CTRL_0(base, value) (BME_AND32(&XCVR_RSSI_CTRL_0_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_RSSI_CTRL_0(base, value) (BME_XOR32(&XCVR_RSSI_CTRL_0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_RSSI_CTRL_0 bitfields
 */

/*!
 * @name Register XCVR_RSSI_CTRL_0, field RSSI_USE_VALS[0] (RW)
 *
 * Enable use of TCA and BBF gain values programmed in registers for calculation.
 */
/*@{*/
/*! @brief Read current value of the XCVR_RSSI_CTRL_0_RSSI_USE_VALS field. */
#define XCVR_RD_RSSI_CTRL_0_RSSI_USE_VALS(base) ((XCVR_RSSI_CTRL_0_REG(base) & XCVR_RSSI_CTRL_0_RSSI_USE_VALS_MASK) >> XCVR_RSSI_CTRL_0_RSSI_USE_VALS_SHIFT)
#define XCVR_BRD_RSSI_CTRL_0_RSSI_USE_VALS(base) (BME_UBFX32(&XCVR_RSSI_CTRL_0_REG(base), XCVR_RSSI_CTRL_0_RSSI_USE_VALS_SHIFT, XCVR_RSSI_CTRL_0_RSSI_USE_VALS_WIDTH))

/*! @brief Set the RSSI_USE_VALS field to a new value. */
#define XCVR_WR_RSSI_CTRL_0_RSSI_USE_VALS(base, value) (XCVR_RMW_RSSI_CTRL_0(base, XCVR_RSSI_CTRL_0_RSSI_USE_VALS_MASK, XCVR_RSSI_CTRL_0_RSSI_USE_VALS(value)))
#define XCVR_BWR_RSSI_CTRL_0_RSSI_USE_VALS(base, value) (BME_BFI32(&XCVR_RSSI_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_RSSI_CTRL_0_RSSI_USE_VALS_SHIFT), XCVR_RSSI_CTRL_0_RSSI_USE_VALS_SHIFT, XCVR_RSSI_CTRL_0_RSSI_USE_VALS_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RSSI_CTRL_0, field RSSI_HOLD_SRC[2:1] (RW)
 *
 * Select trigger source for entering freezing RSSI measurement.
 *
 * Values:
 * - 0b00 - BTLE Preamble Detect
 * - 0b01 - Zigbee Preamble Detect
 */
/*@{*/
/*! @brief Read current value of the XCVR_RSSI_CTRL_0_RSSI_HOLD_SRC field. */
#define XCVR_RD_RSSI_CTRL_0_RSSI_HOLD_SRC(base) ((XCVR_RSSI_CTRL_0_REG(base) & XCVR_RSSI_CTRL_0_RSSI_HOLD_SRC_MASK) >> XCVR_RSSI_CTRL_0_RSSI_HOLD_SRC_SHIFT)
#define XCVR_BRD_RSSI_CTRL_0_RSSI_HOLD_SRC(base) (BME_UBFX32(&XCVR_RSSI_CTRL_0_REG(base), XCVR_RSSI_CTRL_0_RSSI_HOLD_SRC_SHIFT, XCVR_RSSI_CTRL_0_RSSI_HOLD_SRC_WIDTH))

/*! @brief Set the RSSI_HOLD_SRC field to a new value. */
#define XCVR_WR_RSSI_CTRL_0_RSSI_HOLD_SRC(base, value) (XCVR_RMW_RSSI_CTRL_0(base, XCVR_RSSI_CTRL_0_RSSI_HOLD_SRC_MASK, XCVR_RSSI_CTRL_0_RSSI_HOLD_SRC(value)))
#define XCVR_BWR_RSSI_CTRL_0_RSSI_HOLD_SRC(base, value) (BME_BFI32(&XCVR_RSSI_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_RSSI_CTRL_0_RSSI_HOLD_SRC_SHIFT), XCVR_RSSI_CTRL_0_RSSI_HOLD_SRC_SHIFT, XCVR_RSSI_CTRL_0_RSSI_HOLD_SRC_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RSSI_CTRL_0, field RSSI_HOLD_EN[3] (RW)
 *
 * Enable RSSI to freeze after hold criterion met. RSSI will still be briefly
 * held when a gain change occurs.
 */
/*@{*/
/*! @brief Read current value of the XCVR_RSSI_CTRL_0_RSSI_HOLD_EN field. */
#define XCVR_RD_RSSI_CTRL_0_RSSI_HOLD_EN(base) ((XCVR_RSSI_CTRL_0_REG(base) & XCVR_RSSI_CTRL_0_RSSI_HOLD_EN_MASK) >> XCVR_RSSI_CTRL_0_RSSI_HOLD_EN_SHIFT)
#define XCVR_BRD_RSSI_CTRL_0_RSSI_HOLD_EN(base) (BME_UBFX32(&XCVR_RSSI_CTRL_0_REG(base), XCVR_RSSI_CTRL_0_RSSI_HOLD_EN_SHIFT, XCVR_RSSI_CTRL_0_RSSI_HOLD_EN_WIDTH))

/*! @brief Set the RSSI_HOLD_EN field to a new value. */
#define XCVR_WR_RSSI_CTRL_0_RSSI_HOLD_EN(base, value) (XCVR_RMW_RSSI_CTRL_0(base, XCVR_RSSI_CTRL_0_RSSI_HOLD_EN_MASK, XCVR_RSSI_CTRL_0_RSSI_HOLD_EN(value)))
#define XCVR_BWR_RSSI_CTRL_0_RSSI_HOLD_EN(base, value) (BME_BFI32(&XCVR_RSSI_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_RSSI_CTRL_0_RSSI_HOLD_EN_SHIFT), XCVR_RSSI_CTRL_0_RSSI_HOLD_EN_SHIFT, XCVR_RSSI_CTRL_0_RSSI_HOLD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RSSI_CTRL_0, field RSSI_DEC_EN[4] (RW)
 *
 * Enable RSSI 4x decimation stage.
 */
/*@{*/
/*! @brief Read current value of the XCVR_RSSI_CTRL_0_RSSI_DEC_EN field. */
#define XCVR_RD_RSSI_CTRL_0_RSSI_DEC_EN(base) ((XCVR_RSSI_CTRL_0_REG(base) & XCVR_RSSI_CTRL_0_RSSI_DEC_EN_MASK) >> XCVR_RSSI_CTRL_0_RSSI_DEC_EN_SHIFT)
#define XCVR_BRD_RSSI_CTRL_0_RSSI_DEC_EN(base) (BME_UBFX32(&XCVR_RSSI_CTRL_0_REG(base), XCVR_RSSI_CTRL_0_RSSI_DEC_EN_SHIFT, XCVR_RSSI_CTRL_0_RSSI_DEC_EN_WIDTH))

/*! @brief Set the RSSI_DEC_EN field to a new value. */
#define XCVR_WR_RSSI_CTRL_0_RSSI_DEC_EN(base, value) (XCVR_RMW_RSSI_CTRL_0(base, XCVR_RSSI_CTRL_0_RSSI_DEC_EN_MASK, XCVR_RSSI_CTRL_0_RSSI_DEC_EN(value)))
#define XCVR_BWR_RSSI_CTRL_0_RSSI_DEC_EN(base, value) (BME_BFI32(&XCVR_RSSI_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_RSSI_CTRL_0_RSSI_DEC_EN_SHIFT), XCVR_RSSI_CTRL_0_RSSI_DEC_EN_SHIFT, XCVR_RSSI_CTRL_0_RSSI_DEC_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RSSI_CTRL_0, field RSSI_IIR_CW_WEIGHT[6:5] (RW)
 *
 * IIR filter weight for RSSI filtering of a CW input.
 *
 * Values:
 * - 0b00 - Bypass
 * - 0b01 - 1/8
 */
/*@{*/
/*! @brief Read current value of the XCVR_RSSI_CTRL_0_RSSI_IIR_CW_WEIGHT field. */
#define XCVR_RD_RSSI_CTRL_0_RSSI_IIR_CW_WEIGHT(base) ((XCVR_RSSI_CTRL_0_REG(base) & XCVR_RSSI_CTRL_0_RSSI_IIR_CW_WEIGHT_MASK) >> XCVR_RSSI_CTRL_0_RSSI_IIR_CW_WEIGHT_SHIFT)
#define XCVR_BRD_RSSI_CTRL_0_RSSI_IIR_CW_WEIGHT(base) (BME_UBFX32(&XCVR_RSSI_CTRL_0_REG(base), XCVR_RSSI_CTRL_0_RSSI_IIR_CW_WEIGHT_SHIFT, XCVR_RSSI_CTRL_0_RSSI_IIR_CW_WEIGHT_WIDTH))

/*! @brief Set the RSSI_IIR_CW_WEIGHT field to a new value. */
#define XCVR_WR_RSSI_CTRL_0_RSSI_IIR_CW_WEIGHT(base, value) (XCVR_RMW_RSSI_CTRL_0(base, XCVR_RSSI_CTRL_0_RSSI_IIR_CW_WEIGHT_MASK, XCVR_RSSI_CTRL_0_RSSI_IIR_CW_WEIGHT(value)))
#define XCVR_BWR_RSSI_CTRL_0_RSSI_IIR_CW_WEIGHT(base, value) (BME_BFI32(&XCVR_RSSI_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_RSSI_CTRL_0_RSSI_IIR_CW_WEIGHT_SHIFT), XCVR_RSSI_CTRL_0_RSSI_IIR_CW_WEIGHT_SHIFT, XCVR_RSSI_CTRL_0_RSSI_IIR_CW_WEIGHT_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RSSI_CTRL_0, field RSSI_IIR_WEIGHT[19:16] (RW)
 *
 * IIR filter weight for RSSI filtering.
 *
 * Values:
 * - 0b0000 - Bypass
 * - 0b0001 - 1/2
 */
/*@{*/
/*! @brief Read current value of the XCVR_RSSI_CTRL_0_RSSI_IIR_WEIGHT field. */
#define XCVR_RD_RSSI_CTRL_0_RSSI_IIR_WEIGHT(base) ((XCVR_RSSI_CTRL_0_REG(base) & XCVR_RSSI_CTRL_0_RSSI_IIR_WEIGHT_MASK) >> XCVR_RSSI_CTRL_0_RSSI_IIR_WEIGHT_SHIFT)
#define XCVR_BRD_RSSI_CTRL_0_RSSI_IIR_WEIGHT(base) (BME_UBFX32(&XCVR_RSSI_CTRL_0_REG(base), XCVR_RSSI_CTRL_0_RSSI_IIR_WEIGHT_SHIFT, XCVR_RSSI_CTRL_0_RSSI_IIR_WEIGHT_WIDTH))

/*! @brief Set the RSSI_IIR_WEIGHT field to a new value. */
#define XCVR_WR_RSSI_CTRL_0_RSSI_IIR_WEIGHT(base, value) (XCVR_RMW_RSSI_CTRL_0(base, XCVR_RSSI_CTRL_0_RSSI_IIR_WEIGHT_MASK, XCVR_RSSI_CTRL_0_RSSI_IIR_WEIGHT(value)))
#define XCVR_BWR_RSSI_CTRL_0_RSSI_IIR_WEIGHT(base, value) (BME_BFI32(&XCVR_RSSI_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_RSSI_CTRL_0_RSSI_IIR_WEIGHT_SHIFT), XCVR_RSSI_CTRL_0_RSSI_IIR_WEIGHT_SHIFT, XCVR_RSSI_CTRL_0_RSSI_IIR_WEIGHT_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RSSI_CTRL_0, field RSSI_ADJ[31:24] (RW)
 *
 * RSSI calculation adjustment (8-bit signed 1/4 dB).
 */
/*@{*/
/*! @brief Read current value of the XCVR_RSSI_CTRL_0_RSSI_ADJ field. */
#define XCVR_RD_RSSI_CTRL_0_RSSI_ADJ(base) ((XCVR_RSSI_CTRL_0_REG(base) & XCVR_RSSI_CTRL_0_RSSI_ADJ_MASK) >> XCVR_RSSI_CTRL_0_RSSI_ADJ_SHIFT)
#define XCVR_BRD_RSSI_CTRL_0_RSSI_ADJ(base) (BME_UBFX32(&XCVR_RSSI_CTRL_0_REG(base), XCVR_RSSI_CTRL_0_RSSI_ADJ_SHIFT, XCVR_RSSI_CTRL_0_RSSI_ADJ_WIDTH))

/*! @brief Set the RSSI_ADJ field to a new value. */
#define XCVR_WR_RSSI_CTRL_0_RSSI_ADJ(base, value) (XCVR_RMW_RSSI_CTRL_0(base, XCVR_RSSI_CTRL_0_RSSI_ADJ_MASK, XCVR_RSSI_CTRL_0_RSSI_ADJ(value)))
#define XCVR_BWR_RSSI_CTRL_0_RSSI_ADJ(base, value) (BME_BFI32(&XCVR_RSSI_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_RSSI_CTRL_0_RSSI_ADJ_SHIFT), XCVR_RSSI_CTRL_0_RSSI_ADJ_SHIFT, XCVR_RSSI_CTRL_0_RSSI_ADJ_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_RSSI_CTRL_1 - RSSI Control 1
 ******************************************************************************/

/*!
 * @brief XCVR_RSSI_CTRL_1 - RSSI Control 1 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_RSSI_CTRL_1 register
 */
/*@{*/
#define XCVR_RD_RSSI_CTRL_1(base) (XCVR_RSSI_CTRL_1_REG(base))
#define XCVR_WR_RSSI_CTRL_1(base, value) (XCVR_RSSI_CTRL_1_REG(base) = (value))
#define XCVR_RMW_RSSI_CTRL_1(base, mask, value) (XCVR_WR_RSSI_CTRL_1(base, (XCVR_RD_RSSI_CTRL_1(base) & ~(mask)) | (value)))
#define XCVR_SET_RSSI_CTRL_1(base, value) (BME_OR32(&XCVR_RSSI_CTRL_1_REG(base), (uint32_t)(value)))
#define XCVR_CLR_RSSI_CTRL_1(base, value) (BME_AND32(&XCVR_RSSI_CTRL_1_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_RSSI_CTRL_1(base, value) (BME_XOR32(&XCVR_RSSI_CTRL_1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_RSSI_CTRL_1 bitfields
 */

/*!
 * @name Register XCVR_RSSI_CTRL_1, field RSSI_ED_THRESH0[7:0] (RW)
 *
 * Threshold for setting energy detect 0 to scanner.
 */
/*@{*/
/*! @brief Read current value of the XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0 field. */
#define XCVR_RD_RSSI_CTRL_1_RSSI_ED_THRESH0(base) ((XCVR_RSSI_CTRL_1_REG(base) & XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_MASK) >> XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_SHIFT)
#define XCVR_BRD_RSSI_CTRL_1_RSSI_ED_THRESH0(base) (BME_UBFX32(&XCVR_RSSI_CTRL_1_REG(base), XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_SHIFT, XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_WIDTH))

/*! @brief Set the RSSI_ED_THRESH0 field to a new value. */
#define XCVR_WR_RSSI_CTRL_1_RSSI_ED_THRESH0(base, value) (XCVR_RMW_RSSI_CTRL_1(base, XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_MASK, XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0(value)))
#define XCVR_BWR_RSSI_CTRL_1_RSSI_ED_THRESH0(base, value) (BME_BFI32(&XCVR_RSSI_CTRL_1_REG(base), ((uint32_t)(value) << XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_SHIFT), XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_SHIFT, XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RSSI_CTRL_1, field RSSI_ED_THRESH1[15:8] (RW)
 *
 * Threshold for setting energy detect 1 to scanner.
 */
/*@{*/
/*! @brief Read current value of the XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1 field. */
#define XCVR_RD_RSSI_CTRL_1_RSSI_ED_THRESH1(base) ((XCVR_RSSI_CTRL_1_REG(base) & XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_MASK) >> XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_SHIFT)
#define XCVR_BRD_RSSI_CTRL_1_RSSI_ED_THRESH1(base) (BME_UBFX32(&XCVR_RSSI_CTRL_1_REG(base), XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_SHIFT, XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_WIDTH))

/*! @brief Set the RSSI_ED_THRESH1 field to a new value. */
#define XCVR_WR_RSSI_CTRL_1_RSSI_ED_THRESH1(base, value) (XCVR_RMW_RSSI_CTRL_1(base, XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_MASK, XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1(value)))
#define XCVR_BWR_RSSI_CTRL_1_RSSI_ED_THRESH1(base, value) (BME_BFI32(&XCVR_RSSI_CTRL_1_REG(base), ((uint32_t)(value) << XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_SHIFT), XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_SHIFT, XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RSSI_CTRL_1, field RSSI_ED_THRESH0_H[19:16] (RW)
 *
 * ED hysteresis window size.
 */
/*@{*/
/*! @brief Read current value of the XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_H field. */
#define XCVR_RD_RSSI_CTRL_1_RSSI_ED_THRESH0_H(base) ((XCVR_RSSI_CTRL_1_REG(base) & XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_H_MASK) >> XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_H_SHIFT)
#define XCVR_BRD_RSSI_CTRL_1_RSSI_ED_THRESH0_H(base) (BME_UBFX32(&XCVR_RSSI_CTRL_1_REG(base), XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_H_SHIFT, XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_H_WIDTH))

/*! @brief Set the RSSI_ED_THRESH0_H field to a new value. */
#define XCVR_WR_RSSI_CTRL_1_RSSI_ED_THRESH0_H(base, value) (XCVR_RMW_RSSI_CTRL_1(base, XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_H_MASK, XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_H(value)))
#define XCVR_BWR_RSSI_CTRL_1_RSSI_ED_THRESH0_H(base, value) (BME_BFI32(&XCVR_RSSI_CTRL_1_REG(base), ((uint32_t)(value) << XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_H_SHIFT), XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_H_SHIFT, XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_H_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RSSI_CTRL_1, field RSSI_ED_THRESH1_H[23:20] (RW)
 *
 * ED hysteresis window size.
 */
/*@{*/
/*! @brief Read current value of the XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_H field. */
#define XCVR_RD_RSSI_CTRL_1_RSSI_ED_THRESH1_H(base) ((XCVR_RSSI_CTRL_1_REG(base) & XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_H_MASK) >> XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_H_SHIFT)
#define XCVR_BRD_RSSI_CTRL_1_RSSI_ED_THRESH1_H(base) (BME_UBFX32(&XCVR_RSSI_CTRL_1_REG(base), XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_H_SHIFT, XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_H_WIDTH))

/*! @brief Set the RSSI_ED_THRESH1_H field to a new value. */
#define XCVR_WR_RSSI_CTRL_1_RSSI_ED_THRESH1_H(base, value) (XCVR_RMW_RSSI_CTRL_1(base, XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_H_MASK, XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_H(value)))
#define XCVR_BWR_RSSI_CTRL_1_RSSI_ED_THRESH1_H(base, value) (BME_BFI32(&XCVR_RSSI_CTRL_1_REG(base), ((uint32_t)(value) << XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_H_SHIFT), XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_H_SHIFT, XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_H_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RSSI_CTRL_1, field RSSI_OUT[31:24] (RO)
 *
 * RSSI output (8-bit signed).
 */
/*@{*/
/*! @brief Read current value of the XCVR_RSSI_CTRL_1_RSSI_OUT field. */
#define XCVR_RD_RSSI_CTRL_1_RSSI_OUT(base) ((XCVR_RSSI_CTRL_1_REG(base) & XCVR_RSSI_CTRL_1_RSSI_OUT_MASK) >> XCVR_RSSI_CTRL_1_RSSI_OUT_SHIFT)
#define XCVR_BRD_RSSI_CTRL_1_RSSI_OUT(base) (BME_UBFX32(&XCVR_RSSI_CTRL_1_REG(base), XCVR_RSSI_CTRL_1_RSSI_OUT_SHIFT, XCVR_RSSI_CTRL_1_RSSI_OUT_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DCOC_CTRL_0 - DCOC Control 0
 ******************************************************************************/

/*!
 * @brief XCVR_DCOC_CTRL_0 - DCOC Control 0 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_DCOC_CTRL_0 register
 */
/*@{*/
#define XCVR_RD_DCOC_CTRL_0(base) (XCVR_DCOC_CTRL_0_REG(base))
#define XCVR_WR_DCOC_CTRL_0(base, value) (XCVR_DCOC_CTRL_0_REG(base) = (value))
#define XCVR_RMW_DCOC_CTRL_0(base, mask, value) (XCVR_WR_DCOC_CTRL_0(base, (XCVR_RD_DCOC_CTRL_0(base) & ~(mask)) | (value)))
#define XCVR_SET_DCOC_CTRL_0(base, value) (BME_OR32(&XCVR_DCOC_CTRL_0_REG(base), (uint32_t)(value)))
#define XCVR_CLR_DCOC_CTRL_0(base, value) (BME_AND32(&XCVR_DCOC_CTRL_0_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_DCOC_CTRL_0(base, value) (BME_XOR32(&XCVR_DCOC_CTRL_0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_DCOC_CTRL_0 bitfields
 */

/*!
 * @name Register XCVR_DCOC_CTRL_0, field DCOC_MAN[1] (RW)
 *
 * If the manual override bit is set, it forces the DCOC to use the DAC and
 * digital correction values from registers XCVR_DCOC_CTRL_3 and XCVR_DCOC_CTRL_4,
 * respectively.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_0_DCOC_MAN field. */
#define XCVR_RD_DCOC_CTRL_0_DCOC_MAN(base) ((XCVR_DCOC_CTRL_0_REG(base) & XCVR_DCOC_CTRL_0_DCOC_MAN_MASK) >> XCVR_DCOC_CTRL_0_DCOC_MAN_SHIFT)
#define XCVR_BRD_DCOC_CTRL_0_DCOC_MAN(base) (BME_UBFX32(&XCVR_DCOC_CTRL_0_REG(base), XCVR_DCOC_CTRL_0_DCOC_MAN_SHIFT, XCVR_DCOC_CTRL_0_DCOC_MAN_WIDTH))

/*! @brief Set the DCOC_MAN field to a new value. */
#define XCVR_WR_DCOC_CTRL_0_DCOC_MAN(base, value) (XCVR_RMW_DCOC_CTRL_0(base, XCVR_DCOC_CTRL_0_DCOC_MAN_MASK, XCVR_DCOC_CTRL_0_DCOC_MAN(value)))
#define XCVR_BWR_DCOC_CTRL_0_DCOC_MAN(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_0_DCOC_MAN_SHIFT), XCVR_DCOC_CTRL_0_DCOC_MAN_SHIFT, XCVR_DCOC_CTRL_0_DCOC_MAN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CTRL_0, field DCOC_TRACK_EN[3] (RW)
 *
 * Enables the DCOC tracking estimator to correct the DC offset. Can be used
 * with or without DCOC calibration (RX_DCOC_CAL_EN).
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_0_DCOC_TRACK_EN field. */
#define XCVR_RD_DCOC_CTRL_0_DCOC_TRACK_EN(base) ((XCVR_DCOC_CTRL_0_REG(base) & XCVR_DCOC_CTRL_0_DCOC_TRACK_EN_MASK) >> XCVR_DCOC_CTRL_0_DCOC_TRACK_EN_SHIFT)
#define XCVR_BRD_DCOC_CTRL_0_DCOC_TRACK_EN(base) (BME_UBFX32(&XCVR_DCOC_CTRL_0_REG(base), XCVR_DCOC_CTRL_0_DCOC_TRACK_EN_SHIFT, XCVR_DCOC_CTRL_0_DCOC_TRACK_EN_WIDTH))

/*! @brief Set the DCOC_TRACK_EN field to a new value. */
#define XCVR_WR_DCOC_CTRL_0_DCOC_TRACK_EN(base, value) (XCVR_RMW_DCOC_CTRL_0(base, XCVR_DCOC_CTRL_0_DCOC_TRACK_EN_MASK, XCVR_DCOC_CTRL_0_DCOC_TRACK_EN(value)))
#define XCVR_BWR_DCOC_CTRL_0_DCOC_TRACK_EN(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_0_DCOC_TRACK_EN_SHIFT), XCVR_DCOC_CTRL_0_DCOC_TRACK_EN_SHIFT, XCVR_DCOC_CTRL_0_DCOC_TRACK_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CTRL_0, field DCOC_CORRECT_EN[4] (RW)
 *
 * Enables the DCOC to use the TZA and BBA DACs to correct the DC offset.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_0_DCOC_CORRECT_EN field. */
#define XCVR_RD_DCOC_CTRL_0_DCOC_CORRECT_EN(base) ((XCVR_DCOC_CTRL_0_REG(base) & XCVR_DCOC_CTRL_0_DCOC_CORRECT_EN_MASK) >> XCVR_DCOC_CTRL_0_DCOC_CORRECT_EN_SHIFT)
#define XCVR_BRD_DCOC_CTRL_0_DCOC_CORRECT_EN(base) (BME_UBFX32(&XCVR_DCOC_CTRL_0_REG(base), XCVR_DCOC_CTRL_0_DCOC_CORRECT_EN_SHIFT, XCVR_DCOC_CTRL_0_DCOC_CORRECT_EN_WIDTH))

/*! @brief Set the DCOC_CORRECT_EN field to a new value. */
#define XCVR_WR_DCOC_CTRL_0_DCOC_CORRECT_EN(base, value) (XCVR_RMW_DCOC_CTRL_0(base, XCVR_DCOC_CTRL_0_DCOC_CORRECT_EN_MASK, XCVR_DCOC_CTRL_0_DCOC_CORRECT_EN(value)))
#define XCVR_BWR_DCOC_CTRL_0_DCOC_CORRECT_EN(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_0_DCOC_CORRECT_EN_SHIFT), XCVR_DCOC_CTRL_0_DCOC_CORRECT_EN_SHIFT, XCVR_DCOC_CTRL_0_DCOC_CORRECT_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CTRL_0, field DCOC_SIGN_SCALE_IDX[6:5] (RW)
 *
 * DCOC Sign Scaling. Sign()-based scaling factor used in the DCOC tracking
 * estimator. Used when DCOC_TRACK_EN=1.
 *
 * Values:
 * - 0b00 - 1/4
 * - 0b01 - 1/8
 * - 0b10 - 1/16
 * - 0b11 - 1/32
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_0_DCOC_SIGN_SCALE_IDX field. */
#define XCVR_RD_DCOC_CTRL_0_DCOC_SIGN_SCALE_IDX(base) ((XCVR_DCOC_CTRL_0_REG(base) & XCVR_DCOC_CTRL_0_DCOC_SIGN_SCALE_IDX_MASK) >> XCVR_DCOC_CTRL_0_DCOC_SIGN_SCALE_IDX_SHIFT)
#define XCVR_BRD_DCOC_CTRL_0_DCOC_SIGN_SCALE_IDX(base) (BME_UBFX32(&XCVR_DCOC_CTRL_0_REG(base), XCVR_DCOC_CTRL_0_DCOC_SIGN_SCALE_IDX_SHIFT, XCVR_DCOC_CTRL_0_DCOC_SIGN_SCALE_IDX_WIDTH))

/*! @brief Set the DCOC_SIGN_SCALE_IDX field to a new value. */
#define XCVR_WR_DCOC_CTRL_0_DCOC_SIGN_SCALE_IDX(base, value) (XCVR_RMW_DCOC_CTRL_0(base, XCVR_DCOC_CTRL_0_DCOC_SIGN_SCALE_IDX_MASK, XCVR_DCOC_CTRL_0_DCOC_SIGN_SCALE_IDX(value)))
#define XCVR_BWR_DCOC_CTRL_0_DCOC_SIGN_SCALE_IDX(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_0_DCOC_SIGN_SCALE_IDX_SHIFT), XCVR_DCOC_CTRL_0_DCOC_SIGN_SCALE_IDX_SHIFT, XCVR_DCOC_CTRL_0_DCOC_SIGN_SCALE_IDX_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CTRL_0, field DCOC_ALPHAC_SCALE_IDX[9:8] (RW)
 *
 * DCOC Alpha-C Scaling. I/Q center stepsize used in the DCOC tracking
 * estimator. Used when DCOC_TRACK_EN=1.
 *
 * Values:
 * - 0b00 - 1/2
 * - 0b01 - 1/4
 * - 0b10 - 1/8
 * - 0b11 - 1/16
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_0_DCOC_ALPHAC_SCALE_IDX field. */
#define XCVR_RD_DCOC_CTRL_0_DCOC_ALPHAC_SCALE_IDX(base) ((XCVR_DCOC_CTRL_0_REG(base) & XCVR_DCOC_CTRL_0_DCOC_ALPHAC_SCALE_IDX_MASK) >> XCVR_DCOC_CTRL_0_DCOC_ALPHAC_SCALE_IDX_SHIFT)
#define XCVR_BRD_DCOC_CTRL_0_DCOC_ALPHAC_SCALE_IDX(base) (BME_UBFX32(&XCVR_DCOC_CTRL_0_REG(base), XCVR_DCOC_CTRL_0_DCOC_ALPHAC_SCALE_IDX_SHIFT, XCVR_DCOC_CTRL_0_DCOC_ALPHAC_SCALE_IDX_WIDTH))

/*! @brief Set the DCOC_ALPHAC_SCALE_IDX field to a new value. */
#define XCVR_WR_DCOC_CTRL_0_DCOC_ALPHAC_SCALE_IDX(base, value) (XCVR_RMW_DCOC_CTRL_0(base, XCVR_DCOC_CTRL_0_DCOC_ALPHAC_SCALE_IDX_MASK, XCVR_DCOC_CTRL_0_DCOC_ALPHAC_SCALE_IDX(value)))
#define XCVR_BWR_DCOC_CTRL_0_DCOC_ALPHAC_SCALE_IDX(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_0_DCOC_ALPHAC_SCALE_IDX_SHIFT), XCVR_DCOC_CTRL_0_DCOC_ALPHAC_SCALE_IDX_SHIFT, XCVR_DCOC_CTRL_0_DCOC_ALPHAC_SCALE_IDX_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CTRL_0, field DCOC_ALPHA_RADIUS_IDX[14:12] (RW)
 *
 * DCOC Alpha-R Scaling. Radius stepsize used in the DCOC tracking estimator.
 * Used when DCOC_TRACK_EN=1.
 *
 * Values:
 * - 0b000 - 1
 * - 0b001 - 1/2
 * - 0b010 - 1/4
 * - 0b011 - 1/8
 * - 0b100 - 1/16
 * - 0b101 - 1/32
 * - 0b110 - 1/64
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_0_DCOC_ALPHA_RADIUS_IDX field. */
#define XCVR_RD_DCOC_CTRL_0_DCOC_ALPHA_RADIUS_IDX(base) ((XCVR_DCOC_CTRL_0_REG(base) & XCVR_DCOC_CTRL_0_DCOC_ALPHA_RADIUS_IDX_MASK) >> XCVR_DCOC_CTRL_0_DCOC_ALPHA_RADIUS_IDX_SHIFT)
#define XCVR_BRD_DCOC_CTRL_0_DCOC_ALPHA_RADIUS_IDX(base) (BME_UBFX32(&XCVR_DCOC_CTRL_0_REG(base), XCVR_DCOC_CTRL_0_DCOC_ALPHA_RADIUS_IDX_SHIFT, XCVR_DCOC_CTRL_0_DCOC_ALPHA_RADIUS_IDX_WIDTH))

/*! @brief Set the DCOC_ALPHA_RADIUS_IDX field to a new value. */
#define XCVR_WR_DCOC_CTRL_0_DCOC_ALPHA_RADIUS_IDX(base, value) (XCVR_RMW_DCOC_CTRL_0(base, XCVR_DCOC_CTRL_0_DCOC_ALPHA_RADIUS_IDX_MASK, XCVR_DCOC_CTRL_0_DCOC_ALPHA_RADIUS_IDX(value)))
#define XCVR_BWR_DCOC_CTRL_0_DCOC_ALPHA_RADIUS_IDX(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_0_DCOC_ALPHA_RADIUS_IDX_SHIFT), XCVR_DCOC_CTRL_0_DCOC_ALPHA_RADIUS_IDX_SHIFT, XCVR_DCOC_CTRL_0_DCOC_ALPHA_RADIUS_IDX_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CTRL_0, field DCOC_CAL_DURATION[19:15] (RW)
 *
 * Duration (in uS) of a calibration (1-31uS). A value of 0 should never be used.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_0_DCOC_CAL_DURATION field. */
#define XCVR_RD_DCOC_CTRL_0_DCOC_CAL_DURATION(base) ((XCVR_DCOC_CTRL_0_REG(base) & XCVR_DCOC_CTRL_0_DCOC_CAL_DURATION_MASK) >> XCVR_DCOC_CTRL_0_DCOC_CAL_DURATION_SHIFT)
#define XCVR_BRD_DCOC_CTRL_0_DCOC_CAL_DURATION(base) (BME_UBFX32(&XCVR_DCOC_CTRL_0_REG(base), XCVR_DCOC_CTRL_0_DCOC_CAL_DURATION_SHIFT, XCVR_DCOC_CTRL_0_DCOC_CAL_DURATION_WIDTH))

/*! @brief Set the DCOC_CAL_DURATION field to a new value. */
#define XCVR_WR_DCOC_CTRL_0_DCOC_CAL_DURATION(base, value) (XCVR_RMW_DCOC_CTRL_0(base, XCVR_DCOC_CTRL_0_DCOC_CAL_DURATION_MASK, XCVR_DCOC_CTRL_0_DCOC_CAL_DURATION(value)))
#define XCVR_BWR_DCOC_CTRL_0_DCOC_CAL_DURATION(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_0_DCOC_CAL_DURATION_SHIFT), XCVR_DCOC_CTRL_0_DCOC_CAL_DURATION_SHIFT, XCVR_DCOC_CTRL_0_DCOC_CAL_DURATION_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CTRL_0, field DCOC_CORR_DLY[24:20] (RW)
 *
 * Wait time (in uS) between corrections (1-31uS). A value of 0 should never be
 * used.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_0_DCOC_CORR_DLY field. */
#define XCVR_RD_DCOC_CTRL_0_DCOC_CORR_DLY(base) ((XCVR_DCOC_CTRL_0_REG(base) & XCVR_DCOC_CTRL_0_DCOC_CORR_DLY_MASK) >> XCVR_DCOC_CTRL_0_DCOC_CORR_DLY_SHIFT)
#define XCVR_BRD_DCOC_CTRL_0_DCOC_CORR_DLY(base) (BME_UBFX32(&XCVR_DCOC_CTRL_0_REG(base), XCVR_DCOC_CTRL_0_DCOC_CORR_DLY_SHIFT, XCVR_DCOC_CTRL_0_DCOC_CORR_DLY_WIDTH))

/*! @brief Set the DCOC_CORR_DLY field to a new value. */
#define XCVR_WR_DCOC_CTRL_0_DCOC_CORR_DLY(base, value) (XCVR_RMW_DCOC_CTRL_0(base, XCVR_DCOC_CTRL_0_DCOC_CORR_DLY_MASK, XCVR_DCOC_CTRL_0_DCOC_CORR_DLY(value)))
#define XCVR_BWR_DCOC_CTRL_0_DCOC_CORR_DLY(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_0_DCOC_CORR_DLY_SHIFT), XCVR_DCOC_CTRL_0_DCOC_CORR_DLY_SHIFT, XCVR_DCOC_CTRL_0_DCOC_CORR_DLY_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CTRL_0, field DCOC_CORR_HOLD_TIME[31:25] (RW)
 *
 * Delay (in uS) from last gain change to freezing DC correction (1-127uS,
 * 127=never freeze). A value of 0 should never be used.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_0_DCOC_CORR_HOLD_TIME field. */
#define XCVR_RD_DCOC_CTRL_0_DCOC_CORR_HOLD_TIME(base) ((XCVR_DCOC_CTRL_0_REG(base) & XCVR_DCOC_CTRL_0_DCOC_CORR_HOLD_TIME_MASK) >> XCVR_DCOC_CTRL_0_DCOC_CORR_HOLD_TIME_SHIFT)
#define XCVR_BRD_DCOC_CTRL_0_DCOC_CORR_HOLD_TIME(base) (BME_UBFX32(&XCVR_DCOC_CTRL_0_REG(base), XCVR_DCOC_CTRL_0_DCOC_CORR_HOLD_TIME_SHIFT, XCVR_DCOC_CTRL_0_DCOC_CORR_HOLD_TIME_WIDTH))

/*! @brief Set the DCOC_CORR_HOLD_TIME field to a new value. */
#define XCVR_WR_DCOC_CTRL_0_DCOC_CORR_HOLD_TIME(base, value) (XCVR_RMW_DCOC_CTRL_0(base, XCVR_DCOC_CTRL_0_DCOC_CORR_HOLD_TIME_MASK, XCVR_DCOC_CTRL_0_DCOC_CORR_HOLD_TIME(value)))
#define XCVR_BWR_DCOC_CTRL_0_DCOC_CORR_HOLD_TIME(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_0_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_0_DCOC_CORR_HOLD_TIME_SHIFT), XCVR_DCOC_CTRL_0_DCOC_CORR_HOLD_TIME_SHIFT, XCVR_DCOC_CTRL_0_DCOC_CORR_HOLD_TIME_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DCOC_CTRL_1 - DCOC Control 1
 ******************************************************************************/

/*!
 * @brief XCVR_DCOC_CTRL_1 - DCOC Control 1 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_DCOC_CTRL_1 register
 */
/*@{*/
#define XCVR_RD_DCOC_CTRL_1(base) (XCVR_DCOC_CTRL_1_REG(base))
#define XCVR_WR_DCOC_CTRL_1(base, value) (XCVR_DCOC_CTRL_1_REG(base) = (value))
#define XCVR_RMW_DCOC_CTRL_1(base, mask, value) (XCVR_WR_DCOC_CTRL_1(base, (XCVR_RD_DCOC_CTRL_1(base) & ~(mask)) | (value)))
#define XCVR_SET_DCOC_CTRL_1(base, value) (BME_OR32(&XCVR_DCOC_CTRL_1_REG(base), (uint32_t)(value)))
#define XCVR_CLR_DCOC_CTRL_1(base, value) (BME_AND32(&XCVR_DCOC_CTRL_1_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_DCOC_CTRL_1(base, value) (BME_XOR32(&XCVR_DCOC_CTRL_1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_DCOC_CTRL_1 bitfields
 */

/*!
 * @name Register XCVR_DCOC_CTRL_1, field BBF_DCOC_STEP[8:0] (RW)
 *
 * DCOC BBF Step Size (format: 6.3). The nominal value for this is the DAC
 * resolution (1.2/2^6= 18.7mV) times AGC gain of -1.7dB ( 10^(-1.7/20)=0.822) times
 * an AGC mV to quantization scaling factor (2^11/1000 = 2.048), which is 31.57.
 * This value is stored in the register with 3 fractional bits, so use
 * round(31.57*2^3) = 253 decimal.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_1_BBF_DCOC_STEP field. */
#define XCVR_RD_DCOC_CTRL_1_BBF_DCOC_STEP(base) ((XCVR_DCOC_CTRL_1_REG(base) & XCVR_DCOC_CTRL_1_BBF_DCOC_STEP_MASK) >> XCVR_DCOC_CTRL_1_BBF_DCOC_STEP_SHIFT)
#define XCVR_BRD_DCOC_CTRL_1_BBF_DCOC_STEP(base) (BME_UBFX32(&XCVR_DCOC_CTRL_1_REG(base), XCVR_DCOC_CTRL_1_BBF_DCOC_STEP_SHIFT, XCVR_DCOC_CTRL_1_BBF_DCOC_STEP_WIDTH))

/*! @brief Set the BBF_DCOC_STEP field to a new value. */
#define XCVR_WR_DCOC_CTRL_1_BBF_DCOC_STEP(base, value) (XCVR_RMW_DCOC_CTRL_1(base, XCVR_DCOC_CTRL_1_BBF_DCOC_STEP_MASK, XCVR_DCOC_CTRL_1_BBF_DCOC_STEP(value)))
#define XCVR_BWR_DCOC_CTRL_1_BBF_DCOC_STEP(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_1_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_1_BBF_DCOC_STEP_SHIFT), XCVR_DCOC_CTRL_1_BBF_DCOC_STEP_SHIFT, XCVR_DCOC_CTRL_1_BBF_DCOC_STEP_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CTRL_1, field TRACK_FROM_ZERO[24] (RW)
 *
 * Selects whether the tracking estimator resets its DC estimate on every AGC
 * gain change to zero or uses the current I/Q sample.
 *
 * Values:
 * - 0b0 - Track from current I/Q sample.
 * - 0b1 - Track from zero.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_1_TRACK_FROM_ZERO field. */
#define XCVR_RD_DCOC_CTRL_1_TRACK_FROM_ZERO(base) ((XCVR_DCOC_CTRL_1_REG(base) & XCVR_DCOC_CTRL_1_TRACK_FROM_ZERO_MASK) >> XCVR_DCOC_CTRL_1_TRACK_FROM_ZERO_SHIFT)
#define XCVR_BRD_DCOC_CTRL_1_TRACK_FROM_ZERO(base) (BME_UBFX32(&XCVR_DCOC_CTRL_1_REG(base), XCVR_DCOC_CTRL_1_TRACK_FROM_ZERO_SHIFT, XCVR_DCOC_CTRL_1_TRACK_FROM_ZERO_WIDTH))

/*! @brief Set the TRACK_FROM_ZERO field to a new value. */
#define XCVR_WR_DCOC_CTRL_1_TRACK_FROM_ZERO(base, value) (XCVR_RMW_DCOC_CTRL_1(base, XCVR_DCOC_CTRL_1_TRACK_FROM_ZERO_MASK, XCVR_DCOC_CTRL_1_TRACK_FROM_ZERO(value)))
#define XCVR_BWR_DCOC_CTRL_1_TRACK_FROM_ZERO(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_1_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_1_TRACK_FROM_ZERO_SHIFT), XCVR_DCOC_CTRL_1_TRACK_FROM_ZERO_SHIFT, XCVR_DCOC_CTRL_1_TRACK_FROM_ZERO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CTRL_1, field BBA_CORR_POL[25] (RW)
 *
 * Selects polarity of BBA corrections.
 *
 * Values:
 * - 0b0 - Normal polarity.
 * - 0b1 - Negative polarity. This should be set if the ADC output is inverted,
 *     or if the BBA DACs were implemented with negative polarity.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_1_BBA_CORR_POL field. */
#define XCVR_RD_DCOC_CTRL_1_BBA_CORR_POL(base) ((XCVR_DCOC_CTRL_1_REG(base) & XCVR_DCOC_CTRL_1_BBA_CORR_POL_MASK) >> XCVR_DCOC_CTRL_1_BBA_CORR_POL_SHIFT)
#define XCVR_BRD_DCOC_CTRL_1_BBA_CORR_POL(base) (BME_UBFX32(&XCVR_DCOC_CTRL_1_REG(base), XCVR_DCOC_CTRL_1_BBA_CORR_POL_SHIFT, XCVR_DCOC_CTRL_1_BBA_CORR_POL_WIDTH))

/*! @brief Set the BBA_CORR_POL field to a new value. */
#define XCVR_WR_DCOC_CTRL_1_BBA_CORR_POL(base, value) (XCVR_RMW_DCOC_CTRL_1(base, XCVR_DCOC_CTRL_1_BBA_CORR_POL_MASK, XCVR_DCOC_CTRL_1_BBA_CORR_POL(value)))
#define XCVR_BWR_DCOC_CTRL_1_BBA_CORR_POL(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_1_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_1_BBA_CORR_POL_SHIFT), XCVR_DCOC_CTRL_1_BBA_CORR_POL_SHIFT, XCVR_DCOC_CTRL_1_BBA_CORR_POL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CTRL_1, field TZA_CORR_POL[26] (RW)
 *
 * Selects polarity of TZA corrections.
 *
 * Values:
 * - 0b0 - Normal polarity.
 * - 0b1 - Negative polarity. This should be set if the ADC output is inverted,
 *     or if the TZA DACs were implemented with negative polarity.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_1_TZA_CORR_POL field. */
#define XCVR_RD_DCOC_CTRL_1_TZA_CORR_POL(base) ((XCVR_DCOC_CTRL_1_REG(base) & XCVR_DCOC_CTRL_1_TZA_CORR_POL_MASK) >> XCVR_DCOC_CTRL_1_TZA_CORR_POL_SHIFT)
#define XCVR_BRD_DCOC_CTRL_1_TZA_CORR_POL(base) (BME_UBFX32(&XCVR_DCOC_CTRL_1_REG(base), XCVR_DCOC_CTRL_1_TZA_CORR_POL_SHIFT, XCVR_DCOC_CTRL_1_TZA_CORR_POL_WIDTH))

/*! @brief Set the TZA_CORR_POL field to a new value. */
#define XCVR_WR_DCOC_CTRL_1_TZA_CORR_POL(base, value) (XCVR_RMW_DCOC_CTRL_1(base, XCVR_DCOC_CTRL_1_TZA_CORR_POL_MASK, XCVR_DCOC_CTRL_1_TZA_CORR_POL(value)))
#define XCVR_BWR_DCOC_CTRL_1_TZA_CORR_POL(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_1_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_1_TZA_CORR_POL_SHIFT), XCVR_DCOC_CTRL_1_TZA_CORR_POL_SHIFT, XCVR_DCOC_CTRL_1_TZA_CORR_POL_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DCOC_CTRL_2 - DCOC Control 2
 ******************************************************************************/

/*!
 * @brief XCVR_DCOC_CTRL_2 - DCOC Control 2 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_DCOC_CTRL_2 register
 */
/*@{*/
#define XCVR_RD_DCOC_CTRL_2(base) (XCVR_DCOC_CTRL_2_REG(base))
#define XCVR_WR_DCOC_CTRL_2(base, value) (XCVR_DCOC_CTRL_2_REG(base) = (value))
#define XCVR_RMW_DCOC_CTRL_2(base, mask, value) (XCVR_WR_DCOC_CTRL_2(base, (XCVR_RD_DCOC_CTRL_2(base) & ~(mask)) | (value)))
#define XCVR_SET_DCOC_CTRL_2(base, value) (BME_OR32(&XCVR_DCOC_CTRL_2_REG(base), (uint32_t)(value)))
#define XCVR_CLR_DCOC_CTRL_2(base, value) (BME_AND32(&XCVR_DCOC_CTRL_2_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_DCOC_CTRL_2(base, value) (BME_XOR32(&XCVR_DCOC_CTRL_2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_DCOC_CTRL_2 bitfields
 */

/*!
 * @name Register XCVR_DCOC_CTRL_2, field BBF_DCOC_STEP_RECIP[12:0] (RW)
 *
 * DCOC BBF Reciprocal of Step Size (format: .[00]13). This the reciprocal of
 * the BBF DCOC STEP value programmed in the XCVR_DCOC_CTRL_1 register. It's
 * nominal value is 1.0/31.57. This value is stored as a 15 bit fraction (though only
 * 13 bits are programmed), so use round(1.0/31.57*2^15) = 1038decimal.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_2_BBF_DCOC_STEP_RECIP field. */
#define XCVR_RD_DCOC_CTRL_2_BBF_DCOC_STEP_RECIP(base) ((XCVR_DCOC_CTRL_2_REG(base) & XCVR_DCOC_CTRL_2_BBF_DCOC_STEP_RECIP_MASK) >> XCVR_DCOC_CTRL_2_BBF_DCOC_STEP_RECIP_SHIFT)
#define XCVR_BRD_DCOC_CTRL_2_BBF_DCOC_STEP_RECIP(base) (BME_UBFX32(&XCVR_DCOC_CTRL_2_REG(base), XCVR_DCOC_CTRL_2_BBF_DCOC_STEP_RECIP_SHIFT, XCVR_DCOC_CTRL_2_BBF_DCOC_STEP_RECIP_WIDTH))

/*! @brief Set the BBF_DCOC_STEP_RECIP field to a new value. */
#define XCVR_WR_DCOC_CTRL_2_BBF_DCOC_STEP_RECIP(base, value) (XCVR_RMW_DCOC_CTRL_2(base, XCVR_DCOC_CTRL_2_BBF_DCOC_STEP_RECIP_MASK, XCVR_DCOC_CTRL_2_BBF_DCOC_STEP_RECIP(value)))
#define XCVR_BWR_DCOC_CTRL_2_BBF_DCOC_STEP_RECIP(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_2_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_2_BBF_DCOC_STEP_RECIP_SHIFT), XCVR_DCOC_CTRL_2_BBF_DCOC_STEP_RECIP_SHIFT, XCVR_DCOC_CTRL_2_BBF_DCOC_STEP_RECIP_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DCOC_CTRL_3 - DCOC Control 3
 ******************************************************************************/

/*!
 * @brief XCVR_DCOC_CTRL_3 - DCOC Control 3 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_DCOC_CTRL_3 register
 */
/*@{*/
#define XCVR_RD_DCOC_CTRL_3(base) (XCVR_DCOC_CTRL_3_REG(base))
#define XCVR_WR_DCOC_CTRL_3(base, value) (XCVR_DCOC_CTRL_3_REG(base) = (value))
#define XCVR_RMW_DCOC_CTRL_3(base, mask, value) (XCVR_WR_DCOC_CTRL_3(base, (XCVR_RD_DCOC_CTRL_3(base) & ~(mask)) | (value)))
#define XCVR_SET_DCOC_CTRL_3(base, value) (BME_OR32(&XCVR_DCOC_CTRL_3_REG(base), (uint32_t)(value)))
#define XCVR_CLR_DCOC_CTRL_3(base, value) (BME_AND32(&XCVR_DCOC_CTRL_3_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_DCOC_CTRL_3(base, value) (BME_XOR32(&XCVR_DCOC_CTRL_3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_DCOC_CTRL_3 bitfields
 */

/*!
 * @name Register XCVR_DCOC_CTRL_3, field BBF_DCOC_INIT_I[5:0] (RW)
 *
 * Manual override value for DCOC BBF I channel DAC. Used when DCOC_MAN=1.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_I field. */
#define XCVR_RD_DCOC_CTRL_3_BBF_DCOC_INIT_I(base) ((XCVR_DCOC_CTRL_3_REG(base) & XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_I_MASK) >> XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_I_SHIFT)
#define XCVR_BRD_DCOC_CTRL_3_BBF_DCOC_INIT_I(base) (BME_UBFX32(&XCVR_DCOC_CTRL_3_REG(base), XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_I_SHIFT, XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_I_WIDTH))

/*! @brief Set the BBF_DCOC_INIT_I field to a new value. */
#define XCVR_WR_DCOC_CTRL_3_BBF_DCOC_INIT_I(base, value) (XCVR_RMW_DCOC_CTRL_3(base, XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_I_MASK, XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_I(value)))
#define XCVR_BWR_DCOC_CTRL_3_BBF_DCOC_INIT_I(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_3_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_I_SHIFT), XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_I_SHIFT, XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_I_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CTRL_3, field BBF_DCOC_INIT_Q[13:8] (RW)
 *
 * Manual override value for DCOC BBF Q channel DAC. Used when DCOC_MAN=1.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_Q field. */
#define XCVR_RD_DCOC_CTRL_3_BBF_DCOC_INIT_Q(base) ((XCVR_DCOC_CTRL_3_REG(base) & XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_Q_MASK) >> XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_Q_SHIFT)
#define XCVR_BRD_DCOC_CTRL_3_BBF_DCOC_INIT_Q(base) (BME_UBFX32(&XCVR_DCOC_CTRL_3_REG(base), XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_Q_SHIFT, XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_Q_WIDTH))

/*! @brief Set the BBF_DCOC_INIT_Q field to a new value. */
#define XCVR_WR_DCOC_CTRL_3_BBF_DCOC_INIT_Q(base, value) (XCVR_RMW_DCOC_CTRL_3(base, XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_Q_MASK, XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_Q(value)))
#define XCVR_BWR_DCOC_CTRL_3_BBF_DCOC_INIT_Q(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_3_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_Q_SHIFT), XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_Q_SHIFT, XCVR_DCOC_CTRL_3_BBF_DCOC_INIT_Q_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CTRL_3, field TZA_DCOC_INIT_I[23:16] (RW)
 *
 * Manual override value for DCOC TZA I channel DAC. Used when DCOC_MAN=1.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_I field. */
#define XCVR_RD_DCOC_CTRL_3_TZA_DCOC_INIT_I(base) ((XCVR_DCOC_CTRL_3_REG(base) & XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_I_MASK) >> XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_I_SHIFT)
#define XCVR_BRD_DCOC_CTRL_3_TZA_DCOC_INIT_I(base) (BME_UBFX32(&XCVR_DCOC_CTRL_3_REG(base), XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_I_SHIFT, XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_I_WIDTH))

/*! @brief Set the TZA_DCOC_INIT_I field to a new value. */
#define XCVR_WR_DCOC_CTRL_3_TZA_DCOC_INIT_I(base, value) (XCVR_RMW_DCOC_CTRL_3(base, XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_I_MASK, XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_I(value)))
#define XCVR_BWR_DCOC_CTRL_3_TZA_DCOC_INIT_I(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_3_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_I_SHIFT), XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_I_SHIFT, XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_I_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CTRL_3, field TZA_DCOC_INIT_Q[31:24] (RW)
 *
 * Manual override value for DCOC TZA Q channel DAC. Used when DCOC_MAN=1.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_Q field. */
#define XCVR_RD_DCOC_CTRL_3_TZA_DCOC_INIT_Q(base) ((XCVR_DCOC_CTRL_3_REG(base) & XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_Q_MASK) >> XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_Q_SHIFT)
#define XCVR_BRD_DCOC_CTRL_3_TZA_DCOC_INIT_Q(base) (BME_UBFX32(&XCVR_DCOC_CTRL_3_REG(base), XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_Q_SHIFT, XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_Q_WIDTH))

/*! @brief Set the TZA_DCOC_INIT_Q field to a new value. */
#define XCVR_WR_DCOC_CTRL_3_TZA_DCOC_INIT_Q(base, value) (XCVR_RMW_DCOC_CTRL_3(base, XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_Q_MASK, XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_Q(value)))
#define XCVR_BWR_DCOC_CTRL_3_TZA_DCOC_INIT_Q(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_3_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_Q_SHIFT), XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_Q_SHIFT, XCVR_DCOC_CTRL_3_TZA_DCOC_INIT_Q_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DCOC_CTRL_4 - DCOC Control 4
 ******************************************************************************/

/*!
 * @brief XCVR_DCOC_CTRL_4 - DCOC Control 4 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_DCOC_CTRL_4 register
 */
/*@{*/
#define XCVR_RD_DCOC_CTRL_4(base) (XCVR_DCOC_CTRL_4_REG(base))
#define XCVR_WR_DCOC_CTRL_4(base, value) (XCVR_DCOC_CTRL_4_REG(base) = (value))
#define XCVR_RMW_DCOC_CTRL_4(base, mask, value) (XCVR_WR_DCOC_CTRL_4(base, (XCVR_RD_DCOC_CTRL_4(base) & ~(mask)) | (value)))
#define XCVR_SET_DCOC_CTRL_4(base, value) (BME_OR32(&XCVR_DCOC_CTRL_4_REG(base), (uint32_t)(value)))
#define XCVR_CLR_DCOC_CTRL_4(base, value) (BME_AND32(&XCVR_DCOC_CTRL_4_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_DCOC_CTRL_4(base, value) (BME_XOR32(&XCVR_DCOC_CTRL_4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_DCOC_CTRL_4 bitfields
 */

/*!
 * @name Register XCVR_DCOC_CTRL_4, field DIG_DCOC_INIT_I[11:0] (RW)
 *
 * Manual override for DCOC DIG I channel correction. Value to be subtracted
 * from downsampled I channel. Used when DCOC_MAN=1.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_I field. */
#define XCVR_RD_DCOC_CTRL_4_DIG_DCOC_INIT_I(base) ((XCVR_DCOC_CTRL_4_REG(base) & XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_I_MASK) >> XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_I_SHIFT)
#define XCVR_BRD_DCOC_CTRL_4_DIG_DCOC_INIT_I(base) (BME_UBFX32(&XCVR_DCOC_CTRL_4_REG(base), XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_I_SHIFT, XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_I_WIDTH))

/*! @brief Set the DIG_DCOC_INIT_I field to a new value. */
#define XCVR_WR_DCOC_CTRL_4_DIG_DCOC_INIT_I(base, value) (XCVR_RMW_DCOC_CTRL_4(base, XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_I_MASK, XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_I(value)))
#define XCVR_BWR_DCOC_CTRL_4_DIG_DCOC_INIT_I(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_4_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_I_SHIFT), XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_I_SHIFT, XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_I_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CTRL_4, field DIG_DCOC_INIT_Q[27:16] (RW)
 *
 * Manual override for DCOC DIG Q channel correction. Value to be subtracted
 * from downsampled Q channel. Used when DCOC_MAN=1.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_Q field. */
#define XCVR_RD_DCOC_CTRL_4_DIG_DCOC_INIT_Q(base) ((XCVR_DCOC_CTRL_4_REG(base) & XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_Q_MASK) >> XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_Q_SHIFT)
#define XCVR_BRD_DCOC_CTRL_4_DIG_DCOC_INIT_Q(base) (BME_UBFX32(&XCVR_DCOC_CTRL_4_REG(base), XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_Q_SHIFT, XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_Q_WIDTH))

/*! @brief Set the DIG_DCOC_INIT_Q field to a new value. */
#define XCVR_WR_DCOC_CTRL_4_DIG_DCOC_INIT_Q(base, value) (XCVR_RMW_DCOC_CTRL_4(base, XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_Q_MASK, XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_Q(value)))
#define XCVR_BWR_DCOC_CTRL_4_DIG_DCOC_INIT_Q(base, value) (BME_BFI32(&XCVR_DCOC_CTRL_4_REG(base), ((uint32_t)(value) << XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_Q_SHIFT), XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_Q_SHIFT, XCVR_DCOC_CTRL_4_DIG_DCOC_INIT_Q_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DCOC_CAL_GAIN - DCOC Calibration Gain
 ******************************************************************************/

/*!
 * @brief XCVR_DCOC_CAL_GAIN - DCOC Calibration Gain (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_DCOC_CAL_GAIN register
 */
/*@{*/
#define XCVR_RD_DCOC_CAL_GAIN(base) (XCVR_DCOC_CAL_GAIN_REG(base))
#define XCVR_WR_DCOC_CAL_GAIN(base, value) (XCVR_DCOC_CAL_GAIN_REG(base) = (value))
#define XCVR_RMW_DCOC_CAL_GAIN(base, mask, value) (XCVR_WR_DCOC_CAL_GAIN(base, (XCVR_RD_DCOC_CAL_GAIN(base) & ~(mask)) | (value)))
#define XCVR_SET_DCOC_CAL_GAIN(base, value) (BME_OR32(&XCVR_DCOC_CAL_GAIN_REG(base), (uint32_t)(value)))
#define XCVR_CLR_DCOC_CAL_GAIN(base, value) (BME_AND32(&XCVR_DCOC_CAL_GAIN_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_DCOC_CAL_GAIN(base, value) (BME_XOR32(&XCVR_DCOC_CAL_GAIN_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_DCOC_CAL_GAIN bitfields
 */

/*!
 * @name Register XCVR_DCOC_CAL_GAIN, field DCOC_BBF_CAL_GAIN1[11:8] (RW)
 *
 * The BBF gain index used for the 1st DCOC calibration point. Used when
 * RX_DCOC_CAL_EN=1.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN1 field. */
#define XCVR_RD_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN1(base) ((XCVR_DCOC_CAL_GAIN_REG(base) & XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN1_MASK) >> XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN1_SHIFT)
#define XCVR_BRD_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN1(base) (BME_UBFX32(&XCVR_DCOC_CAL_GAIN_REG(base), XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN1_SHIFT, XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN1_WIDTH))

/*! @brief Set the DCOC_BBF_CAL_GAIN1 field to a new value. */
#define XCVR_WR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN1(base, value) (XCVR_RMW_DCOC_CAL_GAIN(base, XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN1_MASK, XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN1(value)))
#define XCVR_BWR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN1(base, value) (BME_BFI32(&XCVR_DCOC_CAL_GAIN_REG(base), ((uint32_t)(value) << XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN1_SHIFT), XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN1_SHIFT, XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN1_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CAL_GAIN, field DCOC_TZA_CAL_GAIN1[15:12] (RW)
 *
 * The LNM gain index used for the 1st DCOC calibration point. Used when
 * RX_DCOC_CAL_EN=1.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN1 field. */
#define XCVR_RD_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN1(base) ((XCVR_DCOC_CAL_GAIN_REG(base) & XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN1_MASK) >> XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN1_SHIFT)
#define XCVR_BRD_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN1(base) (BME_UBFX32(&XCVR_DCOC_CAL_GAIN_REG(base), XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN1_SHIFT, XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN1_WIDTH))

/*! @brief Set the DCOC_TZA_CAL_GAIN1 field to a new value. */
#define XCVR_WR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN1(base, value) (XCVR_RMW_DCOC_CAL_GAIN(base, XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN1_MASK, XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN1(value)))
#define XCVR_BWR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN1(base, value) (BME_BFI32(&XCVR_DCOC_CAL_GAIN_REG(base), ((uint32_t)(value) << XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN1_SHIFT), XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN1_SHIFT, XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN1_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CAL_GAIN, field DCOC_BBF_CAL_GAIN2[19:16] (RW)
 *
 * The BBF gain index used for the 2nd DCOC calibration point. Used when
 * RX_DCOC_CAL_EN=1.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN2 field. */
#define XCVR_RD_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN2(base) ((XCVR_DCOC_CAL_GAIN_REG(base) & XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN2_MASK) >> XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN2_SHIFT)
#define XCVR_BRD_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN2(base) (BME_UBFX32(&XCVR_DCOC_CAL_GAIN_REG(base), XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN2_SHIFT, XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN2_WIDTH))

/*! @brief Set the DCOC_BBF_CAL_GAIN2 field to a new value. */
#define XCVR_WR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN2(base, value) (XCVR_RMW_DCOC_CAL_GAIN(base, XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN2_MASK, XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN2(value)))
#define XCVR_BWR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN2(base, value) (BME_BFI32(&XCVR_DCOC_CAL_GAIN_REG(base), ((uint32_t)(value) << XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN2_SHIFT), XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN2_SHIFT, XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN2_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CAL_GAIN, field DCOC_TZA_CAL_GAIN2[23:20] (RW)
 *
 * The LNM gain index used for the 2nd DCOC calibration point. Used when
 * RX_DCOC_CAL_EN=1.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN2 field. */
#define XCVR_RD_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN2(base) ((XCVR_DCOC_CAL_GAIN_REG(base) & XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN2_MASK) >> XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN2_SHIFT)
#define XCVR_BRD_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN2(base) (BME_UBFX32(&XCVR_DCOC_CAL_GAIN_REG(base), XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN2_SHIFT, XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN2_WIDTH))

/*! @brief Set the DCOC_TZA_CAL_GAIN2 field to a new value. */
#define XCVR_WR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN2(base, value) (XCVR_RMW_DCOC_CAL_GAIN(base, XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN2_MASK, XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN2(value)))
#define XCVR_BWR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN2(base, value) (BME_BFI32(&XCVR_DCOC_CAL_GAIN_REG(base), ((uint32_t)(value) << XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN2_SHIFT), XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN2_SHIFT, XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN2_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CAL_GAIN, field DCOC_BBF_CAL_GAIN3[27:24] (RW)
 *
 * The BBF gain index used for the 3rd DCOC calibration point. Used when
 * RX_DCOC_CAL_EN=1.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN3 field. */
#define XCVR_RD_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN3(base) ((XCVR_DCOC_CAL_GAIN_REG(base) & XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN3_MASK) >> XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN3_SHIFT)
#define XCVR_BRD_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN3(base) (BME_UBFX32(&XCVR_DCOC_CAL_GAIN_REG(base), XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN3_SHIFT, XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN3_WIDTH))

/*! @brief Set the DCOC_BBF_CAL_GAIN3 field to a new value. */
#define XCVR_WR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN3(base, value) (XCVR_RMW_DCOC_CAL_GAIN(base, XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN3_MASK, XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN3(value)))
#define XCVR_BWR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN3(base, value) (BME_BFI32(&XCVR_DCOC_CAL_GAIN_REG(base), ((uint32_t)(value) << XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN3_SHIFT), XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN3_SHIFT, XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN3_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CAL_GAIN, field DCOC_TZA_CAL_GAIN3[31:28] (RW)
 *
 * The LNM gain index used for the 3rd DCOC calibration point. Used when
 * RX_DCOC_CAL_EN=1.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN3 field. */
#define XCVR_RD_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN3(base) ((XCVR_DCOC_CAL_GAIN_REG(base) & XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN3_MASK) >> XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN3_SHIFT)
#define XCVR_BRD_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN3(base) (BME_UBFX32(&XCVR_DCOC_CAL_GAIN_REG(base), XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN3_SHIFT, XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN3_WIDTH))

/*! @brief Set the DCOC_TZA_CAL_GAIN3 field to a new value. */
#define XCVR_WR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN3(base, value) (XCVR_RMW_DCOC_CAL_GAIN(base, XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN3_MASK, XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN3(value)))
#define XCVR_BWR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN3(base, value) (BME_BFI32(&XCVR_DCOC_CAL_GAIN_REG(base), ((uint32_t)(value) << XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN3_SHIFT), XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN3_SHIFT, XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN3_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DCOC_STAT - DCOC Status
 ******************************************************************************/

/*!
 * @brief XCVR_DCOC_STAT - DCOC Status (RO)
 *
 * Reset value: 0x80802020U
 */
/*!
 * @name Constants and macros for entire XCVR_DCOC_STAT register
 */
/*@{*/
#define XCVR_RD_DCOC_STAT(base)  (XCVR_DCOC_STAT_REG(base))
/*@}*/

/*
 * Constants & macros for individual XCVR_DCOC_STAT bitfields
 */

/*!
 * @name Register XCVR_DCOC_STAT, field BBF_DCOC_I[5:0] (RO)
 *
 * Current BBF DAC setting for I channel. Note that the BBF DACs have a bias of
 * 0x20; 0x0 represents the most negative DC offset, 0x20 represents a DC offset
 * of 0, and 0x3F represents the most postiive DC offset. This is provided for
 * debug and characterization purposes only.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_STAT_BBF_DCOC_I field. */
#define XCVR_RD_DCOC_STAT_BBF_DCOC_I(base) ((XCVR_DCOC_STAT_REG(base) & XCVR_DCOC_STAT_BBF_DCOC_I_MASK) >> XCVR_DCOC_STAT_BBF_DCOC_I_SHIFT)
#define XCVR_BRD_DCOC_STAT_BBF_DCOC_I(base) (BME_UBFX32(&XCVR_DCOC_STAT_REG(base), XCVR_DCOC_STAT_BBF_DCOC_I_SHIFT, XCVR_DCOC_STAT_BBF_DCOC_I_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_STAT, field BBF_DCOC_Q[13:8] (RO)
 *
 * Current BBF DAC setting for Q channel. Note that the BBF DACs have a bias of
 * 0x20; 0x0 represents the most negative DC offset, 0x20 represents a DC offset
 * of 0, and 0x3F represents the most postiive DC offset. This is provided for
 * debug and characterization purposes only.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_STAT_BBF_DCOC_Q field. */
#define XCVR_RD_DCOC_STAT_BBF_DCOC_Q(base) ((XCVR_DCOC_STAT_REG(base) & XCVR_DCOC_STAT_BBF_DCOC_Q_MASK) >> XCVR_DCOC_STAT_BBF_DCOC_Q_SHIFT)
#define XCVR_BRD_DCOC_STAT_BBF_DCOC_Q(base) (BME_UBFX32(&XCVR_DCOC_STAT_REG(base), XCVR_DCOC_STAT_BBF_DCOC_Q_SHIFT, XCVR_DCOC_STAT_BBF_DCOC_Q_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_STAT, field TZA_DCOC_I[23:16] (RO)
 *
 * Current TZA DAC setting for I channel. Note that the TZA DACs have a bias of
 * 0x80; 0x0 represents the most negative DC offset, 0x80 represents a DC offset
 * of 0, and 0xFF represents the most postiive DC offset. This is provided for
 * debug and characterization purposes only.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_STAT_TZA_DCOC_I field. */
#define XCVR_RD_DCOC_STAT_TZA_DCOC_I(base) ((XCVR_DCOC_STAT_REG(base) & XCVR_DCOC_STAT_TZA_DCOC_I_MASK) >> XCVR_DCOC_STAT_TZA_DCOC_I_SHIFT)
#define XCVR_BRD_DCOC_STAT_TZA_DCOC_I(base) (BME_UBFX32(&XCVR_DCOC_STAT_REG(base), XCVR_DCOC_STAT_TZA_DCOC_I_SHIFT, XCVR_DCOC_STAT_TZA_DCOC_I_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_STAT, field TZA_DCOC_Q[31:24] (RO)
 *
 * Current TZA DAC setting for Q channel. Note that the TZA DACs have a bias of
 * 0x80; 0x0 represents the most negative DC offset, 0x80 represents a DC offset
 * of 0, and 0xFF represents the most postiive DC offset. This is provided for
 * debug and characterization purposes only.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_STAT_TZA_DCOC_Q field. */
#define XCVR_RD_DCOC_STAT_TZA_DCOC_Q(base) ((XCVR_DCOC_STAT_REG(base) & XCVR_DCOC_STAT_TZA_DCOC_Q_MASK) >> XCVR_DCOC_STAT_TZA_DCOC_Q_SHIFT)
#define XCVR_BRD_DCOC_STAT_TZA_DCOC_Q(base) (BME_UBFX32(&XCVR_DCOC_STAT_REG(base), XCVR_DCOC_STAT_TZA_DCOC_Q_SHIFT, XCVR_DCOC_STAT_TZA_DCOC_Q_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DCOC_DC_EST - DCOC DC Estimate
 ******************************************************************************/

/*!
 * @brief XCVR_DCOC_DC_EST - DCOC DC Estimate (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_DCOC_DC_EST register
 */
/*@{*/
#define XCVR_RD_DCOC_DC_EST(base) (XCVR_DCOC_DC_EST_REG(base))
/*@}*/

/*
 * Constants & macros for individual XCVR_DCOC_DC_EST bitfields
 */

/*!
 * @name Register XCVR_DCOC_DC_EST, field DC_EST_I[11:0] (RO)
 *
 * Reflects the current DCOC DC tracking estimate for I channel. Used when
 * DCOC_TRACK_EN=1. This is provided for debug and characterization purposes only.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_DC_EST_DC_EST_I field. */
#define XCVR_RD_DCOC_DC_EST_DC_EST_I(base) ((XCVR_DCOC_DC_EST_REG(base) & XCVR_DCOC_DC_EST_DC_EST_I_MASK) >> XCVR_DCOC_DC_EST_DC_EST_I_SHIFT)
#define XCVR_BRD_DCOC_DC_EST_DC_EST_I(base) (BME_UBFX32(&XCVR_DCOC_DC_EST_REG(base), XCVR_DCOC_DC_EST_DC_EST_I_SHIFT, XCVR_DCOC_DC_EST_DC_EST_I_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_DC_EST, field DC_EST_Q[27:16] (RO)
 *
 * Reflects the current DCOC DC tracking estimate for Q channel. Used when
 * DCOC_TRACK_EN=1. This is provided for debug and characterization purposes only.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_DC_EST_DC_EST_Q field. */
#define XCVR_RD_DCOC_DC_EST_DC_EST_Q(base) ((XCVR_DCOC_DC_EST_REG(base) & XCVR_DCOC_DC_EST_DC_EST_Q_MASK) >> XCVR_DCOC_DC_EST_DC_EST_Q_SHIFT)
#define XCVR_BRD_DCOC_DC_EST_DC_EST_Q(base) (BME_UBFX32(&XCVR_DCOC_DC_EST_REG(base), XCVR_DCOC_DC_EST_DC_EST_Q_SHIFT, XCVR_DCOC_DC_EST_DC_EST_Q_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DCOC_CAL_RCP - DCOC Calibration Reciprocals
 ******************************************************************************/

/*!
 * @brief XCVR_DCOC_CAL_RCP - DCOC Calibration Reciprocals (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_DCOC_CAL_RCP register
 */
/*@{*/
#define XCVR_RD_DCOC_CAL_RCP(base) (XCVR_DCOC_CAL_RCP_REG(base))
#define XCVR_WR_DCOC_CAL_RCP(base, value) (XCVR_DCOC_CAL_RCP_REG(base) = (value))
#define XCVR_RMW_DCOC_CAL_RCP(base, mask, value) (XCVR_WR_DCOC_CAL_RCP(base, (XCVR_RD_DCOC_CAL_RCP(base) & ~(mask)) | (value)))
#define XCVR_SET_DCOC_CAL_RCP(base, value) (BME_OR32(&XCVR_DCOC_CAL_RCP_REG(base), (uint32_t)(value)))
#define XCVR_CLR_DCOC_CAL_RCP(base, value) (BME_AND32(&XCVR_DCOC_CAL_RCP_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_DCOC_CAL_RCP(base, value) (BME_XOR32(&XCVR_DCOC_CAL_RCP_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_DCOC_CAL_RCP bitfields
 */

/*!
 * @name Register XCVR_DCOC_CAL_RCP, field DCOC_TMP_CALC_RECIP[9:0] (RW)
 *
 * DCOC_tmp calculation reciprocal (format: .10). This is used in DCDC
 * calibration calculation. It is defined as 1.0/(GB_HI - GB_LO) This is stored with 10
 * fractional bits, so program the value round([1.0/(GB_HI - GB_LO)]*2^10).
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_RCP_DCOC_TMP_CALC_RECIP field. */
#define XCVR_RD_DCOC_CAL_RCP_DCOC_TMP_CALC_RECIP(base) ((XCVR_DCOC_CAL_RCP_REG(base) & XCVR_DCOC_CAL_RCP_DCOC_TMP_CALC_RECIP_MASK) >> XCVR_DCOC_CAL_RCP_DCOC_TMP_CALC_RECIP_SHIFT)
#define XCVR_BRD_DCOC_CAL_RCP_DCOC_TMP_CALC_RECIP(base) (BME_UBFX32(&XCVR_DCOC_CAL_RCP_REG(base), XCVR_DCOC_CAL_RCP_DCOC_TMP_CALC_RECIP_SHIFT, XCVR_DCOC_CAL_RCP_DCOC_TMP_CALC_RECIP_WIDTH))

/*! @brief Set the DCOC_TMP_CALC_RECIP field to a new value. */
#define XCVR_WR_DCOC_CAL_RCP_DCOC_TMP_CALC_RECIP(base, value) (XCVR_RMW_DCOC_CAL_RCP(base, XCVR_DCOC_CAL_RCP_DCOC_TMP_CALC_RECIP_MASK, XCVR_DCOC_CAL_RCP_DCOC_TMP_CALC_RECIP(value)))
#define XCVR_BWR_DCOC_CAL_RCP_DCOC_TMP_CALC_RECIP(base, value) (BME_BFI32(&XCVR_DCOC_CAL_RCP_REG(base), ((uint32_t)(value) << XCVR_DCOC_CAL_RCP_DCOC_TMP_CALC_RECIP_SHIFT), XCVR_DCOC_CAL_RCP_DCOC_TMP_CALC_RECIP_SHIFT, XCVR_DCOC_CAL_RCP_DCOC_TMP_CALC_RECIP_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CAL_RCP, field ALPHA_CALC_RECIP[20:10] (RW)
 *
 * DCOC Alpha calculation reciprocal (format: .11). This is used in DCOC
 * calibration calculation of the alpha DC component. It is defined as: 1.0/((GL_HI -
 * GL_LO)*GB_LO) This is stored as with 11 fractional bits, so program the value
 * round([1.0/((GL_HI - GL_LO)*GB_LO)]*2^11).
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_RCP_ALPHA_CALC_RECIP field. */
#define XCVR_RD_DCOC_CAL_RCP_ALPHA_CALC_RECIP(base) ((XCVR_DCOC_CAL_RCP_REG(base) & XCVR_DCOC_CAL_RCP_ALPHA_CALC_RECIP_MASK) >> XCVR_DCOC_CAL_RCP_ALPHA_CALC_RECIP_SHIFT)
#define XCVR_BRD_DCOC_CAL_RCP_ALPHA_CALC_RECIP(base) (BME_UBFX32(&XCVR_DCOC_CAL_RCP_REG(base), XCVR_DCOC_CAL_RCP_ALPHA_CALC_RECIP_SHIFT, XCVR_DCOC_CAL_RCP_ALPHA_CALC_RECIP_WIDTH))

/*! @brief Set the ALPHA_CALC_RECIP field to a new value. */
#define XCVR_WR_DCOC_CAL_RCP_ALPHA_CALC_RECIP(base, value) (XCVR_RMW_DCOC_CAL_RCP(base, XCVR_DCOC_CAL_RCP_ALPHA_CALC_RECIP_MASK, XCVR_DCOC_CAL_RCP_ALPHA_CALC_RECIP(value)))
#define XCVR_BWR_DCOC_CAL_RCP_ALPHA_CALC_RECIP(base, value) (BME_BFI32(&XCVR_DCOC_CAL_RCP_REG(base), ((uint32_t)(value) << XCVR_DCOC_CAL_RCP_ALPHA_CALC_RECIP_SHIFT), XCVR_DCOC_CAL_RCP_ALPHA_CALC_RECIP_SHIFT, XCVR_DCOC_CAL_RCP_ALPHA_CALC_RECIP_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_IQMC_CTRL - IQMC Control
 ******************************************************************************/

/*!
 * @brief XCVR_IQMC_CTRL - IQMC Control (RW)
 *
 * Reset value: 0x00008000U
 */
/*!
 * @name Constants and macros for entire XCVR_IQMC_CTRL register
 */
/*@{*/
#define XCVR_RD_IQMC_CTRL(base)  (XCVR_IQMC_CTRL_REG(base))
#define XCVR_WR_IQMC_CTRL(base, value) (XCVR_IQMC_CTRL_REG(base) = (value))
#define XCVR_RMW_IQMC_CTRL(base, mask, value) (XCVR_WR_IQMC_CTRL(base, (XCVR_RD_IQMC_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_IQMC_CTRL(base, value) (BME_OR32(&XCVR_IQMC_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_IQMC_CTRL(base, value) (BME_AND32(&XCVR_IQMC_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_IQMC_CTRL(base, value) (BME_XOR32(&XCVR_IQMC_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_IQMC_CTRL bitfields
 */

/*!
 * @name Register XCVR_IQMC_CTRL, field IQMC_CAL_EN[0] (RW)
 *
 * Enables IQ mismatch calibration.
 */
/*@{*/
/*! @brief Read current value of the XCVR_IQMC_CTRL_IQMC_CAL_EN field. */
#define XCVR_RD_IQMC_CTRL_IQMC_CAL_EN(base) ((XCVR_IQMC_CTRL_REG(base) & XCVR_IQMC_CTRL_IQMC_CAL_EN_MASK) >> XCVR_IQMC_CTRL_IQMC_CAL_EN_SHIFT)
#define XCVR_BRD_IQMC_CTRL_IQMC_CAL_EN(base) (BME_UBFX32(&XCVR_IQMC_CTRL_REG(base), XCVR_IQMC_CTRL_IQMC_CAL_EN_SHIFT, XCVR_IQMC_CTRL_IQMC_CAL_EN_WIDTH))

/*! @brief Set the IQMC_CAL_EN field to a new value. */
#define XCVR_WR_IQMC_CTRL_IQMC_CAL_EN(base, value) (XCVR_RMW_IQMC_CTRL(base, XCVR_IQMC_CTRL_IQMC_CAL_EN_MASK, XCVR_IQMC_CTRL_IQMC_CAL_EN(value)))
#define XCVR_BWR_IQMC_CTRL_IQMC_CAL_EN(base, value) (BME_BFI32(&XCVR_IQMC_CTRL_REG(base), ((uint32_t)(value) << XCVR_IQMC_CTRL_IQMC_CAL_EN_SHIFT), XCVR_IQMC_CTRL_IQMC_CAL_EN_SHIFT, XCVR_IQMC_CTRL_IQMC_CAL_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_IQMC_CTRL, field IQMC_NUM_ITER[15:8] (RW)
 *
 * Number of iterations for IQ Mismatch Calibration.
 */
/*@{*/
/*! @brief Read current value of the XCVR_IQMC_CTRL_IQMC_NUM_ITER field. */
#define XCVR_RD_IQMC_CTRL_IQMC_NUM_ITER(base) ((XCVR_IQMC_CTRL_REG(base) & XCVR_IQMC_CTRL_IQMC_NUM_ITER_MASK) >> XCVR_IQMC_CTRL_IQMC_NUM_ITER_SHIFT)
#define XCVR_BRD_IQMC_CTRL_IQMC_NUM_ITER(base) (BME_UBFX32(&XCVR_IQMC_CTRL_REG(base), XCVR_IQMC_CTRL_IQMC_NUM_ITER_SHIFT, XCVR_IQMC_CTRL_IQMC_NUM_ITER_WIDTH))

/*! @brief Set the IQMC_NUM_ITER field to a new value. */
#define XCVR_WR_IQMC_CTRL_IQMC_NUM_ITER(base, value) (XCVR_RMW_IQMC_CTRL(base, XCVR_IQMC_CTRL_IQMC_NUM_ITER_MASK, XCVR_IQMC_CTRL_IQMC_NUM_ITER(value)))
#define XCVR_BWR_IQMC_CTRL_IQMC_NUM_ITER(base, value) (BME_BFI32(&XCVR_IQMC_CTRL_REG(base), ((uint32_t)(value) << XCVR_IQMC_CTRL_IQMC_NUM_ITER_SHIFT), XCVR_IQMC_CTRL_IQMC_NUM_ITER_SHIFT, XCVR_IQMC_CTRL_IQMC_NUM_ITER_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_IQMC_CAL - IQMC Calibration
 ******************************************************************************/

/*!
 * @brief XCVR_IQMC_CAL - IQMC Calibration (RW)
 *
 * Reset value: 0x00000400U
 */
/*!
 * @name Constants and macros for entire XCVR_IQMC_CAL register
 */
/*@{*/
#define XCVR_RD_IQMC_CAL(base)   (XCVR_IQMC_CAL_REG(base))
#define XCVR_WR_IQMC_CAL(base, value) (XCVR_IQMC_CAL_REG(base) = (value))
#define XCVR_RMW_IQMC_CAL(base, mask, value) (XCVR_WR_IQMC_CAL(base, (XCVR_RD_IQMC_CAL(base) & ~(mask)) | (value)))
#define XCVR_SET_IQMC_CAL(base, value) (BME_OR32(&XCVR_IQMC_CAL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_IQMC_CAL(base, value) (BME_AND32(&XCVR_IQMC_CAL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_IQMC_CAL(base, value) (BME_XOR32(&XCVR_IQMC_CAL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_IQMC_CAL bitfields
 */

/*!
 * @name Register XCVR_IQMC_CAL, field IQMC_GAIN_ADJ[10:0] (RW)
 *
 * I/Q mismatch correction gain coefficient.
 */
/*@{*/
/*! @brief Read current value of the XCVR_IQMC_CAL_IQMC_GAIN_ADJ field. */
#define XCVR_RD_IQMC_CAL_IQMC_GAIN_ADJ(base) ((XCVR_IQMC_CAL_REG(base) & XCVR_IQMC_CAL_IQMC_GAIN_ADJ_MASK) >> XCVR_IQMC_CAL_IQMC_GAIN_ADJ_SHIFT)
#define XCVR_BRD_IQMC_CAL_IQMC_GAIN_ADJ(base) (BME_UBFX32(&XCVR_IQMC_CAL_REG(base), XCVR_IQMC_CAL_IQMC_GAIN_ADJ_SHIFT, XCVR_IQMC_CAL_IQMC_GAIN_ADJ_WIDTH))

/*! @brief Set the IQMC_GAIN_ADJ field to a new value. */
#define XCVR_WR_IQMC_CAL_IQMC_GAIN_ADJ(base, value) (XCVR_RMW_IQMC_CAL(base, XCVR_IQMC_CAL_IQMC_GAIN_ADJ_MASK, XCVR_IQMC_CAL_IQMC_GAIN_ADJ(value)))
#define XCVR_BWR_IQMC_CAL_IQMC_GAIN_ADJ(base, value) (BME_BFI32(&XCVR_IQMC_CAL_REG(base), ((uint32_t)(value) << XCVR_IQMC_CAL_IQMC_GAIN_ADJ_SHIFT), XCVR_IQMC_CAL_IQMC_GAIN_ADJ_SHIFT, XCVR_IQMC_CAL_IQMC_GAIN_ADJ_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_IQMC_CAL, field IQMC_PHASE_ADJ[27:16] (RW)
 *
 * I/Q mismatch correction phase coefficient.
 */
/*@{*/
/*! @brief Read current value of the XCVR_IQMC_CAL_IQMC_PHASE_ADJ field. */
#define XCVR_RD_IQMC_CAL_IQMC_PHASE_ADJ(base) ((XCVR_IQMC_CAL_REG(base) & XCVR_IQMC_CAL_IQMC_PHASE_ADJ_MASK) >> XCVR_IQMC_CAL_IQMC_PHASE_ADJ_SHIFT)
#define XCVR_BRD_IQMC_CAL_IQMC_PHASE_ADJ(base) (BME_UBFX32(&XCVR_IQMC_CAL_REG(base), XCVR_IQMC_CAL_IQMC_PHASE_ADJ_SHIFT, XCVR_IQMC_CAL_IQMC_PHASE_ADJ_WIDTH))

/*! @brief Set the IQMC_PHASE_ADJ field to a new value. */
#define XCVR_WR_IQMC_CAL_IQMC_PHASE_ADJ(base, value) (XCVR_RMW_IQMC_CAL(base, XCVR_IQMC_CAL_IQMC_PHASE_ADJ_MASK, XCVR_IQMC_CAL_IQMC_PHASE_ADJ(value)))
#define XCVR_BWR_IQMC_CAL_IQMC_PHASE_ADJ(base, value) (BME_BFI32(&XCVR_IQMC_CAL_REG(base), ((uint32_t)(value) << XCVR_IQMC_CAL_IQMC_PHASE_ADJ_SHIFT), XCVR_IQMC_CAL_IQMC_PHASE_ADJ_SHIFT, XCVR_IQMC_CAL_IQMC_PHASE_ADJ_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TCA_AGC_VAL_3_0 - TCA AGC Step Values 3..0
 ******************************************************************************/

/*!
 * @brief XCVR_TCA_AGC_VAL_3_0 - TCA AGC Step Values 3..0 (RW)
 *
 * Reset value: 0x3C242C14U
 */
/*!
 * @name Constants and macros for entire XCVR_TCA_AGC_VAL_3_0 register
 */
/*@{*/
#define XCVR_RD_TCA_AGC_VAL_3_0(base) (XCVR_TCA_AGC_VAL_3_0_REG(base))
#define XCVR_WR_TCA_AGC_VAL_3_0(base, value) (XCVR_TCA_AGC_VAL_3_0_REG(base) = (value))
#define XCVR_RMW_TCA_AGC_VAL_3_0(base, mask, value) (XCVR_WR_TCA_AGC_VAL_3_0(base, (XCVR_RD_TCA_AGC_VAL_3_0(base) & ~(mask)) | (value)))
#define XCVR_SET_TCA_AGC_VAL_3_0(base, value) (BME_OR32(&XCVR_TCA_AGC_VAL_3_0_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TCA_AGC_VAL_3_0(base, value) (BME_AND32(&XCVR_TCA_AGC_VAL_3_0_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TCA_AGC_VAL_3_0(base, value) (BME_XOR32(&XCVR_TCA_AGC_VAL_3_0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TCA_AGC_VAL_3_0 bitfields
 */

/*!
 * @name Register XCVR_TCA_AGC_VAL_3_0, field TCA_AGC_VAL_0[7:0] (RW)
 *
 * 4(x+8) value of TCA_AGC step 0, for RSSI calculation.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_0 field. */
#define XCVR_RD_TCA_AGC_VAL_3_0_TCA_AGC_VAL_0(base) ((XCVR_TCA_AGC_VAL_3_0_REG(base) & XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_0_MASK) >> XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_0_SHIFT)
#define XCVR_BRD_TCA_AGC_VAL_3_0_TCA_AGC_VAL_0(base) (BME_UBFX32(&XCVR_TCA_AGC_VAL_3_0_REG(base), XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_0_SHIFT, XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_0_WIDTH))

/*! @brief Set the TCA_AGC_VAL_0 field to a new value. */
#define XCVR_WR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_0(base, value) (XCVR_RMW_TCA_AGC_VAL_3_0(base, XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_0_MASK, XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_0(value)))
#define XCVR_BWR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_0(base, value) (BME_BFI32(&XCVR_TCA_AGC_VAL_3_0_REG(base), ((uint32_t)(value) << XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_0_SHIFT), XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_0_SHIFT, XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_0_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TCA_AGC_VAL_3_0, field TCA_AGC_VAL_1[15:8] (RW)
 *
 * 4(x+8) value of TCA_AGC step 1, for RSSI calculation.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_1 field. */
#define XCVR_RD_TCA_AGC_VAL_3_0_TCA_AGC_VAL_1(base) ((XCVR_TCA_AGC_VAL_3_0_REG(base) & XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_1_MASK) >> XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_1_SHIFT)
#define XCVR_BRD_TCA_AGC_VAL_3_0_TCA_AGC_VAL_1(base) (BME_UBFX32(&XCVR_TCA_AGC_VAL_3_0_REG(base), XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_1_SHIFT, XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_1_WIDTH))

/*! @brief Set the TCA_AGC_VAL_1 field to a new value. */
#define XCVR_WR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_1(base, value) (XCVR_RMW_TCA_AGC_VAL_3_0(base, XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_1_MASK, XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_1(value)))
#define XCVR_BWR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_1(base, value) (BME_BFI32(&XCVR_TCA_AGC_VAL_3_0_REG(base), ((uint32_t)(value) << XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_1_SHIFT), XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_1_SHIFT, XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_1_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TCA_AGC_VAL_3_0, field TCA_AGC_VAL_2[23:16] (RW)
 *
 * 4x value of TCA_AGC step 2, for RSSI calculation.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_2 field. */
#define XCVR_RD_TCA_AGC_VAL_3_0_TCA_AGC_VAL_2(base) ((XCVR_TCA_AGC_VAL_3_0_REG(base) & XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_2_MASK) >> XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_2_SHIFT)
#define XCVR_BRD_TCA_AGC_VAL_3_0_TCA_AGC_VAL_2(base) (BME_UBFX32(&XCVR_TCA_AGC_VAL_3_0_REG(base), XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_2_SHIFT, XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_2_WIDTH))

/*! @brief Set the TCA_AGC_VAL_2 field to a new value. */
#define XCVR_WR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_2(base, value) (XCVR_RMW_TCA_AGC_VAL_3_0(base, XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_2_MASK, XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_2(value)))
#define XCVR_BWR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_2(base, value) (BME_BFI32(&XCVR_TCA_AGC_VAL_3_0_REG(base), ((uint32_t)(value) << XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_2_SHIFT), XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_2_SHIFT, XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_2_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TCA_AGC_VAL_3_0, field TCA_AGC_VAL_3[31:24] (RW)
 *
 * 4x value of TCA_AGC step 3, for RSSI calculation.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_3 field. */
#define XCVR_RD_TCA_AGC_VAL_3_0_TCA_AGC_VAL_3(base) ((XCVR_TCA_AGC_VAL_3_0_REG(base) & XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_3_MASK) >> XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_3_SHIFT)
#define XCVR_BRD_TCA_AGC_VAL_3_0_TCA_AGC_VAL_3(base) (BME_UBFX32(&XCVR_TCA_AGC_VAL_3_0_REG(base), XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_3_SHIFT, XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_3_WIDTH))

/*! @brief Set the TCA_AGC_VAL_3 field to a new value. */
#define XCVR_WR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_3(base, value) (XCVR_RMW_TCA_AGC_VAL_3_0(base, XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_3_MASK, XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_3(value)))
#define XCVR_BWR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_3(base, value) (BME_BFI32(&XCVR_TCA_AGC_VAL_3_0_REG(base), ((uint32_t)(value) << XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_3_SHIFT), XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_3_SHIFT, XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_3_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TCA_AGC_VAL_7_4 - TCA AGC Step Values 7..4
 ******************************************************************************/

/*!
 * @brief XCVR_TCA_AGC_VAL_7_4 - TCA AGC Step Values 7..4 (RW)
 *
 * Reset value: 0x9C846C54U
 */
/*!
 * @name Constants and macros for entire XCVR_TCA_AGC_VAL_7_4 register
 */
/*@{*/
#define XCVR_RD_TCA_AGC_VAL_7_4(base) (XCVR_TCA_AGC_VAL_7_4_REG(base))
#define XCVR_WR_TCA_AGC_VAL_7_4(base, value) (XCVR_TCA_AGC_VAL_7_4_REG(base) = (value))
#define XCVR_RMW_TCA_AGC_VAL_7_4(base, mask, value) (XCVR_WR_TCA_AGC_VAL_7_4(base, (XCVR_RD_TCA_AGC_VAL_7_4(base) & ~(mask)) | (value)))
#define XCVR_SET_TCA_AGC_VAL_7_4(base, value) (BME_OR32(&XCVR_TCA_AGC_VAL_7_4_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TCA_AGC_VAL_7_4(base, value) (BME_AND32(&XCVR_TCA_AGC_VAL_7_4_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TCA_AGC_VAL_7_4(base, value) (BME_XOR32(&XCVR_TCA_AGC_VAL_7_4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TCA_AGC_VAL_7_4 bitfields
 */

/*!
 * @name Register XCVR_TCA_AGC_VAL_7_4, field TCA_AGC_VAL_4[7:0] (RW)
 *
 * 4x value of TCA_AGC step 4, for RSSI calculation.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_4 field. */
#define XCVR_RD_TCA_AGC_VAL_7_4_TCA_AGC_VAL_4(base) ((XCVR_TCA_AGC_VAL_7_4_REG(base) & XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_4_MASK) >> XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_4_SHIFT)
#define XCVR_BRD_TCA_AGC_VAL_7_4_TCA_AGC_VAL_4(base) (BME_UBFX32(&XCVR_TCA_AGC_VAL_7_4_REG(base), XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_4_SHIFT, XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_4_WIDTH))

/*! @brief Set the TCA_AGC_VAL_4 field to a new value. */
#define XCVR_WR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_4(base, value) (XCVR_RMW_TCA_AGC_VAL_7_4(base, XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_4_MASK, XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_4(value)))
#define XCVR_BWR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_4(base, value) (BME_BFI32(&XCVR_TCA_AGC_VAL_7_4_REG(base), ((uint32_t)(value) << XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_4_SHIFT), XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_4_SHIFT, XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_4_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TCA_AGC_VAL_7_4, field TCA_AGC_VAL_5[15:8] (RW)
 *
 * 4x value of TCA_AGC step 5, for RSSI calculation.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_5 field. */
#define XCVR_RD_TCA_AGC_VAL_7_4_TCA_AGC_VAL_5(base) ((XCVR_TCA_AGC_VAL_7_4_REG(base) & XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_5_MASK) >> XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_5_SHIFT)
#define XCVR_BRD_TCA_AGC_VAL_7_4_TCA_AGC_VAL_5(base) (BME_UBFX32(&XCVR_TCA_AGC_VAL_7_4_REG(base), XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_5_SHIFT, XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_5_WIDTH))

/*! @brief Set the TCA_AGC_VAL_5 field to a new value. */
#define XCVR_WR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_5(base, value) (XCVR_RMW_TCA_AGC_VAL_7_4(base, XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_5_MASK, XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_5(value)))
#define XCVR_BWR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_5(base, value) (BME_BFI32(&XCVR_TCA_AGC_VAL_7_4_REG(base), ((uint32_t)(value) << XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_5_SHIFT), XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_5_SHIFT, XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_5_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TCA_AGC_VAL_7_4, field TCA_AGC_VAL_6[23:16] (RW)
 *
 * 4x value of TCA_AGC step 6, for RSSI calculation.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_6 field. */
#define XCVR_RD_TCA_AGC_VAL_7_4_TCA_AGC_VAL_6(base) ((XCVR_TCA_AGC_VAL_7_4_REG(base) & XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_6_MASK) >> XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_6_SHIFT)
#define XCVR_BRD_TCA_AGC_VAL_7_4_TCA_AGC_VAL_6(base) (BME_UBFX32(&XCVR_TCA_AGC_VAL_7_4_REG(base), XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_6_SHIFT, XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_6_WIDTH))

/*! @brief Set the TCA_AGC_VAL_6 field to a new value. */
#define XCVR_WR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_6(base, value) (XCVR_RMW_TCA_AGC_VAL_7_4(base, XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_6_MASK, XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_6(value)))
#define XCVR_BWR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_6(base, value) (BME_BFI32(&XCVR_TCA_AGC_VAL_7_4_REG(base), ((uint32_t)(value) << XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_6_SHIFT), XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_6_SHIFT, XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_6_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TCA_AGC_VAL_7_4, field TCA_AGC_VAL_7[31:24] (RW)
 *
 * 4x value of TCA_AGC step 7, for RSSI calculation.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_7 field. */
#define XCVR_RD_TCA_AGC_VAL_7_4_TCA_AGC_VAL_7(base) ((XCVR_TCA_AGC_VAL_7_4_REG(base) & XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_7_MASK) >> XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_7_SHIFT)
#define XCVR_BRD_TCA_AGC_VAL_7_4_TCA_AGC_VAL_7(base) (BME_UBFX32(&XCVR_TCA_AGC_VAL_7_4_REG(base), XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_7_SHIFT, XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_7_WIDTH))

/*! @brief Set the TCA_AGC_VAL_7 field to a new value. */
#define XCVR_WR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_7(base, value) (XCVR_RMW_TCA_AGC_VAL_7_4(base, XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_7_MASK, XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_7(value)))
#define XCVR_BWR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_7(base, value) (BME_BFI32(&XCVR_TCA_AGC_VAL_7_4_REG(base), ((uint32_t)(value) << XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_7_SHIFT), XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_7_SHIFT, XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_7_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TCA_AGC_VAL_8 - TCA AGC Step Values 8
 ******************************************************************************/

/*!
 * @brief XCVR_TCA_AGC_VAL_8 - TCA AGC Step Values 8 (RW)
 *
 * Reset value: 0x000000B4U
 */
/*!
 * @name Constants and macros for entire XCVR_TCA_AGC_VAL_8 register
 */
/*@{*/
#define XCVR_RD_TCA_AGC_VAL_8(base) (XCVR_TCA_AGC_VAL_8_REG(base))
#define XCVR_WR_TCA_AGC_VAL_8(base, value) (XCVR_TCA_AGC_VAL_8_REG(base) = (value))
#define XCVR_RMW_TCA_AGC_VAL_8(base, mask, value) (XCVR_WR_TCA_AGC_VAL_8(base, (XCVR_RD_TCA_AGC_VAL_8(base) & ~(mask)) | (value)))
#define XCVR_SET_TCA_AGC_VAL_8(base, value) (BME_OR32(&XCVR_TCA_AGC_VAL_8_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TCA_AGC_VAL_8(base, value) (BME_AND32(&XCVR_TCA_AGC_VAL_8_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TCA_AGC_VAL_8(base, value) (BME_XOR32(&XCVR_TCA_AGC_VAL_8_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TCA_AGC_VAL_8 bitfields
 */

/*!
 * @name Register XCVR_TCA_AGC_VAL_8, field TCA_AGC_VAL_8[7:0] (RW)
 *
 * 4x value of TCA_AGC step 8, for RSSI calculation.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_AGC_VAL_8_TCA_AGC_VAL_8 field. */
#define XCVR_RD_TCA_AGC_VAL_8_TCA_AGC_VAL_8(base) ((XCVR_TCA_AGC_VAL_8_REG(base) & XCVR_TCA_AGC_VAL_8_TCA_AGC_VAL_8_MASK) >> XCVR_TCA_AGC_VAL_8_TCA_AGC_VAL_8_SHIFT)
#define XCVR_BRD_TCA_AGC_VAL_8_TCA_AGC_VAL_8(base) (BME_UBFX32(&XCVR_TCA_AGC_VAL_8_REG(base), XCVR_TCA_AGC_VAL_8_TCA_AGC_VAL_8_SHIFT, XCVR_TCA_AGC_VAL_8_TCA_AGC_VAL_8_WIDTH))

/*! @brief Set the TCA_AGC_VAL_8 field to a new value. */
#define XCVR_WR_TCA_AGC_VAL_8_TCA_AGC_VAL_8(base, value) (XCVR_RMW_TCA_AGC_VAL_8(base, XCVR_TCA_AGC_VAL_8_TCA_AGC_VAL_8_MASK, XCVR_TCA_AGC_VAL_8_TCA_AGC_VAL_8(value)))
#define XCVR_BWR_TCA_AGC_VAL_8_TCA_AGC_VAL_8(base, value) (BME_BFI32(&XCVR_TCA_AGC_VAL_8_REG(base), ((uint32_t)(value) << XCVR_TCA_AGC_VAL_8_TCA_AGC_VAL_8_SHIFT), XCVR_TCA_AGC_VAL_8_TCA_AGC_VAL_8_SHIFT, XCVR_TCA_AGC_VAL_8_TCA_AGC_VAL_8_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_BBF_RES_TUNE_VAL_7_0 - BBF Resistor Tune Values 7..0
 ******************************************************************************/

/*!
 * @brief XCVR_BBF_RES_TUNE_VAL_7_0 - BBF Resistor Tune Values 7..0 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_BBF_RES_TUNE_VAL_7_0 register
 */
/*@{*/
#define XCVR_RD_BBF_RES_TUNE_VAL_7_0(base) (XCVR_BBF_RES_TUNE_VAL_7_0_REG(base))
#define XCVR_WR_BBF_RES_TUNE_VAL_7_0(base, value) (XCVR_BBF_RES_TUNE_VAL_7_0_REG(base) = (value))
#define XCVR_RMW_BBF_RES_TUNE_VAL_7_0(base, mask, value) (XCVR_WR_BBF_RES_TUNE_VAL_7_0(base, (XCVR_RD_BBF_RES_TUNE_VAL_7_0(base) & ~(mask)) | (value)))
#define XCVR_SET_BBF_RES_TUNE_VAL_7_0(base, value) (BME_OR32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), (uint32_t)(value)))
#define XCVR_CLR_BBF_RES_TUNE_VAL_7_0(base, value) (BME_AND32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_BBF_RES_TUNE_VAL_7_0(base, value) (BME_XOR32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_BBF_RES_TUNE_VAL_7_0 bitfields
 */

/*!
 * @name Register XCVR_BBF_RES_TUNE_VAL_7_0, field BBF_RES_TUNE_VAL_0[3:0] (RW)
 *
 * Signed, 2x offset value of bbf_res_tune step 0 agc delta.
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_0 field. */
#define XCVR_RD_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_0(base) ((XCVR_BBF_RES_TUNE_VAL_7_0_REG(base) & XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_0_MASK) >> XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_0_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_0(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_0_SHIFT, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_0_WIDTH))

/*! @brief Set the BBF_RES_TUNE_VAL_0 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_0(base, value) (XCVR_RMW_BBF_RES_TUNE_VAL_7_0(base, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_0_MASK, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_0(value)))
#define XCVR_BWR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_0(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_0_SHIFT), XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_0_SHIFT, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_0_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_RES_TUNE_VAL_7_0, field BBF_RES_TUNE_VAL_1[7:4] (RW)
 *
 * Signed, 2x offset value of bbf_res_tune step 1 agc delta.
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_1 field. */
#define XCVR_RD_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_1(base) ((XCVR_BBF_RES_TUNE_VAL_7_0_REG(base) & XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_1_MASK) >> XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_1_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_1(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_1_SHIFT, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_1_WIDTH))

/*! @brief Set the BBF_RES_TUNE_VAL_1 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_1(base, value) (XCVR_RMW_BBF_RES_TUNE_VAL_7_0(base, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_1_MASK, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_1(value)))
#define XCVR_BWR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_1(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_1_SHIFT), XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_1_SHIFT, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_1_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_RES_TUNE_VAL_7_0, field BBF_RES_TUNE_VAL_2[11:8] (RW)
 *
 * Signed, 2x offset value of bbf_res_tune step 2 agc delta.
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_2 field. */
#define XCVR_RD_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_2(base) ((XCVR_BBF_RES_TUNE_VAL_7_0_REG(base) & XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_2_MASK) >> XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_2_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_2(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_2_SHIFT, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_2_WIDTH))

/*! @brief Set the BBF_RES_TUNE_VAL_2 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_2(base, value) (XCVR_RMW_BBF_RES_TUNE_VAL_7_0(base, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_2_MASK, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_2(value)))
#define XCVR_BWR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_2(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_2_SHIFT), XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_2_SHIFT, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_2_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_RES_TUNE_VAL_7_0, field BBF_RES_TUNE_VAL_3[15:12] (RW)
 *
 * Signed, 2x offset value of bbf_res_tune step 3 agc delta.
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_3 field. */
#define XCVR_RD_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_3(base) ((XCVR_BBF_RES_TUNE_VAL_7_0_REG(base) & XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_3_MASK) >> XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_3_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_3(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_3_SHIFT, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_3_WIDTH))

/*! @brief Set the BBF_RES_TUNE_VAL_3 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_3(base, value) (XCVR_RMW_BBF_RES_TUNE_VAL_7_0(base, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_3_MASK, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_3(value)))
#define XCVR_BWR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_3(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_3_SHIFT), XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_3_SHIFT, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_3_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_RES_TUNE_VAL_7_0, field BBF_RES_TUNE_VAL_4[19:16] (RW)
 *
 * Signed, 2x offset value of bbf_res_tune step 4 agc delta.
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_4 field. */
#define XCVR_RD_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_4(base) ((XCVR_BBF_RES_TUNE_VAL_7_0_REG(base) & XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_4_MASK) >> XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_4_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_4(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_4_SHIFT, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_4_WIDTH))

/*! @brief Set the BBF_RES_TUNE_VAL_4 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_4(base, value) (XCVR_RMW_BBF_RES_TUNE_VAL_7_0(base, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_4_MASK, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_4(value)))
#define XCVR_BWR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_4(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_4_SHIFT), XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_4_SHIFT, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_4_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_RES_TUNE_VAL_7_0, field BBF_RES_TUNE_VAL_5[23:20] (RW)
 *
 * Signed, 2x offset value of bbf_res_tune step 5 agc delta.
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_5 field. */
#define XCVR_RD_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_5(base) ((XCVR_BBF_RES_TUNE_VAL_7_0_REG(base) & XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_5_MASK) >> XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_5_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_5(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_5_SHIFT, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_5_WIDTH))

/*! @brief Set the BBF_RES_TUNE_VAL_5 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_5(base, value) (XCVR_RMW_BBF_RES_TUNE_VAL_7_0(base, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_5_MASK, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_5(value)))
#define XCVR_BWR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_5(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_5_SHIFT), XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_5_SHIFT, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_5_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_RES_TUNE_VAL_7_0, field BBF_RES_TUNE_VAL_6[27:24] (RW)
 *
 * Signed, 2x offset value of bbf_res_tune step 6 agc delta.
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_6 field. */
#define XCVR_RD_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_6(base) ((XCVR_BBF_RES_TUNE_VAL_7_0_REG(base) & XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_6_MASK) >> XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_6_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_6(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_6_SHIFT, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_6_WIDTH))

/*! @brief Set the BBF_RES_TUNE_VAL_6 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_6(base, value) (XCVR_RMW_BBF_RES_TUNE_VAL_7_0(base, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_6_MASK, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_6(value)))
#define XCVR_BWR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_6(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_6_SHIFT), XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_6_SHIFT, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_6_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_RES_TUNE_VAL_7_0, field BBF_RES_TUNE_VAL_7[31:28] (RW)
 *
 * Signed, 2x offset value of bbf_res_tune step 7 agc delta.
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_7 field. */
#define XCVR_RD_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_7(base) ((XCVR_BBF_RES_TUNE_VAL_7_0_REG(base) & XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_7_MASK) >> XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_7_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_7(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_7_SHIFT, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_7_WIDTH))

/*! @brief Set the BBF_RES_TUNE_VAL_7 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_7(base, value) (XCVR_RMW_BBF_RES_TUNE_VAL_7_0(base, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_7_MASK, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_7(value)))
#define XCVR_BWR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_7(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_VAL_7_0_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_7_SHIFT), XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_7_SHIFT, XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_7_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_BBF_RES_TUNE_VAL_10_8 - BBF Resistor Tune Values 10..8
 ******************************************************************************/

/*!
 * @brief XCVR_BBF_RES_TUNE_VAL_10_8 - BBF Resistor Tune Values 10..8 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_BBF_RES_TUNE_VAL_10_8 register
 */
/*@{*/
#define XCVR_RD_BBF_RES_TUNE_VAL_10_8(base) (XCVR_BBF_RES_TUNE_VAL_10_8_REG(base))
#define XCVR_WR_BBF_RES_TUNE_VAL_10_8(base, value) (XCVR_BBF_RES_TUNE_VAL_10_8_REG(base) = (value))
#define XCVR_RMW_BBF_RES_TUNE_VAL_10_8(base, mask, value) (XCVR_WR_BBF_RES_TUNE_VAL_10_8(base, (XCVR_RD_BBF_RES_TUNE_VAL_10_8(base) & ~(mask)) | (value)))
#define XCVR_SET_BBF_RES_TUNE_VAL_10_8(base, value) (BME_OR32(&XCVR_BBF_RES_TUNE_VAL_10_8_REG(base), (uint32_t)(value)))
#define XCVR_CLR_BBF_RES_TUNE_VAL_10_8(base, value) (BME_AND32(&XCVR_BBF_RES_TUNE_VAL_10_8_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_BBF_RES_TUNE_VAL_10_8(base, value) (BME_XOR32(&XCVR_BBF_RES_TUNE_VAL_10_8_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_BBF_RES_TUNE_VAL_10_8 bitfields
 */

/*!
 * @name Register XCVR_BBF_RES_TUNE_VAL_10_8, field BBF_RES_TUNE_VAL_8[3:0] (RW)
 *
 * Signed, 2x offset value of bbf_res_tune step 8 agc delta.
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_8 field. */
#define XCVR_RD_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_8(base) ((XCVR_BBF_RES_TUNE_VAL_10_8_REG(base) & XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_8_MASK) >> XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_8_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_8(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_VAL_10_8_REG(base), XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_8_SHIFT, XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_8_WIDTH))

/*! @brief Set the BBF_RES_TUNE_VAL_8 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_8(base, value) (XCVR_RMW_BBF_RES_TUNE_VAL_10_8(base, XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_8_MASK, XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_8(value)))
#define XCVR_BWR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_8(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_VAL_10_8_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_8_SHIFT), XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_8_SHIFT, XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_8_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_RES_TUNE_VAL_10_8, field BBF_RES_TUNE_VAL_9[7:4] (RW)
 *
 * Signed, 2x offset value of bbf_res_tune step 9 agc delta.
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_9 field. */
#define XCVR_RD_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_9(base) ((XCVR_BBF_RES_TUNE_VAL_10_8_REG(base) & XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_9_MASK) >> XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_9_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_9(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_VAL_10_8_REG(base), XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_9_SHIFT, XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_9_WIDTH))

/*! @brief Set the BBF_RES_TUNE_VAL_9 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_9(base, value) (XCVR_RMW_BBF_RES_TUNE_VAL_10_8(base, XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_9_MASK, XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_9(value)))
#define XCVR_BWR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_9(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_VAL_10_8_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_9_SHIFT), XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_9_SHIFT, XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_9_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_RES_TUNE_VAL_10_8, field BBF_RES_TUNE_VAL_10[11:8] (RW)
 *
 * Signed, 2x offset value of bbf_res_tune step 10 agc delta.
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_10 field. */
#define XCVR_RD_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_10(base) ((XCVR_BBF_RES_TUNE_VAL_10_8_REG(base) & XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_10_MASK) >> XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_10_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_10(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_VAL_10_8_REG(base), XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_10_SHIFT, XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_10_WIDTH))

/*! @brief Set the BBF_RES_TUNE_VAL_10 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_10(base, value) (XCVR_RMW_BBF_RES_TUNE_VAL_10_8(base, XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_10_MASK, XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_10(value)))
#define XCVR_BWR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_10(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_VAL_10_8_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_10_SHIFT), XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_10_SHIFT, XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_10_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TCA_AGC_LIN_VAL_2_0 - TCA AGC Linear Gain Values 2..0
 ******************************************************************************/

/*!
 * @brief XCVR_TCA_AGC_LIN_VAL_2_0 - TCA AGC Linear Gain Values 2..0 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_TCA_AGC_LIN_VAL_2_0 register
 */
/*@{*/
#define XCVR_RD_TCA_AGC_LIN_VAL_2_0(base) (XCVR_TCA_AGC_LIN_VAL_2_0_REG(base))
#define XCVR_WR_TCA_AGC_LIN_VAL_2_0(base, value) (XCVR_TCA_AGC_LIN_VAL_2_0_REG(base) = (value))
#define XCVR_RMW_TCA_AGC_LIN_VAL_2_0(base, mask, value) (XCVR_WR_TCA_AGC_LIN_VAL_2_0(base, (XCVR_RD_TCA_AGC_LIN_VAL_2_0(base) & ~(mask)) | (value)))
#define XCVR_SET_TCA_AGC_LIN_VAL_2_0(base, value) (BME_OR32(&XCVR_TCA_AGC_LIN_VAL_2_0_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TCA_AGC_LIN_VAL_2_0(base, value) (BME_AND32(&XCVR_TCA_AGC_LIN_VAL_2_0_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TCA_AGC_LIN_VAL_2_0(base, value) (BME_XOR32(&XCVR_TCA_AGC_LIN_VAL_2_0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TCA_AGC_LIN_VAL_2_0 bitfields
 */

/*!
 * @name Register XCVR_TCA_AGC_LIN_VAL_2_0, field TCA_AGC_LIN_VAL_0[9:0] (RW)
 *
 * Linear gain (8.2).
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_0 field. */
#define XCVR_RD_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_0(base) ((XCVR_TCA_AGC_LIN_VAL_2_0_REG(base) & XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_0_MASK) >> XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_0_SHIFT)
#define XCVR_BRD_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_0(base) (BME_UBFX32(&XCVR_TCA_AGC_LIN_VAL_2_0_REG(base), XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_0_SHIFT, XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_0_WIDTH))

/*! @brief Set the TCA_AGC_LIN_VAL_0 field to a new value. */
#define XCVR_WR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_0(base, value) (XCVR_RMW_TCA_AGC_LIN_VAL_2_0(base, XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_0_MASK, XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_0(value)))
#define XCVR_BWR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_0(base, value) (BME_BFI32(&XCVR_TCA_AGC_LIN_VAL_2_0_REG(base), ((uint32_t)(value) << XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_0_SHIFT), XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_0_SHIFT, XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_0_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TCA_AGC_LIN_VAL_2_0, field TCA_AGC_LIN_VAL_1[19:10] (RW)
 *
 * LNM linear gain value for index 1, e.g. nominal value is 10^(3/20). Stored
 * with 2 fractional bits, e.g. round([10^(3/20)]*2^2) = 6decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_1 field. */
#define XCVR_RD_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_1(base) ((XCVR_TCA_AGC_LIN_VAL_2_0_REG(base) & XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_1_MASK) >> XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_1_SHIFT)
#define XCVR_BRD_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_1(base) (BME_UBFX32(&XCVR_TCA_AGC_LIN_VAL_2_0_REG(base), XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_1_SHIFT, XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_1_WIDTH))

/*! @brief Set the TCA_AGC_LIN_VAL_1 field to a new value. */
#define XCVR_WR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_1(base, value) (XCVR_RMW_TCA_AGC_LIN_VAL_2_0(base, XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_1_MASK, XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_1(value)))
#define XCVR_BWR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_1(base, value) (BME_BFI32(&XCVR_TCA_AGC_LIN_VAL_2_0_REG(base), ((uint32_t)(value) << XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_1_SHIFT), XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_1_SHIFT, XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_1_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TCA_AGC_LIN_VAL_2_0, field TCA_AGC_LIN_VAL_2[29:20] (RW)
 *
 * LNM linear gain value for index 2, e.g. nominal value is 10^(9/20). Stored
 * with 2 fractional bits, e.g. round([10^(9/20)]*2^2) = 11decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_2 field. */
#define XCVR_RD_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_2(base) ((XCVR_TCA_AGC_LIN_VAL_2_0_REG(base) & XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_2_MASK) >> XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_2_SHIFT)
#define XCVR_BRD_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_2(base) (BME_UBFX32(&XCVR_TCA_AGC_LIN_VAL_2_0_REG(base), XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_2_SHIFT, XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_2_WIDTH))

/*! @brief Set the TCA_AGC_LIN_VAL_2 field to a new value. */
#define XCVR_WR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_2(base, value) (XCVR_RMW_TCA_AGC_LIN_VAL_2_0(base, XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_2_MASK, XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_2(value)))
#define XCVR_BWR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_2(base, value) (BME_BFI32(&XCVR_TCA_AGC_LIN_VAL_2_0_REG(base), ((uint32_t)(value) << XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_2_SHIFT), XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_2_SHIFT, XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_2_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TCA_AGC_LIN_VAL_5_3 - TCA AGC Linear Gain Values 5..3
 ******************************************************************************/

/*!
 * @brief XCVR_TCA_AGC_LIN_VAL_5_3 - TCA AGC Linear Gain Values 5..3 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_TCA_AGC_LIN_VAL_5_3 register
 */
/*@{*/
#define XCVR_RD_TCA_AGC_LIN_VAL_5_3(base) (XCVR_TCA_AGC_LIN_VAL_5_3_REG(base))
#define XCVR_WR_TCA_AGC_LIN_VAL_5_3(base, value) (XCVR_TCA_AGC_LIN_VAL_5_3_REG(base) = (value))
#define XCVR_RMW_TCA_AGC_LIN_VAL_5_3(base, mask, value) (XCVR_WR_TCA_AGC_LIN_VAL_5_3(base, (XCVR_RD_TCA_AGC_LIN_VAL_5_3(base) & ~(mask)) | (value)))
#define XCVR_SET_TCA_AGC_LIN_VAL_5_3(base, value) (BME_OR32(&XCVR_TCA_AGC_LIN_VAL_5_3_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TCA_AGC_LIN_VAL_5_3(base, value) (BME_AND32(&XCVR_TCA_AGC_LIN_VAL_5_3_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TCA_AGC_LIN_VAL_5_3(base, value) (BME_XOR32(&XCVR_TCA_AGC_LIN_VAL_5_3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TCA_AGC_LIN_VAL_5_3 bitfields
 */

/*!
 * @name Register XCVR_TCA_AGC_LIN_VAL_5_3, field TCA_AGC_LIN_VAL_3[9:0] (RW)
 *
 * LNM linear gain value for index 3, e.g. nominal value is 10^(15/20). Stored
 * with 2 fractional bits, e.g. round([10^(15/20)]*2^2) = 22decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_3 field. */
#define XCVR_RD_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_3(base) ((XCVR_TCA_AGC_LIN_VAL_5_3_REG(base) & XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_3_MASK) >> XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_3_SHIFT)
#define XCVR_BRD_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_3(base) (BME_UBFX32(&XCVR_TCA_AGC_LIN_VAL_5_3_REG(base), XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_3_SHIFT, XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_3_WIDTH))

/*! @brief Set the TCA_AGC_LIN_VAL_3 field to a new value. */
#define XCVR_WR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_3(base, value) (XCVR_RMW_TCA_AGC_LIN_VAL_5_3(base, XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_3_MASK, XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_3(value)))
#define XCVR_BWR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_3(base, value) (BME_BFI32(&XCVR_TCA_AGC_LIN_VAL_5_3_REG(base), ((uint32_t)(value) << XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_3_SHIFT), XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_3_SHIFT, XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_3_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TCA_AGC_LIN_VAL_5_3, field TCA_AGC_LIN_VAL_4[19:10] (RW)
 *
 * LNM linear gain value for index 4, e.g. nominal value is 10^(21/20). Stored
 * with 2 fractional bits, e.g. round([10^(21/20)]*2^2) = 45decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_4 field. */
#define XCVR_RD_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_4(base) ((XCVR_TCA_AGC_LIN_VAL_5_3_REG(base) & XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_4_MASK) >> XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_4_SHIFT)
#define XCVR_BRD_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_4(base) (BME_UBFX32(&XCVR_TCA_AGC_LIN_VAL_5_3_REG(base), XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_4_SHIFT, XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_4_WIDTH))

/*! @brief Set the TCA_AGC_LIN_VAL_4 field to a new value. */
#define XCVR_WR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_4(base, value) (XCVR_RMW_TCA_AGC_LIN_VAL_5_3(base, XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_4_MASK, XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_4(value)))
#define XCVR_BWR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_4(base, value) (BME_BFI32(&XCVR_TCA_AGC_LIN_VAL_5_3_REG(base), ((uint32_t)(value) << XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_4_SHIFT), XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_4_SHIFT, XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_4_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TCA_AGC_LIN_VAL_5_3, field TCA_AGC_LIN_VAL_5[29:20] (RW)
 *
 * LNM linear gain value for index 5, e.g. nominal value is 10^(27/20). Stored
 * with 2 fractional bits, e.g. round([10^(27/20)]*2^2) = 90decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_5 field. */
#define XCVR_RD_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_5(base) ((XCVR_TCA_AGC_LIN_VAL_5_3_REG(base) & XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_5_MASK) >> XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_5_SHIFT)
#define XCVR_BRD_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_5(base) (BME_UBFX32(&XCVR_TCA_AGC_LIN_VAL_5_3_REG(base), XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_5_SHIFT, XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_5_WIDTH))

/*! @brief Set the TCA_AGC_LIN_VAL_5 field to a new value. */
#define XCVR_WR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_5(base, value) (XCVR_RMW_TCA_AGC_LIN_VAL_5_3(base, XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_5_MASK, XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_5(value)))
#define XCVR_BWR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_5(base, value) (BME_BFI32(&XCVR_TCA_AGC_LIN_VAL_5_3_REG(base), ((uint32_t)(value) << XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_5_SHIFT), XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_5_SHIFT, XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_5_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TCA_AGC_LIN_VAL_8_6 - TCA AGC Linear Gain Values 8..6
 ******************************************************************************/

/*!
 * @brief XCVR_TCA_AGC_LIN_VAL_8_6 - TCA AGC Linear Gain Values 8..6 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_TCA_AGC_LIN_VAL_8_6 register
 */
/*@{*/
#define XCVR_RD_TCA_AGC_LIN_VAL_8_6(base) (XCVR_TCA_AGC_LIN_VAL_8_6_REG(base))
#define XCVR_WR_TCA_AGC_LIN_VAL_8_6(base, value) (XCVR_TCA_AGC_LIN_VAL_8_6_REG(base) = (value))
#define XCVR_RMW_TCA_AGC_LIN_VAL_8_6(base, mask, value) (XCVR_WR_TCA_AGC_LIN_VAL_8_6(base, (XCVR_RD_TCA_AGC_LIN_VAL_8_6(base) & ~(mask)) | (value)))
#define XCVR_SET_TCA_AGC_LIN_VAL_8_6(base, value) (BME_OR32(&XCVR_TCA_AGC_LIN_VAL_8_6_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TCA_AGC_LIN_VAL_8_6(base, value) (BME_AND32(&XCVR_TCA_AGC_LIN_VAL_8_6_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TCA_AGC_LIN_VAL_8_6(base, value) (BME_XOR32(&XCVR_TCA_AGC_LIN_VAL_8_6_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TCA_AGC_LIN_VAL_8_6 bitfields
 */

/*!
 * @name Register XCVR_TCA_AGC_LIN_VAL_8_6, field TCA_AGC_LIN_VAL_6[9:0] (RW)
 *
 * LNM linear gain value for index 6, e.g. nominal value is 10^(33/20). Stored
 * with 2 fractional bits, e.g. round([10^(33/20)]*2^2) = 179decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_6 field. */
#define XCVR_RD_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_6(base) ((XCVR_TCA_AGC_LIN_VAL_8_6_REG(base) & XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_6_MASK) >> XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_6_SHIFT)
#define XCVR_BRD_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_6(base) (BME_UBFX32(&XCVR_TCA_AGC_LIN_VAL_8_6_REG(base), XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_6_SHIFT, XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_6_WIDTH))

/*! @brief Set the TCA_AGC_LIN_VAL_6 field to a new value. */
#define XCVR_WR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_6(base, value) (XCVR_RMW_TCA_AGC_LIN_VAL_8_6(base, XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_6_MASK, XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_6(value)))
#define XCVR_BWR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_6(base, value) (BME_BFI32(&XCVR_TCA_AGC_LIN_VAL_8_6_REG(base), ((uint32_t)(value) << XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_6_SHIFT), XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_6_SHIFT, XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_6_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TCA_AGC_LIN_VAL_8_6, field TCA_AGC_LIN_VAL_7[19:10] (RW)
 *
 * LNM linear gain value for index 7, e.g. nominal value is 10^(39/20). Stored
 * with 2 fractional bits, e.g. round([10^(39/20)]*2^2) = 357decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_7 field. */
#define XCVR_RD_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_7(base) ((XCVR_TCA_AGC_LIN_VAL_8_6_REG(base) & XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_7_MASK) >> XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_7_SHIFT)
#define XCVR_BRD_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_7(base) (BME_UBFX32(&XCVR_TCA_AGC_LIN_VAL_8_6_REG(base), XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_7_SHIFT, XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_7_WIDTH))

/*! @brief Set the TCA_AGC_LIN_VAL_7 field to a new value. */
#define XCVR_WR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_7(base, value) (XCVR_RMW_TCA_AGC_LIN_VAL_8_6(base, XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_7_MASK, XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_7(value)))
#define XCVR_BWR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_7(base, value) (BME_BFI32(&XCVR_TCA_AGC_LIN_VAL_8_6_REG(base), ((uint32_t)(value) << XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_7_SHIFT), XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_7_SHIFT, XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_7_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TCA_AGC_LIN_VAL_8_6, field TCA_AGC_LIN_VAL_8[29:20] (RW)
 *
 * LNM linear gain value for index 8, e.g. nominal value is 10^(45/20). Stored
 * with 2 fractional bits, e.g. round([10^(45/20)]*2^2) = 711decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_8 field. */
#define XCVR_RD_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_8(base) ((XCVR_TCA_AGC_LIN_VAL_8_6_REG(base) & XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_8_MASK) >> XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_8_SHIFT)
#define XCVR_BRD_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_8(base) (BME_UBFX32(&XCVR_TCA_AGC_LIN_VAL_8_6_REG(base), XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_8_SHIFT, XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_8_WIDTH))

/*! @brief Set the TCA_AGC_LIN_VAL_8 field to a new value. */
#define XCVR_WR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_8(base, value) (XCVR_RMW_TCA_AGC_LIN_VAL_8_6(base, XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_8_MASK, XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_8(value)))
#define XCVR_BWR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_8(base, value) (BME_BFI32(&XCVR_TCA_AGC_LIN_VAL_8_6_REG(base), ((uint32_t)(value) << XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_8_SHIFT), XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_8_SHIFT, XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_8_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_BBF_RES_TUNE_LIN_VAL_3_0 - BBF Resistor Tune Values 3..0
 ******************************************************************************/

/*!
 * @brief XCVR_BBF_RES_TUNE_LIN_VAL_3_0 - BBF Resistor Tune Values 3..0 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_BBF_RES_TUNE_LIN_VAL_3_0 register
 */
/*@{*/
#define XCVR_RD_BBF_RES_TUNE_LIN_VAL_3_0(base) (XCVR_BBF_RES_TUNE_LIN_VAL_3_0_REG(base))
#define XCVR_WR_BBF_RES_TUNE_LIN_VAL_3_0(base, value) (XCVR_BBF_RES_TUNE_LIN_VAL_3_0_REG(base) = (value))
#define XCVR_RMW_BBF_RES_TUNE_LIN_VAL_3_0(base, mask, value) (XCVR_WR_BBF_RES_TUNE_LIN_VAL_3_0(base, (XCVR_RD_BBF_RES_TUNE_LIN_VAL_3_0(base) & ~(mask)) | (value)))
#define XCVR_SET_BBF_RES_TUNE_LIN_VAL_3_0(base, value) (BME_OR32(&XCVR_BBF_RES_TUNE_LIN_VAL_3_0_REG(base), (uint32_t)(value)))
#define XCVR_CLR_BBF_RES_TUNE_LIN_VAL_3_0(base, value) (BME_AND32(&XCVR_BBF_RES_TUNE_LIN_VAL_3_0_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_BBF_RES_TUNE_LIN_VAL_3_0(base, value) (BME_XOR32(&XCVR_BBF_RES_TUNE_LIN_VAL_3_0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_BBF_RES_TUNE_LIN_VAL_3_0 bitfields
 */

/*!
 * @name Register XCVR_BBF_RES_TUNE_LIN_VAL_3_0, field BBF_RES_TUNE_LIN_VAL_0[7:0] (RW)
 *
 * BBF linear gain value for index 0 (format: 5.3). Nominal value is 10^(0/20).
 * Stored with 3 fractional bits, e.g. round([10^(0/20)]*2^3) = 8decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_0 field. */
#define XCVR_RD_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_0(base) ((XCVR_BBF_RES_TUNE_LIN_VAL_3_0_REG(base) & XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_0_MASK) >> XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_0_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_0(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_LIN_VAL_3_0_REG(base), XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_0_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_0_WIDTH))

/*! @brief Set the BBF_RES_TUNE_LIN_VAL_0 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_0(base, value) (XCVR_RMW_BBF_RES_TUNE_LIN_VAL_3_0(base, XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_0_MASK, XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_0(value)))
#define XCVR_BWR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_0(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_LIN_VAL_3_0_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_0_SHIFT), XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_0_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_0_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_RES_TUNE_LIN_VAL_3_0, field BBF_RES_TUNE_LIN_VAL_1[15:8] (RW)
 *
 * BBF linear gain value for index 1 (format: 5.3). Nominal value is 10^(3/20).
 * Stored with 3 fractional bits, e.g. round([10^(3/20)]*2^3) = 11decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_1 field. */
#define XCVR_RD_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_1(base) ((XCVR_BBF_RES_TUNE_LIN_VAL_3_0_REG(base) & XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_1_MASK) >> XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_1_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_1(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_LIN_VAL_3_0_REG(base), XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_1_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_1_WIDTH))

/*! @brief Set the BBF_RES_TUNE_LIN_VAL_1 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_1(base, value) (XCVR_RMW_BBF_RES_TUNE_LIN_VAL_3_0(base, XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_1_MASK, XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_1(value)))
#define XCVR_BWR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_1(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_LIN_VAL_3_0_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_1_SHIFT), XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_1_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_1_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_RES_TUNE_LIN_VAL_3_0, field BBF_RES_TUNE_LIN_VAL_2[23:16] (RW)
 *
 * BBF linear gain value for index 2 (format: 5.3). Nominal value is 10^(6/20).
 * Stored with 3 fractional bits, e.g. round([10^(6/20)]*2^3) = 16decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_2 field. */
#define XCVR_RD_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_2(base) ((XCVR_BBF_RES_TUNE_LIN_VAL_3_0_REG(base) & XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_2_MASK) >> XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_2_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_2(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_LIN_VAL_3_0_REG(base), XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_2_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_2_WIDTH))

/*! @brief Set the BBF_RES_TUNE_LIN_VAL_2 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_2(base, value) (XCVR_RMW_BBF_RES_TUNE_LIN_VAL_3_0(base, XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_2_MASK, XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_2(value)))
#define XCVR_BWR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_2(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_LIN_VAL_3_0_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_2_SHIFT), XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_2_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_2_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_RES_TUNE_LIN_VAL_3_0, field BBF_RES_TUNE_LIN_VAL_3[31:24] (RW)
 *
 * BBF linear gain value for index 3 (format: 5.3). Nominal value is 10^(9/20).
 * Stored with 3 fractional bits, e.g. round([10^(9/20)]*2^3) = 23decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_3 field. */
#define XCVR_RD_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_3(base) ((XCVR_BBF_RES_TUNE_LIN_VAL_3_0_REG(base) & XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_3_MASK) >> XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_3_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_3(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_LIN_VAL_3_0_REG(base), XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_3_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_3_WIDTH))

/*! @brief Set the BBF_RES_TUNE_LIN_VAL_3 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_3(base, value) (XCVR_RMW_BBF_RES_TUNE_LIN_VAL_3_0(base, XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_3_MASK, XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_3(value)))
#define XCVR_BWR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_3(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_LIN_VAL_3_0_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_3_SHIFT), XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_3_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_3_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_BBF_RES_TUNE_LIN_VAL_7_4 - BBF Resistor Tune Values 7..4
 ******************************************************************************/

/*!
 * @brief XCVR_BBF_RES_TUNE_LIN_VAL_7_4 - BBF Resistor Tune Values 7..4 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_BBF_RES_TUNE_LIN_VAL_7_4 register
 */
/*@{*/
#define XCVR_RD_BBF_RES_TUNE_LIN_VAL_7_4(base) (XCVR_BBF_RES_TUNE_LIN_VAL_7_4_REG(base))
#define XCVR_WR_BBF_RES_TUNE_LIN_VAL_7_4(base, value) (XCVR_BBF_RES_TUNE_LIN_VAL_7_4_REG(base) = (value))
#define XCVR_RMW_BBF_RES_TUNE_LIN_VAL_7_4(base, mask, value) (XCVR_WR_BBF_RES_TUNE_LIN_VAL_7_4(base, (XCVR_RD_BBF_RES_TUNE_LIN_VAL_7_4(base) & ~(mask)) | (value)))
#define XCVR_SET_BBF_RES_TUNE_LIN_VAL_7_4(base, value) (BME_OR32(&XCVR_BBF_RES_TUNE_LIN_VAL_7_4_REG(base), (uint32_t)(value)))
#define XCVR_CLR_BBF_RES_TUNE_LIN_VAL_7_4(base, value) (BME_AND32(&XCVR_BBF_RES_TUNE_LIN_VAL_7_4_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_BBF_RES_TUNE_LIN_VAL_7_4(base, value) (BME_XOR32(&XCVR_BBF_RES_TUNE_LIN_VAL_7_4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_BBF_RES_TUNE_LIN_VAL_7_4 bitfields
 */

/*!
 * @name Register XCVR_BBF_RES_TUNE_LIN_VAL_7_4, field BBF_RES_TUNE_LIN_VAL_4[7:0] (RW)
 *
 * BBF linear gain value for index 4 (format: 5.3). Nominal value is 10^(12/20).
 * Stored with 3 fractional bits, e.g. round([10^(12/20)]*2^3) = 32decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_4 field. */
#define XCVR_RD_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_4(base) ((XCVR_BBF_RES_TUNE_LIN_VAL_7_4_REG(base) & XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_4_MASK) >> XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_4_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_4(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_LIN_VAL_7_4_REG(base), XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_4_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_4_WIDTH))

/*! @brief Set the BBF_RES_TUNE_LIN_VAL_4 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_4(base, value) (XCVR_RMW_BBF_RES_TUNE_LIN_VAL_7_4(base, XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_4_MASK, XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_4(value)))
#define XCVR_BWR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_4(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_LIN_VAL_7_4_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_4_SHIFT), XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_4_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_4_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_RES_TUNE_LIN_VAL_7_4, field BBF_RES_TUNE_LIN_VAL_5[15:8] (RW)
 *
 * BBF linear gain value for index 5 (format: 5.3). Nominal value is 10^(15/20).
 * Stored with 3 fractional bits, e.g. round([10^(15/20)]*2^3) = 45decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_5 field. */
#define XCVR_RD_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_5(base) ((XCVR_BBF_RES_TUNE_LIN_VAL_7_4_REG(base) & XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_5_MASK) >> XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_5_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_5(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_LIN_VAL_7_4_REG(base), XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_5_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_5_WIDTH))

/*! @brief Set the BBF_RES_TUNE_LIN_VAL_5 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_5(base, value) (XCVR_RMW_BBF_RES_TUNE_LIN_VAL_7_4(base, XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_5_MASK, XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_5(value)))
#define XCVR_BWR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_5(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_LIN_VAL_7_4_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_5_SHIFT), XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_5_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_5_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_RES_TUNE_LIN_VAL_7_4, field BBF_RES_TUNE_LIN_VAL_6[23:16] (RW)
 *
 * BBF linear gain value for index 6 (format: 5.3). Nominal value is 10^(18/20).
 * Stored with 3 fractional bits, e.g. round([10^(18/20)]*2^3) = 64decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_6 field. */
#define XCVR_RD_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_6(base) ((XCVR_BBF_RES_TUNE_LIN_VAL_7_4_REG(base) & XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_6_MASK) >> XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_6_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_6(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_LIN_VAL_7_4_REG(base), XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_6_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_6_WIDTH))

/*! @brief Set the BBF_RES_TUNE_LIN_VAL_6 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_6(base, value) (XCVR_RMW_BBF_RES_TUNE_LIN_VAL_7_4(base, XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_6_MASK, XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_6(value)))
#define XCVR_BWR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_6(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_LIN_VAL_7_4_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_6_SHIFT), XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_6_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_6_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_RES_TUNE_LIN_VAL_7_4, field BBF_RES_TUNE_LIN_VAL_7[31:24] (RW)
 *
 * BBF linear gain value for index 7 (format: 5.3). Nominal value is 10^(21/20).
 * Stored with 3 fractional bits, e.g. round([10^(21/20)]*2^3) = 90decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_7 field. */
#define XCVR_RD_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_7(base) ((XCVR_BBF_RES_TUNE_LIN_VAL_7_4_REG(base) & XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_7_MASK) >> XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_7_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_7(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_LIN_VAL_7_4_REG(base), XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_7_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_7_WIDTH))

/*! @brief Set the BBF_RES_TUNE_LIN_VAL_7 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_7(base, value) (XCVR_RMW_BBF_RES_TUNE_LIN_VAL_7_4(base, XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_7_MASK, XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_7(value)))
#define XCVR_BWR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_7(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_LIN_VAL_7_4_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_7_SHIFT), XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_7_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_7_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_BBF_RES_TUNE_LIN_VAL_10_8 - BBF Resistor Tune Values 10..8
 ******************************************************************************/

/*!
 * @brief XCVR_BBF_RES_TUNE_LIN_VAL_10_8 - BBF Resistor Tune Values 10..8 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_BBF_RES_TUNE_LIN_VAL_10_8 register
 */
/*@{*/
#define XCVR_RD_BBF_RES_TUNE_LIN_VAL_10_8(base) (XCVR_BBF_RES_TUNE_LIN_VAL_10_8_REG(base))
#define XCVR_WR_BBF_RES_TUNE_LIN_VAL_10_8(base, value) (XCVR_BBF_RES_TUNE_LIN_VAL_10_8_REG(base) = (value))
#define XCVR_RMW_BBF_RES_TUNE_LIN_VAL_10_8(base, mask, value) (XCVR_WR_BBF_RES_TUNE_LIN_VAL_10_8(base, (XCVR_RD_BBF_RES_TUNE_LIN_VAL_10_8(base) & ~(mask)) | (value)))
#define XCVR_SET_BBF_RES_TUNE_LIN_VAL_10_8(base, value) (BME_OR32(&XCVR_BBF_RES_TUNE_LIN_VAL_10_8_REG(base), (uint32_t)(value)))
#define XCVR_CLR_BBF_RES_TUNE_LIN_VAL_10_8(base, value) (BME_AND32(&XCVR_BBF_RES_TUNE_LIN_VAL_10_8_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_BBF_RES_TUNE_LIN_VAL_10_8(base, value) (BME_XOR32(&XCVR_BBF_RES_TUNE_LIN_VAL_10_8_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_BBF_RES_TUNE_LIN_VAL_10_8 bitfields
 */

/*!
 * @name Register XCVR_BBF_RES_TUNE_LIN_VAL_10_8, field BBF_RES_TUNE_LIN_VAL_8[7:0] (RW)
 *
 * BBF linear gain value for index 8 (format: 5.3). Nominal value is 10^(24/20).
 * Stored with 3 fractional bits, e.g. round([10^(24/20)]*2^3) = 127decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_8 field. */
#define XCVR_RD_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_8(base) ((XCVR_BBF_RES_TUNE_LIN_VAL_10_8_REG(base) & XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_8_MASK) >> XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_8_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_8(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_LIN_VAL_10_8_REG(base), XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_8_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_8_WIDTH))

/*! @brief Set the BBF_RES_TUNE_LIN_VAL_8 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_8(base, value) (XCVR_RMW_BBF_RES_TUNE_LIN_VAL_10_8(base, XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_8_MASK, XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_8(value)))
#define XCVR_BWR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_8(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_LIN_VAL_10_8_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_8_SHIFT), XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_8_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_8_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_RES_TUNE_LIN_VAL_10_8, field BBF_RES_TUNE_LIN_VAL_9[15:8] (RW)
 *
 * BBF linear gain value for index 9 (format: 5.3). Nominal value is 10^(27/20).
 * Stored with 3 fractional bits, e.g. round([10^(27/20)]*2^3) = 179decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_9 field. */
#define XCVR_RD_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_9(base) ((XCVR_BBF_RES_TUNE_LIN_VAL_10_8_REG(base) & XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_9_MASK) >> XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_9_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_9(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_LIN_VAL_10_8_REG(base), XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_9_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_9_WIDTH))

/*! @brief Set the BBF_RES_TUNE_LIN_VAL_9 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_9(base, value) (XCVR_RMW_BBF_RES_TUNE_LIN_VAL_10_8(base, XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_9_MASK, XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_9(value)))
#define XCVR_BWR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_9(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_LIN_VAL_10_8_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_9_SHIFT), XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_9_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_9_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_RES_TUNE_LIN_VAL_10_8, field BBF_RES_TUNE_LIN_VAL_10[23:16] (RW)
 *
 * BBF linear gain value for index 10 (format: 5.3). Nominal value is
 * 10^(30/20). Stored with 3 fractional bits, e.g. round([10^(30/20)]*2^3) = 253decimal
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_10 field. */
#define XCVR_RD_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_10(base) ((XCVR_BBF_RES_TUNE_LIN_VAL_10_8_REG(base) & XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_10_MASK) >> XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_10_SHIFT)
#define XCVR_BRD_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_10(base) (BME_UBFX32(&XCVR_BBF_RES_TUNE_LIN_VAL_10_8_REG(base), XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_10_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_10_WIDTH))

/*! @brief Set the BBF_RES_TUNE_LIN_VAL_10 field to a new value. */
#define XCVR_WR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_10(base, value) (XCVR_RMW_BBF_RES_TUNE_LIN_VAL_10_8(base, XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_10_MASK, XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_10(value)))
#define XCVR_BWR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_10(base, value) (BME_BFI32(&XCVR_BBF_RES_TUNE_LIN_VAL_10_8_REG(base), ((uint32_t)(value) << XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_10_SHIFT), XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_10_SHIFT, XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_10_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_AGC_GAIN_TBL_03_00 - AGC Gain Tables Step 03..00
 ******************************************************************************/

/*!
 * @brief XCVR_AGC_GAIN_TBL_03_00 - AGC Gain Tables Step 03..00 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_AGC_GAIN_TBL_03_00 register
 */
/*@{*/
#define XCVR_RD_AGC_GAIN_TBL_03_00(base) (XCVR_AGC_GAIN_TBL_03_00_REG(base))
#define XCVR_WR_AGC_GAIN_TBL_03_00(base, value) (XCVR_AGC_GAIN_TBL_03_00_REG(base) = (value))
#define XCVR_RMW_AGC_GAIN_TBL_03_00(base, mask, value) (XCVR_WR_AGC_GAIN_TBL_03_00(base, (XCVR_RD_AGC_GAIN_TBL_03_00(base) & ~(mask)) | (value)))
#define XCVR_SET_AGC_GAIN_TBL_03_00(base, value) (BME_OR32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), (uint32_t)(value)))
#define XCVR_CLR_AGC_GAIN_TBL_03_00(base, value) (BME_AND32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_AGC_GAIN_TBL_03_00(base, value) (BME_XOR32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_AGC_GAIN_TBL_03_00 bitfields
 */

/*!
 * @name Register XCVR_AGC_GAIN_TBL_03_00, field BBF_GAIN_00[3:0] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_00 field. */
#define XCVR_RD_AGC_GAIN_TBL_03_00_BBF_GAIN_00(base) ((XCVR_AGC_GAIN_TBL_03_00_REG(base) & XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_00_MASK) >> XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_00_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_03_00_BBF_GAIN_00(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_00_SHIFT, XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_00_WIDTH))

/*! @brief Set the BBF_GAIN_00 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_03_00_BBF_GAIN_00(base, value) (XCVR_RMW_AGC_GAIN_TBL_03_00(base, XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_00_MASK, XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_00(value)))
#define XCVR_BWR_AGC_GAIN_TBL_03_00_BBF_GAIN_00(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_00_SHIFT), XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_00_SHIFT, XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_00_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_03_00, field LNM_GAIN_00[7:4] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_00 field. */
#define XCVR_RD_AGC_GAIN_TBL_03_00_LNM_GAIN_00(base) ((XCVR_AGC_GAIN_TBL_03_00_REG(base) & XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_00_MASK) >> XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_00_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_03_00_LNM_GAIN_00(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_00_SHIFT, XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_00_WIDTH))

/*! @brief Set the LNM_GAIN_00 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_03_00_LNM_GAIN_00(base, value) (XCVR_RMW_AGC_GAIN_TBL_03_00(base, XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_00_MASK, XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_00(value)))
#define XCVR_BWR_AGC_GAIN_TBL_03_00_LNM_GAIN_00(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_00_SHIFT), XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_00_SHIFT, XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_00_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_03_00, field BBF_GAIN_01[11:8] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_01 field. */
#define XCVR_RD_AGC_GAIN_TBL_03_00_BBF_GAIN_01(base) ((XCVR_AGC_GAIN_TBL_03_00_REG(base) & XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_01_MASK) >> XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_01_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_03_00_BBF_GAIN_01(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_01_SHIFT, XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_01_WIDTH))

/*! @brief Set the BBF_GAIN_01 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_03_00_BBF_GAIN_01(base, value) (XCVR_RMW_AGC_GAIN_TBL_03_00(base, XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_01_MASK, XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_01(value)))
#define XCVR_BWR_AGC_GAIN_TBL_03_00_BBF_GAIN_01(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_01_SHIFT), XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_01_SHIFT, XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_01_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_03_00, field LNM_GAIN_01[15:12] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_01 field. */
#define XCVR_RD_AGC_GAIN_TBL_03_00_LNM_GAIN_01(base) ((XCVR_AGC_GAIN_TBL_03_00_REG(base) & XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_01_MASK) >> XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_01_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_03_00_LNM_GAIN_01(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_01_SHIFT, XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_01_WIDTH))

/*! @brief Set the LNM_GAIN_01 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_03_00_LNM_GAIN_01(base, value) (XCVR_RMW_AGC_GAIN_TBL_03_00(base, XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_01_MASK, XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_01(value)))
#define XCVR_BWR_AGC_GAIN_TBL_03_00_LNM_GAIN_01(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_01_SHIFT), XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_01_SHIFT, XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_01_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_03_00, field BBF_GAIN_02[19:16] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_02 field. */
#define XCVR_RD_AGC_GAIN_TBL_03_00_BBF_GAIN_02(base) ((XCVR_AGC_GAIN_TBL_03_00_REG(base) & XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_02_MASK) >> XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_02_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_03_00_BBF_GAIN_02(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_02_SHIFT, XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_02_WIDTH))

/*! @brief Set the BBF_GAIN_02 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_03_00_BBF_GAIN_02(base, value) (XCVR_RMW_AGC_GAIN_TBL_03_00(base, XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_02_MASK, XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_02(value)))
#define XCVR_BWR_AGC_GAIN_TBL_03_00_BBF_GAIN_02(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_02_SHIFT), XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_02_SHIFT, XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_02_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_03_00, field LNM_GAIN_02[23:20] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_02 field. */
#define XCVR_RD_AGC_GAIN_TBL_03_00_LNM_GAIN_02(base) ((XCVR_AGC_GAIN_TBL_03_00_REG(base) & XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_02_MASK) >> XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_02_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_03_00_LNM_GAIN_02(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_02_SHIFT, XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_02_WIDTH))

/*! @brief Set the LNM_GAIN_02 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_03_00_LNM_GAIN_02(base, value) (XCVR_RMW_AGC_GAIN_TBL_03_00(base, XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_02_MASK, XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_02(value)))
#define XCVR_BWR_AGC_GAIN_TBL_03_00_LNM_GAIN_02(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_02_SHIFT), XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_02_SHIFT, XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_02_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_03_00, field BBF_GAIN_03[27:24] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_03 field. */
#define XCVR_RD_AGC_GAIN_TBL_03_00_BBF_GAIN_03(base) ((XCVR_AGC_GAIN_TBL_03_00_REG(base) & XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_03_MASK) >> XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_03_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_03_00_BBF_GAIN_03(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_03_SHIFT, XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_03_WIDTH))

/*! @brief Set the BBF_GAIN_03 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_03_00_BBF_GAIN_03(base, value) (XCVR_RMW_AGC_GAIN_TBL_03_00(base, XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_03_MASK, XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_03(value)))
#define XCVR_BWR_AGC_GAIN_TBL_03_00_BBF_GAIN_03(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_03_SHIFT), XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_03_SHIFT, XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_03_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_03_00, field LNM_GAIN_03[31:28] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_03 field. */
#define XCVR_RD_AGC_GAIN_TBL_03_00_LNM_GAIN_03(base) ((XCVR_AGC_GAIN_TBL_03_00_REG(base) & XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_03_MASK) >> XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_03_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_03_00_LNM_GAIN_03(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_03_SHIFT, XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_03_WIDTH))

/*! @brief Set the LNM_GAIN_03 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_03_00_LNM_GAIN_03(base, value) (XCVR_RMW_AGC_GAIN_TBL_03_00(base, XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_03_MASK, XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_03(value)))
#define XCVR_BWR_AGC_GAIN_TBL_03_00_LNM_GAIN_03(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_03_00_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_03_SHIFT), XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_03_SHIFT, XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_03_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_AGC_GAIN_TBL_07_04 - AGC Gain Tables Step 07..04
 ******************************************************************************/

/*!
 * @brief XCVR_AGC_GAIN_TBL_07_04 - AGC Gain Tables Step 07..04 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_AGC_GAIN_TBL_07_04 register
 */
/*@{*/
#define XCVR_RD_AGC_GAIN_TBL_07_04(base) (XCVR_AGC_GAIN_TBL_07_04_REG(base))
#define XCVR_WR_AGC_GAIN_TBL_07_04(base, value) (XCVR_AGC_GAIN_TBL_07_04_REG(base) = (value))
#define XCVR_RMW_AGC_GAIN_TBL_07_04(base, mask, value) (XCVR_WR_AGC_GAIN_TBL_07_04(base, (XCVR_RD_AGC_GAIN_TBL_07_04(base) & ~(mask)) | (value)))
#define XCVR_SET_AGC_GAIN_TBL_07_04(base, value) (BME_OR32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), (uint32_t)(value)))
#define XCVR_CLR_AGC_GAIN_TBL_07_04(base, value) (BME_AND32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_AGC_GAIN_TBL_07_04(base, value) (BME_XOR32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_AGC_GAIN_TBL_07_04 bitfields
 */

/*!
 * @name Register XCVR_AGC_GAIN_TBL_07_04, field BBF_GAIN_04[3:0] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_04 field. */
#define XCVR_RD_AGC_GAIN_TBL_07_04_BBF_GAIN_04(base) ((XCVR_AGC_GAIN_TBL_07_04_REG(base) & XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_04_MASK) >> XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_04_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_07_04_BBF_GAIN_04(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_04_SHIFT, XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_04_WIDTH))

/*! @brief Set the BBF_GAIN_04 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_07_04_BBF_GAIN_04(base, value) (XCVR_RMW_AGC_GAIN_TBL_07_04(base, XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_04_MASK, XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_04(value)))
#define XCVR_BWR_AGC_GAIN_TBL_07_04_BBF_GAIN_04(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_04_SHIFT), XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_04_SHIFT, XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_04_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_07_04, field LNM_GAIN_04[7:4] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_04 field. */
#define XCVR_RD_AGC_GAIN_TBL_07_04_LNM_GAIN_04(base) ((XCVR_AGC_GAIN_TBL_07_04_REG(base) & XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_04_MASK) >> XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_04_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_07_04_LNM_GAIN_04(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_04_SHIFT, XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_04_WIDTH))

/*! @brief Set the LNM_GAIN_04 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_07_04_LNM_GAIN_04(base, value) (XCVR_RMW_AGC_GAIN_TBL_07_04(base, XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_04_MASK, XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_04(value)))
#define XCVR_BWR_AGC_GAIN_TBL_07_04_LNM_GAIN_04(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_04_SHIFT), XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_04_SHIFT, XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_04_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_07_04, field BBF_GAIN_05[11:8] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_05 field. */
#define XCVR_RD_AGC_GAIN_TBL_07_04_BBF_GAIN_05(base) ((XCVR_AGC_GAIN_TBL_07_04_REG(base) & XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_05_MASK) >> XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_05_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_07_04_BBF_GAIN_05(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_05_SHIFT, XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_05_WIDTH))

/*! @brief Set the BBF_GAIN_05 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_07_04_BBF_GAIN_05(base, value) (XCVR_RMW_AGC_GAIN_TBL_07_04(base, XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_05_MASK, XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_05(value)))
#define XCVR_BWR_AGC_GAIN_TBL_07_04_BBF_GAIN_05(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_05_SHIFT), XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_05_SHIFT, XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_05_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_07_04, field LNM_GAIN_05[15:12] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_05 field. */
#define XCVR_RD_AGC_GAIN_TBL_07_04_LNM_GAIN_05(base) ((XCVR_AGC_GAIN_TBL_07_04_REG(base) & XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_05_MASK) >> XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_05_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_07_04_LNM_GAIN_05(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_05_SHIFT, XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_05_WIDTH))

/*! @brief Set the LNM_GAIN_05 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_07_04_LNM_GAIN_05(base, value) (XCVR_RMW_AGC_GAIN_TBL_07_04(base, XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_05_MASK, XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_05(value)))
#define XCVR_BWR_AGC_GAIN_TBL_07_04_LNM_GAIN_05(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_05_SHIFT), XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_05_SHIFT, XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_05_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_07_04, field BBF_GAIN_06[19:16] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_06 field. */
#define XCVR_RD_AGC_GAIN_TBL_07_04_BBF_GAIN_06(base) ((XCVR_AGC_GAIN_TBL_07_04_REG(base) & XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_06_MASK) >> XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_06_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_07_04_BBF_GAIN_06(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_06_SHIFT, XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_06_WIDTH))

/*! @brief Set the BBF_GAIN_06 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_07_04_BBF_GAIN_06(base, value) (XCVR_RMW_AGC_GAIN_TBL_07_04(base, XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_06_MASK, XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_06(value)))
#define XCVR_BWR_AGC_GAIN_TBL_07_04_BBF_GAIN_06(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_06_SHIFT), XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_06_SHIFT, XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_06_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_07_04, field LNM_GAIN_06[23:20] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_06 field. */
#define XCVR_RD_AGC_GAIN_TBL_07_04_LNM_GAIN_06(base) ((XCVR_AGC_GAIN_TBL_07_04_REG(base) & XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_06_MASK) >> XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_06_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_07_04_LNM_GAIN_06(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_06_SHIFT, XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_06_WIDTH))

/*! @brief Set the LNM_GAIN_06 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_07_04_LNM_GAIN_06(base, value) (XCVR_RMW_AGC_GAIN_TBL_07_04(base, XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_06_MASK, XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_06(value)))
#define XCVR_BWR_AGC_GAIN_TBL_07_04_LNM_GAIN_06(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_06_SHIFT), XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_06_SHIFT, XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_06_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_07_04, field BBF_GAIN_07[27:24] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_07 field. */
#define XCVR_RD_AGC_GAIN_TBL_07_04_BBF_GAIN_07(base) ((XCVR_AGC_GAIN_TBL_07_04_REG(base) & XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_07_MASK) >> XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_07_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_07_04_BBF_GAIN_07(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_07_SHIFT, XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_07_WIDTH))

/*! @brief Set the BBF_GAIN_07 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_07_04_BBF_GAIN_07(base, value) (XCVR_RMW_AGC_GAIN_TBL_07_04(base, XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_07_MASK, XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_07(value)))
#define XCVR_BWR_AGC_GAIN_TBL_07_04_BBF_GAIN_07(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_07_SHIFT), XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_07_SHIFT, XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_07_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_07_04, field LNM_GAIN_07[31:28] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_07 field. */
#define XCVR_RD_AGC_GAIN_TBL_07_04_LNM_GAIN_07(base) ((XCVR_AGC_GAIN_TBL_07_04_REG(base) & XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_07_MASK) >> XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_07_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_07_04_LNM_GAIN_07(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_07_SHIFT, XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_07_WIDTH))

/*! @brief Set the LNM_GAIN_07 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_07_04_LNM_GAIN_07(base, value) (XCVR_RMW_AGC_GAIN_TBL_07_04(base, XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_07_MASK, XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_07(value)))
#define XCVR_BWR_AGC_GAIN_TBL_07_04_LNM_GAIN_07(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_07_04_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_07_SHIFT), XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_07_SHIFT, XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_07_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_AGC_GAIN_TBL_11_08 - AGC Gain Tables Step 11..08
 ******************************************************************************/

/*!
 * @brief XCVR_AGC_GAIN_TBL_11_08 - AGC Gain Tables Step 11..08 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_AGC_GAIN_TBL_11_08 register
 */
/*@{*/
#define XCVR_RD_AGC_GAIN_TBL_11_08(base) (XCVR_AGC_GAIN_TBL_11_08_REG(base))
#define XCVR_WR_AGC_GAIN_TBL_11_08(base, value) (XCVR_AGC_GAIN_TBL_11_08_REG(base) = (value))
#define XCVR_RMW_AGC_GAIN_TBL_11_08(base, mask, value) (XCVR_WR_AGC_GAIN_TBL_11_08(base, (XCVR_RD_AGC_GAIN_TBL_11_08(base) & ~(mask)) | (value)))
#define XCVR_SET_AGC_GAIN_TBL_11_08(base, value) (BME_OR32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), (uint32_t)(value)))
#define XCVR_CLR_AGC_GAIN_TBL_11_08(base, value) (BME_AND32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_AGC_GAIN_TBL_11_08(base, value) (BME_XOR32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_AGC_GAIN_TBL_11_08 bitfields
 */

/*!
 * @name Register XCVR_AGC_GAIN_TBL_11_08, field BBF_GAIN_08[3:0] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_08 field. */
#define XCVR_RD_AGC_GAIN_TBL_11_08_BBF_GAIN_08(base) ((XCVR_AGC_GAIN_TBL_11_08_REG(base) & XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_08_MASK) >> XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_08_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_11_08_BBF_GAIN_08(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_08_SHIFT, XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_08_WIDTH))

/*! @brief Set the BBF_GAIN_08 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_11_08_BBF_GAIN_08(base, value) (XCVR_RMW_AGC_GAIN_TBL_11_08(base, XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_08_MASK, XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_08(value)))
#define XCVR_BWR_AGC_GAIN_TBL_11_08_BBF_GAIN_08(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_08_SHIFT), XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_08_SHIFT, XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_08_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_11_08, field LNM_GAIN_08[7:4] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_08 field. */
#define XCVR_RD_AGC_GAIN_TBL_11_08_LNM_GAIN_08(base) ((XCVR_AGC_GAIN_TBL_11_08_REG(base) & XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_08_MASK) >> XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_08_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_11_08_LNM_GAIN_08(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_08_SHIFT, XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_08_WIDTH))

/*! @brief Set the LNM_GAIN_08 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_11_08_LNM_GAIN_08(base, value) (XCVR_RMW_AGC_GAIN_TBL_11_08(base, XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_08_MASK, XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_08(value)))
#define XCVR_BWR_AGC_GAIN_TBL_11_08_LNM_GAIN_08(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_08_SHIFT), XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_08_SHIFT, XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_08_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_11_08, field BBF_GAIN_09[11:8] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_09 field. */
#define XCVR_RD_AGC_GAIN_TBL_11_08_BBF_GAIN_09(base) ((XCVR_AGC_GAIN_TBL_11_08_REG(base) & XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_09_MASK) >> XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_09_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_11_08_BBF_GAIN_09(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_09_SHIFT, XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_09_WIDTH))

/*! @brief Set the BBF_GAIN_09 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_11_08_BBF_GAIN_09(base, value) (XCVR_RMW_AGC_GAIN_TBL_11_08(base, XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_09_MASK, XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_09(value)))
#define XCVR_BWR_AGC_GAIN_TBL_11_08_BBF_GAIN_09(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_09_SHIFT), XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_09_SHIFT, XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_09_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_11_08, field LNM_GAIN_09[15:12] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_09 field. */
#define XCVR_RD_AGC_GAIN_TBL_11_08_LNM_GAIN_09(base) ((XCVR_AGC_GAIN_TBL_11_08_REG(base) & XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_09_MASK) >> XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_09_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_11_08_LNM_GAIN_09(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_09_SHIFT, XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_09_WIDTH))

/*! @brief Set the LNM_GAIN_09 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_11_08_LNM_GAIN_09(base, value) (XCVR_RMW_AGC_GAIN_TBL_11_08(base, XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_09_MASK, XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_09(value)))
#define XCVR_BWR_AGC_GAIN_TBL_11_08_LNM_GAIN_09(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_09_SHIFT), XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_09_SHIFT, XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_09_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_11_08, field BBF_GAIN_10[19:16] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_10 field. */
#define XCVR_RD_AGC_GAIN_TBL_11_08_BBF_GAIN_10(base) ((XCVR_AGC_GAIN_TBL_11_08_REG(base) & XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_10_MASK) >> XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_10_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_11_08_BBF_GAIN_10(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_10_SHIFT, XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_10_WIDTH))

/*! @brief Set the BBF_GAIN_10 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_11_08_BBF_GAIN_10(base, value) (XCVR_RMW_AGC_GAIN_TBL_11_08(base, XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_10_MASK, XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_10(value)))
#define XCVR_BWR_AGC_GAIN_TBL_11_08_BBF_GAIN_10(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_10_SHIFT), XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_10_SHIFT, XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_10_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_11_08, field LNM_GAIN_10[23:20] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_10 field. */
#define XCVR_RD_AGC_GAIN_TBL_11_08_LNM_GAIN_10(base) ((XCVR_AGC_GAIN_TBL_11_08_REG(base) & XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_10_MASK) >> XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_10_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_11_08_LNM_GAIN_10(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_10_SHIFT, XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_10_WIDTH))

/*! @brief Set the LNM_GAIN_10 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_11_08_LNM_GAIN_10(base, value) (XCVR_RMW_AGC_GAIN_TBL_11_08(base, XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_10_MASK, XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_10(value)))
#define XCVR_BWR_AGC_GAIN_TBL_11_08_LNM_GAIN_10(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_10_SHIFT), XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_10_SHIFT, XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_10_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_11_08, field BBF_GAIN_11[27:24] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_11 field. */
#define XCVR_RD_AGC_GAIN_TBL_11_08_BBF_GAIN_11(base) ((XCVR_AGC_GAIN_TBL_11_08_REG(base) & XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_11_MASK) >> XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_11_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_11_08_BBF_GAIN_11(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_11_SHIFT, XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_11_WIDTH))

/*! @brief Set the BBF_GAIN_11 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_11_08_BBF_GAIN_11(base, value) (XCVR_RMW_AGC_GAIN_TBL_11_08(base, XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_11_MASK, XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_11(value)))
#define XCVR_BWR_AGC_GAIN_TBL_11_08_BBF_GAIN_11(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_11_SHIFT), XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_11_SHIFT, XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_11_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_11_08, field LNM_GAIN_11[31:28] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_11 field. */
#define XCVR_RD_AGC_GAIN_TBL_11_08_LNM_GAIN_11(base) ((XCVR_AGC_GAIN_TBL_11_08_REG(base) & XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_11_MASK) >> XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_11_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_11_08_LNM_GAIN_11(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_11_SHIFT, XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_11_WIDTH))

/*! @brief Set the LNM_GAIN_11 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_11_08_LNM_GAIN_11(base, value) (XCVR_RMW_AGC_GAIN_TBL_11_08(base, XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_11_MASK, XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_11(value)))
#define XCVR_BWR_AGC_GAIN_TBL_11_08_LNM_GAIN_11(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_11_08_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_11_SHIFT), XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_11_SHIFT, XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_11_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_AGC_GAIN_TBL_15_12 - AGC Gain Tables Step 15..12
 ******************************************************************************/

/*!
 * @brief XCVR_AGC_GAIN_TBL_15_12 - AGC Gain Tables Step 15..12 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_AGC_GAIN_TBL_15_12 register
 */
/*@{*/
#define XCVR_RD_AGC_GAIN_TBL_15_12(base) (XCVR_AGC_GAIN_TBL_15_12_REG(base))
#define XCVR_WR_AGC_GAIN_TBL_15_12(base, value) (XCVR_AGC_GAIN_TBL_15_12_REG(base) = (value))
#define XCVR_RMW_AGC_GAIN_TBL_15_12(base, mask, value) (XCVR_WR_AGC_GAIN_TBL_15_12(base, (XCVR_RD_AGC_GAIN_TBL_15_12(base) & ~(mask)) | (value)))
#define XCVR_SET_AGC_GAIN_TBL_15_12(base, value) (BME_OR32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), (uint32_t)(value)))
#define XCVR_CLR_AGC_GAIN_TBL_15_12(base, value) (BME_AND32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_AGC_GAIN_TBL_15_12(base, value) (BME_XOR32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_AGC_GAIN_TBL_15_12 bitfields
 */

/*!
 * @name Register XCVR_AGC_GAIN_TBL_15_12, field BBF_GAIN_12[3:0] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_12 field. */
#define XCVR_RD_AGC_GAIN_TBL_15_12_BBF_GAIN_12(base) ((XCVR_AGC_GAIN_TBL_15_12_REG(base) & XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_12_MASK) >> XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_12_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_15_12_BBF_GAIN_12(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_12_SHIFT, XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_12_WIDTH))

/*! @brief Set the BBF_GAIN_12 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_15_12_BBF_GAIN_12(base, value) (XCVR_RMW_AGC_GAIN_TBL_15_12(base, XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_12_MASK, XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_12(value)))
#define XCVR_BWR_AGC_GAIN_TBL_15_12_BBF_GAIN_12(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_12_SHIFT), XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_12_SHIFT, XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_12_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_15_12, field LNM_GAIN_12[7:4] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_12 field. */
#define XCVR_RD_AGC_GAIN_TBL_15_12_LNM_GAIN_12(base) ((XCVR_AGC_GAIN_TBL_15_12_REG(base) & XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_12_MASK) >> XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_12_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_15_12_LNM_GAIN_12(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_12_SHIFT, XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_12_WIDTH))

/*! @brief Set the LNM_GAIN_12 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_15_12_LNM_GAIN_12(base, value) (XCVR_RMW_AGC_GAIN_TBL_15_12(base, XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_12_MASK, XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_12(value)))
#define XCVR_BWR_AGC_GAIN_TBL_15_12_LNM_GAIN_12(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_12_SHIFT), XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_12_SHIFT, XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_12_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_15_12, field BBF_GAIN_13[11:8] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_13 field. */
#define XCVR_RD_AGC_GAIN_TBL_15_12_BBF_GAIN_13(base) ((XCVR_AGC_GAIN_TBL_15_12_REG(base) & XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_13_MASK) >> XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_13_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_15_12_BBF_GAIN_13(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_13_SHIFT, XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_13_WIDTH))

/*! @brief Set the BBF_GAIN_13 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_15_12_BBF_GAIN_13(base, value) (XCVR_RMW_AGC_GAIN_TBL_15_12(base, XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_13_MASK, XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_13(value)))
#define XCVR_BWR_AGC_GAIN_TBL_15_12_BBF_GAIN_13(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_13_SHIFT), XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_13_SHIFT, XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_13_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_15_12, field LNM_GAIN_13[15:12] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_13 field. */
#define XCVR_RD_AGC_GAIN_TBL_15_12_LNM_GAIN_13(base) ((XCVR_AGC_GAIN_TBL_15_12_REG(base) & XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_13_MASK) >> XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_13_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_15_12_LNM_GAIN_13(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_13_SHIFT, XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_13_WIDTH))

/*! @brief Set the LNM_GAIN_13 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_15_12_LNM_GAIN_13(base, value) (XCVR_RMW_AGC_GAIN_TBL_15_12(base, XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_13_MASK, XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_13(value)))
#define XCVR_BWR_AGC_GAIN_TBL_15_12_LNM_GAIN_13(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_13_SHIFT), XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_13_SHIFT, XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_13_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_15_12, field BBF_GAIN_14[19:16] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_14 field. */
#define XCVR_RD_AGC_GAIN_TBL_15_12_BBF_GAIN_14(base) ((XCVR_AGC_GAIN_TBL_15_12_REG(base) & XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_14_MASK) >> XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_14_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_15_12_BBF_GAIN_14(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_14_SHIFT, XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_14_WIDTH))

/*! @brief Set the BBF_GAIN_14 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_15_12_BBF_GAIN_14(base, value) (XCVR_RMW_AGC_GAIN_TBL_15_12(base, XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_14_MASK, XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_14(value)))
#define XCVR_BWR_AGC_GAIN_TBL_15_12_BBF_GAIN_14(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_14_SHIFT), XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_14_SHIFT, XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_14_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_15_12, field LNM_GAIN_14[23:20] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_14 field. */
#define XCVR_RD_AGC_GAIN_TBL_15_12_LNM_GAIN_14(base) ((XCVR_AGC_GAIN_TBL_15_12_REG(base) & XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_14_MASK) >> XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_14_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_15_12_LNM_GAIN_14(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_14_SHIFT, XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_14_WIDTH))

/*! @brief Set the LNM_GAIN_14 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_15_12_LNM_GAIN_14(base, value) (XCVR_RMW_AGC_GAIN_TBL_15_12(base, XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_14_MASK, XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_14(value)))
#define XCVR_BWR_AGC_GAIN_TBL_15_12_LNM_GAIN_14(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_14_SHIFT), XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_14_SHIFT, XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_14_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_15_12, field BBF_GAIN_15[27:24] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_15 field. */
#define XCVR_RD_AGC_GAIN_TBL_15_12_BBF_GAIN_15(base) ((XCVR_AGC_GAIN_TBL_15_12_REG(base) & XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_15_MASK) >> XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_15_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_15_12_BBF_GAIN_15(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_15_SHIFT, XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_15_WIDTH))

/*! @brief Set the BBF_GAIN_15 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_15_12_BBF_GAIN_15(base, value) (XCVR_RMW_AGC_GAIN_TBL_15_12(base, XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_15_MASK, XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_15(value)))
#define XCVR_BWR_AGC_GAIN_TBL_15_12_BBF_GAIN_15(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_15_SHIFT), XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_15_SHIFT, XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_15_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_15_12, field LNM_GAIN_15[31:28] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_15 field. */
#define XCVR_RD_AGC_GAIN_TBL_15_12_LNM_GAIN_15(base) ((XCVR_AGC_GAIN_TBL_15_12_REG(base) & XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_15_MASK) >> XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_15_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_15_12_LNM_GAIN_15(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_15_SHIFT, XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_15_WIDTH))

/*! @brief Set the LNM_GAIN_15 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_15_12_LNM_GAIN_15(base, value) (XCVR_RMW_AGC_GAIN_TBL_15_12(base, XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_15_MASK, XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_15(value)))
#define XCVR_BWR_AGC_GAIN_TBL_15_12_LNM_GAIN_15(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_15_12_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_15_SHIFT), XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_15_SHIFT, XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_15_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_AGC_GAIN_TBL_19_16 - AGC Gain Tables Step 19..16
 ******************************************************************************/

/*!
 * @brief XCVR_AGC_GAIN_TBL_19_16 - AGC Gain Tables Step 19..16 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_AGC_GAIN_TBL_19_16 register
 */
/*@{*/
#define XCVR_RD_AGC_GAIN_TBL_19_16(base) (XCVR_AGC_GAIN_TBL_19_16_REG(base))
#define XCVR_WR_AGC_GAIN_TBL_19_16(base, value) (XCVR_AGC_GAIN_TBL_19_16_REG(base) = (value))
#define XCVR_RMW_AGC_GAIN_TBL_19_16(base, mask, value) (XCVR_WR_AGC_GAIN_TBL_19_16(base, (XCVR_RD_AGC_GAIN_TBL_19_16(base) & ~(mask)) | (value)))
#define XCVR_SET_AGC_GAIN_TBL_19_16(base, value) (BME_OR32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), (uint32_t)(value)))
#define XCVR_CLR_AGC_GAIN_TBL_19_16(base, value) (BME_AND32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_AGC_GAIN_TBL_19_16(base, value) (BME_XOR32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_AGC_GAIN_TBL_19_16 bitfields
 */

/*!
 * @name Register XCVR_AGC_GAIN_TBL_19_16, field BBF_GAIN_16[3:0] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_16 field. */
#define XCVR_RD_AGC_GAIN_TBL_19_16_BBF_GAIN_16(base) ((XCVR_AGC_GAIN_TBL_19_16_REG(base) & XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_16_MASK) >> XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_16_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_19_16_BBF_GAIN_16(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_16_SHIFT, XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_16_WIDTH))

/*! @brief Set the BBF_GAIN_16 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_19_16_BBF_GAIN_16(base, value) (XCVR_RMW_AGC_GAIN_TBL_19_16(base, XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_16_MASK, XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_16(value)))
#define XCVR_BWR_AGC_GAIN_TBL_19_16_BBF_GAIN_16(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_16_SHIFT), XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_16_SHIFT, XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_16_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_19_16, field LNM_GAIN_16[7:4] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_16 field. */
#define XCVR_RD_AGC_GAIN_TBL_19_16_LNM_GAIN_16(base) ((XCVR_AGC_GAIN_TBL_19_16_REG(base) & XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_16_MASK) >> XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_16_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_19_16_LNM_GAIN_16(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_16_SHIFT, XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_16_WIDTH))

/*! @brief Set the LNM_GAIN_16 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_19_16_LNM_GAIN_16(base, value) (XCVR_RMW_AGC_GAIN_TBL_19_16(base, XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_16_MASK, XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_16(value)))
#define XCVR_BWR_AGC_GAIN_TBL_19_16_LNM_GAIN_16(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_16_SHIFT), XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_16_SHIFT, XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_16_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_19_16, field BBF_GAIN_17[11:8] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_17 field. */
#define XCVR_RD_AGC_GAIN_TBL_19_16_BBF_GAIN_17(base) ((XCVR_AGC_GAIN_TBL_19_16_REG(base) & XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_17_MASK) >> XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_17_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_19_16_BBF_GAIN_17(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_17_SHIFT, XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_17_WIDTH))

/*! @brief Set the BBF_GAIN_17 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_19_16_BBF_GAIN_17(base, value) (XCVR_RMW_AGC_GAIN_TBL_19_16(base, XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_17_MASK, XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_17(value)))
#define XCVR_BWR_AGC_GAIN_TBL_19_16_BBF_GAIN_17(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_17_SHIFT), XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_17_SHIFT, XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_17_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_19_16, field LNM_GAIN_17[15:12] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_17 field. */
#define XCVR_RD_AGC_GAIN_TBL_19_16_LNM_GAIN_17(base) ((XCVR_AGC_GAIN_TBL_19_16_REG(base) & XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_17_MASK) >> XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_17_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_19_16_LNM_GAIN_17(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_17_SHIFT, XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_17_WIDTH))

/*! @brief Set the LNM_GAIN_17 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_19_16_LNM_GAIN_17(base, value) (XCVR_RMW_AGC_GAIN_TBL_19_16(base, XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_17_MASK, XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_17(value)))
#define XCVR_BWR_AGC_GAIN_TBL_19_16_LNM_GAIN_17(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_17_SHIFT), XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_17_SHIFT, XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_17_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_19_16, field BBF_GAIN_18[19:16] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_18 field. */
#define XCVR_RD_AGC_GAIN_TBL_19_16_BBF_GAIN_18(base) ((XCVR_AGC_GAIN_TBL_19_16_REG(base) & XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_18_MASK) >> XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_18_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_19_16_BBF_GAIN_18(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_18_SHIFT, XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_18_WIDTH))

/*! @brief Set the BBF_GAIN_18 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_19_16_BBF_GAIN_18(base, value) (XCVR_RMW_AGC_GAIN_TBL_19_16(base, XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_18_MASK, XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_18(value)))
#define XCVR_BWR_AGC_GAIN_TBL_19_16_BBF_GAIN_18(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_18_SHIFT), XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_18_SHIFT, XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_18_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_19_16, field LNM_GAIN_18[23:20] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_18 field. */
#define XCVR_RD_AGC_GAIN_TBL_19_16_LNM_GAIN_18(base) ((XCVR_AGC_GAIN_TBL_19_16_REG(base) & XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_18_MASK) >> XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_18_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_19_16_LNM_GAIN_18(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_18_SHIFT, XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_18_WIDTH))

/*! @brief Set the LNM_GAIN_18 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_19_16_LNM_GAIN_18(base, value) (XCVR_RMW_AGC_GAIN_TBL_19_16(base, XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_18_MASK, XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_18(value)))
#define XCVR_BWR_AGC_GAIN_TBL_19_16_LNM_GAIN_18(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_18_SHIFT), XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_18_SHIFT, XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_18_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_19_16, field BBF_GAIN_19[27:24] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_19 field. */
#define XCVR_RD_AGC_GAIN_TBL_19_16_BBF_GAIN_19(base) ((XCVR_AGC_GAIN_TBL_19_16_REG(base) & XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_19_MASK) >> XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_19_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_19_16_BBF_GAIN_19(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_19_SHIFT, XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_19_WIDTH))

/*! @brief Set the BBF_GAIN_19 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_19_16_BBF_GAIN_19(base, value) (XCVR_RMW_AGC_GAIN_TBL_19_16(base, XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_19_MASK, XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_19(value)))
#define XCVR_BWR_AGC_GAIN_TBL_19_16_BBF_GAIN_19(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_19_SHIFT), XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_19_SHIFT, XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_19_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_19_16, field LNM_GAIN_19[31:28] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_19 field. */
#define XCVR_RD_AGC_GAIN_TBL_19_16_LNM_GAIN_19(base) ((XCVR_AGC_GAIN_TBL_19_16_REG(base) & XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_19_MASK) >> XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_19_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_19_16_LNM_GAIN_19(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_19_SHIFT, XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_19_WIDTH))

/*! @brief Set the LNM_GAIN_19 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_19_16_LNM_GAIN_19(base, value) (XCVR_RMW_AGC_GAIN_TBL_19_16(base, XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_19_MASK, XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_19(value)))
#define XCVR_BWR_AGC_GAIN_TBL_19_16_LNM_GAIN_19(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_19_16_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_19_SHIFT), XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_19_SHIFT, XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_19_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_AGC_GAIN_TBL_23_20 - AGC Gain Tables Step 23..20
 ******************************************************************************/

/*!
 * @brief XCVR_AGC_GAIN_TBL_23_20 - AGC Gain Tables Step 23..20 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_AGC_GAIN_TBL_23_20 register
 */
/*@{*/
#define XCVR_RD_AGC_GAIN_TBL_23_20(base) (XCVR_AGC_GAIN_TBL_23_20_REG(base))
#define XCVR_WR_AGC_GAIN_TBL_23_20(base, value) (XCVR_AGC_GAIN_TBL_23_20_REG(base) = (value))
#define XCVR_RMW_AGC_GAIN_TBL_23_20(base, mask, value) (XCVR_WR_AGC_GAIN_TBL_23_20(base, (XCVR_RD_AGC_GAIN_TBL_23_20(base) & ~(mask)) | (value)))
#define XCVR_SET_AGC_GAIN_TBL_23_20(base, value) (BME_OR32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), (uint32_t)(value)))
#define XCVR_CLR_AGC_GAIN_TBL_23_20(base, value) (BME_AND32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_AGC_GAIN_TBL_23_20(base, value) (BME_XOR32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_AGC_GAIN_TBL_23_20 bitfields
 */

/*!
 * @name Register XCVR_AGC_GAIN_TBL_23_20, field BBF_GAIN_20[3:0] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_20 field. */
#define XCVR_RD_AGC_GAIN_TBL_23_20_BBF_GAIN_20(base) ((XCVR_AGC_GAIN_TBL_23_20_REG(base) & XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_20_MASK) >> XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_20_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_23_20_BBF_GAIN_20(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_20_SHIFT, XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_20_WIDTH))

/*! @brief Set the BBF_GAIN_20 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_23_20_BBF_GAIN_20(base, value) (XCVR_RMW_AGC_GAIN_TBL_23_20(base, XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_20_MASK, XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_20(value)))
#define XCVR_BWR_AGC_GAIN_TBL_23_20_BBF_GAIN_20(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_20_SHIFT), XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_20_SHIFT, XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_20_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_23_20, field LNM_GAIN_20[7:4] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_20 field. */
#define XCVR_RD_AGC_GAIN_TBL_23_20_LNM_GAIN_20(base) ((XCVR_AGC_GAIN_TBL_23_20_REG(base) & XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_20_MASK) >> XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_20_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_23_20_LNM_GAIN_20(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_20_SHIFT, XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_20_WIDTH))

/*! @brief Set the LNM_GAIN_20 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_23_20_LNM_GAIN_20(base, value) (XCVR_RMW_AGC_GAIN_TBL_23_20(base, XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_20_MASK, XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_20(value)))
#define XCVR_BWR_AGC_GAIN_TBL_23_20_LNM_GAIN_20(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_20_SHIFT), XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_20_SHIFT, XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_20_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_23_20, field BBF_GAIN_21[11:8] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_21 field. */
#define XCVR_RD_AGC_GAIN_TBL_23_20_BBF_GAIN_21(base) ((XCVR_AGC_GAIN_TBL_23_20_REG(base) & XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_21_MASK) >> XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_21_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_23_20_BBF_GAIN_21(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_21_SHIFT, XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_21_WIDTH))

/*! @brief Set the BBF_GAIN_21 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_23_20_BBF_GAIN_21(base, value) (XCVR_RMW_AGC_GAIN_TBL_23_20(base, XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_21_MASK, XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_21(value)))
#define XCVR_BWR_AGC_GAIN_TBL_23_20_BBF_GAIN_21(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_21_SHIFT), XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_21_SHIFT, XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_21_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_23_20, field LNM_GAIN_21[15:12] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_21 field. */
#define XCVR_RD_AGC_GAIN_TBL_23_20_LNM_GAIN_21(base) ((XCVR_AGC_GAIN_TBL_23_20_REG(base) & XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_21_MASK) >> XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_21_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_23_20_LNM_GAIN_21(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_21_SHIFT, XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_21_WIDTH))

/*! @brief Set the LNM_GAIN_21 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_23_20_LNM_GAIN_21(base, value) (XCVR_RMW_AGC_GAIN_TBL_23_20(base, XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_21_MASK, XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_21(value)))
#define XCVR_BWR_AGC_GAIN_TBL_23_20_LNM_GAIN_21(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_21_SHIFT), XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_21_SHIFT, XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_21_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_23_20, field BBF_GAIN_22[19:16] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_22 field. */
#define XCVR_RD_AGC_GAIN_TBL_23_20_BBF_GAIN_22(base) ((XCVR_AGC_GAIN_TBL_23_20_REG(base) & XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_22_MASK) >> XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_22_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_23_20_BBF_GAIN_22(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_22_SHIFT, XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_22_WIDTH))

/*! @brief Set the BBF_GAIN_22 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_23_20_BBF_GAIN_22(base, value) (XCVR_RMW_AGC_GAIN_TBL_23_20(base, XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_22_MASK, XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_22(value)))
#define XCVR_BWR_AGC_GAIN_TBL_23_20_BBF_GAIN_22(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_22_SHIFT), XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_22_SHIFT, XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_22_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_23_20, field LNM_GAIN_22[23:20] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_22 field. */
#define XCVR_RD_AGC_GAIN_TBL_23_20_LNM_GAIN_22(base) ((XCVR_AGC_GAIN_TBL_23_20_REG(base) & XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_22_MASK) >> XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_22_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_23_20_LNM_GAIN_22(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_22_SHIFT, XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_22_WIDTH))

/*! @brief Set the LNM_GAIN_22 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_23_20_LNM_GAIN_22(base, value) (XCVR_RMW_AGC_GAIN_TBL_23_20(base, XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_22_MASK, XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_22(value)))
#define XCVR_BWR_AGC_GAIN_TBL_23_20_LNM_GAIN_22(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_22_SHIFT), XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_22_SHIFT, XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_22_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_23_20, field BBF_GAIN_23[27:24] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_23 field. */
#define XCVR_RD_AGC_GAIN_TBL_23_20_BBF_GAIN_23(base) ((XCVR_AGC_GAIN_TBL_23_20_REG(base) & XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_23_MASK) >> XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_23_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_23_20_BBF_GAIN_23(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_23_SHIFT, XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_23_WIDTH))

/*! @brief Set the BBF_GAIN_23 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_23_20_BBF_GAIN_23(base, value) (XCVR_RMW_AGC_GAIN_TBL_23_20(base, XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_23_MASK, XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_23(value)))
#define XCVR_BWR_AGC_GAIN_TBL_23_20_BBF_GAIN_23(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_23_SHIFT), XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_23_SHIFT, XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_23_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_23_20, field LNM_GAIN_23[31:28] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_23 field. */
#define XCVR_RD_AGC_GAIN_TBL_23_20_LNM_GAIN_23(base) ((XCVR_AGC_GAIN_TBL_23_20_REG(base) & XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_23_MASK) >> XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_23_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_23_20_LNM_GAIN_23(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_23_SHIFT, XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_23_WIDTH))

/*! @brief Set the LNM_GAIN_23 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_23_20_LNM_GAIN_23(base, value) (XCVR_RMW_AGC_GAIN_TBL_23_20(base, XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_23_MASK, XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_23(value)))
#define XCVR_BWR_AGC_GAIN_TBL_23_20_LNM_GAIN_23(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_23_20_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_23_SHIFT), XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_23_SHIFT, XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_23_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_AGC_GAIN_TBL_26_24 - AGC Gain Tables Step 26..24
 ******************************************************************************/

/*!
 * @brief XCVR_AGC_GAIN_TBL_26_24 - AGC Gain Tables Step 26..24 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_AGC_GAIN_TBL_26_24 register
 */
/*@{*/
#define XCVR_RD_AGC_GAIN_TBL_26_24(base) (XCVR_AGC_GAIN_TBL_26_24_REG(base))
#define XCVR_WR_AGC_GAIN_TBL_26_24(base, value) (XCVR_AGC_GAIN_TBL_26_24_REG(base) = (value))
#define XCVR_RMW_AGC_GAIN_TBL_26_24(base, mask, value) (XCVR_WR_AGC_GAIN_TBL_26_24(base, (XCVR_RD_AGC_GAIN_TBL_26_24(base) & ~(mask)) | (value)))
#define XCVR_SET_AGC_GAIN_TBL_26_24(base, value) (BME_OR32(&XCVR_AGC_GAIN_TBL_26_24_REG(base), (uint32_t)(value)))
#define XCVR_CLR_AGC_GAIN_TBL_26_24(base, value) (BME_AND32(&XCVR_AGC_GAIN_TBL_26_24_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_AGC_GAIN_TBL_26_24(base, value) (BME_XOR32(&XCVR_AGC_GAIN_TBL_26_24_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_AGC_GAIN_TBL_26_24 bitfields
 */

/*!
 * @name Register XCVR_AGC_GAIN_TBL_26_24, field BBF_GAIN_24[3:0] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_24 field. */
#define XCVR_RD_AGC_GAIN_TBL_26_24_BBF_GAIN_24(base) ((XCVR_AGC_GAIN_TBL_26_24_REG(base) & XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_24_MASK) >> XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_24_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_26_24_BBF_GAIN_24(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_26_24_REG(base), XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_24_SHIFT, XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_24_WIDTH))

/*! @brief Set the BBF_GAIN_24 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_26_24_BBF_GAIN_24(base, value) (XCVR_RMW_AGC_GAIN_TBL_26_24(base, XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_24_MASK, XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_24(value)))
#define XCVR_BWR_AGC_GAIN_TBL_26_24_BBF_GAIN_24(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_26_24_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_24_SHIFT), XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_24_SHIFT, XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_24_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_26_24, field LNM_GAIN_24[7:4] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_24 field. */
#define XCVR_RD_AGC_GAIN_TBL_26_24_LNM_GAIN_24(base) ((XCVR_AGC_GAIN_TBL_26_24_REG(base) & XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_24_MASK) >> XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_24_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_26_24_LNM_GAIN_24(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_26_24_REG(base), XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_24_SHIFT, XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_24_WIDTH))

/*! @brief Set the LNM_GAIN_24 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_26_24_LNM_GAIN_24(base, value) (XCVR_RMW_AGC_GAIN_TBL_26_24(base, XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_24_MASK, XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_24(value)))
#define XCVR_BWR_AGC_GAIN_TBL_26_24_LNM_GAIN_24(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_26_24_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_24_SHIFT), XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_24_SHIFT, XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_24_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_26_24, field BBF_GAIN_25[11:8] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_25 field. */
#define XCVR_RD_AGC_GAIN_TBL_26_24_BBF_GAIN_25(base) ((XCVR_AGC_GAIN_TBL_26_24_REG(base) & XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_25_MASK) >> XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_25_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_26_24_BBF_GAIN_25(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_26_24_REG(base), XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_25_SHIFT, XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_25_WIDTH))

/*! @brief Set the BBF_GAIN_25 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_26_24_BBF_GAIN_25(base, value) (XCVR_RMW_AGC_GAIN_TBL_26_24(base, XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_25_MASK, XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_25(value)))
#define XCVR_BWR_AGC_GAIN_TBL_26_24_BBF_GAIN_25(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_26_24_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_25_SHIFT), XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_25_SHIFT, XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_25_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_26_24, field LNM_GAIN_25[15:12] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_25 field. */
#define XCVR_RD_AGC_GAIN_TBL_26_24_LNM_GAIN_25(base) ((XCVR_AGC_GAIN_TBL_26_24_REG(base) & XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_25_MASK) >> XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_25_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_26_24_LNM_GAIN_25(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_26_24_REG(base), XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_25_SHIFT, XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_25_WIDTH))

/*! @brief Set the LNM_GAIN_25 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_26_24_LNM_GAIN_25(base, value) (XCVR_RMW_AGC_GAIN_TBL_26_24(base, XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_25_MASK, XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_25(value)))
#define XCVR_BWR_AGC_GAIN_TBL_26_24_LNM_GAIN_25(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_26_24_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_25_SHIFT), XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_25_SHIFT, XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_25_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_26_24, field BBF_GAIN_26[19:16] (RW)
 *
 * BBF GAIN 0=0 dB, 1=3 dB, 2=6 dB  A=30 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_26 field. */
#define XCVR_RD_AGC_GAIN_TBL_26_24_BBF_GAIN_26(base) ((XCVR_AGC_GAIN_TBL_26_24_REG(base) & XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_26_MASK) >> XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_26_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_26_24_BBF_GAIN_26(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_26_24_REG(base), XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_26_SHIFT, XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_26_WIDTH))

/*! @brief Set the BBF_GAIN_26 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_26_24_BBF_GAIN_26(base, value) (XCVR_RMW_AGC_GAIN_TBL_26_24(base, XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_26_MASK, XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_26(value)))
#define XCVR_BWR_AGC_GAIN_TBL_26_24_BBF_GAIN_26(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_26_24_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_26_SHIFT), XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_26_SHIFT, XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_26_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_AGC_GAIN_TBL_26_24, field LNM_GAIN_26[23:20] (RW)
 *
 * LNM GAIN 0=-3 dB, 1=3 dB, 2=9 dB  8=45 dB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_26 field. */
#define XCVR_RD_AGC_GAIN_TBL_26_24_LNM_GAIN_26(base) ((XCVR_AGC_GAIN_TBL_26_24_REG(base) & XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_26_MASK) >> XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_26_SHIFT)
#define XCVR_BRD_AGC_GAIN_TBL_26_24_LNM_GAIN_26(base) (BME_UBFX32(&XCVR_AGC_GAIN_TBL_26_24_REG(base), XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_26_SHIFT, XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_26_WIDTH))

/*! @brief Set the LNM_GAIN_26 field to a new value. */
#define XCVR_WR_AGC_GAIN_TBL_26_24_LNM_GAIN_26(base, value) (XCVR_RMW_AGC_GAIN_TBL_26_24(base, XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_26_MASK, XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_26(value)))
#define XCVR_BWR_AGC_GAIN_TBL_26_24_LNM_GAIN_26(base, value) (BME_BFI32(&XCVR_AGC_GAIN_TBL_26_24_REG(base), ((uint32_t)(value) << XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_26_SHIFT), XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_26_SHIFT, XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_26_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DCOC_OFFSET_ - DCOC Offset
 ******************************************************************************/

/*!
 * @brief XCVR_DCOC_OFFSET_ - DCOC Offset (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_DCOC_OFFSET_ register
 */
/*@{*/
#define XCVR_RD_DCOC_OFFSET_(base, index) (XCVR_DCOC_OFFSET__REG(base, index))
#define XCVR_WR_DCOC_OFFSET_(base, index, value) (XCVR_DCOC_OFFSET__REG(base, index) = (value))
#define XCVR_RMW_DCOC_OFFSET_(base, index, mask, value) (XCVR_WR_DCOC_OFFSET_(base, index, (XCVR_RD_DCOC_OFFSET_(base, index) & ~(mask)) | (value)))
#define XCVR_SET_DCOC_OFFSET_(base, index, value) (BME_OR32(&XCVR_DCOC_OFFSET__REG(base, index), (uint32_t)(value)))
#define XCVR_CLR_DCOC_OFFSET_(base, index, value) (BME_AND32(&XCVR_DCOC_OFFSET__REG(base, index), (uint32_t)(~(value))))
#define XCVR_TOG_DCOC_OFFSET_(base, index, value) (BME_XOR32(&XCVR_DCOC_OFFSET__REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_DCOC_OFFSET_ bitfields
 */

/*!
 * @name Register XCVR_DCOC_OFFSET_, field DCOC_BBF_OFFSET_I[5:0] (RW)
 *
 * DCOC BBF I-channel offset. When RX_DCOC_CAL_EN=1, this table is generated by
 * the DCOC during calibration. When RX_DCOC_CAL_EN=0, this table may optionally
 * be written by software.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_I field. */
#define XCVR_RD_DCOC_OFFSET__DCOC_BBF_OFFSET_I(base, index) ((XCVR_DCOC_OFFSET__REG(base, index) & XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_I_MASK) >> XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_I_SHIFT)
#define XCVR_BRD_DCOC_OFFSET__DCOC_BBF_OFFSET_I(base, index) (BME_UBFX32(&XCVR_DCOC_OFFSET__REG(base, index), XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_I_SHIFT, XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_I_WIDTH))

/*! @brief Set the DCOC_BBF_OFFSET_I field to a new value. */
#define XCVR_WR_DCOC_OFFSET__DCOC_BBF_OFFSET_I(base, index, value) (XCVR_RMW_DCOC_OFFSET_(base, index, XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_I_MASK, XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_I(value)))
#define XCVR_BWR_DCOC_OFFSET__DCOC_BBF_OFFSET_I(base, index, value) (BME_BFI32(&XCVR_DCOC_OFFSET__REG(base, index), ((uint32_t)(value) << XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_I_SHIFT), XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_I_SHIFT, XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_I_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_OFFSET_, field DCOC_BBF_OFFSET_Q[13:8] (RW)
 *
 * DCOC BBF Q-channel offset. When RX_DCOC_CAL_EN=1, this table is generated by
 * the DCOC during calibration. When RX_DCOC_CAL_EN=0, this table may optionally
 * be written by software.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_Q field. */
#define XCVR_RD_DCOC_OFFSET__DCOC_BBF_OFFSET_Q(base, index) ((XCVR_DCOC_OFFSET__REG(base, index) & XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_Q_MASK) >> XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_Q_SHIFT)
#define XCVR_BRD_DCOC_OFFSET__DCOC_BBF_OFFSET_Q(base, index) (BME_UBFX32(&XCVR_DCOC_OFFSET__REG(base, index), XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_Q_SHIFT, XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_Q_WIDTH))

/*! @brief Set the DCOC_BBF_OFFSET_Q field to a new value. */
#define XCVR_WR_DCOC_OFFSET__DCOC_BBF_OFFSET_Q(base, index, value) (XCVR_RMW_DCOC_OFFSET_(base, index, XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_Q_MASK, XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_Q(value)))
#define XCVR_BWR_DCOC_OFFSET__DCOC_BBF_OFFSET_Q(base, index, value) (BME_BFI32(&XCVR_DCOC_OFFSET__REG(base, index), ((uint32_t)(value) << XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_Q_SHIFT), XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_Q_SHIFT, XCVR_DCOC_OFFSET__DCOC_BBF_OFFSET_Q_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_OFFSET_, field DCOC_TZA_OFFSET_I[23:16] (RW)
 *
 * DCOC TZA I-channel offset. When RX_DCOC_CAL_EN=1, this table is generated by
 * the DCOC during calibration. When RX_DCOC_CAL_EN=0, this table may optionally
 * be written by software.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_I field. */
#define XCVR_RD_DCOC_OFFSET__DCOC_TZA_OFFSET_I(base, index) ((XCVR_DCOC_OFFSET__REG(base, index) & XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_I_MASK) >> XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_I_SHIFT)
#define XCVR_BRD_DCOC_OFFSET__DCOC_TZA_OFFSET_I(base, index) (BME_UBFX32(&XCVR_DCOC_OFFSET__REG(base, index), XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_I_SHIFT, XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_I_WIDTH))

/*! @brief Set the DCOC_TZA_OFFSET_I field to a new value. */
#define XCVR_WR_DCOC_OFFSET__DCOC_TZA_OFFSET_I(base, index, value) (XCVR_RMW_DCOC_OFFSET_(base, index, XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_I_MASK, XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_I(value)))
#define XCVR_BWR_DCOC_OFFSET__DCOC_TZA_OFFSET_I(base, index, value) (BME_BFI32(&XCVR_DCOC_OFFSET__REG(base, index), ((uint32_t)(value) << XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_I_SHIFT), XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_I_SHIFT, XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_I_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_OFFSET_, field DCOC_TZA_OFFSET_Q[31:24] (RW)
 *
 * DCOC TZA Q-channel offset. When RX_DCOC_CAL_EN=1, this table is generated by
 * the DCOC during calibration. When RX_DCOC_CAL_EN=0, this table may optionally
 * be written by software.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_Q field. */
#define XCVR_RD_DCOC_OFFSET__DCOC_TZA_OFFSET_Q(base, index) ((XCVR_DCOC_OFFSET__REG(base, index) & XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_Q_MASK) >> XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_Q_SHIFT)
#define XCVR_BRD_DCOC_OFFSET__DCOC_TZA_OFFSET_Q(base, index) (BME_UBFX32(&XCVR_DCOC_OFFSET__REG(base, index), XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_Q_SHIFT, XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_Q_WIDTH))

/*! @brief Set the DCOC_TZA_OFFSET_Q field to a new value. */
#define XCVR_WR_DCOC_OFFSET__DCOC_TZA_OFFSET_Q(base, index, value) (XCVR_RMW_DCOC_OFFSET_(base, index, XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_Q_MASK, XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_Q(value)))
#define XCVR_BWR_DCOC_OFFSET__DCOC_TZA_OFFSET_Q(base, index, value) (BME_BFI32(&XCVR_DCOC_OFFSET__REG(base, index), ((uint32_t)(value) << XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_Q_SHIFT), XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_Q_SHIFT, XCVR_DCOC_OFFSET__DCOC_TZA_OFFSET_Q_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DCOC_TZA_STEP_ - DCOC TZA DC step
 ******************************************************************************/

/*!
 * @brief XCVR_DCOC_TZA_STEP_ - DCOC TZA DC step (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_DCOC_TZA_STEP_ register
 */
/*@{*/
#define XCVR_RD_DCOC_TZA_STEP_(base, index) (XCVR_DCOC_TZA_STEP__REG(base, index))
#define XCVR_WR_DCOC_TZA_STEP_(base, index, value) (XCVR_DCOC_TZA_STEP__REG(base, index) = (value))
#define XCVR_RMW_DCOC_TZA_STEP_(base, index, mask, value) (XCVR_WR_DCOC_TZA_STEP_(base, index, (XCVR_RD_DCOC_TZA_STEP_(base, index) & ~(mask)) | (value)))
#define XCVR_SET_DCOC_TZA_STEP_(base, index, value) (BME_OR32(&XCVR_DCOC_TZA_STEP__REG(base, index), (uint32_t)(value)))
#define XCVR_CLR_DCOC_TZA_STEP_(base, index, value) (BME_AND32(&XCVR_DCOC_TZA_STEP__REG(base, index), (uint32_t)(~(value))))
#define XCVR_TOG_DCOC_TZA_STEP_(base, index, value) (BME_XOR32(&XCVR_DCOC_TZA_STEP__REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_DCOC_TZA_STEP_ bitfields
 */

/*!
 * @name Register XCVR_DCOC_TZA_STEP_, field DCOC_TZA_STEP_RCP[12:0] (RW)
 *
 * DCOC TZA Reciprocal of Step Size, (format: [00]13). This the reciprocal of
 * the DCOC_TZA_STEP_GAIN. E.g., for DCOC_TZA_STEP_0, it's nominal value is
 * 1.0/9.209 or 0.10859. The value is stored as a 15bit fractional value (though only 13
 * bits are programmed), so use round(0.10859*2^15) = 3588decimal.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP field. */
#define XCVR_RD_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP(base, index) ((XCVR_DCOC_TZA_STEP__REG(base, index) & XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_MASK) >> XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_SHIFT)
#define XCVR_BRD_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP(base, index) (BME_UBFX32(&XCVR_DCOC_TZA_STEP__REG(base, index), XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_SHIFT, XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_WIDTH))

/*! @brief Set the DCOC_TZA_STEP_RCP field to a new value. */
#define XCVR_WR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP(base, index, value) (XCVR_RMW_DCOC_TZA_STEP_(base, index, XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_MASK, XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP(value)))
#define XCVR_BWR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP(base, index, value) (BME_BFI32(&XCVR_DCOC_TZA_STEP__REG(base, index), ((uint32_t)(value) << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_SHIFT), XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_SHIFT, XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_TZA_STEP_, field DCOC_TZA_STEP_GAIN[27:16] (RW)
 *
 * DCOC TZA Step Size with gain (format 9.3). The nominal value for this is the
 * TZA DAC resolution (1.4/2^8= 5.47mV) times AGC gain of -1.7dB (
 * 10^(-1.7/20)=0.822) times an AGC mV to quantization scaling factor (2^11/1000 = 2.048),
 * times the nth BBF gain. E.g., for XCVR_DCOC_TZA_STEP_0 the BBF gain index 0 is
 * 0dB=1.0, so DCOC_TZA_STEP_GAIN = 9.209. This value is stored in the register with
 * 3 fractional bits, so use round(9.209*2^3) = 74 decimal.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN field. */
#define XCVR_RD_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN(base, index) ((XCVR_DCOC_TZA_STEP__REG(base, index) & XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_MASK) >> XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_SHIFT)
#define XCVR_BRD_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN(base, index) (BME_UBFX32(&XCVR_DCOC_TZA_STEP__REG(base, index), XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_SHIFT, XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_WIDTH))

/*! @brief Set the DCOC_TZA_STEP_GAIN field to a new value. */
#define XCVR_WR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN(base, index, value) (XCVR_RMW_DCOC_TZA_STEP_(base, index, XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_MASK, XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN(value)))
#define XCVR_BWR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN(base, index, value) (BME_BFI32(&XCVR_DCOC_TZA_STEP__REG(base, index), ((uint32_t)(value) << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_SHIFT), XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_SHIFT, XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DCOC_CAL_ALPHA - DCOC Calibration Alpha
 ******************************************************************************/

/*!
 * @brief XCVR_DCOC_CAL_ALPHA - DCOC Calibration Alpha (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_DCOC_CAL_ALPHA register
 */
/*@{*/
#define XCVR_RD_DCOC_CAL_ALPHA(base) (XCVR_DCOC_CAL_ALPHA_REG(base))
/*@}*/

/*
 * Constants & macros for individual XCVR_DCOC_CAL_ALPHA bitfields
 */

/*!
 * @name Register XCVR_DCOC_CAL_ALPHA, field DCOC_CAL_ALPHA_I[15:0] (RO)
 *
 * DCOC Calibration I-channel ALPHA. This read-only, signed 16bit value
 * represents the I channel estimate of the ALPHA DC component calculated in DCOC
 * calibration. This is provided for debug/characterization purposes.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_ALPHA_DCOC_CAL_ALPHA_I field. */
#define XCVR_RD_DCOC_CAL_ALPHA_DCOC_CAL_ALPHA_I(base) ((XCVR_DCOC_CAL_ALPHA_REG(base) & XCVR_DCOC_CAL_ALPHA_DCOC_CAL_ALPHA_I_MASK) >> XCVR_DCOC_CAL_ALPHA_DCOC_CAL_ALPHA_I_SHIFT)
#define XCVR_BRD_DCOC_CAL_ALPHA_DCOC_CAL_ALPHA_I(base) (BME_UBFX32(&XCVR_DCOC_CAL_ALPHA_REG(base), XCVR_DCOC_CAL_ALPHA_DCOC_CAL_ALPHA_I_SHIFT, XCVR_DCOC_CAL_ALPHA_DCOC_CAL_ALPHA_I_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CAL_ALPHA, field DCOC_CAL_ALPHA_Q[31:16] (RO)
 *
 * DCOC Calibration Q-channel ALPHA. This read-only, signed 16bit value
 * represents the Q channel estimate of the ALPHA DC component calculated in DCOC
 * calibration. This is provided for debug/characterization purposes.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_ALPHA_DCOC_CAL_ALPHA_Q field. */
#define XCVR_RD_DCOC_CAL_ALPHA_DCOC_CAL_ALPHA_Q(base) ((XCVR_DCOC_CAL_ALPHA_REG(base) & XCVR_DCOC_CAL_ALPHA_DCOC_CAL_ALPHA_Q_MASK) >> XCVR_DCOC_CAL_ALPHA_DCOC_CAL_ALPHA_Q_SHIFT)
#define XCVR_BRD_DCOC_CAL_ALPHA_DCOC_CAL_ALPHA_Q(base) (BME_UBFX32(&XCVR_DCOC_CAL_ALPHA_REG(base), XCVR_DCOC_CAL_ALPHA_DCOC_CAL_ALPHA_Q_SHIFT, XCVR_DCOC_CAL_ALPHA_DCOC_CAL_ALPHA_Q_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DCOC_CAL_BETA - DCOC Calibration Beta
 ******************************************************************************/

/*!
 * @brief XCVR_DCOC_CAL_BETA - DCOC Calibration Beta (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_DCOC_CAL_BETA register
 */
/*@{*/
#define XCVR_RD_DCOC_CAL_BETA(base) (XCVR_DCOC_CAL_BETA_REG(base))
/*@}*/

/*
 * Constants & macros for individual XCVR_DCOC_CAL_BETA bitfields
 */

/*!
 * @name Register XCVR_DCOC_CAL_BETA, field DCOC_CAL_BETA_I[15:0] (RO)
 *
 * DCOC Calibration I-channel BETA. This read-only, signed 16bit value
 * represents the I channel estimate of the BETA DC component calculated in DCOC
 * calibration. This is provided for debug/characterization purposes.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_BETA_DCOC_CAL_BETA_I field. */
#define XCVR_RD_DCOC_CAL_BETA_DCOC_CAL_BETA_I(base) ((XCVR_DCOC_CAL_BETA_REG(base) & XCVR_DCOC_CAL_BETA_DCOC_CAL_BETA_I_MASK) >> XCVR_DCOC_CAL_BETA_DCOC_CAL_BETA_I_SHIFT)
#define XCVR_BRD_DCOC_CAL_BETA_DCOC_CAL_BETA_I(base) (BME_UBFX32(&XCVR_DCOC_CAL_BETA_REG(base), XCVR_DCOC_CAL_BETA_DCOC_CAL_BETA_I_SHIFT, XCVR_DCOC_CAL_BETA_DCOC_CAL_BETA_I_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CAL_BETA, field DCOC_CAL_BETA_Q[31:16] (RO)
 *
 * DCOC Calibration Q-channel BETA. This read-only, signed 16bit value
 * represents the Q channel estimate of the BETA DC component calculated in DCOC
 * calibration. This is provided for debug/characterization purposes.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_BETA_DCOC_CAL_BETA_Q field. */
#define XCVR_RD_DCOC_CAL_BETA_DCOC_CAL_BETA_Q(base) ((XCVR_DCOC_CAL_BETA_REG(base) & XCVR_DCOC_CAL_BETA_DCOC_CAL_BETA_Q_MASK) >> XCVR_DCOC_CAL_BETA_DCOC_CAL_BETA_Q_SHIFT)
#define XCVR_BRD_DCOC_CAL_BETA_DCOC_CAL_BETA_Q(base) (BME_UBFX32(&XCVR_DCOC_CAL_BETA_REG(base), XCVR_DCOC_CAL_BETA_DCOC_CAL_BETA_Q_SHIFT, XCVR_DCOC_CAL_BETA_DCOC_CAL_BETA_Q_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DCOC_CAL_GAMMA - DCOC Calibration Gamma
 ******************************************************************************/

/*!
 * @brief XCVR_DCOC_CAL_GAMMA - DCOC Calibration Gamma (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_DCOC_CAL_GAMMA register
 */
/*@{*/
#define XCVR_RD_DCOC_CAL_GAMMA(base) (XCVR_DCOC_CAL_GAMMA_REG(base))
/*@}*/

/*
 * Constants & macros for individual XCVR_DCOC_CAL_GAMMA bitfields
 */

/*!
 * @name Register XCVR_DCOC_CAL_GAMMA, field DCOC_CAL_GAMMA_I[15:0] (RO)
 *
 * DCOC Calibration I-channel GAMMA. This read-only, signed 16bit value
 * represents the I channel estimate of the GAMMA DC component calculated in DCOC
 * calibration. This is provided for debug/characterization purposes.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_GAMMA_DCOC_CAL_GAMMA_I field. */
#define XCVR_RD_DCOC_CAL_GAMMA_DCOC_CAL_GAMMA_I(base) ((XCVR_DCOC_CAL_GAMMA_REG(base) & XCVR_DCOC_CAL_GAMMA_DCOC_CAL_GAMMA_I_MASK) >> XCVR_DCOC_CAL_GAMMA_DCOC_CAL_GAMMA_I_SHIFT)
#define XCVR_BRD_DCOC_CAL_GAMMA_DCOC_CAL_GAMMA_I(base) (BME_UBFX32(&XCVR_DCOC_CAL_GAMMA_REG(base), XCVR_DCOC_CAL_GAMMA_DCOC_CAL_GAMMA_I_SHIFT, XCVR_DCOC_CAL_GAMMA_DCOC_CAL_GAMMA_I_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CAL_GAMMA, field DCOC_CAL_GAMMA_Q[31:16] (RO)
 *
 * DCOC Calibration Q-channel GAMMA. This read-only, signed 16bit value
 * represents the Q channel estimate of the GAMMA DC component calculated in DCOC
 * calibration. This is provided for debug/characterization purposes.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_GAMMA_DCOC_CAL_GAMMA_Q field. */
#define XCVR_RD_DCOC_CAL_GAMMA_DCOC_CAL_GAMMA_Q(base) ((XCVR_DCOC_CAL_GAMMA_REG(base) & XCVR_DCOC_CAL_GAMMA_DCOC_CAL_GAMMA_Q_MASK) >> XCVR_DCOC_CAL_GAMMA_DCOC_CAL_GAMMA_Q_SHIFT)
#define XCVR_BRD_DCOC_CAL_GAMMA_DCOC_CAL_GAMMA_Q(base) (BME_UBFX32(&XCVR_DCOC_CAL_GAMMA_REG(base), XCVR_DCOC_CAL_GAMMA_DCOC_CAL_GAMMA_Q_SHIFT, XCVR_DCOC_CAL_GAMMA_DCOC_CAL_GAMMA_Q_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DCOC_CAL_IIR - DCOC Calibration IIR
 ******************************************************************************/

/*!
 * @brief XCVR_DCOC_CAL_IIR - DCOC Calibration IIR (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_DCOC_CAL_IIR register
 */
/*@{*/
#define XCVR_RD_DCOC_CAL_IIR(base) (XCVR_DCOC_CAL_IIR_REG(base))
#define XCVR_WR_DCOC_CAL_IIR(base, value) (XCVR_DCOC_CAL_IIR_REG(base) = (value))
#define XCVR_RMW_DCOC_CAL_IIR(base, mask, value) (XCVR_WR_DCOC_CAL_IIR(base, (XCVR_RD_DCOC_CAL_IIR(base) & ~(mask)) | (value)))
#define XCVR_SET_DCOC_CAL_IIR(base, value) (BME_OR32(&XCVR_DCOC_CAL_IIR_REG(base), (uint32_t)(value)))
#define XCVR_CLR_DCOC_CAL_IIR(base, value) (BME_AND32(&XCVR_DCOC_CAL_IIR_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_DCOC_CAL_IIR(base, value) (BME_XOR32(&XCVR_DCOC_CAL_IIR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_DCOC_CAL_IIR bitfields
 */

/*!
 * @name Register XCVR_DCOC_CAL_IIR, field DCOC_CAL_IIR1A_IDX[1:0] (RW)
 *
 * DCOC Calibration IIR 1A Index. Defines the filter coefficient use for the 1st
 * IIR filter in the DCOC calibration DC estimator.
 *
 * Values:
 * - 0b00 - 1/1
 * - 0b01 - 1/4
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR1A_IDX field. */
#define XCVR_RD_DCOC_CAL_IIR_DCOC_CAL_IIR1A_IDX(base) ((XCVR_DCOC_CAL_IIR_REG(base) & XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR1A_IDX_MASK) >> XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR1A_IDX_SHIFT)
#define XCVR_BRD_DCOC_CAL_IIR_DCOC_CAL_IIR1A_IDX(base) (BME_UBFX32(&XCVR_DCOC_CAL_IIR_REG(base), XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR1A_IDX_SHIFT, XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR1A_IDX_WIDTH))

/*! @brief Set the DCOC_CAL_IIR1A_IDX field to a new value. */
#define XCVR_WR_DCOC_CAL_IIR_DCOC_CAL_IIR1A_IDX(base, value) (XCVR_RMW_DCOC_CAL_IIR(base, XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR1A_IDX_MASK, XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR1A_IDX(value)))
#define XCVR_BWR_DCOC_CAL_IIR_DCOC_CAL_IIR1A_IDX(base, value) (BME_BFI32(&XCVR_DCOC_CAL_IIR_REG(base), ((uint32_t)(value) << XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR1A_IDX_SHIFT), XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR1A_IDX_SHIFT, XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR1A_IDX_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CAL_IIR, field DCOC_CAL_IIR2A_IDX[3:2] (RW)
 *
 * DCOC Calibration IIR 2A Index. Defines the filter coefficient use for the 2nd
 * IIR filter in the DCOC calibration DC estimator.
 *
 * Values:
 * - 0b00 - 1/1
 * - 0b01 - 1/4
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR2A_IDX field. */
#define XCVR_RD_DCOC_CAL_IIR_DCOC_CAL_IIR2A_IDX(base) ((XCVR_DCOC_CAL_IIR_REG(base) & XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR2A_IDX_MASK) >> XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR2A_IDX_SHIFT)
#define XCVR_BRD_DCOC_CAL_IIR_DCOC_CAL_IIR2A_IDX(base) (BME_UBFX32(&XCVR_DCOC_CAL_IIR_REG(base), XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR2A_IDX_SHIFT, XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR2A_IDX_WIDTH))

/*! @brief Set the DCOC_CAL_IIR2A_IDX field to a new value. */
#define XCVR_WR_DCOC_CAL_IIR_DCOC_CAL_IIR2A_IDX(base, value) (XCVR_RMW_DCOC_CAL_IIR(base, XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR2A_IDX_MASK, XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR2A_IDX(value)))
#define XCVR_BWR_DCOC_CAL_IIR_DCOC_CAL_IIR2A_IDX(base, value) (BME_BFI32(&XCVR_DCOC_CAL_IIR_REG(base), ((uint32_t)(value) << XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR2A_IDX_SHIFT), XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR2A_IDX_SHIFT, XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR2A_IDX_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CAL_IIR, field DCOC_CAL_IIR3A_IDX[5:4] (RW)
 *
 * DCOC Calibration IIR 3A Index. Defines the filter coefficient use for the 3rd
 * IIR filter in the DCOC calibration DC estimator.
 *
 * Values:
 * - 0b00 - 1/4
 * - 0b01 - 1/8
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR3A_IDX field. */
#define XCVR_RD_DCOC_CAL_IIR_DCOC_CAL_IIR3A_IDX(base) ((XCVR_DCOC_CAL_IIR_REG(base) & XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR3A_IDX_MASK) >> XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR3A_IDX_SHIFT)
#define XCVR_BRD_DCOC_CAL_IIR_DCOC_CAL_IIR3A_IDX(base) (BME_UBFX32(&XCVR_DCOC_CAL_IIR_REG(base), XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR3A_IDX_SHIFT, XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR3A_IDX_WIDTH))

/*! @brief Set the DCOC_CAL_IIR3A_IDX field to a new value. */
#define XCVR_WR_DCOC_CAL_IIR_DCOC_CAL_IIR3A_IDX(base, value) (XCVR_RMW_DCOC_CAL_IIR(base, XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR3A_IDX_MASK, XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR3A_IDX(value)))
#define XCVR_BWR_DCOC_CAL_IIR_DCOC_CAL_IIR3A_IDX(base, value) (BME_BFI32(&XCVR_DCOC_CAL_IIR_REG(base), ((uint32_t)(value) << XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR3A_IDX_SHIFT), XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR3A_IDX_SHIFT, XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR3A_IDX_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DCOC_CAL - DCOC Calibration Result
 ******************************************************************************/

/*!
 * @brief XCVR_DCOC_CAL - DCOC Calibration Result (RO)
 *
 * Reset value: 0x00000000U
 *
 * Result of one of the calibration iterations.
 */
/*!
 * @name Constants and macros for entire XCVR_DCOC_CAL register
 */
/*@{*/
#define XCVR_RD_DCOC_CAL(base, index) (XCVR_DCOC_CAL_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual XCVR_DCOC_CAL bitfields
 */

/*!
 * @name Register XCVR_DCOC_CAL, field DCOC_CAL_RES_I[11:0] (RO)
 *
 * I channel DCOC calibration result. This 12bit signed value represents the
 * DCOC's I channel DC estimate for the nth calibration gain setting.This is
 * provided for debug/chacterization purposes.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_DCOC_CAL_RES_I field. */
#define XCVR_RD_DCOC_CAL_DCOC_CAL_RES_I(base, index) ((XCVR_DCOC_CAL_REG(base, index) & XCVR_DCOC_CAL_DCOC_CAL_RES_I_MASK) >> XCVR_DCOC_CAL_DCOC_CAL_RES_I_SHIFT)
#define XCVR_BRD_DCOC_CAL_DCOC_CAL_RES_I(base, index) (BME_UBFX32(&XCVR_DCOC_CAL_REG(base, index), XCVR_DCOC_CAL_DCOC_CAL_RES_I_SHIFT, XCVR_DCOC_CAL_DCOC_CAL_RES_I_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DCOC_CAL, field DCOC_CAL_RES_Q[27:16] (RO)
 *
 * Q channel DCOC calibration result. This 12bit signed value represents the
 * DCOC's Q channel DC estimate for the nth calibration gain setting.This is
 * provided for debug/chacterization purposes.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DCOC_CAL_DCOC_CAL_RES_Q field. */
#define XCVR_RD_DCOC_CAL_DCOC_CAL_RES_Q(base, index) ((XCVR_DCOC_CAL_REG(base, index) & XCVR_DCOC_CAL_DCOC_CAL_RES_Q_MASK) >> XCVR_DCOC_CAL_DCOC_CAL_RES_Q_SHIFT)
#define XCVR_BRD_DCOC_CAL_DCOC_CAL_RES_Q(base, index) (BME_UBFX32(&XCVR_DCOC_CAL_REG(base, index), XCVR_DCOC_CAL_DCOC_CAL_RES_Q_SHIFT, XCVR_DCOC_CAL_DCOC_CAL_RES_Q_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_RX_CHF_COEF - Receive Channel Filter Coefficient
 ******************************************************************************/

/*!
 * @brief XCVR_RX_CHF_COEF - Receive Channel Filter Coefficient (RW)
 *
 * Reset value: 0x00000000U
 *
 * Receive channel filter coefficient (8-bit signed fractional)
 */
/*!
 * @name Constants and macros for entire XCVR_RX_CHF_COEF register
 */
/*@{*/
#define XCVR_RD_RX_CHF_COEF(base, index) (XCVR_RX_CHF_COEF_REG(base, index))
#define XCVR_WR_RX_CHF_COEF(base, index, value) (XCVR_RX_CHF_COEF_REG(base, index) = (value))
#define XCVR_RMW_RX_CHF_COEF(base, index, mask, value) (XCVR_WR_RX_CHF_COEF(base, index, (XCVR_RD_RX_CHF_COEF(base, index) & ~(mask)) | (value)))
#define XCVR_SET_RX_CHF_COEF(base, index, value) (BME_OR32(&XCVR_RX_CHF_COEF_REG(base, index), (uint32_t)(value)))
#define XCVR_CLR_RX_CHF_COEF(base, index, value) (BME_AND32(&XCVR_RX_CHF_COEF_REG(base, index), (uint32_t)(~(value))))
#define XCVR_TOG_RX_CHF_COEF(base, index, value) (BME_XOR32(&XCVR_RX_CHF_COEF_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_RX_CHF_COEF bitfields
 */

/*!
 * @name Register XCVR_RX_CHF_COEF, field RX_CH_FILT_HX[7:0] (RW)
 *
 * Receive channel filter coefficient (8-bit signed fractional)
 */
/*@{*/
/*! @brief Read current value of the XCVR_RX_CHF_COEF_RX_CH_FILT_HX field. */
#define XCVR_RD_RX_CHF_COEF_RX_CH_FILT_HX(base, index) ((XCVR_RX_CHF_COEF_REG(base, index) & XCVR_RX_CHF_COEF_RX_CH_FILT_HX_MASK) >> XCVR_RX_CHF_COEF_RX_CH_FILT_HX_SHIFT)
#define XCVR_BRD_RX_CHF_COEF_RX_CH_FILT_HX(base, index) (BME_UBFX32(&XCVR_RX_CHF_COEF_REG(base, index), XCVR_RX_CHF_COEF_RX_CH_FILT_HX_SHIFT, XCVR_RX_CHF_COEF_RX_CH_FILT_HX_WIDTH))

/*! @brief Set the RX_CH_FILT_HX field to a new value. */
#define XCVR_WR_RX_CHF_COEF_RX_CH_FILT_HX(base, index, value) (XCVR_RMW_RX_CHF_COEF(base, index, XCVR_RX_CHF_COEF_RX_CH_FILT_HX_MASK, XCVR_RX_CHF_COEF_RX_CH_FILT_HX(value)))
#define XCVR_BWR_RX_CHF_COEF_RX_CH_FILT_HX(base, index, value) (BME_BFI32(&XCVR_RX_CHF_COEF_REG(base, index), ((uint32_t)(value) << XCVR_RX_CHF_COEF_RX_CH_FILT_HX_SHIFT), XCVR_RX_CHF_COEF_RX_CH_FILT_HX_SHIFT, XCVR_RX_CHF_COEF_RX_CH_FILT_HX_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TX_DIG_CTRL - TX Digital Control
 ******************************************************************************/

/*!
 * @brief XCVR_TX_DIG_CTRL - TX Digital Control (RW)
 *
 * Reset value: 0x00000140U
 */
/*!
 * @name Constants and macros for entire XCVR_TX_DIG_CTRL register
 */
/*@{*/
#define XCVR_RD_TX_DIG_CTRL(base) (XCVR_TX_DIG_CTRL_REG(base))
#define XCVR_WR_TX_DIG_CTRL(base, value) (XCVR_TX_DIG_CTRL_REG(base) = (value))
#define XCVR_RMW_TX_DIG_CTRL(base, mask, value) (XCVR_WR_TX_DIG_CTRL(base, (XCVR_RD_TX_DIG_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_TX_DIG_CTRL(base, value) (BME_OR32(&XCVR_TX_DIG_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TX_DIG_CTRL(base, value) (BME_AND32(&XCVR_TX_DIG_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TX_DIG_CTRL(base, value) (BME_XOR32(&XCVR_TX_DIG_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TX_DIG_CTRL bitfields
 */

/*!
 * @name Register XCVR_TX_DIG_CTRL, field DFT_MODE[2:0] (RW)
 *
 * This register selects the Radio DFT mode as described below. In addition to
 * setting the Radio DFT mode, the DFT LFSR needs to be configured, and the Radio
 * Protocol needs to be chosen. Note that the LFSR Symbols mode is not supported
 * for GFSK Protocols, and the Tone modes bypass both the GFSK and the FSK
 * modulators.
 *
 * Values:
 * - 0b000 - Normal Radio Operation. DFT not engaged.
 * - 0b001 - Pattern Register Mode. TX DFT Modulation Pattern Register is
 *     shifted out as the transmission data stream. Note that the DFT_EN bit must be
 *     set.
 * - 0b010 - LFSR Data Mode. TX LFSR is used as the transmission data stream.
 *     Note that the LFSR_EN bit must be set.
 * - 0b011 - LFSR Symbol Mode. TX LFSR is used to create 802.15.4 symbols which
 *     are then converted to Chips and transmitted. Note that the LFSR_EN bit
 *     must be set.
 * - 0b100 - Not implemented on Apache 1.0, future use will allow a package pin
 *     to be used as the source of the TX data stream. Note that the DFT_EN bit
 *     must be set.
 * - 0b101 - Constant Frequency Mode. No data modulation is done, Radio
 *     transmits at the channel frequency selected.
 * - 0b110 - LFSR Tone Mode. TX LFSR is used to select the DFT Tone register to
 *     transmit, LFSR_EN bit must be set.
 * - 0b111 - Manual Tone Mode. TONE_SEL is used to select the DFT Tone register
 *     to transmit.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_DIG_CTRL_DFT_MODE field. */
#define XCVR_RD_TX_DIG_CTRL_DFT_MODE(base) ((XCVR_TX_DIG_CTRL_REG(base) & XCVR_TX_DIG_CTRL_DFT_MODE_MASK) >> XCVR_TX_DIG_CTRL_DFT_MODE_SHIFT)
#define XCVR_BRD_TX_DIG_CTRL_DFT_MODE(base) (BME_UBFX32(&XCVR_TX_DIG_CTRL_REG(base), XCVR_TX_DIG_CTRL_DFT_MODE_SHIFT, XCVR_TX_DIG_CTRL_DFT_MODE_WIDTH))

/*! @brief Set the DFT_MODE field to a new value. */
#define XCVR_WR_TX_DIG_CTRL_DFT_MODE(base, value) (XCVR_RMW_TX_DIG_CTRL(base, XCVR_TX_DIG_CTRL_DFT_MODE_MASK, XCVR_TX_DIG_CTRL_DFT_MODE(value)))
#define XCVR_BWR_TX_DIG_CTRL_DFT_MODE(base, value) (BME_BFI32(&XCVR_TX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_TX_DIG_CTRL_DFT_MODE_SHIFT), XCVR_TX_DIG_CTRL_DFT_MODE_SHIFT, XCVR_TX_DIG_CTRL_DFT_MODE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TX_DIG_CTRL, field DFT_EN[3] (RW)
 *
 * If the Radio is in DFT Pattern Register mode, then this bit is used to turn
 * on and off the modulation.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_DIG_CTRL_DFT_EN field. */
#define XCVR_RD_TX_DIG_CTRL_DFT_EN(base) ((XCVR_TX_DIG_CTRL_REG(base) & XCVR_TX_DIG_CTRL_DFT_EN_MASK) >> XCVR_TX_DIG_CTRL_DFT_EN_SHIFT)
#define XCVR_BRD_TX_DIG_CTRL_DFT_EN(base) (BME_UBFX32(&XCVR_TX_DIG_CTRL_REG(base), XCVR_TX_DIG_CTRL_DFT_EN_SHIFT, XCVR_TX_DIG_CTRL_DFT_EN_WIDTH))

/*! @brief Set the DFT_EN field to a new value. */
#define XCVR_WR_TX_DIG_CTRL_DFT_EN(base, value) (XCVR_RMW_TX_DIG_CTRL(base, XCVR_TX_DIG_CTRL_DFT_EN_MASK, XCVR_TX_DIG_CTRL_DFT_EN(value)))
#define XCVR_BWR_TX_DIG_CTRL_DFT_EN(base, value) (BME_BFI32(&XCVR_TX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_TX_DIG_CTRL_DFT_EN_SHIFT), XCVR_TX_DIG_CTRL_DFT_EN_SHIFT, XCVR_TX_DIG_CTRL_DFT_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TX_DIG_CTRL, field DFT_LFSR_LEN[6:4] (RW)
 *
 * This register selects the length of the DFT LFSR and the associated LFSR Tap
 * Mask. The Mask is in the form of [MSB...LSB]
 *
 * Values:
 * - 0b000 - LFSR 9, tap mask 100010000
 * - 0b001 - LFSR 10, tap mask 1001000000
 * - 0b010 - LFSR 11, tap mask 11101000000
 * - 0b011 - LFSR 13, tap mask 1101100000000
 * - 0b100 - LFSR 15, tap mask 111010000000000
 * - 0b101 - LFSR 17, tap mask 11110000000000000
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_DIG_CTRL_DFT_LFSR_LEN field. */
#define XCVR_RD_TX_DIG_CTRL_DFT_LFSR_LEN(base) ((XCVR_TX_DIG_CTRL_REG(base) & XCVR_TX_DIG_CTRL_DFT_LFSR_LEN_MASK) >> XCVR_TX_DIG_CTRL_DFT_LFSR_LEN_SHIFT)
#define XCVR_BRD_TX_DIG_CTRL_DFT_LFSR_LEN(base) (BME_UBFX32(&XCVR_TX_DIG_CTRL_REG(base), XCVR_TX_DIG_CTRL_DFT_LFSR_LEN_SHIFT, XCVR_TX_DIG_CTRL_DFT_LFSR_LEN_WIDTH))

/*! @brief Set the DFT_LFSR_LEN field to a new value. */
#define XCVR_WR_TX_DIG_CTRL_DFT_LFSR_LEN(base, value) (XCVR_RMW_TX_DIG_CTRL(base, XCVR_TX_DIG_CTRL_DFT_LFSR_LEN_MASK, XCVR_TX_DIG_CTRL_DFT_LFSR_LEN(value)))
#define XCVR_BWR_TX_DIG_CTRL_DFT_LFSR_LEN(base, value) (BME_BFI32(&XCVR_TX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_TX_DIG_CTRL_DFT_LFSR_LEN_SHIFT), XCVR_TX_DIG_CTRL_DFT_LFSR_LEN_SHIFT, XCVR_TX_DIG_CTRL_DFT_LFSR_LEN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TX_DIG_CTRL, field LFSR_EN[7] (RW)
 *
 * This bit enables the DFT LFSR for use as a source for Data Padding and TX
 * Data in LFSR Data mode, for use as TX Symbols in LFSR Symbol mode, and for use as
 * the Tone Selector in LFSR Tone mode. Effectively this is the on-off switch
 * for modulation in these modes. Note that the LFSR is clocked at the DFT Clock
 * frequency.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_DIG_CTRL_LFSR_EN field. */
#define XCVR_RD_TX_DIG_CTRL_LFSR_EN(base) ((XCVR_TX_DIG_CTRL_REG(base) & XCVR_TX_DIG_CTRL_LFSR_EN_MASK) >> XCVR_TX_DIG_CTRL_LFSR_EN_SHIFT)
#define XCVR_BRD_TX_DIG_CTRL_LFSR_EN(base) (BME_UBFX32(&XCVR_TX_DIG_CTRL_REG(base), XCVR_TX_DIG_CTRL_LFSR_EN_SHIFT, XCVR_TX_DIG_CTRL_LFSR_EN_WIDTH))

/*! @brief Set the LFSR_EN field to a new value. */
#define XCVR_WR_TX_DIG_CTRL_LFSR_EN(base, value) (XCVR_RMW_TX_DIG_CTRL(base, XCVR_TX_DIG_CTRL_LFSR_EN_MASK, XCVR_TX_DIG_CTRL_LFSR_EN(value)))
#define XCVR_BWR_TX_DIG_CTRL_LFSR_EN(base, value) (BME_BFI32(&XCVR_TX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_TX_DIG_CTRL_LFSR_EN_SHIFT), XCVR_TX_DIG_CTRL_LFSR_EN_SHIFT, XCVR_TX_DIG_CTRL_LFSR_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TX_DIG_CTRL, field DFT_CLK_SEL[10:8] (RW)
 *
 * This register selects the frequency of the DFT clock that is used to shift
 * out the DFT Modulation Pattern and also used to clock the LFSR in DFT LFSR modes.
 *
 * Values:
 * - 0b000 - 62.5 kHz
 * - 0b001 - 125 kHz
 * - 0b010 - 250 kHz
 * - 0b011 - 500 kHz
 * - 0b100 - 1 MHz
 * - 0b101 - 2 MHz
 * - 0b110 - 4 MHz
 * - 0b111 - Clock is off
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_DIG_CTRL_DFT_CLK_SEL field. */
#define XCVR_RD_TX_DIG_CTRL_DFT_CLK_SEL(base) ((XCVR_TX_DIG_CTRL_REG(base) & XCVR_TX_DIG_CTRL_DFT_CLK_SEL_MASK) >> XCVR_TX_DIG_CTRL_DFT_CLK_SEL_SHIFT)
#define XCVR_BRD_TX_DIG_CTRL_DFT_CLK_SEL(base) (BME_UBFX32(&XCVR_TX_DIG_CTRL_REG(base), XCVR_TX_DIG_CTRL_DFT_CLK_SEL_SHIFT, XCVR_TX_DIG_CTRL_DFT_CLK_SEL_WIDTH))

/*! @brief Set the DFT_CLK_SEL field to a new value. */
#define XCVR_WR_TX_DIG_CTRL_DFT_CLK_SEL(base, value) (XCVR_RMW_TX_DIG_CTRL(base, XCVR_TX_DIG_CTRL_DFT_CLK_SEL_MASK, XCVR_TX_DIG_CTRL_DFT_CLK_SEL(value)))
#define XCVR_BWR_TX_DIG_CTRL_DFT_CLK_SEL(base, value) (BME_BFI32(&XCVR_TX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_TX_DIG_CTRL_DFT_CLK_SEL_SHIFT), XCVR_TX_DIG_CTRL_DFT_CLK_SEL_SHIFT, XCVR_TX_DIG_CTRL_DFT_CLK_SEL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TX_DIG_CTRL, field TONE_SEL[13:12] (RW)
 *
 * This register selects the DFT Tone register to use as the Modulation Source
 * in DFT Manual Tone mode. The selected Tone will be added as a constant
 * frequency offset to the current Radio frequency. Software can change the tone
 * selection to modulate the Radio frequency at a software derived frequency. Note that
 * the DFT LFSR Tone mode can be used to randomly modulate with tones at the DFT
 * Clock frequency.
 *
 * Values:
 * - 0b00 - DFT Tone 0
 * - 0b01 - DFT Tone 1
 * - 0b10 - DFT Tone 2
 * - 0b11 - DFT Tone 3
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_DIG_CTRL_TONE_SEL field. */
#define XCVR_RD_TX_DIG_CTRL_TONE_SEL(base) ((XCVR_TX_DIG_CTRL_REG(base) & XCVR_TX_DIG_CTRL_TONE_SEL_MASK) >> XCVR_TX_DIG_CTRL_TONE_SEL_SHIFT)
#define XCVR_BRD_TX_DIG_CTRL_TONE_SEL(base) (BME_UBFX32(&XCVR_TX_DIG_CTRL_REG(base), XCVR_TX_DIG_CTRL_TONE_SEL_SHIFT, XCVR_TX_DIG_CTRL_TONE_SEL_WIDTH))

/*! @brief Set the TONE_SEL field to a new value. */
#define XCVR_WR_TX_DIG_CTRL_TONE_SEL(base, value) (XCVR_RMW_TX_DIG_CTRL(base, XCVR_TX_DIG_CTRL_TONE_SEL_MASK, XCVR_TX_DIG_CTRL_TONE_SEL(value)))
#define XCVR_BWR_TX_DIG_CTRL_TONE_SEL(base, value) (BME_BFI32(&XCVR_TX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_TX_DIG_CTRL_TONE_SEL_SHIFT), XCVR_TX_DIG_CTRL_TONE_SEL_SHIFT, XCVR_TX_DIG_CTRL_TONE_SEL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TX_DIG_CTRL, field POL[16] (RW)
 *
 * This bit selects between Even or Odd reference clock cycles to sample the TX
 * Modulators output values. The TX Modulator to sample is selected by the Radio
 * Protocol and the Radio DFT Mode, and can be either the GFSK modulator, the FSK
 * modulator, or the DFT Tone modulator. The resulting Oversampled Modulation is
 * the Baseband Frequency Word presented to the PLL
 *
 * Values:
 * - 0b0 - Selects Even clock cycle
 * - 0b1 - Selects Odd clock cycle, a one cycle delay
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_DIG_CTRL_POL field. */
#define XCVR_RD_TX_DIG_CTRL_POL(base) ((XCVR_TX_DIG_CTRL_REG(base) & XCVR_TX_DIG_CTRL_POL_MASK) >> XCVR_TX_DIG_CTRL_POL_SHIFT)
#define XCVR_BRD_TX_DIG_CTRL_POL(base) (BME_UBFX32(&XCVR_TX_DIG_CTRL_REG(base), XCVR_TX_DIG_CTRL_POL_SHIFT, XCVR_TX_DIG_CTRL_POL_WIDTH))

/*! @brief Set the POL field to a new value. */
#define XCVR_WR_TX_DIG_CTRL_POL(base, value) (XCVR_RMW_TX_DIG_CTRL(base, XCVR_TX_DIG_CTRL_POL_MASK, XCVR_TX_DIG_CTRL_POL(value)))
#define XCVR_BWR_TX_DIG_CTRL_POL(base, value) (BME_BFI32(&XCVR_TX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_TX_DIG_CTRL_POL_SHIFT), XCVR_TX_DIG_CTRL_POL_SHIFT, XCVR_TX_DIG_CTRL_POL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TX_DIG_CTRL, field DP_SEL[20] (RW)
 *
 * In normal user GSFK modes the BLE link layer overrides this bit to match the
 * first bit of the packet preamble. In Radio Protocol 7, 128 Channel GFSK mode,
 * this register bit is active and selects the 8 bits of data padding. For DFT
 * GFSK modes, this register bit is active and the unselected data padding pattern
 * is added as an additional 8 bits of padding after the selected pattern is
 * shifted out. For 802.15.4 Radio Protocols, this register bit selects the data
 * padding pattern to be used as Symbols and converted to Chips for padding. In all
 * cases the LSB is the first bit shifted out as data padding.
 *
 * Values:
 * - 0b0 - Selects DATA_PADDING_PATTERN_0 as the source for data padding
 * - 0b1 - Selects DATA_PADDING_PATTERN_1 as the source for data padding
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_DIG_CTRL_DP_SEL field. */
#define XCVR_RD_TX_DIG_CTRL_DP_SEL(base) ((XCVR_TX_DIG_CTRL_REG(base) & XCVR_TX_DIG_CTRL_DP_SEL_MASK) >> XCVR_TX_DIG_CTRL_DP_SEL_SHIFT)
#define XCVR_BRD_TX_DIG_CTRL_DP_SEL(base) (BME_UBFX32(&XCVR_TX_DIG_CTRL_REG(base), XCVR_TX_DIG_CTRL_DP_SEL_SHIFT, XCVR_TX_DIG_CTRL_DP_SEL_WIDTH))

/*! @brief Set the DP_SEL field to a new value. */
#define XCVR_WR_TX_DIG_CTRL_DP_SEL(base, value) (XCVR_RMW_TX_DIG_CTRL(base, XCVR_TX_DIG_CTRL_DP_SEL_MASK, XCVR_TX_DIG_CTRL_DP_SEL(value)))
#define XCVR_BWR_TX_DIG_CTRL_DP_SEL(base, value) (BME_BFI32(&XCVR_TX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_TX_DIG_CTRL_DP_SEL_SHIFT), XCVR_TX_DIG_CTRL_DP_SEL_SHIFT, XCVR_TX_DIG_CTRL_DP_SEL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TX_DIG_CTRL, field FREQ_WORD_ADJ[31:22] (RW)
 *
 * This register is a signed 9 bit number that is added to the GFSK modulator
 * output. This allows the GFSK modulation to be adjusted, or skewed, by a range of
 * -512 to +511.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_DIG_CTRL_FREQ_WORD_ADJ field. */
#define XCVR_RD_TX_DIG_CTRL_FREQ_WORD_ADJ(base) ((XCVR_TX_DIG_CTRL_REG(base) & XCVR_TX_DIG_CTRL_FREQ_WORD_ADJ_MASK) >> XCVR_TX_DIG_CTRL_FREQ_WORD_ADJ_SHIFT)
#define XCVR_BRD_TX_DIG_CTRL_FREQ_WORD_ADJ(base) (BME_UBFX32(&XCVR_TX_DIG_CTRL_REG(base), XCVR_TX_DIG_CTRL_FREQ_WORD_ADJ_SHIFT, XCVR_TX_DIG_CTRL_FREQ_WORD_ADJ_WIDTH))

/*! @brief Set the FREQ_WORD_ADJ field to a new value. */
#define XCVR_WR_TX_DIG_CTRL_FREQ_WORD_ADJ(base, value) (XCVR_RMW_TX_DIG_CTRL(base, XCVR_TX_DIG_CTRL_FREQ_WORD_ADJ_MASK, XCVR_TX_DIG_CTRL_FREQ_WORD_ADJ(value)))
#define XCVR_BWR_TX_DIG_CTRL_FREQ_WORD_ADJ(base, value) (BME_BFI32(&XCVR_TX_DIG_CTRL_REG(base), ((uint32_t)(value) << XCVR_TX_DIG_CTRL_FREQ_WORD_ADJ_SHIFT), XCVR_TX_DIG_CTRL_FREQ_WORD_ADJ_SHIFT, XCVR_TX_DIG_CTRL_FREQ_WORD_ADJ_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TX_DATA_PAD_PAT - TX Data Padding Pattern
 ******************************************************************************/

/*!
 * @brief XCVR_TX_DATA_PAD_PAT - TX Data Padding Pattern (RW)
 *
 * Reset value: 0x7FFF55AAU
 */
/*!
 * @name Constants and macros for entire XCVR_TX_DATA_PAD_PAT register
 */
/*@{*/
#define XCVR_RD_TX_DATA_PAD_PAT(base) (XCVR_TX_DATA_PAD_PAT_REG(base))
#define XCVR_WR_TX_DATA_PAD_PAT(base, value) (XCVR_TX_DATA_PAD_PAT_REG(base) = (value))
#define XCVR_RMW_TX_DATA_PAD_PAT(base, mask, value) (XCVR_WR_TX_DATA_PAD_PAT(base, (XCVR_RD_TX_DATA_PAD_PAT(base) & ~(mask)) | (value)))
#define XCVR_SET_TX_DATA_PAD_PAT(base, value) (BME_OR32(&XCVR_TX_DATA_PAD_PAT_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TX_DATA_PAD_PAT(base, value) (BME_AND32(&XCVR_TX_DATA_PAD_PAT_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TX_DATA_PAD_PAT(base, value) (BME_XOR32(&XCVR_TX_DATA_PAD_PAT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TX_DATA_PAD_PAT bitfields
 */

/*!
 * @name Register XCVR_TX_DATA_PAD_PAT, field DATA_PADDING_PAT_0[7:0] (RW)
 *
 * These bits are used for Data Padding when Pattern 0 is selected, the LSB is
 * the first bit shifted out as padding.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_0 field. */
#define XCVR_RD_TX_DATA_PAD_PAT_DATA_PADDING_PAT_0(base) ((XCVR_TX_DATA_PAD_PAT_REG(base) & XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_0_MASK) >> XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_0_SHIFT)
#define XCVR_BRD_TX_DATA_PAD_PAT_DATA_PADDING_PAT_0(base) (BME_UBFX32(&XCVR_TX_DATA_PAD_PAT_REG(base), XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_0_SHIFT, XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_0_WIDTH))

/*! @brief Set the DATA_PADDING_PAT_0 field to a new value. */
#define XCVR_WR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_0(base, value) (XCVR_RMW_TX_DATA_PAD_PAT(base, XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_0_MASK, XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_0(value)))
#define XCVR_BWR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_0(base, value) (BME_BFI32(&XCVR_TX_DATA_PAD_PAT_REG(base), ((uint32_t)(value) << XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_0_SHIFT), XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_0_SHIFT, XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_0_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TX_DATA_PAD_PAT, field DATA_PADDING_PAT_1[15:8] (RW)
 *
 * These bits are used for Data Padding when Pattern 1 is selected, the LSB is
 * the first bit shifted out as padding.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_1 field. */
#define XCVR_RD_TX_DATA_PAD_PAT_DATA_PADDING_PAT_1(base) ((XCVR_TX_DATA_PAD_PAT_REG(base) & XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_1_MASK) >> XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_1_SHIFT)
#define XCVR_BRD_TX_DATA_PAD_PAT_DATA_PADDING_PAT_1(base) (BME_UBFX32(&XCVR_TX_DATA_PAD_PAT_REG(base), XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_1_SHIFT, XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_1_WIDTH))

/*! @brief Set the DATA_PADDING_PAT_1 field to a new value. */
#define XCVR_WR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_1(base, value) (XCVR_RMW_TX_DATA_PAD_PAT(base, XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_1_MASK, XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_1(value)))
#define XCVR_BWR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_1(base, value) (BME_BFI32(&XCVR_TX_DATA_PAD_PAT_REG(base), ((uint32_t)(value) << XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_1_SHIFT), XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_1_SHIFT, XCVR_TX_DATA_PAD_PAT_DATA_PADDING_PAT_1_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TX_DATA_PAD_PAT, field DFT_LFSR_OUT[30:16] (RO)
 *
 * This register can be read to observe the current value of the DFT LFSR, only
 * bits [14:0] are available.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_DATA_PAD_PAT_DFT_LFSR_OUT field. */
#define XCVR_RD_TX_DATA_PAD_PAT_DFT_LFSR_OUT(base) ((XCVR_TX_DATA_PAD_PAT_REG(base) & XCVR_TX_DATA_PAD_PAT_DFT_LFSR_OUT_MASK) >> XCVR_TX_DATA_PAD_PAT_DFT_LFSR_OUT_SHIFT)
#define XCVR_BRD_TX_DATA_PAD_PAT_DFT_LFSR_OUT(base) (BME_UBFX32(&XCVR_TX_DATA_PAD_PAT_REG(base), XCVR_TX_DATA_PAD_PAT_DFT_LFSR_OUT_SHIFT, XCVR_TX_DATA_PAD_PAT_DFT_LFSR_OUT_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TX_DATA_PAD_PAT, field LRM[31] (RW)
 *
 * When this bit is set the DFT LFSR will not be reset when LFSR_EN is cleared
 * and will instead continue to repeat its sequence as defined by the DFT_LFSR_LEN
 * bits when LFSR_EN is next set. When this bit is cleared the DFT LFSR will
 * reset every time LFSR_EN is cleared.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_DATA_PAD_PAT_LRM field. */
#define XCVR_RD_TX_DATA_PAD_PAT_LRM(base) ((XCVR_TX_DATA_PAD_PAT_REG(base) & XCVR_TX_DATA_PAD_PAT_LRM_MASK) >> XCVR_TX_DATA_PAD_PAT_LRM_SHIFT)
#define XCVR_BRD_TX_DATA_PAD_PAT_LRM(base) (BME_UBFX32(&XCVR_TX_DATA_PAD_PAT_REG(base), XCVR_TX_DATA_PAD_PAT_LRM_SHIFT, XCVR_TX_DATA_PAD_PAT_LRM_WIDTH))

/*! @brief Set the LRM field to a new value. */
#define XCVR_WR_TX_DATA_PAD_PAT_LRM(base, value) (XCVR_RMW_TX_DATA_PAD_PAT(base, XCVR_TX_DATA_PAD_PAT_LRM_MASK, XCVR_TX_DATA_PAD_PAT_LRM(value)))
#define XCVR_BWR_TX_DATA_PAD_PAT_LRM(base, value) (BME_BFI32(&XCVR_TX_DATA_PAD_PAT_REG(base), ((uint32_t)(value) << XCVR_TX_DATA_PAD_PAT_LRM_SHIFT), XCVR_TX_DATA_PAD_PAT_LRM_SHIFT, XCVR_TX_DATA_PAD_PAT_LRM_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TX_GFSK_MOD_CTRL - TX GFSK Modulation Control
 ******************************************************************************/

/*!
 * @brief XCVR_TX_GFSK_MOD_CTRL - TX GFSK Modulation Control (RW)
 *
 * Reset value: 0x03014000U
 */
/*!
 * @name Constants and macros for entire XCVR_TX_GFSK_MOD_CTRL register
 */
/*@{*/
#define XCVR_RD_TX_GFSK_MOD_CTRL(base) (XCVR_TX_GFSK_MOD_CTRL_REG(base))
#define XCVR_WR_TX_GFSK_MOD_CTRL(base, value) (XCVR_TX_GFSK_MOD_CTRL_REG(base) = (value))
#define XCVR_RMW_TX_GFSK_MOD_CTRL(base, mask, value) (XCVR_WR_TX_GFSK_MOD_CTRL(base, (XCVR_RD_TX_GFSK_MOD_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_TX_GFSK_MOD_CTRL(base, value) (BME_OR32(&XCVR_TX_GFSK_MOD_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TX_GFSK_MOD_CTRL(base, value) (BME_AND32(&XCVR_TX_GFSK_MOD_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TX_GFSK_MOD_CTRL(base, value) (BME_XOR32(&XCVR_TX_GFSK_MOD_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TX_GFSK_MOD_CTRL bitfields
 */

/*!
 * @name Register XCVR_TX_GFSK_MOD_CTRL, field GFSK_MULTIPLY_TABLE_MANUAL[15:0] (RW)
 *
 * The GFSK Modulator Multiplier uses a lookup table to select the multiplicand
 * representing the (Frequency Deviation divided by the Low Port Sigma Delta LSB
 * resolution in Hz) for the Modulation requested based on the Modulation Index,
 * the Symbol Rate, and the Reference Clock Frequency. The lookup table value is
 * overridden by this register if GFSK_MLD is set, and these bits should then
 * contain a number that represents {FDev/SD_LSB integer[11:0] + FDev/SD_LSB
 * fraction[3:0]}
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_GFSK_MOD_CTRL_GFSK_MULTIPLY_TABLE_MANUAL field. */
#define XCVR_RD_TX_GFSK_MOD_CTRL_GFSK_MULTIPLY_TABLE_MANUAL(base) ((XCVR_TX_GFSK_MOD_CTRL_REG(base) & XCVR_TX_GFSK_MOD_CTRL_GFSK_MULTIPLY_TABLE_MANUAL_MASK) >> XCVR_TX_GFSK_MOD_CTRL_GFSK_MULTIPLY_TABLE_MANUAL_SHIFT)
#define XCVR_BRD_TX_GFSK_MOD_CTRL_GFSK_MULTIPLY_TABLE_MANUAL(base) (BME_UBFX32(&XCVR_TX_GFSK_MOD_CTRL_REG(base), XCVR_TX_GFSK_MOD_CTRL_GFSK_MULTIPLY_TABLE_MANUAL_SHIFT, XCVR_TX_GFSK_MOD_CTRL_GFSK_MULTIPLY_TABLE_MANUAL_WIDTH))

/*! @brief Set the GFSK_MULTIPLY_TABLE_MANUAL field to a new value. */
#define XCVR_WR_TX_GFSK_MOD_CTRL_GFSK_MULTIPLY_TABLE_MANUAL(base, value) (XCVR_RMW_TX_GFSK_MOD_CTRL(base, XCVR_TX_GFSK_MOD_CTRL_GFSK_MULTIPLY_TABLE_MANUAL_MASK, XCVR_TX_GFSK_MOD_CTRL_GFSK_MULTIPLY_TABLE_MANUAL(value)))
#define XCVR_BWR_TX_GFSK_MOD_CTRL_GFSK_MULTIPLY_TABLE_MANUAL(base, value) (BME_BFI32(&XCVR_TX_GFSK_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_TX_GFSK_MOD_CTRL_GFSK_MULTIPLY_TABLE_MANUAL_SHIFT), XCVR_TX_GFSK_MOD_CTRL_GFSK_MULTIPLY_TABLE_MANUAL_SHIFT, XCVR_TX_GFSK_MOD_CTRL_GFSK_MULTIPLY_TABLE_MANUAL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TX_GFSK_MOD_CTRL, field GFSK_MI[17:16] (RW)
 *
 * This register selects the GFSK Modulation Index which together with the GFSK
 * Symbol Rate determines the Peak Modulation frequency.The formula used for the
 * Peak Modulation is (Symbol Rate / (2 x 1/Modulation Index))
 *
 * Values:
 * - 0b00 - 0.32
 * - 0b01 - 0.50
 * - 0b10 - 0.80
 * - 0b11 - 1.00
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_GFSK_MOD_CTRL_GFSK_MI field. */
#define XCVR_RD_TX_GFSK_MOD_CTRL_GFSK_MI(base) ((XCVR_TX_GFSK_MOD_CTRL_REG(base) & XCVR_TX_GFSK_MOD_CTRL_GFSK_MI_MASK) >> XCVR_TX_GFSK_MOD_CTRL_GFSK_MI_SHIFT)
#define XCVR_BRD_TX_GFSK_MOD_CTRL_GFSK_MI(base) (BME_UBFX32(&XCVR_TX_GFSK_MOD_CTRL_REG(base), XCVR_TX_GFSK_MOD_CTRL_GFSK_MI_SHIFT, XCVR_TX_GFSK_MOD_CTRL_GFSK_MI_WIDTH))

/*! @brief Set the GFSK_MI field to a new value. */
#define XCVR_WR_TX_GFSK_MOD_CTRL_GFSK_MI(base, value) (XCVR_RMW_TX_GFSK_MOD_CTRL(base, XCVR_TX_GFSK_MOD_CTRL_GFSK_MI_MASK, XCVR_TX_GFSK_MOD_CTRL_GFSK_MI(value)))
#define XCVR_BWR_TX_GFSK_MOD_CTRL_GFSK_MI(base, value) (BME_BFI32(&XCVR_TX_GFSK_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_TX_GFSK_MOD_CTRL_GFSK_MI_SHIFT), XCVR_TX_GFSK_MOD_CTRL_GFSK_MI_SHIFT, XCVR_TX_GFSK_MOD_CTRL_GFSK_MI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TX_GFSK_MOD_CTRL, field GFSK_MLD[20] (RW)
 *
 * If this bit is set, the GFSK Multiply Lookup table is disabled and
 * GFSK_MULTIPLY_TABLE_MANUAL is used instead.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_GFSK_MOD_CTRL_GFSK_MLD field. */
#define XCVR_RD_TX_GFSK_MOD_CTRL_GFSK_MLD(base) ((XCVR_TX_GFSK_MOD_CTRL_REG(base) & XCVR_TX_GFSK_MOD_CTRL_GFSK_MLD_MASK) >> XCVR_TX_GFSK_MOD_CTRL_GFSK_MLD_SHIFT)
#define XCVR_BRD_TX_GFSK_MOD_CTRL_GFSK_MLD(base) (BME_UBFX32(&XCVR_TX_GFSK_MOD_CTRL_REG(base), XCVR_TX_GFSK_MOD_CTRL_GFSK_MLD_SHIFT, XCVR_TX_GFSK_MOD_CTRL_GFSK_MLD_WIDTH))

/*! @brief Set the GFSK_MLD field to a new value. */
#define XCVR_WR_TX_GFSK_MOD_CTRL_GFSK_MLD(base, value) (XCVR_RMW_TX_GFSK_MOD_CTRL(base, XCVR_TX_GFSK_MOD_CTRL_GFSK_MLD_MASK, XCVR_TX_GFSK_MOD_CTRL_GFSK_MLD(value)))
#define XCVR_BWR_TX_GFSK_MOD_CTRL_GFSK_MLD(base, value) (BME_BFI32(&XCVR_TX_GFSK_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_TX_GFSK_MOD_CTRL_GFSK_MLD_SHIFT), XCVR_TX_GFSK_MOD_CTRL_GFSK_MLD_SHIFT, XCVR_TX_GFSK_MOD_CTRL_GFSK_MLD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TX_GFSK_MOD_CTRL, field GFSK_SYMBOL_RATE[26:24] (RW)
 *
 * This register selects the GFSK Symbol Rate which together with the GFSK
 * Modulation Index determines the Peak Modulation frequency.The formula used for the
 * Peak Modulation is (Symbol Rate / (2 x 1/Modulation Index))
 *
 * Values:
 * - 0b000 - 50 kHz
 * - 0b001 - 100 kHz
 * - 0b010 - 200 kHz
 * - 0b011 - 1 MHz
 * - 0b100 - 2 MHz
 * - 0b101 - Reserved
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_GFSK_MOD_CTRL_GFSK_SYMBOL_RATE field. */
#define XCVR_RD_TX_GFSK_MOD_CTRL_GFSK_SYMBOL_RATE(base) ((XCVR_TX_GFSK_MOD_CTRL_REG(base) & XCVR_TX_GFSK_MOD_CTRL_GFSK_SYMBOL_RATE_MASK) >> XCVR_TX_GFSK_MOD_CTRL_GFSK_SYMBOL_RATE_SHIFT)
#define XCVR_BRD_TX_GFSK_MOD_CTRL_GFSK_SYMBOL_RATE(base) (BME_UBFX32(&XCVR_TX_GFSK_MOD_CTRL_REG(base), XCVR_TX_GFSK_MOD_CTRL_GFSK_SYMBOL_RATE_SHIFT, XCVR_TX_GFSK_MOD_CTRL_GFSK_SYMBOL_RATE_WIDTH))

/*! @brief Set the GFSK_SYMBOL_RATE field to a new value. */
#define XCVR_WR_TX_GFSK_MOD_CTRL_GFSK_SYMBOL_RATE(base, value) (XCVR_RMW_TX_GFSK_MOD_CTRL(base, XCVR_TX_GFSK_MOD_CTRL_GFSK_SYMBOL_RATE_MASK, XCVR_TX_GFSK_MOD_CTRL_GFSK_SYMBOL_RATE(value)))
#define XCVR_BWR_TX_GFSK_MOD_CTRL_GFSK_SYMBOL_RATE(base, value) (BME_BFI32(&XCVR_TX_GFSK_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_TX_GFSK_MOD_CTRL_GFSK_SYMBOL_RATE_SHIFT), XCVR_TX_GFSK_MOD_CTRL_GFSK_SYMBOL_RATE_SHIFT, XCVR_TX_GFSK_MOD_CTRL_GFSK_SYMBOL_RATE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TX_GFSK_MOD_CTRL, field GFSK_FLD[28] (RW)
 *
 * If this bit is set, the internal GFSK filter coefficients that are normally
 * derived from a lookup table based on the reference clock frequency, are
 * disabled, and the coefficients are instead derived from the GFSK_FILTER_COEFF_MANUAL1
 * and GFSK_FILTER_COEFF_MANUAL2 registers.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_GFSK_MOD_CTRL_GFSK_FLD field. */
#define XCVR_RD_TX_GFSK_MOD_CTRL_GFSK_FLD(base) ((XCVR_TX_GFSK_MOD_CTRL_REG(base) & XCVR_TX_GFSK_MOD_CTRL_GFSK_FLD_MASK) >> XCVR_TX_GFSK_MOD_CTRL_GFSK_FLD_SHIFT)
#define XCVR_BRD_TX_GFSK_MOD_CTRL_GFSK_FLD(base) (BME_UBFX32(&XCVR_TX_GFSK_MOD_CTRL_REG(base), XCVR_TX_GFSK_MOD_CTRL_GFSK_FLD_SHIFT, XCVR_TX_GFSK_MOD_CTRL_GFSK_FLD_WIDTH))

/*! @brief Set the GFSK_FLD field to a new value. */
#define XCVR_WR_TX_GFSK_MOD_CTRL_GFSK_FLD(base, value) (XCVR_RMW_TX_GFSK_MOD_CTRL(base, XCVR_TX_GFSK_MOD_CTRL_GFSK_FLD_MASK, XCVR_TX_GFSK_MOD_CTRL_GFSK_FLD(value)))
#define XCVR_BWR_TX_GFSK_MOD_CTRL_GFSK_FLD(base, value) (BME_BFI32(&XCVR_TX_GFSK_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_TX_GFSK_MOD_CTRL_GFSK_FLD_SHIFT), XCVR_TX_GFSK_MOD_CTRL_GFSK_FLD_SHIFT, XCVR_TX_GFSK_MOD_CTRL_GFSK_FLD_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TX_GFSK_COEFF2 - TX GFSK Filter Coefficients 2
 ******************************************************************************/

/*!
 * @brief XCVR_TX_GFSK_COEFF2 - TX GFSK Filter Coefficients 2 (RW)
 *
 * Reset value: 0xC0630401U
 *
 * The two registers TX_GFSK_COEFF1 and TX_GFSK_COEFF2 form a 64-bit little
 * endian register that is memory mapped internally as shown to override the GFSK
 * Filter Coefficients. In 64-bit they combine as
 * {TX_GFSK_COEFF2[31:0],TX_GFSK_COEFF1[31:0]} The resulting 64-bit value is GFSK Manual Filter Coefficient [63:0]
 */
/*!
 * @name Constants and macros for entire XCVR_TX_GFSK_COEFF2 register
 */
/*@{*/
#define XCVR_RD_TX_GFSK_COEFF2(base) (XCVR_TX_GFSK_COEFF2_REG(base))
#define XCVR_WR_TX_GFSK_COEFF2(base, value) (XCVR_TX_GFSK_COEFF2_REG(base) = (value))
#define XCVR_RMW_TX_GFSK_COEFF2(base, mask, value) (XCVR_WR_TX_GFSK_COEFF2(base, (XCVR_RD_TX_GFSK_COEFF2(base) & ~(mask)) | (value)))
#define XCVR_SET_TX_GFSK_COEFF2(base, value) (BME_OR32(&XCVR_TX_GFSK_COEFF2_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TX_GFSK_COEFF2(base, value) (BME_AND32(&XCVR_TX_GFSK_COEFF2_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TX_GFSK_COEFF2(base, value) (BME_XOR32(&XCVR_TX_GFSK_COEFF2_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * XCVR_TX_GFSK_COEFF1 - TX GFSK Filter Coefficients 1
 ******************************************************************************/

/*!
 * @brief XCVR_TX_GFSK_COEFF1 - TX GFSK Filter Coefficients 1 (RW)
 *
 * Reset value: 0xBB29960DU
 *
 * The two registers TX_GFSK_COEFF1 and TX_GFSK_COEFF2 form a 64-bit little
 * endian register that is memory mapped internally as shown to override the GFSK
 * Filter Coefficients. In 64-bit they combine as
 * {TX_GFSK_COEFF2[31:0],TX_GFSK_COEFF1[31:0]} The resulting 64-bit value is GFSK Manual Filter Coefficient [63:0]
 */
/*!
 * @name Constants and macros for entire XCVR_TX_GFSK_COEFF1 register
 */
/*@{*/
#define XCVR_RD_TX_GFSK_COEFF1(base) (XCVR_TX_GFSK_COEFF1_REG(base))
#define XCVR_WR_TX_GFSK_COEFF1(base, value) (XCVR_TX_GFSK_COEFF1_REG(base) = (value))
#define XCVR_RMW_TX_GFSK_COEFF1(base, mask, value) (XCVR_WR_TX_GFSK_COEFF1(base, (XCVR_RD_TX_GFSK_COEFF1(base) & ~(mask)) | (value)))
#define XCVR_SET_TX_GFSK_COEFF1(base, value) (BME_OR32(&XCVR_TX_GFSK_COEFF1_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TX_GFSK_COEFF1(base, value) (BME_AND32(&XCVR_TX_GFSK_COEFF1_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TX_GFSK_COEFF1(base, value) (BME_XOR32(&XCVR_TX_GFSK_COEFF1_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * XCVR_TX_FSK_MOD_SCALE - TX FSK Modulation Scale
 ******************************************************************************/

/*!
 * @brief XCVR_TX_FSK_MOD_SCALE - TX FSK Modulation Scale (RW)
 *
 * Reset value: 0x07FF1800U
 */
/*!
 * @name Constants and macros for entire XCVR_TX_FSK_MOD_SCALE register
 */
/*@{*/
#define XCVR_RD_TX_FSK_MOD_SCALE(base) (XCVR_TX_FSK_MOD_SCALE_REG(base))
#define XCVR_WR_TX_FSK_MOD_SCALE(base, value) (XCVR_TX_FSK_MOD_SCALE_REG(base) = (value))
#define XCVR_RMW_TX_FSK_MOD_SCALE(base, mask, value) (XCVR_WR_TX_FSK_MOD_SCALE(base, (XCVR_RD_TX_FSK_MOD_SCALE(base) & ~(mask)) | (value)))
#define XCVR_SET_TX_FSK_MOD_SCALE(base, value) (BME_OR32(&XCVR_TX_FSK_MOD_SCALE_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TX_FSK_MOD_SCALE(base, value) (BME_AND32(&XCVR_TX_FSK_MOD_SCALE_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TX_FSK_MOD_SCALE(base, value) (BME_XOR32(&XCVR_TX_FSK_MOD_SCALE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TX_FSK_MOD_SCALE bitfields
 */

/*!
 * @name Register XCVR_TX_FSK_MOD_SCALE, field FSK_MODULATION_SCALE_0[12:0] (RW)
 *
 * This register is used to provide the modulation level for a data 0 in
 * 802.15.4 Protocols. The signed 12 bit value that is represented by this register is
 * presented to the PLL as the Baseband Frequency Word. The frequency result for
 * this Modulation Scale will be the value of this register times the PLL Low Port
 * Modulator Frequency Resolution; a typical value for the Frequency Resolution
 * is 244.14 Hz. The reset value of this little endian register is 0x1800 which
 * is the 13-bit value of 1_1000_0000_0000 The two's complement of this reset
 * value is -2048 The range of signed values that this register supports is -4096 to
 * 4095
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_0 field. */
#define XCVR_RD_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_0(base) ((XCVR_TX_FSK_MOD_SCALE_REG(base) & XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_0_MASK) >> XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_0_SHIFT)
#define XCVR_BRD_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_0(base) (BME_UBFX32(&XCVR_TX_FSK_MOD_SCALE_REG(base), XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_0_SHIFT, XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_0_WIDTH))

/*! @brief Set the FSK_MODULATION_SCALE_0 field to a new value. */
#define XCVR_WR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_0(base, value) (XCVR_RMW_TX_FSK_MOD_SCALE(base, XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_0_MASK, XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_0(value)))
#define XCVR_BWR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_0(base, value) (BME_BFI32(&XCVR_TX_FSK_MOD_SCALE_REG(base), ((uint32_t)(value) << XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_0_SHIFT), XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_0_SHIFT, XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_0_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TX_FSK_MOD_SCALE, field FSK_MODULATION_SCALE_1[28:16] (RW)
 *
 * This register is used to provide the modulation level for a data 1 in
 * 802.15.4 Protocols. The signed 12 bit value that is represented by this register is
 * presented to the PLL as the Baseband Frequency Word. The frequency result for
 * this Modulation Scale will be the value of this register times the PLL Low Port
 * Modulator Frequency Resolution; a typical value for the Frequency Resolution
 * is 244.14 Hz. The reset value of this little endian register is 0x07FF which
 * is the 13-bit value of 0_0111_1111_1111 The two's complement of this reset
 * value is 2047 The range of signed values that this register supports is -4096 to
 * 4095
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_1 field. */
#define XCVR_RD_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_1(base) ((XCVR_TX_FSK_MOD_SCALE_REG(base) & XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_1_MASK) >> XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_1_SHIFT)
#define XCVR_BRD_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_1(base) (BME_UBFX32(&XCVR_TX_FSK_MOD_SCALE_REG(base), XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_1_SHIFT, XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_1_WIDTH))

/*! @brief Set the FSK_MODULATION_SCALE_1 field to a new value. */
#define XCVR_WR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_1(base, value) (XCVR_RMW_TX_FSK_MOD_SCALE(base, XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_1_MASK, XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_1(value)))
#define XCVR_BWR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_1(base, value) (BME_BFI32(&XCVR_TX_FSK_MOD_SCALE_REG(base), ((uint32_t)(value) << XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_1_SHIFT), XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_1_SHIFT, XCVR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_1_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TX_DFT_MOD_PAT - TX DFT Modulation Pattern
 ******************************************************************************/

/*!
 * @brief XCVR_TX_DFT_MOD_PAT - TX DFT Modulation Pattern (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_TX_DFT_MOD_PAT register
 */
/*@{*/
#define XCVR_RD_TX_DFT_MOD_PAT(base) (XCVR_TX_DFT_MOD_PAT_REG(base))
#define XCVR_WR_TX_DFT_MOD_PAT(base, value) (XCVR_TX_DFT_MOD_PAT_REG(base) = (value))
#define XCVR_RMW_TX_DFT_MOD_PAT(base, mask, value) (XCVR_WR_TX_DFT_MOD_PAT(base, (XCVR_RD_TX_DFT_MOD_PAT(base) & ~(mask)) | (value)))
#define XCVR_SET_TX_DFT_MOD_PAT(base, value) (BME_OR32(&XCVR_TX_DFT_MOD_PAT_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TX_DFT_MOD_PAT(base, value) (BME_AND32(&XCVR_TX_DFT_MOD_PAT_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TX_DFT_MOD_PAT(base, value) (BME_XOR32(&XCVR_TX_DFT_MOD_PAT_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * XCVR_TX_DFT_TONE_0_1 - TX DFT Tones 0 and 1
 ******************************************************************************/

/*!
 * @brief XCVR_TX_DFT_TONE_0_1 - TX DFT Tones 0 and 1 (RW)
 *
 * Reset value: 0x10000FFFU
 *
 * The DFT Tone Registers are used in DFT Tone modes to bypass the GFSK and FSK
 * Modulators and instead present the selected Tone to the PLL as a constant tone
 * modulation. The two's complement range of these little endian registers is
 * -4096 to 4095
 */
/*!
 * @name Constants and macros for entire XCVR_TX_DFT_TONE_0_1 register
 */
/*@{*/
#define XCVR_RD_TX_DFT_TONE_0_1(base) (XCVR_TX_DFT_TONE_0_1_REG(base))
#define XCVR_WR_TX_DFT_TONE_0_1(base, value) (XCVR_TX_DFT_TONE_0_1_REG(base) = (value))
#define XCVR_RMW_TX_DFT_TONE_0_1(base, mask, value) (XCVR_WR_TX_DFT_TONE_0_1(base, (XCVR_RD_TX_DFT_TONE_0_1(base) & ~(mask)) | (value)))
#define XCVR_SET_TX_DFT_TONE_0_1(base, value) (BME_OR32(&XCVR_TX_DFT_TONE_0_1_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TX_DFT_TONE_0_1(base, value) (BME_AND32(&XCVR_TX_DFT_TONE_0_1_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TX_DFT_TONE_0_1(base, value) (BME_XOR32(&XCVR_TX_DFT_TONE_0_1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TX_DFT_TONE_0_1 bitfields
 */

/*!
 * @name Register XCVR_TX_DFT_TONE_0_1, field DFT_TONE_1[12:0] (RW)
 *
 * This register is used to provide the modulation level in DFT Tone Modes. The
 * signed 12 bit value that is represented by this register is presented to the
 * PLL as the Baseband Frequency Word. The frequency result for this Tone will be
 * the value of this register times the PLL Low Port Modulator Frequency
 * Resolution; a typical value for the Frequency Resolution is 244.14 Hz.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_DFT_TONE_0_1_DFT_TONE_1 field. */
#define XCVR_RD_TX_DFT_TONE_0_1_DFT_TONE_1(base) ((XCVR_TX_DFT_TONE_0_1_REG(base) & XCVR_TX_DFT_TONE_0_1_DFT_TONE_1_MASK) >> XCVR_TX_DFT_TONE_0_1_DFT_TONE_1_SHIFT)
#define XCVR_BRD_TX_DFT_TONE_0_1_DFT_TONE_1(base) (BME_UBFX32(&XCVR_TX_DFT_TONE_0_1_REG(base), XCVR_TX_DFT_TONE_0_1_DFT_TONE_1_SHIFT, XCVR_TX_DFT_TONE_0_1_DFT_TONE_1_WIDTH))

/*! @brief Set the DFT_TONE_1 field to a new value. */
#define XCVR_WR_TX_DFT_TONE_0_1_DFT_TONE_1(base, value) (XCVR_RMW_TX_DFT_TONE_0_1(base, XCVR_TX_DFT_TONE_0_1_DFT_TONE_1_MASK, XCVR_TX_DFT_TONE_0_1_DFT_TONE_1(value)))
#define XCVR_BWR_TX_DFT_TONE_0_1_DFT_TONE_1(base, value) (BME_BFI32(&XCVR_TX_DFT_TONE_0_1_REG(base), ((uint32_t)(value) << XCVR_TX_DFT_TONE_0_1_DFT_TONE_1_SHIFT), XCVR_TX_DFT_TONE_0_1_DFT_TONE_1_SHIFT, XCVR_TX_DFT_TONE_0_1_DFT_TONE_1_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TX_DFT_TONE_0_1, field DFT_TONE_0[28:16] (RW)
 *
 * This register is used to provide the modulation level in DFT Tone Modes. The
 * signed 12 bit value that is represented by this register is presented to the
 * PLL as the Baseband Frequency Word. The frequency result for this Tone will be
 * the value of this register times the PLL Low Port Modulator Frequency
 * Resolution; a typical value for the Frequency Resolution is 244.14 Hz.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_DFT_TONE_0_1_DFT_TONE_0 field. */
#define XCVR_RD_TX_DFT_TONE_0_1_DFT_TONE_0(base) ((XCVR_TX_DFT_TONE_0_1_REG(base) & XCVR_TX_DFT_TONE_0_1_DFT_TONE_0_MASK) >> XCVR_TX_DFT_TONE_0_1_DFT_TONE_0_SHIFT)
#define XCVR_BRD_TX_DFT_TONE_0_1_DFT_TONE_0(base) (BME_UBFX32(&XCVR_TX_DFT_TONE_0_1_REG(base), XCVR_TX_DFT_TONE_0_1_DFT_TONE_0_SHIFT, XCVR_TX_DFT_TONE_0_1_DFT_TONE_0_WIDTH))

/*! @brief Set the DFT_TONE_0 field to a new value. */
#define XCVR_WR_TX_DFT_TONE_0_1_DFT_TONE_0(base, value) (XCVR_RMW_TX_DFT_TONE_0_1(base, XCVR_TX_DFT_TONE_0_1_DFT_TONE_0_MASK, XCVR_TX_DFT_TONE_0_1_DFT_TONE_0(value)))
#define XCVR_BWR_TX_DFT_TONE_0_1_DFT_TONE_0(base, value) (BME_BFI32(&XCVR_TX_DFT_TONE_0_1_REG(base), ((uint32_t)(value) << XCVR_TX_DFT_TONE_0_1_DFT_TONE_0_SHIFT), XCVR_TX_DFT_TONE_0_1_DFT_TONE_0_SHIFT, XCVR_TX_DFT_TONE_0_1_DFT_TONE_0_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TX_DFT_TONE_2_3 - TX DFT Tones 2 and 3
 ******************************************************************************/

/*!
 * @brief XCVR_TX_DFT_TONE_2_3 - TX DFT Tones 2 and 3 (RW)
 *
 * Reset value: 0x1E0001FFU
 *
 * The DFT Tone Registers are used in DFT Tone modes to bypass the GFSK and FSK
 * Modulators and instead present the selected Tone to the PLL as a constant tone
 * modulation. The two's complement range of these little endian registers is
 * -4096 to 4095
 */
/*!
 * @name Constants and macros for entire XCVR_TX_DFT_TONE_2_3 register
 */
/*@{*/
#define XCVR_RD_TX_DFT_TONE_2_3(base) (XCVR_TX_DFT_TONE_2_3_REG(base))
#define XCVR_WR_TX_DFT_TONE_2_3(base, value) (XCVR_TX_DFT_TONE_2_3_REG(base) = (value))
#define XCVR_RMW_TX_DFT_TONE_2_3(base, mask, value) (XCVR_WR_TX_DFT_TONE_2_3(base, (XCVR_RD_TX_DFT_TONE_2_3(base) & ~(mask)) | (value)))
#define XCVR_SET_TX_DFT_TONE_2_3(base, value) (BME_OR32(&XCVR_TX_DFT_TONE_2_3_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TX_DFT_TONE_2_3(base, value) (BME_AND32(&XCVR_TX_DFT_TONE_2_3_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TX_DFT_TONE_2_3(base, value) (BME_XOR32(&XCVR_TX_DFT_TONE_2_3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TX_DFT_TONE_2_3 bitfields
 */

/*!
 * @name Register XCVR_TX_DFT_TONE_2_3, field DFT_TONE_3[12:0] (RW)
 *
 * This register is used to provide the modulation level in DFT Tone Modes. The
 * signed 12 bit value that is represented by this register is presented to the
 * PLL as the Baseband Frequency Word. The frequency result for this Tone will be
 * the value of this register times the PLL Low Port Modulator Frequency
 * Resolution; a typical value for the Frequency Resolution is 244.14 Hz.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_DFT_TONE_2_3_DFT_TONE_3 field. */
#define XCVR_RD_TX_DFT_TONE_2_3_DFT_TONE_3(base) ((XCVR_TX_DFT_TONE_2_3_REG(base) & XCVR_TX_DFT_TONE_2_3_DFT_TONE_3_MASK) >> XCVR_TX_DFT_TONE_2_3_DFT_TONE_3_SHIFT)
#define XCVR_BRD_TX_DFT_TONE_2_3_DFT_TONE_3(base) (BME_UBFX32(&XCVR_TX_DFT_TONE_2_3_REG(base), XCVR_TX_DFT_TONE_2_3_DFT_TONE_3_SHIFT, XCVR_TX_DFT_TONE_2_3_DFT_TONE_3_WIDTH))

/*! @brief Set the DFT_TONE_3 field to a new value. */
#define XCVR_WR_TX_DFT_TONE_2_3_DFT_TONE_3(base, value) (XCVR_RMW_TX_DFT_TONE_2_3(base, XCVR_TX_DFT_TONE_2_3_DFT_TONE_3_MASK, XCVR_TX_DFT_TONE_2_3_DFT_TONE_3(value)))
#define XCVR_BWR_TX_DFT_TONE_2_3_DFT_TONE_3(base, value) (BME_BFI32(&XCVR_TX_DFT_TONE_2_3_REG(base), ((uint32_t)(value) << XCVR_TX_DFT_TONE_2_3_DFT_TONE_3_SHIFT), XCVR_TX_DFT_TONE_2_3_DFT_TONE_3_SHIFT, XCVR_TX_DFT_TONE_2_3_DFT_TONE_3_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TX_DFT_TONE_2_3, field DFT_TONE_2[28:16] (RW)
 *
 * This register is used to provide the modulation level in DFT Tone Modes. The
 * signed 12 bit value that is represented by this register is presented to the
 * PLL as the Baseband Frequency Word. The frequency result for this Tone will be
 * the value of this register times the PLL Low Port Modulator Frequency
 * Resolution; a typical value for the Frequency Resolution is 244.14 Hz.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_DFT_TONE_2_3_DFT_TONE_2 field. */
#define XCVR_RD_TX_DFT_TONE_2_3_DFT_TONE_2(base) ((XCVR_TX_DFT_TONE_2_3_REG(base) & XCVR_TX_DFT_TONE_2_3_DFT_TONE_2_MASK) >> XCVR_TX_DFT_TONE_2_3_DFT_TONE_2_SHIFT)
#define XCVR_BRD_TX_DFT_TONE_2_3_DFT_TONE_2(base) (BME_UBFX32(&XCVR_TX_DFT_TONE_2_3_REG(base), XCVR_TX_DFT_TONE_2_3_DFT_TONE_2_SHIFT, XCVR_TX_DFT_TONE_2_3_DFT_TONE_2_WIDTH))

/*! @brief Set the DFT_TONE_2 field to a new value. */
#define XCVR_WR_TX_DFT_TONE_2_3_DFT_TONE_2(base, value) (XCVR_RMW_TX_DFT_TONE_2_3(base, XCVR_TX_DFT_TONE_2_3_DFT_TONE_2_MASK, XCVR_TX_DFT_TONE_2_3_DFT_TONE_2(value)))
#define XCVR_BWR_TX_DFT_TONE_2_3_DFT_TONE_2(base, value) (BME_BFI32(&XCVR_TX_DFT_TONE_2_3_REG(base), ((uint32_t)(value) << XCVR_TX_DFT_TONE_2_3_DFT_TONE_2_SHIFT), XCVR_TX_DFT_TONE_2_3_DFT_TONE_2_SHIFT, XCVR_TX_DFT_TONE_2_3_DFT_TONE_2_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_MOD_OVRD - PLL Modulation Overrides
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_MOD_OVRD - PLL Modulation Overrides (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_MOD_OVRD register
 */
/*@{*/
#define XCVR_RD_PLL_MOD_OVRD(base) (XCVR_PLL_MOD_OVRD_REG(base))
#define XCVR_WR_PLL_MOD_OVRD(base, value) (XCVR_PLL_MOD_OVRD_REG(base) = (value))
#define XCVR_RMW_PLL_MOD_OVRD(base, mask, value) (XCVR_WR_PLL_MOD_OVRD(base, (XCVR_RD_PLL_MOD_OVRD(base) & ~(mask)) | (value)))
#define XCVR_SET_PLL_MOD_OVRD(base, value) (BME_OR32(&XCVR_PLL_MOD_OVRD_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PLL_MOD_OVRD(base, value) (BME_AND32(&XCVR_PLL_MOD_OVRD_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PLL_MOD_OVRD(base, value) (BME_XOR32(&XCVR_PLL_MOD_OVRD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_MOD_OVRD bitfields
 */

/*!
 * @name Register XCVR_PLL_MOD_OVRD, field MODULATION_WORD_MANUAL[12:0] (RW)
 *
 * If MOD_DIS is set, the signed 12 bit value that is represented by this
 * register is the Baseband Frequency Word.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_MOD_OVRD_MODULATION_WORD_MANUAL field. */
#define XCVR_RD_PLL_MOD_OVRD_MODULATION_WORD_MANUAL(base) ((XCVR_PLL_MOD_OVRD_REG(base) & XCVR_PLL_MOD_OVRD_MODULATION_WORD_MANUAL_MASK) >> XCVR_PLL_MOD_OVRD_MODULATION_WORD_MANUAL_SHIFT)
#define XCVR_BRD_PLL_MOD_OVRD_MODULATION_WORD_MANUAL(base) (BME_UBFX32(&XCVR_PLL_MOD_OVRD_REG(base), XCVR_PLL_MOD_OVRD_MODULATION_WORD_MANUAL_SHIFT, XCVR_PLL_MOD_OVRD_MODULATION_WORD_MANUAL_WIDTH))

/*! @brief Set the MODULATION_WORD_MANUAL field to a new value. */
#define XCVR_WR_PLL_MOD_OVRD_MODULATION_WORD_MANUAL(base, value) (XCVR_RMW_PLL_MOD_OVRD(base, XCVR_PLL_MOD_OVRD_MODULATION_WORD_MANUAL_MASK, XCVR_PLL_MOD_OVRD_MODULATION_WORD_MANUAL(value)))
#define XCVR_BWR_PLL_MOD_OVRD_MODULATION_WORD_MANUAL(base, value) (BME_BFI32(&XCVR_PLL_MOD_OVRD_REG(base), ((uint32_t)(value) << XCVR_PLL_MOD_OVRD_MODULATION_WORD_MANUAL_SHIFT), XCVR_PLL_MOD_OVRD_MODULATION_WORD_MANUAL_SHIFT, XCVR_PLL_MOD_OVRD_MODULATION_WORD_MANUAL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_MOD_OVRD, field MOD_DIS[15] (RW)
 *
 * If this bit is set, any modulation from the TX Digital is disabled and the
 * source of the Baseband Frequency Word is the MODULATION_WORD_MANUAL register.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_MOD_OVRD_MOD_DIS field. */
#define XCVR_RD_PLL_MOD_OVRD_MOD_DIS(base) ((XCVR_PLL_MOD_OVRD_REG(base) & XCVR_PLL_MOD_OVRD_MOD_DIS_MASK) >> XCVR_PLL_MOD_OVRD_MOD_DIS_SHIFT)
#define XCVR_BRD_PLL_MOD_OVRD_MOD_DIS(base) (BME_UBFX32(&XCVR_PLL_MOD_OVRD_REG(base), XCVR_PLL_MOD_OVRD_MOD_DIS_SHIFT, XCVR_PLL_MOD_OVRD_MOD_DIS_WIDTH))

/*! @brief Set the MOD_DIS field to a new value. */
#define XCVR_WR_PLL_MOD_OVRD_MOD_DIS(base, value) (XCVR_RMW_PLL_MOD_OVRD(base, XCVR_PLL_MOD_OVRD_MOD_DIS_MASK, XCVR_PLL_MOD_OVRD_MOD_DIS(value)))
#define XCVR_BWR_PLL_MOD_OVRD_MOD_DIS(base, value) (BME_BFI32(&XCVR_PLL_MOD_OVRD_REG(base), ((uint32_t)(value) << XCVR_PLL_MOD_OVRD_MOD_DIS_SHIFT), XCVR_PLL_MOD_OVRD_MOD_DIS_SHIFT, XCVR_PLL_MOD_OVRD_MOD_DIS_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_MOD_OVRD, field HPM_BANK_MANUAL[23:16] (RW)
 *
 * If HPM_BANK_DIS is set, this register is the value that is applied to the VCO
 * High Port Bank.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_MOD_OVRD_HPM_BANK_MANUAL field. */
#define XCVR_RD_PLL_MOD_OVRD_HPM_BANK_MANUAL(base) ((XCVR_PLL_MOD_OVRD_REG(base) & XCVR_PLL_MOD_OVRD_HPM_BANK_MANUAL_MASK) >> XCVR_PLL_MOD_OVRD_HPM_BANK_MANUAL_SHIFT)
#define XCVR_BRD_PLL_MOD_OVRD_HPM_BANK_MANUAL(base) (BME_UBFX32(&XCVR_PLL_MOD_OVRD_REG(base), XCVR_PLL_MOD_OVRD_HPM_BANK_MANUAL_SHIFT, XCVR_PLL_MOD_OVRD_HPM_BANK_MANUAL_WIDTH))

/*! @brief Set the HPM_BANK_MANUAL field to a new value. */
#define XCVR_WR_PLL_MOD_OVRD_HPM_BANK_MANUAL(base, value) (XCVR_RMW_PLL_MOD_OVRD(base, XCVR_PLL_MOD_OVRD_HPM_BANK_MANUAL_MASK, XCVR_PLL_MOD_OVRD_HPM_BANK_MANUAL(value)))
#define XCVR_BWR_PLL_MOD_OVRD_HPM_BANK_MANUAL(base, value) (BME_BFI32(&XCVR_PLL_MOD_OVRD_REG(base), ((uint32_t)(value) << XCVR_PLL_MOD_OVRD_HPM_BANK_MANUAL_SHIFT), XCVR_PLL_MOD_OVRD_HPM_BANK_MANUAL_SHIFT, XCVR_PLL_MOD_OVRD_HPM_BANK_MANUAL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_MOD_OVRD, field HPM_BANK_DIS[27] (RW)
 *
 * If this bit is set, the High Port Bank Modulation is disabled, and the High
 * Port Bank value applied to the VCO comes from the HPM_BANK_MANUAL register.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_MOD_OVRD_HPM_BANK_DIS field. */
#define XCVR_RD_PLL_MOD_OVRD_HPM_BANK_DIS(base) ((XCVR_PLL_MOD_OVRD_REG(base) & XCVR_PLL_MOD_OVRD_HPM_BANK_DIS_MASK) >> XCVR_PLL_MOD_OVRD_HPM_BANK_DIS_SHIFT)
#define XCVR_BRD_PLL_MOD_OVRD_HPM_BANK_DIS(base) (BME_UBFX32(&XCVR_PLL_MOD_OVRD_REG(base), XCVR_PLL_MOD_OVRD_HPM_BANK_DIS_SHIFT, XCVR_PLL_MOD_OVRD_HPM_BANK_DIS_WIDTH))

/*! @brief Set the HPM_BANK_DIS field to a new value. */
#define XCVR_WR_PLL_MOD_OVRD_HPM_BANK_DIS(base, value) (XCVR_RMW_PLL_MOD_OVRD(base, XCVR_PLL_MOD_OVRD_HPM_BANK_DIS_MASK, XCVR_PLL_MOD_OVRD_HPM_BANK_DIS(value)))
#define XCVR_BWR_PLL_MOD_OVRD_HPM_BANK_DIS(base, value) (BME_BFI32(&XCVR_PLL_MOD_OVRD_REG(base), ((uint32_t)(value) << XCVR_PLL_MOD_OVRD_HPM_BANK_DIS_SHIFT), XCVR_PLL_MOD_OVRD_HPM_BANK_DIS_SHIFT, XCVR_PLL_MOD_OVRD_HPM_BANK_DIS_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_MOD_OVRD, field HPM_LSB_MANUAL[29:28] (RW)
 *
 * If HPM_LSB_DIS is set, this register is the value that is applied to the VCO
 * High Port LSB.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_MOD_OVRD_HPM_LSB_MANUAL field. */
#define XCVR_RD_PLL_MOD_OVRD_HPM_LSB_MANUAL(base) ((XCVR_PLL_MOD_OVRD_REG(base) & XCVR_PLL_MOD_OVRD_HPM_LSB_MANUAL_MASK) >> XCVR_PLL_MOD_OVRD_HPM_LSB_MANUAL_SHIFT)
#define XCVR_BRD_PLL_MOD_OVRD_HPM_LSB_MANUAL(base) (BME_UBFX32(&XCVR_PLL_MOD_OVRD_REG(base), XCVR_PLL_MOD_OVRD_HPM_LSB_MANUAL_SHIFT, XCVR_PLL_MOD_OVRD_HPM_LSB_MANUAL_WIDTH))

/*! @brief Set the HPM_LSB_MANUAL field to a new value. */
#define XCVR_WR_PLL_MOD_OVRD_HPM_LSB_MANUAL(base, value) (XCVR_RMW_PLL_MOD_OVRD(base, XCVR_PLL_MOD_OVRD_HPM_LSB_MANUAL_MASK, XCVR_PLL_MOD_OVRD_HPM_LSB_MANUAL(value)))
#define XCVR_BWR_PLL_MOD_OVRD_HPM_LSB_MANUAL(base, value) (BME_BFI32(&XCVR_PLL_MOD_OVRD_REG(base), ((uint32_t)(value) << XCVR_PLL_MOD_OVRD_HPM_LSB_MANUAL_SHIFT), XCVR_PLL_MOD_OVRD_HPM_LSB_MANUAL_SHIFT, XCVR_PLL_MOD_OVRD_HPM_LSB_MANUAL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_MOD_OVRD, field HPM_LSB_DIS[31] (RW)
 *
 * If this bit is set, the High Port Sigma Delta Modulator output is disabled,
 * and the High Port LSB value applied to the VCO comes from the HPM_LSB_MANUAL
 * register.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_MOD_OVRD_HPM_LSB_DIS field. */
#define XCVR_RD_PLL_MOD_OVRD_HPM_LSB_DIS(base) ((XCVR_PLL_MOD_OVRD_REG(base) & XCVR_PLL_MOD_OVRD_HPM_LSB_DIS_MASK) >> XCVR_PLL_MOD_OVRD_HPM_LSB_DIS_SHIFT)
#define XCVR_BRD_PLL_MOD_OVRD_HPM_LSB_DIS(base) (BME_UBFX32(&XCVR_PLL_MOD_OVRD_REG(base), XCVR_PLL_MOD_OVRD_HPM_LSB_DIS_SHIFT, XCVR_PLL_MOD_OVRD_HPM_LSB_DIS_WIDTH))

/*! @brief Set the HPM_LSB_DIS field to a new value. */
#define XCVR_WR_PLL_MOD_OVRD_HPM_LSB_DIS(base, value) (XCVR_RMW_PLL_MOD_OVRD(base, XCVR_PLL_MOD_OVRD_HPM_LSB_DIS_MASK, XCVR_PLL_MOD_OVRD_HPM_LSB_DIS(value)))
#define XCVR_BWR_PLL_MOD_OVRD_HPM_LSB_DIS(base, value) (BME_BFI32(&XCVR_PLL_MOD_OVRD_REG(base), ((uint32_t)(value) << XCVR_PLL_MOD_OVRD_HPM_LSB_DIS_SHIFT), XCVR_PLL_MOD_OVRD_HPM_LSB_DIS_SHIFT, XCVR_PLL_MOD_OVRD_HPM_LSB_DIS_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_CHAN_MAP - PLL Channel Mapping
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_CHAN_MAP - PLL Channel Mapping (RW)
 *
 * Reset value: 0x00000200U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_CHAN_MAP register
 */
/*@{*/
#define XCVR_RD_PLL_CHAN_MAP(base) (XCVR_PLL_CHAN_MAP_REG(base))
#define XCVR_WR_PLL_CHAN_MAP(base, value) (XCVR_PLL_CHAN_MAP_REG(base) = (value))
#define XCVR_RMW_PLL_CHAN_MAP(base, mask, value) (XCVR_WR_PLL_CHAN_MAP(base, (XCVR_RD_PLL_CHAN_MAP(base) & ~(mask)) | (value)))
#define XCVR_SET_PLL_CHAN_MAP(base, value) (BME_OR32(&XCVR_PLL_CHAN_MAP_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PLL_CHAN_MAP(base, value) (BME_AND32(&XCVR_PLL_CHAN_MAP_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PLL_CHAN_MAP(base, value) (BME_XOR32(&XCVR_PLL_CHAN_MAP_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_CHAN_MAP bitfields
 */

/*!
 * @name Register XCVR_PLL_CHAN_MAP, field CHANNEL_NUM[6:0] (RW)
 *
 * When this register is active, it can be used to directly select a Protocol
 * specific Channel Number, which is mapped internally to the correct Radio Carrier
 * Frequency for PLL tuning. The internal mapping is detailed in the table
 * below. This register is active when BOC or ZOC are set along with their
 * corresponding Radio Protocols, and this register is also active in the 128 Channel FSK
 * and GFSK protocols. The Radio Carrier Frequency in the 128 Channel FSK and GFSK
 * protocols can be calculated using the formula below: Radio Carrier Frequency =
 * (Channel Number + 2360) x 1 MHz The Radio Channel Frequency can also be
 * selected by setting the SDM_MAP_DIS bit in the PLL_LP_SDM_CTRL1 register along with
 * the LPM_INTG, LPM_NUM, and LPM_DENOM registers to get a frequency that equals
 * ((Reference Clock Frequency x 2) x (LPM_INTG + (LPM_NUM / LPM_DENOM)) This
 * table shows the internal mapping by Protocol of the Channel Numbers to the Radio
 * Carrier Frequency (MHz). Channel Number 000 BLE 001 BLE in MBAN 010 BLE
 * Overlap MBAN 100 Zigbee 101 802.15.4j 0 2402 2360 2402 2400 2363 1 2404 2361 2404
 * 2400 2368 2 2406 2362 2406 2400 2373 3 2408 2363 2408 2400 2378 4 2410 2364
 * 2410 2400 2383 5 2412 2365 2412 2400 2388 6 2414 2366 2414 2400 2393 7 2416 2367
 * 2416 2400 2367 8 2418 2368 2418 2400 2372 9 2420 2369 2420 2400 2377 10 2422
 * 2370 2422 2400 2382 11 2424 2371 2424 2405 2387 12 2426 2372 2426 2410 2392 13
 * 2428 2373 2428 2415 2397 14 2430 2374 2430 2420 2395 15 2432 2375 2432 2425
 * 2399 16 2434 2376 2434 2430 2399 17 2436 2377 2436 2435 2399 18 2438 2378 2438
 * 2440 2399 19 2440 2379 2440 2445 2399 20 2442 2380 2442 2450 2399 21 2444 2381
 * 2444 2455 2399 22 2446 2382 2446 2460 2399 23 2448 2383 2448 2465 2399 24 2450
 * 2384 2450 2470 2399 25 2452 2385 2452 2475 2399 26 2454 2386 2454 2480 2399
 * 27 2456 2387 2456 2400 2399 28 2458 2388 2458 2400 2399 29 2460 2389 2460 2400
 * 2399 30 2462 2390 2390 2400 2399 31 2464 2391 2391 2400 2399 32 2466 2392 2392
 * 2400 2399 33 2468 2393 2393 2400 2399 34 2470 2394 2394 2400 2399 35 2472
 * 2395 2395 2400 2399 36 2474 2396 2396 2400 2399 37 2476 2397 2397 2400 2399 38
 * 2478 2398 2398 2400 2399 39 2480 2399 2480 or 2399 * 2400 2399 Default 2400 2399
 * 2399 2400 2399 * The BLE MBAN Channel Remap bit, BMR, controls the frequency
 * mapping in this case.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CHAN_MAP_CHANNEL_NUM field. */
#define XCVR_RD_PLL_CHAN_MAP_CHANNEL_NUM(base) ((XCVR_PLL_CHAN_MAP_REG(base) & XCVR_PLL_CHAN_MAP_CHANNEL_NUM_MASK) >> XCVR_PLL_CHAN_MAP_CHANNEL_NUM_SHIFT)
#define XCVR_BRD_PLL_CHAN_MAP_CHANNEL_NUM(base) (BME_UBFX32(&XCVR_PLL_CHAN_MAP_REG(base), XCVR_PLL_CHAN_MAP_CHANNEL_NUM_SHIFT, XCVR_PLL_CHAN_MAP_CHANNEL_NUM_WIDTH))

/*! @brief Set the CHANNEL_NUM field to a new value. */
#define XCVR_WR_PLL_CHAN_MAP_CHANNEL_NUM(base, value) (XCVR_RMW_PLL_CHAN_MAP(base, XCVR_PLL_CHAN_MAP_CHANNEL_NUM_MASK, XCVR_PLL_CHAN_MAP_CHANNEL_NUM(value)))
#define XCVR_BWR_PLL_CHAN_MAP_CHANNEL_NUM(base, value) (BME_BFI32(&XCVR_PLL_CHAN_MAP_REG(base), ((uint32_t)(value) << XCVR_PLL_CHAN_MAP_CHANNEL_NUM_SHIFT), XCVR_PLL_CHAN_MAP_CHANNEL_NUM_SHIFT, XCVR_PLL_CHAN_MAP_CHANNEL_NUM_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CHAN_MAP, field BOC[8] (RW)
 *
 * This bit controls the source of the BLE channel selection.
 *
 * Values:
 * - 0b0 - BLE channel number comes from the BLE Link Layer
 * - 0b1 - BLE channel number comes from the CHANNEL_NUM register
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CHAN_MAP_BOC field. */
#define XCVR_RD_PLL_CHAN_MAP_BOC(base) ((XCVR_PLL_CHAN_MAP_REG(base) & XCVR_PLL_CHAN_MAP_BOC_MASK) >> XCVR_PLL_CHAN_MAP_BOC_SHIFT)
#define XCVR_BRD_PLL_CHAN_MAP_BOC(base) (BME_UBFX32(&XCVR_PLL_CHAN_MAP_REG(base), XCVR_PLL_CHAN_MAP_BOC_SHIFT, XCVR_PLL_CHAN_MAP_BOC_WIDTH))

/*! @brief Set the BOC field to a new value. */
#define XCVR_WR_PLL_CHAN_MAP_BOC(base, value) (XCVR_RMW_PLL_CHAN_MAP(base, XCVR_PLL_CHAN_MAP_BOC_MASK, XCVR_PLL_CHAN_MAP_BOC(value)))
#define XCVR_BWR_PLL_CHAN_MAP_BOC(base, value) (BME_BFI32(&XCVR_PLL_CHAN_MAP_REG(base), ((uint32_t)(value) << XCVR_PLL_CHAN_MAP_BOC_SHIFT), XCVR_PLL_CHAN_MAP_BOC_SHIFT, XCVR_PLL_CHAN_MAP_BOC_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CHAN_MAP, field BMR[9] (RW)
 *
 * This bit controls the mapping of BLE channel 39 in Radio Protocol 2, BLE
 * overlap MBAN mode.
 *
 * Values:
 * - 0b0 - BLE channel 39 is mapped to BLE channel 39, 2.480 GHz
 * - 0b1 - BLE channel 39 is mapped to MBAN channel 39, 2.399 GHz
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CHAN_MAP_BMR field. */
#define XCVR_RD_PLL_CHAN_MAP_BMR(base) ((XCVR_PLL_CHAN_MAP_REG(base) & XCVR_PLL_CHAN_MAP_BMR_MASK) >> XCVR_PLL_CHAN_MAP_BMR_SHIFT)
#define XCVR_BRD_PLL_CHAN_MAP_BMR(base) (BME_UBFX32(&XCVR_PLL_CHAN_MAP_REG(base), XCVR_PLL_CHAN_MAP_BMR_SHIFT, XCVR_PLL_CHAN_MAP_BMR_WIDTH))

/*! @brief Set the BMR field to a new value. */
#define XCVR_WR_PLL_CHAN_MAP_BMR(base, value) (XCVR_RMW_PLL_CHAN_MAP(base, XCVR_PLL_CHAN_MAP_BMR_MASK, XCVR_PLL_CHAN_MAP_BMR(value)))
#define XCVR_BWR_PLL_CHAN_MAP_BMR(base, value) (BME_BFI32(&XCVR_PLL_CHAN_MAP_REG(base), ((uint32_t)(value) << XCVR_PLL_CHAN_MAP_BMR_SHIFT), XCVR_PLL_CHAN_MAP_BMR_SHIFT, XCVR_PLL_CHAN_MAP_BMR_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CHAN_MAP, field ZOC[10] (RW)
 *
 * This bit controls the source of the Zigbee channel selection.
 *
 * Values:
 * - 0b0 - Zigbee channel number comes from the 802.15.4 Link Layer.
 * - 0b1 - Zigbee channel number comes from the CHANNEL_NUM register
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CHAN_MAP_ZOC field. */
#define XCVR_RD_PLL_CHAN_MAP_ZOC(base) ((XCVR_PLL_CHAN_MAP_REG(base) & XCVR_PLL_CHAN_MAP_ZOC_MASK) >> XCVR_PLL_CHAN_MAP_ZOC_SHIFT)
#define XCVR_BRD_PLL_CHAN_MAP_ZOC(base) (BME_UBFX32(&XCVR_PLL_CHAN_MAP_REG(base), XCVR_PLL_CHAN_MAP_ZOC_SHIFT, XCVR_PLL_CHAN_MAP_ZOC_WIDTH))

/*! @brief Set the ZOC field to a new value. */
#define XCVR_WR_PLL_CHAN_MAP_ZOC(base, value) (XCVR_RMW_PLL_CHAN_MAP(base, XCVR_PLL_CHAN_MAP_ZOC_MASK, XCVR_PLL_CHAN_MAP_ZOC(value)))
#define XCVR_BWR_PLL_CHAN_MAP_ZOC(base, value) (BME_BFI32(&XCVR_PLL_CHAN_MAP_REG(base), ((uint32_t)(value) << XCVR_PLL_CHAN_MAP_ZOC_SHIFT), XCVR_PLL_CHAN_MAP_ZOC_SHIFT, XCVR_PLL_CHAN_MAP_ZOC_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_LOCK_DETECT - PLL Lock Detect
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_LOCK_DETECT - PLL Lock Detect (RW)
 *
 * Reset value: 0x00202600U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_LOCK_DETECT register
 */
/*@{*/
#define XCVR_RD_PLL_LOCK_DETECT(base) (XCVR_PLL_LOCK_DETECT_REG(base))
#define XCVR_WR_PLL_LOCK_DETECT(base, value) (XCVR_PLL_LOCK_DETECT_REG(base) = (value))
#define XCVR_RMW_PLL_LOCK_DETECT(base, mask, value) (XCVR_WR_PLL_LOCK_DETECT(base, (XCVR_RD_PLL_LOCK_DETECT(base) & ~(mask)) | (value)))
#define XCVR_SET_PLL_LOCK_DETECT(base, value) (BME_OR32(&XCVR_PLL_LOCK_DETECT_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PLL_LOCK_DETECT(base, value) (BME_AND32(&XCVR_PLL_LOCK_DETECT_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PLL_LOCK_DETECT(base, value) (BME_XOR32(&XCVR_PLL_LOCK_DETECT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_LOCK_DETECT bitfields
 */

/*!
 * @name Register XCVR_PLL_LOCK_DETECT, field CT_FAIL[0] (RO)
 *
 * If the Coarse Tune Calibration has completed and the best count difference is
 * out of the range selected by CTUNE_LDF_LEV, then this bit will be set.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LOCK_DETECT_CT_FAIL field. */
#define XCVR_RD_PLL_LOCK_DETECT_CT_FAIL(base) ((XCVR_PLL_LOCK_DETECT_REG(base) & XCVR_PLL_LOCK_DETECT_CT_FAIL_MASK) >> XCVR_PLL_LOCK_DETECT_CT_FAIL_SHIFT)
#define XCVR_BRD_PLL_LOCK_DETECT_CT_FAIL(base) (BME_UBFX32(&XCVR_PLL_LOCK_DETECT_REG(base), XCVR_PLL_LOCK_DETECT_CT_FAIL_SHIFT, XCVR_PLL_LOCK_DETECT_CT_FAIL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LOCK_DETECT, field CTFF[1] (W1C)
 *
 * This bit is set when CT_FAIL is first set, and this bit is cleared by writing
 * a 1 to it.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LOCK_DETECT_CTFF field. */
#define XCVR_RD_PLL_LOCK_DETECT_CTFF(base) ((XCVR_PLL_LOCK_DETECT_REG(base) & XCVR_PLL_LOCK_DETECT_CTFF_MASK) >> XCVR_PLL_LOCK_DETECT_CTFF_SHIFT)
#define XCVR_BRD_PLL_LOCK_DETECT_CTFF(base) (BME_UBFX32(&XCVR_PLL_LOCK_DETECT_REG(base), XCVR_PLL_LOCK_DETECT_CTFF_SHIFT, XCVR_PLL_LOCK_DETECT_CTFF_WIDTH))

/*! @brief Set the CTFF field to a new value. */
#define XCVR_WR_PLL_LOCK_DETECT_CTFF(base, value) (XCVR_RMW_PLL_LOCK_DETECT(base, (XCVR_PLL_LOCK_DETECT_CTFF_MASK | XCVR_PLL_LOCK_DETECT_CSFF_MASK | XCVR_PLL_LOCK_DETECT_FTFF_MASK | XCVR_PLL_LOCK_DETECT_TAFF_MASK), XCVR_PLL_LOCK_DETECT_CTFF(value)))
#define XCVR_BWR_PLL_LOCK_DETECT_CTFF(base, value) (BME_BFI32(&XCVR_PLL_LOCK_DETECT_REG(base), ((uint32_t)(value) << XCVR_PLL_LOCK_DETECT_CTFF_SHIFT), XCVR_PLL_LOCK_DETECT_CTFF_SHIFT, XCVR_PLL_LOCK_DETECT_CTFF_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LOCK_DETECT, field CS_FAIL[2] (RO)
 *
 * This bit shows the real-time status of the Cycle Slip State Machine Interrupt
 * which is configured using the control bits in the PLL_HPM_CAL1 and
 * PLL_HPM_CAL2 registers.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LOCK_DETECT_CS_FAIL field. */
#define XCVR_RD_PLL_LOCK_DETECT_CS_FAIL(base) ((XCVR_PLL_LOCK_DETECT_REG(base) & XCVR_PLL_LOCK_DETECT_CS_FAIL_MASK) >> XCVR_PLL_LOCK_DETECT_CS_FAIL_SHIFT)
#define XCVR_BRD_PLL_LOCK_DETECT_CS_FAIL(base) (BME_UBFX32(&XCVR_PLL_LOCK_DETECT_REG(base), XCVR_PLL_LOCK_DETECT_CS_FAIL_SHIFT, XCVR_PLL_LOCK_DETECT_CS_FAIL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LOCK_DETECT, field CSFF[3] (W1C)
 *
 * This bit is set when CS_FAIL is first set, and this bit is cleared by writing
 * a 1 to it.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LOCK_DETECT_CSFF field. */
#define XCVR_RD_PLL_LOCK_DETECT_CSFF(base) ((XCVR_PLL_LOCK_DETECT_REG(base) & XCVR_PLL_LOCK_DETECT_CSFF_MASK) >> XCVR_PLL_LOCK_DETECT_CSFF_SHIFT)
#define XCVR_BRD_PLL_LOCK_DETECT_CSFF(base) (BME_UBFX32(&XCVR_PLL_LOCK_DETECT_REG(base), XCVR_PLL_LOCK_DETECT_CSFF_SHIFT, XCVR_PLL_LOCK_DETECT_CSFF_WIDTH))

/*! @brief Set the CSFF field to a new value. */
#define XCVR_WR_PLL_LOCK_DETECT_CSFF(base, value) (XCVR_RMW_PLL_LOCK_DETECT(base, (XCVR_PLL_LOCK_DETECT_CSFF_MASK | XCVR_PLL_LOCK_DETECT_CTFF_MASK | XCVR_PLL_LOCK_DETECT_FTFF_MASK | XCVR_PLL_LOCK_DETECT_TAFF_MASK), XCVR_PLL_LOCK_DETECT_CSFF(value)))
#define XCVR_BWR_PLL_LOCK_DETECT_CSFF(base, value) (BME_BFI32(&XCVR_PLL_LOCK_DETECT_REG(base), ((uint32_t)(value) << XCVR_PLL_LOCK_DETECT_CSFF_SHIFT), XCVR_PLL_LOCK_DETECT_CSFF_SHIFT, XCVR_PLL_LOCK_DETECT_CSFF_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LOCK_DETECT, field FT_FAIL[4] (RO)
 *
 * If the Frequency Target Count has completed and the count was out of the
 * range selected by FTW_TX or FTW_RX, then this bit will be set.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LOCK_DETECT_FT_FAIL field. */
#define XCVR_RD_PLL_LOCK_DETECT_FT_FAIL(base) ((XCVR_PLL_LOCK_DETECT_REG(base) & XCVR_PLL_LOCK_DETECT_FT_FAIL_MASK) >> XCVR_PLL_LOCK_DETECT_FT_FAIL_SHIFT)
#define XCVR_BRD_PLL_LOCK_DETECT_FT_FAIL(base) (BME_UBFX32(&XCVR_PLL_LOCK_DETECT_REG(base), XCVR_PLL_LOCK_DETECT_FT_FAIL_SHIFT, XCVR_PLL_LOCK_DETECT_FT_FAIL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LOCK_DETECT, field FTFF[5] (W1C)
 *
 * This bit is set when FT_FAIL is first set, and this bit is cleared by writing
 * a 1 to it.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LOCK_DETECT_FTFF field. */
#define XCVR_RD_PLL_LOCK_DETECT_FTFF(base) ((XCVR_PLL_LOCK_DETECT_REG(base) & XCVR_PLL_LOCK_DETECT_FTFF_MASK) >> XCVR_PLL_LOCK_DETECT_FTFF_SHIFT)
#define XCVR_BRD_PLL_LOCK_DETECT_FTFF(base) (BME_UBFX32(&XCVR_PLL_LOCK_DETECT_REG(base), XCVR_PLL_LOCK_DETECT_FTFF_SHIFT, XCVR_PLL_LOCK_DETECT_FTFF_WIDTH))

/*! @brief Set the FTFF field to a new value. */
#define XCVR_WR_PLL_LOCK_DETECT_FTFF(base, value) (XCVR_RMW_PLL_LOCK_DETECT(base, (XCVR_PLL_LOCK_DETECT_FTFF_MASK | XCVR_PLL_LOCK_DETECT_CTFF_MASK | XCVR_PLL_LOCK_DETECT_CSFF_MASK | XCVR_PLL_LOCK_DETECT_TAFF_MASK), XCVR_PLL_LOCK_DETECT_FTFF(value)))
#define XCVR_BWR_PLL_LOCK_DETECT_FTFF(base, value) (BME_BFI32(&XCVR_PLL_LOCK_DETECT_REG(base), ((uint32_t)(value) << XCVR_PLL_LOCK_DETECT_FTFF_SHIFT), XCVR_PLL_LOCK_DETECT_FTFF_SHIFT, XCVR_PLL_LOCK_DETECT_FTFF_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LOCK_DETECT, field TAFF[7] (W1C)
 *
 * This bit is set if the TSM Sequence Aborts, and this bit is cleared by
 * writing a 1 to it.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LOCK_DETECT_TAFF field. */
#define XCVR_RD_PLL_LOCK_DETECT_TAFF(base) ((XCVR_PLL_LOCK_DETECT_REG(base) & XCVR_PLL_LOCK_DETECT_TAFF_MASK) >> XCVR_PLL_LOCK_DETECT_TAFF_SHIFT)
#define XCVR_BRD_PLL_LOCK_DETECT_TAFF(base) (BME_UBFX32(&XCVR_PLL_LOCK_DETECT_REG(base), XCVR_PLL_LOCK_DETECT_TAFF_SHIFT, XCVR_PLL_LOCK_DETECT_TAFF_WIDTH))

/*! @brief Set the TAFF field to a new value. */
#define XCVR_WR_PLL_LOCK_DETECT_TAFF(base, value) (XCVR_RMW_PLL_LOCK_DETECT(base, (XCVR_PLL_LOCK_DETECT_TAFF_MASK | XCVR_PLL_LOCK_DETECT_CTFF_MASK | XCVR_PLL_LOCK_DETECT_CSFF_MASK | XCVR_PLL_LOCK_DETECT_FTFF_MASK), XCVR_PLL_LOCK_DETECT_TAFF(value)))
#define XCVR_BWR_PLL_LOCK_DETECT_TAFF(base, value) (BME_BFI32(&XCVR_PLL_LOCK_DETECT_REG(base), ((uint32_t)(value) << XCVR_PLL_LOCK_DETECT_TAFF_SHIFT), XCVR_PLL_LOCK_DETECT_TAFF_SHIFT, XCVR_PLL_LOCK_DETECT_TAFF_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LOCK_DETECT, field CTUNE_LDF_LEV[11:8] (RW)
 *
 * The CT_FAIL and CTFF bits will be set after Coarse Tune Calibration completes
 * if the absolute value of the Coarse Tune best count difference
 * (CTUNE_BEST_DIFF in the PLL_CTUNE_RESULTS register) is greater than this register value.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LOCK_DETECT_CTUNE_LDF_LEV field. */
#define XCVR_RD_PLL_LOCK_DETECT_CTUNE_LDF_LEV(base) ((XCVR_PLL_LOCK_DETECT_REG(base) & XCVR_PLL_LOCK_DETECT_CTUNE_LDF_LEV_MASK) >> XCVR_PLL_LOCK_DETECT_CTUNE_LDF_LEV_SHIFT)
#define XCVR_BRD_PLL_LOCK_DETECT_CTUNE_LDF_LEV(base) (BME_UBFX32(&XCVR_PLL_LOCK_DETECT_REG(base), XCVR_PLL_LOCK_DETECT_CTUNE_LDF_LEV_SHIFT, XCVR_PLL_LOCK_DETECT_CTUNE_LDF_LEV_WIDTH))

/*! @brief Set the CTUNE_LDF_LEV field to a new value. */
#define XCVR_WR_PLL_LOCK_DETECT_CTUNE_LDF_LEV(base, value) (XCVR_RMW_PLL_LOCK_DETECT(base, (XCVR_PLL_LOCK_DETECT_CTUNE_LDF_LEV_MASK | XCVR_PLL_LOCK_DETECT_CTFF_MASK | XCVR_PLL_LOCK_DETECT_CSFF_MASK | XCVR_PLL_LOCK_DETECT_FTFF_MASK | XCVR_PLL_LOCK_DETECT_TAFF_MASK), XCVR_PLL_LOCK_DETECT_CTUNE_LDF_LEV(value)))
#define XCVR_BWR_PLL_LOCK_DETECT_CTUNE_LDF_LEV(base, value) (BME_BFI32(&XCVR_PLL_LOCK_DETECT_REG(base), ((uint32_t)(value) << XCVR_PLL_LOCK_DETECT_CTUNE_LDF_LEV_SHIFT), XCVR_PLL_LOCK_DETECT_CTUNE_LDF_LEV_SHIFT, XCVR_PLL_LOCK_DETECT_CTUNE_LDF_LEV_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LOCK_DETECT, field FTF_RX_THRSH[17:12] (RW)
 *
 * In Radio Receive Mode, the FT_FAIL and FTFF bits will be set after the
 * Frequency Target Count completes if the absolute value of the count difference from
 * the frequency target count is greater than this register value.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LOCK_DETECT_FTF_RX_THRSH field. */
#define XCVR_RD_PLL_LOCK_DETECT_FTF_RX_THRSH(base) ((XCVR_PLL_LOCK_DETECT_REG(base) & XCVR_PLL_LOCK_DETECT_FTF_RX_THRSH_MASK) >> XCVR_PLL_LOCK_DETECT_FTF_RX_THRSH_SHIFT)
#define XCVR_BRD_PLL_LOCK_DETECT_FTF_RX_THRSH(base) (BME_UBFX32(&XCVR_PLL_LOCK_DETECT_REG(base), XCVR_PLL_LOCK_DETECT_FTF_RX_THRSH_SHIFT, XCVR_PLL_LOCK_DETECT_FTF_RX_THRSH_WIDTH))

/*! @brief Set the FTF_RX_THRSH field to a new value. */
#define XCVR_WR_PLL_LOCK_DETECT_FTF_RX_THRSH(base, value) (XCVR_RMW_PLL_LOCK_DETECT(base, (XCVR_PLL_LOCK_DETECT_FTF_RX_THRSH_MASK | XCVR_PLL_LOCK_DETECT_CTFF_MASK | XCVR_PLL_LOCK_DETECT_CSFF_MASK | XCVR_PLL_LOCK_DETECT_FTFF_MASK | XCVR_PLL_LOCK_DETECT_TAFF_MASK), XCVR_PLL_LOCK_DETECT_FTF_RX_THRSH(value)))
#define XCVR_BWR_PLL_LOCK_DETECT_FTF_RX_THRSH(base, value) (BME_BFI32(&XCVR_PLL_LOCK_DETECT_REG(base), ((uint32_t)(value) << XCVR_PLL_LOCK_DETECT_FTF_RX_THRSH_SHIFT), XCVR_PLL_LOCK_DETECT_FTF_RX_THRSH_SHIFT, XCVR_PLL_LOCK_DETECT_FTF_RX_THRSH_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LOCK_DETECT, field FTW_RX[19] (RW)
 *
 * In Radio Receive Mode, this bit selects the length of time to count for the
 * estimation of PLL lock frequency, which is compared with the Frequency Target
 * Window, set by FTF_RX.
 *
 * Values:
 * - 0b0 - 4 us
 * - 0b1 - 8 us
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LOCK_DETECT_FTW_RX field. */
#define XCVR_RD_PLL_LOCK_DETECT_FTW_RX(base) ((XCVR_PLL_LOCK_DETECT_REG(base) & XCVR_PLL_LOCK_DETECT_FTW_RX_MASK) >> XCVR_PLL_LOCK_DETECT_FTW_RX_SHIFT)
#define XCVR_BRD_PLL_LOCK_DETECT_FTW_RX(base) (BME_UBFX32(&XCVR_PLL_LOCK_DETECT_REG(base), XCVR_PLL_LOCK_DETECT_FTW_RX_SHIFT, XCVR_PLL_LOCK_DETECT_FTW_RX_WIDTH))

/*! @brief Set the FTW_RX field to a new value. */
#define XCVR_WR_PLL_LOCK_DETECT_FTW_RX(base, value) (XCVR_RMW_PLL_LOCK_DETECT(base, (XCVR_PLL_LOCK_DETECT_FTW_RX_MASK | XCVR_PLL_LOCK_DETECT_CTFF_MASK | XCVR_PLL_LOCK_DETECT_CSFF_MASK | XCVR_PLL_LOCK_DETECT_FTFF_MASK | XCVR_PLL_LOCK_DETECT_TAFF_MASK), XCVR_PLL_LOCK_DETECT_FTW_RX(value)))
#define XCVR_BWR_PLL_LOCK_DETECT_FTW_RX(base, value) (BME_BFI32(&XCVR_PLL_LOCK_DETECT_REG(base), ((uint32_t)(value) << XCVR_PLL_LOCK_DETECT_FTW_RX_SHIFT), XCVR_PLL_LOCK_DETECT_FTW_RX_SHIFT, XCVR_PLL_LOCK_DETECT_FTW_RX_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LOCK_DETECT, field FTF_TX_THRSH[25:20] (RW)
 *
 * In Radio Transmit Mode, the FT_FAIL and FTFF bits will be set after the
 * Frequency Target Count completes if the absolute value of the count difference from
 * the frequency target count is greater than this register value.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LOCK_DETECT_FTF_TX_THRSH field. */
#define XCVR_RD_PLL_LOCK_DETECT_FTF_TX_THRSH(base) ((XCVR_PLL_LOCK_DETECT_REG(base) & XCVR_PLL_LOCK_DETECT_FTF_TX_THRSH_MASK) >> XCVR_PLL_LOCK_DETECT_FTF_TX_THRSH_SHIFT)
#define XCVR_BRD_PLL_LOCK_DETECT_FTF_TX_THRSH(base) (BME_UBFX32(&XCVR_PLL_LOCK_DETECT_REG(base), XCVR_PLL_LOCK_DETECT_FTF_TX_THRSH_SHIFT, XCVR_PLL_LOCK_DETECT_FTF_TX_THRSH_WIDTH))

/*! @brief Set the FTF_TX_THRSH field to a new value. */
#define XCVR_WR_PLL_LOCK_DETECT_FTF_TX_THRSH(base, value) (XCVR_RMW_PLL_LOCK_DETECT(base, (XCVR_PLL_LOCK_DETECT_FTF_TX_THRSH_MASK | XCVR_PLL_LOCK_DETECT_CTFF_MASK | XCVR_PLL_LOCK_DETECT_CSFF_MASK | XCVR_PLL_LOCK_DETECT_FTFF_MASK | XCVR_PLL_LOCK_DETECT_TAFF_MASK), XCVR_PLL_LOCK_DETECT_FTF_TX_THRSH(value)))
#define XCVR_BWR_PLL_LOCK_DETECT_FTF_TX_THRSH(base, value) (BME_BFI32(&XCVR_PLL_LOCK_DETECT_REG(base), ((uint32_t)(value) << XCVR_PLL_LOCK_DETECT_FTF_TX_THRSH_SHIFT), XCVR_PLL_LOCK_DETECT_FTF_TX_THRSH_SHIFT, XCVR_PLL_LOCK_DETECT_FTF_TX_THRSH_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LOCK_DETECT, field FTW_TX[27] (RW)
 *
 * In Radio Transmit Mode, this bit selects the length of time to count for the
 * estimation of PLL lock frequency, which is compared with the Frequency Target
 * Window, set by FTF_TX.
 *
 * Values:
 * - 0b0 - 4 us
 * - 0b1 - 8 us
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LOCK_DETECT_FTW_TX field. */
#define XCVR_RD_PLL_LOCK_DETECT_FTW_TX(base) ((XCVR_PLL_LOCK_DETECT_REG(base) & XCVR_PLL_LOCK_DETECT_FTW_TX_MASK) >> XCVR_PLL_LOCK_DETECT_FTW_TX_SHIFT)
#define XCVR_BRD_PLL_LOCK_DETECT_FTW_TX(base) (BME_UBFX32(&XCVR_PLL_LOCK_DETECT_REG(base), XCVR_PLL_LOCK_DETECT_FTW_TX_SHIFT, XCVR_PLL_LOCK_DETECT_FTW_TX_WIDTH))

/*! @brief Set the FTW_TX field to a new value. */
#define XCVR_WR_PLL_LOCK_DETECT_FTW_TX(base, value) (XCVR_RMW_PLL_LOCK_DETECT(base, (XCVR_PLL_LOCK_DETECT_FTW_TX_MASK | XCVR_PLL_LOCK_DETECT_CTFF_MASK | XCVR_PLL_LOCK_DETECT_CSFF_MASK | XCVR_PLL_LOCK_DETECT_FTFF_MASK | XCVR_PLL_LOCK_DETECT_TAFF_MASK), XCVR_PLL_LOCK_DETECT_FTW_TX(value)))
#define XCVR_BWR_PLL_LOCK_DETECT_FTW_TX(base, value) (BME_BFI32(&XCVR_PLL_LOCK_DETECT_REG(base), ((uint32_t)(value) << XCVR_PLL_LOCK_DETECT_FTW_TX_SHIFT), XCVR_PLL_LOCK_DETECT_FTW_TX_SHIFT, XCVR_PLL_LOCK_DETECT_FTW_TX_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_HP_MOD_CTRL - PLL High Port Modulation Control
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_HP_MOD_CTRL - PLL High Port Modulation Control (RW)
 *
 * Reset value: 0x00840000U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_HP_MOD_CTRL register
 */
/*@{*/
#define XCVR_RD_PLL_HP_MOD_CTRL(base) (XCVR_PLL_HP_MOD_CTRL_REG(base))
#define XCVR_WR_PLL_HP_MOD_CTRL(base, value) (XCVR_PLL_HP_MOD_CTRL_REG(base) = (value))
#define XCVR_RMW_PLL_HP_MOD_CTRL(base, mask, value) (XCVR_WR_PLL_HP_MOD_CTRL(base, (XCVR_RD_PLL_HP_MOD_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_PLL_HP_MOD_CTRL(base, value) (BME_OR32(&XCVR_PLL_HP_MOD_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PLL_HP_MOD_CTRL(base, value) (BME_AND32(&XCVR_PLL_HP_MOD_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PLL_HP_MOD_CTRL(base, value) (BME_XOR32(&XCVR_PLL_HP_MOD_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_HP_MOD_CTRL bitfields
 */

/*!
 * @name Register XCVR_PLL_HP_MOD_CTRL, field HPM_SDM_MANUAL[9:0] (RW)
 *
 * If HP_SDM_DIS is set, this register is the value that is applied as the
 * Numerator to the High Port SDM.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_HP_MOD_CTRL_HPM_SDM_MANUAL field. */
#define XCVR_RD_PLL_HP_MOD_CTRL_HPM_SDM_MANUAL(base) ((XCVR_PLL_HP_MOD_CTRL_REG(base) & XCVR_PLL_HP_MOD_CTRL_HPM_SDM_MANUAL_MASK) >> XCVR_PLL_HP_MOD_CTRL_HPM_SDM_MANUAL_SHIFT)
#define XCVR_BRD_PLL_HP_MOD_CTRL_HPM_SDM_MANUAL(base) (BME_UBFX32(&XCVR_PLL_HP_MOD_CTRL_REG(base), XCVR_PLL_HP_MOD_CTRL_HPM_SDM_MANUAL_SHIFT, XCVR_PLL_HP_MOD_CTRL_HPM_SDM_MANUAL_WIDTH))

/*! @brief Set the HPM_SDM_MANUAL field to a new value. */
#define XCVR_WR_PLL_HP_MOD_CTRL_HPM_SDM_MANUAL(base, value) (XCVR_RMW_PLL_HP_MOD_CTRL(base, (XCVR_PLL_HP_MOD_CTRL_HPM_SDM_MANUAL_MASK | XCVR_PLL_HP_MOD_CTRL_HPFF_MASK), XCVR_PLL_HP_MOD_CTRL_HPM_SDM_MANUAL(value)))
#define XCVR_BWR_PLL_HP_MOD_CTRL_HPM_SDM_MANUAL(base, value) (BME_BFI32(&XCVR_PLL_HP_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_HP_MOD_CTRL_HPM_SDM_MANUAL_SHIFT), XCVR_PLL_HP_MOD_CTRL_HPM_SDM_MANUAL_SHIFT, XCVR_PLL_HP_MOD_CTRL_HPM_SDM_MANUAL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_HP_MOD_CTRL, field HPFF[13] (W1C)
 *
 * This bit is set if the High Port Sigma Delta Modulator output is invalid due
 * to an error in the Fraction applied, and this bit is cleared by writing a 1 to
 * it.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_HP_MOD_CTRL_HPFF field. */
#define XCVR_RD_PLL_HP_MOD_CTRL_HPFF(base) ((XCVR_PLL_HP_MOD_CTRL_REG(base) & XCVR_PLL_HP_MOD_CTRL_HPFF_MASK) >> XCVR_PLL_HP_MOD_CTRL_HPFF_SHIFT)
#define XCVR_BRD_PLL_HP_MOD_CTRL_HPFF(base) (BME_UBFX32(&XCVR_PLL_HP_MOD_CTRL_REG(base), XCVR_PLL_HP_MOD_CTRL_HPFF_SHIFT, XCVR_PLL_HP_MOD_CTRL_HPFF_WIDTH))

/*! @brief Set the HPFF field to a new value. */
#define XCVR_WR_PLL_HP_MOD_CTRL_HPFF(base, value) (XCVR_RMW_PLL_HP_MOD_CTRL(base, XCVR_PLL_HP_MOD_CTRL_HPFF_MASK, XCVR_PLL_HP_MOD_CTRL_HPFF(value)))
#define XCVR_BWR_PLL_HP_MOD_CTRL_HPFF(base, value) (BME_BFI32(&XCVR_PLL_HP_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_HP_MOD_CTRL_HPFF_SHIFT), XCVR_PLL_HP_MOD_CTRL_HPFF_SHIFT, XCVR_PLL_HP_MOD_CTRL_HPFF_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_HP_MOD_CTRL, field HP_SDM_INV[14] (RW)
 *
 * If this bit is set the High Port LSB Fractional Word, including any
 * Dithering, will be Inverted before it is applied to the High Port Sigma Delta Modulator.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_HP_MOD_CTRL_HP_SDM_INV field. */
#define XCVR_RD_PLL_HP_MOD_CTRL_HP_SDM_INV(base) ((XCVR_PLL_HP_MOD_CTRL_REG(base) & XCVR_PLL_HP_MOD_CTRL_HP_SDM_INV_MASK) >> XCVR_PLL_HP_MOD_CTRL_HP_SDM_INV_SHIFT)
#define XCVR_BRD_PLL_HP_MOD_CTRL_HP_SDM_INV(base) (BME_UBFX32(&XCVR_PLL_HP_MOD_CTRL_REG(base), XCVR_PLL_HP_MOD_CTRL_HP_SDM_INV_SHIFT, XCVR_PLL_HP_MOD_CTRL_HP_SDM_INV_WIDTH))

/*! @brief Set the HP_SDM_INV field to a new value. */
#define XCVR_WR_PLL_HP_MOD_CTRL_HP_SDM_INV(base, value) (XCVR_RMW_PLL_HP_MOD_CTRL(base, (XCVR_PLL_HP_MOD_CTRL_HP_SDM_INV_MASK | XCVR_PLL_HP_MOD_CTRL_HPFF_MASK), XCVR_PLL_HP_MOD_CTRL_HP_SDM_INV(value)))
#define XCVR_BWR_PLL_HP_MOD_CTRL_HP_SDM_INV(base, value) (BME_BFI32(&XCVR_PLL_HP_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_HP_MOD_CTRL_HP_SDM_INV_SHIFT), XCVR_PLL_HP_MOD_CTRL_HP_SDM_INV_SHIFT, XCVR_PLL_HP_MOD_CTRL_HP_SDM_INV_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_HP_MOD_CTRL, field HP_SDM_DIS[15] (RW)
 *
 * If this bit is set, the High Port Modulation to the HP SDM is disabled, and
 * the HP SDM Numerator comes from the HPM_SDM_MANUAL register.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_HP_MOD_CTRL_HP_SDM_DIS field. */
#define XCVR_RD_PLL_HP_MOD_CTRL_HP_SDM_DIS(base) ((XCVR_PLL_HP_MOD_CTRL_REG(base) & XCVR_PLL_HP_MOD_CTRL_HP_SDM_DIS_MASK) >> XCVR_PLL_HP_MOD_CTRL_HP_SDM_DIS_SHIFT)
#define XCVR_BRD_PLL_HP_MOD_CTRL_HP_SDM_DIS(base) (BME_UBFX32(&XCVR_PLL_HP_MOD_CTRL_REG(base), XCVR_PLL_HP_MOD_CTRL_HP_SDM_DIS_SHIFT, XCVR_PLL_HP_MOD_CTRL_HP_SDM_DIS_WIDTH))

/*! @brief Set the HP_SDM_DIS field to a new value. */
#define XCVR_WR_PLL_HP_MOD_CTRL_HP_SDM_DIS(base, value) (XCVR_RMW_PLL_HP_MOD_CTRL(base, (XCVR_PLL_HP_MOD_CTRL_HP_SDM_DIS_MASK | XCVR_PLL_HP_MOD_CTRL_HPFF_MASK), XCVR_PLL_HP_MOD_CTRL_HP_SDM_DIS(value)))
#define XCVR_BWR_PLL_HP_MOD_CTRL_HP_SDM_DIS(base, value) (BME_BFI32(&XCVR_PLL_HP_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_HP_MOD_CTRL_HP_SDM_DIS_SHIFT), XCVR_PLL_HP_MOD_CTRL_HP_SDM_DIS_SHIFT, XCVR_PLL_HP_MOD_CTRL_HP_SDM_DIS_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_HP_MOD_CTRL, field HPM_LFSR_LEN[18:16] (RW)
 *
 * This register selects the length of the HPM LFSR and the associated LFSR Tap
 * Mask
 *
 * Values:
 * - 0b000 - LFSR 9, tap mask 100010000
 * - 0b001 - LFSR 10, tap mask 1001000000
 * - 0b010 - LFSR 11, tap mask 11101000000
 * - 0b011 - LFSR 13, tap mask 1101100000000
 * - 0b100 - LFSR 15, tap mask 111010000000000
 * - 0b101 - LFSR 17, tap mask 11110000000000000
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_HP_MOD_CTRL_HPM_LFSR_LEN field. */
#define XCVR_RD_PLL_HP_MOD_CTRL_HPM_LFSR_LEN(base) ((XCVR_PLL_HP_MOD_CTRL_REG(base) & XCVR_PLL_HP_MOD_CTRL_HPM_LFSR_LEN_MASK) >> XCVR_PLL_HP_MOD_CTRL_HPM_LFSR_LEN_SHIFT)
#define XCVR_BRD_PLL_HP_MOD_CTRL_HPM_LFSR_LEN(base) (BME_UBFX32(&XCVR_PLL_HP_MOD_CTRL_REG(base), XCVR_PLL_HP_MOD_CTRL_HPM_LFSR_LEN_SHIFT, XCVR_PLL_HP_MOD_CTRL_HPM_LFSR_LEN_WIDTH))

/*! @brief Set the HPM_LFSR_LEN field to a new value. */
#define XCVR_WR_PLL_HP_MOD_CTRL_HPM_LFSR_LEN(base, value) (XCVR_RMW_PLL_HP_MOD_CTRL(base, (XCVR_PLL_HP_MOD_CTRL_HPM_LFSR_LEN_MASK | XCVR_PLL_HP_MOD_CTRL_HPFF_MASK), XCVR_PLL_HP_MOD_CTRL_HPM_LFSR_LEN(value)))
#define XCVR_BWR_PLL_HP_MOD_CTRL_HPM_LFSR_LEN(base, value) (BME_BFI32(&XCVR_PLL_HP_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_HP_MOD_CTRL_HPM_LFSR_LEN_SHIFT), XCVR_PLL_HP_MOD_CTRL_HPM_LFSR_LEN_SHIFT, XCVR_PLL_HP_MOD_CTRL_HPM_LFSR_LEN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_HP_MOD_CTRL, field HP_DTH_SCL[20] (RW)
 *
 * If this bit is set, the LFSR dithering of the High Port LSB Fractional Word
 * will be multiplied by 2.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_HP_MOD_CTRL_HP_DTH_SCL field. */
#define XCVR_RD_PLL_HP_MOD_CTRL_HP_DTH_SCL(base) ((XCVR_PLL_HP_MOD_CTRL_REG(base) & XCVR_PLL_HP_MOD_CTRL_HP_DTH_SCL_MASK) >> XCVR_PLL_HP_MOD_CTRL_HP_DTH_SCL_SHIFT)
#define XCVR_BRD_PLL_HP_MOD_CTRL_HP_DTH_SCL(base) (BME_UBFX32(&XCVR_PLL_HP_MOD_CTRL_REG(base), XCVR_PLL_HP_MOD_CTRL_HP_DTH_SCL_SHIFT, XCVR_PLL_HP_MOD_CTRL_HP_DTH_SCL_WIDTH))

/*! @brief Set the HP_DTH_SCL field to a new value. */
#define XCVR_WR_PLL_HP_MOD_CTRL_HP_DTH_SCL(base, value) (XCVR_RMW_PLL_HP_MOD_CTRL(base, (XCVR_PLL_HP_MOD_CTRL_HP_DTH_SCL_MASK | XCVR_PLL_HP_MOD_CTRL_HPFF_MASK), XCVR_PLL_HP_MOD_CTRL_HP_DTH_SCL(value)))
#define XCVR_BWR_PLL_HP_MOD_CTRL_HP_DTH_SCL(base, value) (BME_BFI32(&XCVR_PLL_HP_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_HP_MOD_CTRL_HP_DTH_SCL_SHIFT), XCVR_PLL_HP_MOD_CTRL_HP_DTH_SCL_SHIFT, XCVR_PLL_HP_MOD_CTRL_HP_DTH_SCL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_HP_MOD_CTRL, field HPM_DTH_EN[23] (RW)
 *
 * If this bit is set, the High Port LSB Fractional Word will be Dithered by the
 * High Port LFSR before it is applied to the HP SDM.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_HP_MOD_CTRL_HPM_DTH_EN field. */
#define XCVR_RD_PLL_HP_MOD_CTRL_HPM_DTH_EN(base) ((XCVR_PLL_HP_MOD_CTRL_REG(base) & XCVR_PLL_HP_MOD_CTRL_HPM_DTH_EN_MASK) >> XCVR_PLL_HP_MOD_CTRL_HPM_DTH_EN_SHIFT)
#define XCVR_BRD_PLL_HP_MOD_CTRL_HPM_DTH_EN(base) (BME_UBFX32(&XCVR_PLL_HP_MOD_CTRL_REG(base), XCVR_PLL_HP_MOD_CTRL_HPM_DTH_EN_SHIFT, XCVR_PLL_HP_MOD_CTRL_HPM_DTH_EN_WIDTH))

/*! @brief Set the HPM_DTH_EN field to a new value. */
#define XCVR_WR_PLL_HP_MOD_CTRL_HPM_DTH_EN(base, value) (XCVR_RMW_PLL_HP_MOD_CTRL(base, (XCVR_PLL_HP_MOD_CTRL_HPM_DTH_EN_MASK | XCVR_PLL_HP_MOD_CTRL_HPFF_MASK), XCVR_PLL_HP_MOD_CTRL_HPM_DTH_EN(value)))
#define XCVR_BWR_PLL_HP_MOD_CTRL_HPM_DTH_EN(base, value) (BME_BFI32(&XCVR_PLL_HP_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_HP_MOD_CTRL_HPM_DTH_EN_SHIFT), XCVR_PLL_HP_MOD_CTRL_HPM_DTH_EN_SHIFT, XCVR_PLL_HP_MOD_CTRL_HPM_DTH_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_HP_MOD_CTRL, field HPM_SCALE[25:24] (RW)
 *
 * This register controls the scaling of the High Port Modulation Integer Value
 * applied to the VCO High Port Bank.
 *
 * Values:
 * - 0b00 - No Scaling
 * - 0b01 - Multiply by 2
 * - 0b10 - Divide by 2
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_HP_MOD_CTRL_HPM_SCALE field. */
#define XCVR_RD_PLL_HP_MOD_CTRL_HPM_SCALE(base) ((XCVR_PLL_HP_MOD_CTRL_REG(base) & XCVR_PLL_HP_MOD_CTRL_HPM_SCALE_MASK) >> XCVR_PLL_HP_MOD_CTRL_HPM_SCALE_SHIFT)
#define XCVR_BRD_PLL_HP_MOD_CTRL_HPM_SCALE(base) (BME_UBFX32(&XCVR_PLL_HP_MOD_CTRL_REG(base), XCVR_PLL_HP_MOD_CTRL_HPM_SCALE_SHIFT, XCVR_PLL_HP_MOD_CTRL_HPM_SCALE_WIDTH))

/*! @brief Set the HPM_SCALE field to a new value. */
#define XCVR_WR_PLL_HP_MOD_CTRL_HPM_SCALE(base, value) (XCVR_RMW_PLL_HP_MOD_CTRL(base, (XCVR_PLL_HP_MOD_CTRL_HPM_SCALE_MASK | XCVR_PLL_HP_MOD_CTRL_HPFF_MASK), XCVR_PLL_HP_MOD_CTRL_HPM_SCALE(value)))
#define XCVR_BWR_PLL_HP_MOD_CTRL_HPM_SCALE(base, value) (BME_BFI32(&XCVR_PLL_HP_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_HP_MOD_CTRL_HPM_SCALE_SHIFT), XCVR_PLL_HP_MOD_CTRL_HPM_SCALE_SHIFT, XCVR_PLL_HP_MOD_CTRL_HPM_SCALE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_HP_MOD_CTRL, field HP_MOD_INV[31] (RW)
 *
 * If this bit is set, the Baseband Frequency Word will be Inverted before
 * Scaling and Dithering, and then applied to the High Port Bank and the High Port
 * Sigma Delta Modulator of the HP LSB. Note that the High Port SDM has it's own,
 * additional, inversion bit.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_HP_MOD_CTRL_HP_MOD_INV field. */
#define XCVR_RD_PLL_HP_MOD_CTRL_HP_MOD_INV(base) ((XCVR_PLL_HP_MOD_CTRL_REG(base) & XCVR_PLL_HP_MOD_CTRL_HP_MOD_INV_MASK) >> XCVR_PLL_HP_MOD_CTRL_HP_MOD_INV_SHIFT)
#define XCVR_BRD_PLL_HP_MOD_CTRL_HP_MOD_INV(base) (BME_UBFX32(&XCVR_PLL_HP_MOD_CTRL_REG(base), XCVR_PLL_HP_MOD_CTRL_HP_MOD_INV_SHIFT, XCVR_PLL_HP_MOD_CTRL_HP_MOD_INV_WIDTH))

/*! @brief Set the HP_MOD_INV field to a new value. */
#define XCVR_WR_PLL_HP_MOD_CTRL_HP_MOD_INV(base, value) (XCVR_RMW_PLL_HP_MOD_CTRL(base, (XCVR_PLL_HP_MOD_CTRL_HP_MOD_INV_MASK | XCVR_PLL_HP_MOD_CTRL_HPFF_MASK), XCVR_PLL_HP_MOD_CTRL_HP_MOD_INV(value)))
#define XCVR_BWR_PLL_HP_MOD_CTRL_HP_MOD_INV(base, value) (BME_BFI32(&XCVR_PLL_HP_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_HP_MOD_CTRL_HP_MOD_INV_SHIFT), XCVR_PLL_HP_MOD_CTRL_HP_MOD_INV_SHIFT, XCVR_PLL_HP_MOD_CTRL_HP_MOD_INV_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_HPM_CAL_CTRL - PLL HPM Calibration Control
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_HPM_CAL_CTRL - PLL HPM Calibration Control (RW)
 *
 * Reset value: 0x400002A2U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_HPM_CAL_CTRL register
 */
/*@{*/
#define XCVR_RD_PLL_HPM_CAL_CTRL(base) (XCVR_PLL_HPM_CAL_CTRL_REG(base))
#define XCVR_WR_PLL_HPM_CAL_CTRL(base, value) (XCVR_PLL_HPM_CAL_CTRL_REG(base) = (value))
#define XCVR_RMW_PLL_HPM_CAL_CTRL(base, mask, value) (XCVR_WR_PLL_HPM_CAL_CTRL(base, (XCVR_RD_PLL_HPM_CAL_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_PLL_HPM_CAL_CTRL(base, value) (BME_OR32(&XCVR_PLL_HPM_CAL_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PLL_HPM_CAL_CTRL(base, value) (BME_AND32(&XCVR_PLL_HPM_CAL_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PLL_HPM_CAL_CTRL(base, value) (BME_XOR32(&XCVR_PLL_HPM_CAL_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_HPM_CAL_CTRL bitfields
 */

/*!
 * @name Register XCVR_PLL_HPM_CAL_CTRL, field HPM_CAL_FACTOR[12:0] (RO)
 *
 * This is the value currently being used by High Port Modulation Multiplier.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR field. */
#define XCVR_RD_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR(base) ((XCVR_PLL_HPM_CAL_CTRL_REG(base) & XCVR_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR_MASK) >> XCVR_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR_SHIFT)
#define XCVR_BRD_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR(base) (BME_UBFX32(&XCVR_PLL_HPM_CAL_CTRL_REG(base), XCVR_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR_SHIFT, XCVR_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_HPM_CAL_CTRL, field HP_CAL_DIS[15] (RW)
 *
 * If this bit is set, the lookup table value for the HPM Calibration Factor is
 * overridden by the HPM_CAL_FACTOR_MANUAL register.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_HPM_CAL_CTRL_HP_CAL_DIS field. */
#define XCVR_RD_PLL_HPM_CAL_CTRL_HP_CAL_DIS(base) ((XCVR_PLL_HPM_CAL_CTRL_REG(base) & XCVR_PLL_HPM_CAL_CTRL_HP_CAL_DIS_MASK) >> XCVR_PLL_HPM_CAL_CTRL_HP_CAL_DIS_SHIFT)
#define XCVR_BRD_PLL_HPM_CAL_CTRL_HP_CAL_DIS(base) (BME_UBFX32(&XCVR_PLL_HPM_CAL_CTRL_REG(base), XCVR_PLL_HPM_CAL_CTRL_HP_CAL_DIS_SHIFT, XCVR_PLL_HPM_CAL_CTRL_HP_CAL_DIS_WIDTH))

/*! @brief Set the HP_CAL_DIS field to a new value. */
#define XCVR_WR_PLL_HPM_CAL_CTRL_HP_CAL_DIS(base, value) (XCVR_RMW_PLL_HPM_CAL_CTRL(base, XCVR_PLL_HPM_CAL_CTRL_HP_CAL_DIS_MASK, XCVR_PLL_HPM_CAL_CTRL_HP_CAL_DIS(value)))
#define XCVR_BWR_PLL_HPM_CAL_CTRL_HP_CAL_DIS(base, value) (BME_BFI32(&XCVR_PLL_HPM_CAL_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_HPM_CAL_CTRL_HP_CAL_DIS_SHIFT), XCVR_PLL_HPM_CAL_CTRL_HP_CAL_DIS_SHIFT, XCVR_PLL_HPM_CAL_CTRL_HP_CAL_DIS_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_HPM_CAL_CTRL, field HPM_CAL_FACTOR_MANUAL[28:16] (RW)
 *
 * If HP_CAL_DIS is set, this register is the unsigned 13 bit value used by the
 * HPM Multiplier, the maximum useable value is decimal 6400.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR_MANUAL field. */
#define XCVR_RD_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR_MANUAL(base) ((XCVR_PLL_HPM_CAL_CTRL_REG(base) & XCVR_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR_MANUAL_MASK) >> XCVR_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR_MANUAL_SHIFT)
#define XCVR_BRD_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR_MANUAL(base) (BME_UBFX32(&XCVR_PLL_HPM_CAL_CTRL_REG(base), XCVR_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR_MANUAL_SHIFT, XCVR_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR_MANUAL_WIDTH))

/*! @brief Set the HPM_CAL_FACTOR_MANUAL field to a new value. */
#define XCVR_WR_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR_MANUAL(base, value) (XCVR_RMW_PLL_HPM_CAL_CTRL(base, XCVR_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR_MANUAL_MASK, XCVR_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR_MANUAL(value)))
#define XCVR_BWR_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR_MANUAL(base, value) (BME_BFI32(&XCVR_PLL_HPM_CAL_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR_MANUAL_SHIFT), XCVR_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR_MANUAL_SHIFT, XCVR_PLL_HPM_CAL_CTRL_HPM_CAL_FACTOR_MANUAL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_HPM_CAL_CTRL, field HP_CAL_ARY[30] (RW)
 *
 * This bit selects the size of the array to be used by the math implemented in
 * the HPM Calibration Factor lookup table.
 *
 * Values:
 * - 0b0 - 128
 * - 0b1 - 256
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_HPM_CAL_CTRL_HP_CAL_ARY field. */
#define XCVR_RD_PLL_HPM_CAL_CTRL_HP_CAL_ARY(base) ((XCVR_PLL_HPM_CAL_CTRL_REG(base) & XCVR_PLL_HPM_CAL_CTRL_HP_CAL_ARY_MASK) >> XCVR_PLL_HPM_CAL_CTRL_HP_CAL_ARY_SHIFT)
#define XCVR_BRD_PLL_HPM_CAL_CTRL_HP_CAL_ARY(base) (BME_UBFX32(&XCVR_PLL_HPM_CAL_CTRL_REG(base), XCVR_PLL_HPM_CAL_CTRL_HP_CAL_ARY_SHIFT, XCVR_PLL_HPM_CAL_CTRL_HP_CAL_ARY_WIDTH))

/*! @brief Set the HP_CAL_ARY field to a new value. */
#define XCVR_WR_PLL_HPM_CAL_CTRL_HP_CAL_ARY(base, value) (XCVR_RMW_PLL_HPM_CAL_CTRL(base, XCVR_PLL_HPM_CAL_CTRL_HP_CAL_ARY_MASK, XCVR_PLL_HPM_CAL_CTRL_HP_CAL_ARY(value)))
#define XCVR_BWR_PLL_HPM_CAL_CTRL_HP_CAL_ARY(base, value) (BME_BFI32(&XCVR_PLL_HPM_CAL_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_HPM_CAL_CTRL_HP_CAL_ARY_SHIFT), XCVR_PLL_HPM_CAL_CTRL_HP_CAL_ARY_SHIFT, XCVR_PLL_HPM_CAL_CTRL_HP_CAL_ARY_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_HPM_CAL_CTRL, field HP_CAL_TIME[31] (RW)
 *
 * This bit selects the length of time to count during HPM Calibration and is
 * used by the math implemented in the HPM Calibration Factor lookup table.
 *
 * Values:
 * - 0b0 - 25 us
 * - 0b1 - 50 us
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_HPM_CAL_CTRL_HP_CAL_TIME field. */
#define XCVR_RD_PLL_HPM_CAL_CTRL_HP_CAL_TIME(base) ((XCVR_PLL_HPM_CAL_CTRL_REG(base) & XCVR_PLL_HPM_CAL_CTRL_HP_CAL_TIME_MASK) >> XCVR_PLL_HPM_CAL_CTRL_HP_CAL_TIME_SHIFT)
#define XCVR_BRD_PLL_HPM_CAL_CTRL_HP_CAL_TIME(base) (BME_UBFX32(&XCVR_PLL_HPM_CAL_CTRL_REG(base), XCVR_PLL_HPM_CAL_CTRL_HP_CAL_TIME_SHIFT, XCVR_PLL_HPM_CAL_CTRL_HP_CAL_TIME_WIDTH))

/*! @brief Set the HP_CAL_TIME field to a new value. */
#define XCVR_WR_PLL_HPM_CAL_CTRL_HP_CAL_TIME(base, value) (XCVR_RMW_PLL_HPM_CAL_CTRL(base, XCVR_PLL_HPM_CAL_CTRL_HP_CAL_TIME_MASK, XCVR_PLL_HPM_CAL_CTRL_HP_CAL_TIME(value)))
#define XCVR_BWR_PLL_HPM_CAL_CTRL_HP_CAL_TIME(base, value) (BME_BFI32(&XCVR_PLL_HPM_CAL_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_HPM_CAL_CTRL_HP_CAL_TIME_SHIFT), XCVR_PLL_HPM_CAL_CTRL_HP_CAL_TIME_SHIFT, XCVR_PLL_HPM_CAL_CTRL_HP_CAL_TIME_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_LD_HPM_CAL1 - PLL Cycle Slip Lock Detect Configuration and HPM Calibration 1
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_LD_HPM_CAL1 - PLL Cycle Slip Lock Detect Configuration and HPM Calibration 1 (RW)
 *
 * Reset value: 0x44300000U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_LD_HPM_CAL1 register
 */
/*@{*/
#define XCVR_RD_PLL_LD_HPM_CAL1(base) (XCVR_PLL_LD_HPM_CAL1_REG(base))
#define XCVR_WR_PLL_LD_HPM_CAL1(base, value) (XCVR_PLL_LD_HPM_CAL1_REG(base) = (value))
#define XCVR_RMW_PLL_LD_HPM_CAL1(base, mask, value) (XCVR_WR_PLL_LD_HPM_CAL1(base, (XCVR_RD_PLL_LD_HPM_CAL1(base) & ~(mask)) | (value)))
#define XCVR_SET_PLL_LD_HPM_CAL1(base, value) (BME_OR32(&XCVR_PLL_LD_HPM_CAL1_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PLL_LD_HPM_CAL1(base, value) (BME_AND32(&XCVR_PLL_LD_HPM_CAL1_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PLL_LD_HPM_CAL1(base, value) (BME_XOR32(&XCVR_PLL_LD_HPM_CAL1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_LD_HPM_CAL1 bitfields
 */

/*!
 * @name Register XCVR_PLL_LD_HPM_CAL1, field CNT_1[16:0] (RO)
 *
 * This is the Ripple counter value used for HPM Cal 1.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LD_HPM_CAL1_CNT_1 field. */
#define XCVR_RD_PLL_LD_HPM_CAL1_CNT_1(base) ((XCVR_PLL_LD_HPM_CAL1_REG(base) & XCVR_PLL_LD_HPM_CAL1_CNT_1_MASK) >> XCVR_PLL_LD_HPM_CAL1_CNT_1_SHIFT)
#define XCVR_BRD_PLL_LD_HPM_CAL1_CNT_1(base) (XCVR_RD_PLL_LD_HPM_CAL1_CNT_1(base))
/*@}*/

/*!
 * @name Register XCVR_PLL_LD_HPM_CAL1, field CS_WT[22:20] (RW)
 *
 * This register sets the time to wait before restarting a Cycle Slip Search if
 * CS_RC, Cycle Slip Recycle, is set.
 *
 * Values:
 * - 0b000 - 128 us
 * - 0b001 - 256 us
 * - 0b010 - 384 us
 * - 0b011 - 512 us
 * - 0b100 - 640 us
 * - 0b101 - 768 us
 * - 0b110 - 896 us
 * - 0b111 - 1024 us
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LD_HPM_CAL1_CS_WT field. */
#define XCVR_RD_PLL_LD_HPM_CAL1_CS_WT(base) ((XCVR_PLL_LD_HPM_CAL1_REG(base) & XCVR_PLL_LD_HPM_CAL1_CS_WT_MASK) >> XCVR_PLL_LD_HPM_CAL1_CS_WT_SHIFT)
#define XCVR_BRD_PLL_LD_HPM_CAL1_CS_WT(base) (BME_UBFX32(&XCVR_PLL_LD_HPM_CAL1_REG(base), XCVR_PLL_LD_HPM_CAL1_CS_WT_SHIFT, XCVR_PLL_LD_HPM_CAL1_CS_WT_WIDTH))

/*! @brief Set the CS_WT field to a new value. */
#define XCVR_WR_PLL_LD_HPM_CAL1_CS_WT(base, value) (XCVR_RMW_PLL_LD_HPM_CAL1(base, XCVR_PLL_LD_HPM_CAL1_CS_WT_MASK, XCVR_PLL_LD_HPM_CAL1_CS_WT(value)))
#define XCVR_BWR_PLL_LD_HPM_CAL1_CS_WT(base, value) (BME_BFI32(&XCVR_PLL_LD_HPM_CAL1_REG(base), ((uint32_t)(value) << XCVR_PLL_LD_HPM_CAL1_CS_WT_SHIFT), XCVR_PLL_LD_HPM_CAL1_CS_WT_SHIFT, XCVR_PLL_LD_HPM_CAL1_CS_WT_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LD_HPM_CAL1, field CS_FW[26:24] (RW)
 *
 * This register sets the window time for capturing Cycle Slip Flags before
 * shutting down.
 *
 * Values:
 * - 0b000 - 8 us
 * - 0b001 - 16 us
 * - 0b010 - 24 us
 * - 0b011 - 32 us
 * - 0b100 - 64 us
 * - 0b101 - 96 us
 * - 0b110 - 128 us
 * - 0b111 - 256 us
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LD_HPM_CAL1_CS_FW field. */
#define XCVR_RD_PLL_LD_HPM_CAL1_CS_FW(base) ((XCVR_PLL_LD_HPM_CAL1_REG(base) & XCVR_PLL_LD_HPM_CAL1_CS_FW_MASK) >> XCVR_PLL_LD_HPM_CAL1_CS_FW_SHIFT)
#define XCVR_BRD_PLL_LD_HPM_CAL1_CS_FW(base) (BME_UBFX32(&XCVR_PLL_LD_HPM_CAL1_REG(base), XCVR_PLL_LD_HPM_CAL1_CS_FW_SHIFT, XCVR_PLL_LD_HPM_CAL1_CS_FW_WIDTH))

/*! @brief Set the CS_FW field to a new value. */
#define XCVR_WR_PLL_LD_HPM_CAL1_CS_FW(base, value) (XCVR_RMW_PLL_LD_HPM_CAL1(base, XCVR_PLL_LD_HPM_CAL1_CS_FW_MASK, XCVR_PLL_LD_HPM_CAL1_CS_FW(value)))
#define XCVR_BWR_PLL_LD_HPM_CAL1_CS_FW(base, value) (BME_BFI32(&XCVR_PLL_LD_HPM_CAL1_REG(base), ((uint32_t)(value) << XCVR_PLL_LD_HPM_CAL1_CS_FW_SHIFT), XCVR_PLL_LD_HPM_CAL1_CS_FW_SHIFT, XCVR_PLL_LD_HPM_CAL1_CS_FW_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LD_HPM_CAL1, field CS_FCNT[31:28] (RW)
 *
 * This register value is the maximum number of Cycle Slip Flags that can be
 * counted before the CS_FAIL is set.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LD_HPM_CAL1_CS_FCNT field. */
#define XCVR_RD_PLL_LD_HPM_CAL1_CS_FCNT(base) ((XCVR_PLL_LD_HPM_CAL1_REG(base) & XCVR_PLL_LD_HPM_CAL1_CS_FCNT_MASK) >> XCVR_PLL_LD_HPM_CAL1_CS_FCNT_SHIFT)
#define XCVR_BRD_PLL_LD_HPM_CAL1_CS_FCNT(base) (BME_UBFX32(&XCVR_PLL_LD_HPM_CAL1_REG(base), XCVR_PLL_LD_HPM_CAL1_CS_FCNT_SHIFT, XCVR_PLL_LD_HPM_CAL1_CS_FCNT_WIDTH))

/*! @brief Set the CS_FCNT field to a new value. */
#define XCVR_WR_PLL_LD_HPM_CAL1_CS_FCNT(base, value) (XCVR_RMW_PLL_LD_HPM_CAL1(base, XCVR_PLL_LD_HPM_CAL1_CS_FCNT_MASK, XCVR_PLL_LD_HPM_CAL1_CS_FCNT(value)))
#define XCVR_BWR_PLL_LD_HPM_CAL1_CS_FCNT(base, value) (BME_BFI32(&XCVR_PLL_LD_HPM_CAL1_REG(base), ((uint32_t)(value) << XCVR_PLL_LD_HPM_CAL1_CS_FCNT_SHIFT), XCVR_PLL_LD_HPM_CAL1_CS_FCNT_SHIFT, XCVR_PLL_LD_HPM_CAL1_CS_FCNT_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_LD_HPM_CAL2 - PLL Cycle Slip Lock Detect Configuration and HPM Calibration 2
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_LD_HPM_CAL2 - PLL Cycle Slip Lock Detect Configuration and HPM Calibration 2 (RW)
 *
 * Reset value: 0x02100000U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_LD_HPM_CAL2 register
 */
/*@{*/
#define XCVR_RD_PLL_LD_HPM_CAL2(base) (XCVR_PLL_LD_HPM_CAL2_REG(base))
#define XCVR_WR_PLL_LD_HPM_CAL2(base, value) (XCVR_PLL_LD_HPM_CAL2_REG(base) = (value))
#define XCVR_RMW_PLL_LD_HPM_CAL2(base, mask, value) (XCVR_WR_PLL_LD_HPM_CAL2(base, (XCVR_RD_PLL_LD_HPM_CAL2(base) & ~(mask)) | (value)))
#define XCVR_SET_PLL_LD_HPM_CAL2(base, value) (BME_OR32(&XCVR_PLL_LD_HPM_CAL2_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PLL_LD_HPM_CAL2(base, value) (BME_AND32(&XCVR_PLL_LD_HPM_CAL2_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PLL_LD_HPM_CAL2(base, value) (BME_XOR32(&XCVR_PLL_LD_HPM_CAL2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_LD_HPM_CAL2 bitfields
 */

/*!
 * @name Register XCVR_PLL_LD_HPM_CAL2, field CNT_2[16:0] (RO)
 *
 * This is the Ripple counter value used for HPM Cal 2.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LD_HPM_CAL2_CNT_2 field. */
#define XCVR_RD_PLL_LD_HPM_CAL2_CNT_2(base) ((XCVR_PLL_LD_HPM_CAL2_REG(base) & XCVR_PLL_LD_HPM_CAL2_CNT_2_MASK) >> XCVR_PLL_LD_HPM_CAL2_CNT_2_SHIFT)
#define XCVR_BRD_PLL_LD_HPM_CAL2_CNT_2(base) (XCVR_RD_PLL_LD_HPM_CAL2_CNT_2(base))
/*@}*/

/*!
 * @name Register XCVR_PLL_LD_HPM_CAL2, field CS_RC[20] (RW)
 *
 * If this is bit is set, the Cycle Slip Lock Detector will restart after the
 * Cycle Slip Wait time.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LD_HPM_CAL2_CS_RC field. */
#define XCVR_RD_PLL_LD_HPM_CAL2_CS_RC(base) ((XCVR_PLL_LD_HPM_CAL2_REG(base) & XCVR_PLL_LD_HPM_CAL2_CS_RC_MASK) >> XCVR_PLL_LD_HPM_CAL2_CS_RC_SHIFT)
#define XCVR_BRD_PLL_LD_HPM_CAL2_CS_RC(base) (BME_UBFX32(&XCVR_PLL_LD_HPM_CAL2_REG(base), XCVR_PLL_LD_HPM_CAL2_CS_RC_SHIFT, XCVR_PLL_LD_HPM_CAL2_CS_RC_WIDTH))

/*! @brief Set the CS_RC field to a new value. */
#define XCVR_WR_PLL_LD_HPM_CAL2_CS_RC(base, value) (XCVR_RMW_PLL_LD_HPM_CAL2(base, XCVR_PLL_LD_HPM_CAL2_CS_RC_MASK, XCVR_PLL_LD_HPM_CAL2_CS_RC(value)))
#define XCVR_BWR_PLL_LD_HPM_CAL2_CS_RC(base, value) (BME_BFI32(&XCVR_PLL_LD_HPM_CAL2_REG(base), ((uint32_t)(value) << XCVR_PLL_LD_HPM_CAL2_CS_RC_SHIFT), XCVR_PLL_LD_HPM_CAL2_CS_RC_SHIFT, XCVR_PLL_LD_HPM_CAL2_CS_RC_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LD_HPM_CAL2, field CS_FT[28:24] (RW)
 *
 * This register sets the time to hold the analog cycle slip circuit in reset
 * after a Cycle Slip Flag, the time is a number of counts of the reference clock
 * equal to the value of this register.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LD_HPM_CAL2_CS_FT field. */
#define XCVR_RD_PLL_LD_HPM_CAL2_CS_FT(base) ((XCVR_PLL_LD_HPM_CAL2_REG(base) & XCVR_PLL_LD_HPM_CAL2_CS_FT_MASK) >> XCVR_PLL_LD_HPM_CAL2_CS_FT_SHIFT)
#define XCVR_BRD_PLL_LD_HPM_CAL2_CS_FT(base) (BME_UBFX32(&XCVR_PLL_LD_HPM_CAL2_REG(base), XCVR_PLL_LD_HPM_CAL2_CS_FT_SHIFT, XCVR_PLL_LD_HPM_CAL2_CS_FT_WIDTH))

/*! @brief Set the CS_FT field to a new value. */
#define XCVR_WR_PLL_LD_HPM_CAL2_CS_FT(base, value) (XCVR_RMW_PLL_LD_HPM_CAL2(base, XCVR_PLL_LD_HPM_CAL2_CS_FT_MASK, XCVR_PLL_LD_HPM_CAL2_CS_FT(value)))
#define XCVR_BWR_PLL_LD_HPM_CAL2_CS_FT(base, value) (BME_BFI32(&XCVR_PLL_LD_HPM_CAL2_REG(base), ((uint32_t)(value) << XCVR_PLL_LD_HPM_CAL2_CS_FT_SHIFT), XCVR_PLL_LD_HPM_CAL2_CS_FT_SHIFT, XCVR_PLL_LD_HPM_CAL2_CS_FT_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_HPM_SDM_FRACTION - PLL HPM SDM Fraction
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_HPM_SDM_FRACTION - PLL HPM SDM Fraction (RW)
 *
 * Reset value: 0x01FF0000U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_HPM_SDM_FRACTION register
 */
/*@{*/
#define XCVR_RD_PLL_HPM_SDM_FRACTION(base) (XCVR_PLL_HPM_SDM_FRACTION_REG(base))
#define XCVR_WR_PLL_HPM_SDM_FRACTION(base, value) (XCVR_PLL_HPM_SDM_FRACTION_REG(base) = (value))
#define XCVR_RMW_PLL_HPM_SDM_FRACTION(base, mask, value) (XCVR_WR_PLL_HPM_SDM_FRACTION(base, (XCVR_RD_PLL_HPM_SDM_FRACTION(base) & ~(mask)) | (value)))
#define XCVR_SET_PLL_HPM_SDM_FRACTION(base, value) (BME_OR32(&XCVR_PLL_HPM_SDM_FRACTION_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PLL_HPM_SDM_FRACTION(base, value) (BME_AND32(&XCVR_PLL_HPM_SDM_FRACTION_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PLL_HPM_SDM_FRACTION(base, value) (BME_XOR32(&XCVR_PLL_HPM_SDM_FRACTION_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_HPM_SDM_FRACTION bitfields
 */

/*!
 * @name Register XCVR_PLL_HPM_SDM_FRACTION, field HPM_NUM_SELECTED[9:0] (RO)
 *
 * This is the numerator that is currently being applied to the High Port Sigma
 * Delta Modulator, for valid Sigma Delta operation the resulting fraction
 * NUM/DENOM must be in the range -0.6 to +0.6
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_HPM_SDM_FRACTION_HPM_NUM_SELECTED field. */
#define XCVR_RD_PLL_HPM_SDM_FRACTION_HPM_NUM_SELECTED(base) ((XCVR_PLL_HPM_SDM_FRACTION_REG(base) & XCVR_PLL_HPM_SDM_FRACTION_HPM_NUM_SELECTED_MASK) >> XCVR_PLL_HPM_SDM_FRACTION_HPM_NUM_SELECTED_SHIFT)
#define XCVR_BRD_PLL_HPM_SDM_FRACTION_HPM_NUM_SELECTED(base) (BME_UBFX32(&XCVR_PLL_HPM_SDM_FRACTION_REG(base), XCVR_PLL_HPM_SDM_FRACTION_HPM_NUM_SELECTED_SHIFT, XCVR_PLL_HPM_SDM_FRACTION_HPM_NUM_SELECTED_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_HPM_SDM_FRACTION, field HPM_DENOM[25:16] (RW)
 *
 * This is the denominator that is currently being applied to the High Port
 * Sigma Delta Modulator, for valid Sigma Delta operation the resulting fraction
 * NUM/DENOM must be in the range -0.6 to +0.6 The High Port Sigma Delta Modulator
 * LSB in Hz can be calculated as follows: HP SDM LSB Resolution = High Port Array
 * LSB in Hz / 2^6 = 6e3/256 = 93.75 Hz The High Port Array LSB is expected to be
 * 6 kHz after calibration.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_HPM_SDM_FRACTION_HPM_DENOM field. */
#define XCVR_RD_PLL_HPM_SDM_FRACTION_HPM_DENOM(base) ((XCVR_PLL_HPM_SDM_FRACTION_REG(base) & XCVR_PLL_HPM_SDM_FRACTION_HPM_DENOM_MASK) >> XCVR_PLL_HPM_SDM_FRACTION_HPM_DENOM_SHIFT)
#define XCVR_BRD_PLL_HPM_SDM_FRACTION_HPM_DENOM(base) (BME_UBFX32(&XCVR_PLL_HPM_SDM_FRACTION_REG(base), XCVR_PLL_HPM_SDM_FRACTION_HPM_DENOM_SHIFT, XCVR_PLL_HPM_SDM_FRACTION_HPM_DENOM_WIDTH))

/*! @brief Set the HPM_DENOM field to a new value. */
#define XCVR_WR_PLL_HPM_SDM_FRACTION_HPM_DENOM(base, value) (XCVR_RMW_PLL_HPM_SDM_FRACTION(base, XCVR_PLL_HPM_SDM_FRACTION_HPM_DENOM_MASK, XCVR_PLL_HPM_SDM_FRACTION_HPM_DENOM(value)))
#define XCVR_BWR_PLL_HPM_SDM_FRACTION_HPM_DENOM(base, value) (BME_BFI32(&XCVR_PLL_HPM_SDM_FRACTION_REG(base), ((uint32_t)(value) << XCVR_PLL_HPM_SDM_FRACTION_HPM_DENOM_SHIFT), XCVR_PLL_HPM_SDM_FRACTION_HPM_DENOM_SHIFT, XCVR_PLL_HPM_SDM_FRACTION_HPM_DENOM_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_LP_MOD_CTRL - PLL Low Port Modulation Control
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_LP_MOD_CTRL - PLL Low Port Modulation Control (RW)
 *
 * Reset value: 0x08080000U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_LP_MOD_CTRL register
 */
/*@{*/
#define XCVR_RD_PLL_LP_MOD_CTRL(base) (XCVR_PLL_LP_MOD_CTRL_REG(base))
#define XCVR_WR_PLL_LP_MOD_CTRL(base, value) (XCVR_PLL_LP_MOD_CTRL_REG(base) = (value))
#define XCVR_RMW_PLL_LP_MOD_CTRL(base, mask, value) (XCVR_WR_PLL_LP_MOD_CTRL(base, (XCVR_RD_PLL_LP_MOD_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_PLL_LP_MOD_CTRL(base, value) (BME_OR32(&XCVR_PLL_LP_MOD_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PLL_LP_MOD_CTRL(base, value) (BME_AND32(&XCVR_PLL_LP_MOD_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PLL_LP_MOD_CTRL(base, value) (BME_XOR32(&XCVR_PLL_LP_MOD_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_LP_MOD_CTRL bitfields
 */

/*!
 * @name Register XCVR_PLL_LP_MOD_CTRL, field PLL_LOOP_DIVIDER_MANUAL[5:0] (RW)
 *
 * If PLL_LD_DIS is set, this register is the value that is applied to the PLL
 * Loop Divider i.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LP_MOD_CTRL_PLL_LOOP_DIVIDER_MANUAL field. */
#define XCVR_RD_PLL_LP_MOD_CTRL_PLL_LOOP_DIVIDER_MANUAL(base) ((XCVR_PLL_LP_MOD_CTRL_REG(base) & XCVR_PLL_LP_MOD_CTRL_PLL_LOOP_DIVIDER_MANUAL_MASK) >> XCVR_PLL_LP_MOD_CTRL_PLL_LOOP_DIVIDER_MANUAL_SHIFT)
#define XCVR_BRD_PLL_LP_MOD_CTRL_PLL_LOOP_DIVIDER_MANUAL(base) (BME_UBFX32(&XCVR_PLL_LP_MOD_CTRL_REG(base), XCVR_PLL_LP_MOD_CTRL_PLL_LOOP_DIVIDER_MANUAL_SHIFT, XCVR_PLL_LP_MOD_CTRL_PLL_LOOP_DIVIDER_MANUAL_WIDTH))

/*! @brief Set the PLL_LOOP_DIVIDER_MANUAL field to a new value. */
#define XCVR_WR_PLL_LP_MOD_CTRL_PLL_LOOP_DIVIDER_MANUAL(base, value) (XCVR_RMW_PLL_LP_MOD_CTRL(base, (XCVR_PLL_LP_MOD_CTRL_PLL_LOOP_DIVIDER_MANUAL_MASK | XCVR_PLL_LP_MOD_CTRL_LPFF_MASK), XCVR_PLL_LP_MOD_CTRL_PLL_LOOP_DIVIDER_MANUAL(value)))
#define XCVR_BWR_PLL_LP_MOD_CTRL_PLL_LOOP_DIVIDER_MANUAL(base, value) (BME_BFI32(&XCVR_PLL_LP_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_LP_MOD_CTRL_PLL_LOOP_DIVIDER_MANUAL_SHIFT), XCVR_PLL_LP_MOD_CTRL_PLL_LOOP_DIVIDER_MANUAL_SHIFT, XCVR_PLL_LP_MOD_CTRL_PLL_LOOP_DIVIDER_MANUAL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LP_MOD_CTRL, field PLL_LD_DIS[11] (RW)
 *
 * If this bit is set, the Low Port Sigma Delta Modulator output is disabled,
 * and the PLL Loop Divider value applied to the PLL comes from the
 * PLL_LOOP_DIVIDER_MANUAL register.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LP_MOD_CTRL_PLL_LD_DIS field. */
#define XCVR_RD_PLL_LP_MOD_CTRL_PLL_LD_DIS(base) ((XCVR_PLL_LP_MOD_CTRL_REG(base) & XCVR_PLL_LP_MOD_CTRL_PLL_LD_DIS_MASK) >> XCVR_PLL_LP_MOD_CTRL_PLL_LD_DIS_SHIFT)
#define XCVR_BRD_PLL_LP_MOD_CTRL_PLL_LD_DIS(base) (BME_UBFX32(&XCVR_PLL_LP_MOD_CTRL_REG(base), XCVR_PLL_LP_MOD_CTRL_PLL_LD_DIS_SHIFT, XCVR_PLL_LP_MOD_CTRL_PLL_LD_DIS_WIDTH))

/*! @brief Set the PLL_LD_DIS field to a new value. */
#define XCVR_WR_PLL_LP_MOD_CTRL_PLL_LD_DIS(base, value) (XCVR_RMW_PLL_LP_MOD_CTRL(base, (XCVR_PLL_LP_MOD_CTRL_PLL_LD_DIS_MASK | XCVR_PLL_LP_MOD_CTRL_LPFF_MASK), XCVR_PLL_LP_MOD_CTRL_PLL_LD_DIS(value)))
#define XCVR_BWR_PLL_LP_MOD_CTRL_PLL_LD_DIS(base, value) (BME_BFI32(&XCVR_PLL_LP_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_LP_MOD_CTRL_PLL_LD_DIS_SHIFT), XCVR_PLL_LP_MOD_CTRL_PLL_LD_DIS_SHIFT, XCVR_PLL_LP_MOD_CTRL_PLL_LD_DIS_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LP_MOD_CTRL, field LPFF[13] (W1C)
 *
 * This bit is set if the Low Port Sigma Delta Modulator output is invalid due
 * to an error in the Fraction applied, and this bit is cleared by writing a 1 to
 * it.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LP_MOD_CTRL_LPFF field. */
#define XCVR_RD_PLL_LP_MOD_CTRL_LPFF(base) ((XCVR_PLL_LP_MOD_CTRL_REG(base) & XCVR_PLL_LP_MOD_CTRL_LPFF_MASK) >> XCVR_PLL_LP_MOD_CTRL_LPFF_SHIFT)
#define XCVR_BRD_PLL_LP_MOD_CTRL_LPFF(base) (BME_UBFX32(&XCVR_PLL_LP_MOD_CTRL_REG(base), XCVR_PLL_LP_MOD_CTRL_LPFF_SHIFT, XCVR_PLL_LP_MOD_CTRL_LPFF_WIDTH))

/*! @brief Set the LPFF field to a new value. */
#define XCVR_WR_PLL_LP_MOD_CTRL_LPFF(base, value) (XCVR_RMW_PLL_LP_MOD_CTRL(base, XCVR_PLL_LP_MOD_CTRL_LPFF_MASK, XCVR_PLL_LP_MOD_CTRL_LPFF(value)))
#define XCVR_BWR_PLL_LP_MOD_CTRL_LPFF(base, value) (BME_BFI32(&XCVR_PLL_LP_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_LP_MOD_CTRL_LPFF_SHIFT), XCVR_PLL_LP_MOD_CTRL_LPFF_SHIFT, XCVR_PLL_LP_MOD_CTRL_LPFF_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LP_MOD_CTRL, field LPM_SDM_INV[14] (RW)
 *
 * If this bit is set the Scaled Baseband Frequency Word, including any
 * Dithering, will be Inverted before it is applied to the Low Port Sigma Delta Modulator.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LP_MOD_CTRL_LPM_SDM_INV field. */
#define XCVR_RD_PLL_LP_MOD_CTRL_LPM_SDM_INV(base) ((XCVR_PLL_LP_MOD_CTRL_REG(base) & XCVR_PLL_LP_MOD_CTRL_LPM_SDM_INV_MASK) >> XCVR_PLL_LP_MOD_CTRL_LPM_SDM_INV_SHIFT)
#define XCVR_BRD_PLL_LP_MOD_CTRL_LPM_SDM_INV(base) (BME_UBFX32(&XCVR_PLL_LP_MOD_CTRL_REG(base), XCVR_PLL_LP_MOD_CTRL_LPM_SDM_INV_SHIFT, XCVR_PLL_LP_MOD_CTRL_LPM_SDM_INV_WIDTH))

/*! @brief Set the LPM_SDM_INV field to a new value. */
#define XCVR_WR_PLL_LP_MOD_CTRL_LPM_SDM_INV(base, value) (XCVR_RMW_PLL_LP_MOD_CTRL(base, (XCVR_PLL_LP_MOD_CTRL_LPM_SDM_INV_MASK | XCVR_PLL_LP_MOD_CTRL_LPFF_MASK), XCVR_PLL_LP_MOD_CTRL_LPM_SDM_INV(value)))
#define XCVR_BWR_PLL_LP_MOD_CTRL_LPM_SDM_INV(base, value) (BME_BFI32(&XCVR_PLL_LP_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_LP_MOD_CTRL_LPM_SDM_INV_SHIFT), XCVR_PLL_LP_MOD_CTRL_LPM_SDM_INV_SHIFT, XCVR_PLL_LP_MOD_CTRL_LPM_SDM_INV_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LP_MOD_CTRL, field LPM_SDM_DIS[15] (RW)
 *
 * This bit controls the Modulation of the Low Port Sigma Delta. If this bit is
 * set, the Low Port Sigma Delta will be active and control the PLL to maintain a
 * steady frequency based on the current Integer, Numerator, and Denominator
 * values that are being applied. Modulation and Dithering will be disabled.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LP_MOD_CTRL_LPM_SDM_DIS field. */
#define XCVR_RD_PLL_LP_MOD_CTRL_LPM_SDM_DIS(base) ((XCVR_PLL_LP_MOD_CTRL_REG(base) & XCVR_PLL_LP_MOD_CTRL_LPM_SDM_DIS_MASK) >> XCVR_PLL_LP_MOD_CTRL_LPM_SDM_DIS_SHIFT)
#define XCVR_BRD_PLL_LP_MOD_CTRL_LPM_SDM_DIS(base) (BME_UBFX32(&XCVR_PLL_LP_MOD_CTRL_REG(base), XCVR_PLL_LP_MOD_CTRL_LPM_SDM_DIS_SHIFT, XCVR_PLL_LP_MOD_CTRL_LPM_SDM_DIS_WIDTH))

/*! @brief Set the LPM_SDM_DIS field to a new value. */
#define XCVR_WR_PLL_LP_MOD_CTRL_LPM_SDM_DIS(base, value) (XCVR_RMW_PLL_LP_MOD_CTRL(base, (XCVR_PLL_LP_MOD_CTRL_LPM_SDM_DIS_MASK | XCVR_PLL_LP_MOD_CTRL_LPFF_MASK), XCVR_PLL_LP_MOD_CTRL_LPM_SDM_DIS(value)))
#define XCVR_BWR_PLL_LP_MOD_CTRL_LPM_SDM_DIS(base, value) (BME_BFI32(&XCVR_PLL_LP_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_LP_MOD_CTRL_LPM_SDM_DIS_SHIFT), XCVR_PLL_LP_MOD_CTRL_LPM_SDM_DIS_SHIFT, XCVR_PLL_LP_MOD_CTRL_LPM_SDM_DIS_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LP_MOD_CTRL, field LPM_DTH_SCL[19:16] (RW)
 *
 * This register controls the scale of the Dithering added to the Scaled
 * Baseband Frequency Word before it is applied to the Low Port Sigma Delta Modulator as
 * the LPM Numerator. The unit for the ranges shown below is the LP SDM LSB in
 * Hz.
 *
 * Values:
 * - 0b0000 - Reserved
 * - 0b0001 - Reserved
 * - 0b0010 - Reserved
 * - 0b0011 - Reserved
 * - 0b0100 - Reserved
 * - 0b0101 - -128 to 96
 * - 0b0110 - -256 to 192
 * - 0b0111 - -512 to 384
 * - 0b1000 - -1024 to 768
 * - 0b1001 - -2048 to 1536
 * - 0b1010 - -4096 to 3072
 * - 0b1011 - -8192 to 6144
 * - 0b1100 - Reserved
 * - 0b1101 - Reserved
 * - 0b1110 - Reserved
 * - 0b1111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LP_MOD_CTRL_LPM_DTH_SCL field. */
#define XCVR_RD_PLL_LP_MOD_CTRL_LPM_DTH_SCL(base) ((XCVR_PLL_LP_MOD_CTRL_REG(base) & XCVR_PLL_LP_MOD_CTRL_LPM_DTH_SCL_MASK) >> XCVR_PLL_LP_MOD_CTRL_LPM_DTH_SCL_SHIFT)
#define XCVR_BRD_PLL_LP_MOD_CTRL_LPM_DTH_SCL(base) (BME_UBFX32(&XCVR_PLL_LP_MOD_CTRL_REG(base), XCVR_PLL_LP_MOD_CTRL_LPM_DTH_SCL_SHIFT, XCVR_PLL_LP_MOD_CTRL_LPM_DTH_SCL_WIDTH))

/*! @brief Set the LPM_DTH_SCL field to a new value. */
#define XCVR_WR_PLL_LP_MOD_CTRL_LPM_DTH_SCL(base, value) (XCVR_RMW_PLL_LP_MOD_CTRL(base, (XCVR_PLL_LP_MOD_CTRL_LPM_DTH_SCL_MASK | XCVR_PLL_LP_MOD_CTRL_LPFF_MASK), XCVR_PLL_LP_MOD_CTRL_LPM_DTH_SCL(value)))
#define XCVR_BWR_PLL_LP_MOD_CTRL_LPM_DTH_SCL(base, value) (BME_BFI32(&XCVR_PLL_LP_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_LP_MOD_CTRL_LPM_DTH_SCL_SHIFT), XCVR_PLL_LP_MOD_CTRL_LPM_DTH_SCL_SHIFT, XCVR_PLL_LP_MOD_CTRL_LPM_DTH_SCL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LP_MOD_CTRL, field LPM_D_CTRL[22] (RW)
 *
 * If LPM_D_OVRD is set, this bit turns LPM Dithering on and off.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LP_MOD_CTRL_LPM_D_CTRL field. */
#define XCVR_RD_PLL_LP_MOD_CTRL_LPM_D_CTRL(base) ((XCVR_PLL_LP_MOD_CTRL_REG(base) & XCVR_PLL_LP_MOD_CTRL_LPM_D_CTRL_MASK) >> XCVR_PLL_LP_MOD_CTRL_LPM_D_CTRL_SHIFT)
#define XCVR_BRD_PLL_LP_MOD_CTRL_LPM_D_CTRL(base) (BME_UBFX32(&XCVR_PLL_LP_MOD_CTRL_REG(base), XCVR_PLL_LP_MOD_CTRL_LPM_D_CTRL_SHIFT, XCVR_PLL_LP_MOD_CTRL_LPM_D_CTRL_WIDTH))

/*! @brief Set the LPM_D_CTRL field to a new value. */
#define XCVR_WR_PLL_LP_MOD_CTRL_LPM_D_CTRL(base, value) (XCVR_RMW_PLL_LP_MOD_CTRL(base, (XCVR_PLL_LP_MOD_CTRL_LPM_D_CTRL_MASK | XCVR_PLL_LP_MOD_CTRL_LPFF_MASK), XCVR_PLL_LP_MOD_CTRL_LPM_D_CTRL(value)))
#define XCVR_BWR_PLL_LP_MOD_CTRL_LPM_D_CTRL(base, value) (BME_BFI32(&XCVR_PLL_LP_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_LP_MOD_CTRL_LPM_D_CTRL_SHIFT), XCVR_PLL_LP_MOD_CTRL_LPM_D_CTRL_SHIFT, XCVR_PLL_LP_MOD_CTRL_LPM_D_CTRL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LP_MOD_CTRL, field LPM_D_OVRD[23] (RW)
 *
 * When this bit is set, the Scaled Baseband Frequency Word applied to the Low
 * Port Sigma Delta Modulator will be dithered if LPM_D_CTRL is set, and not
 * dithered if LPM_D_CTRL is cleared. If this bit is cleared, then the LPM Numerator
 * will be dithered in Radio Receive mode, and also when the LPM Numerator
 * approaches an Integer value in order to preserve the validity of the Sigma Delta
 * Modulator output.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LP_MOD_CTRL_LPM_D_OVRD field. */
#define XCVR_RD_PLL_LP_MOD_CTRL_LPM_D_OVRD(base) ((XCVR_PLL_LP_MOD_CTRL_REG(base) & XCVR_PLL_LP_MOD_CTRL_LPM_D_OVRD_MASK) >> XCVR_PLL_LP_MOD_CTRL_LPM_D_OVRD_SHIFT)
#define XCVR_BRD_PLL_LP_MOD_CTRL_LPM_D_OVRD(base) (BME_UBFX32(&XCVR_PLL_LP_MOD_CTRL_REG(base), XCVR_PLL_LP_MOD_CTRL_LPM_D_OVRD_SHIFT, XCVR_PLL_LP_MOD_CTRL_LPM_D_OVRD_WIDTH))

/*! @brief Set the LPM_D_OVRD field to a new value. */
#define XCVR_WR_PLL_LP_MOD_CTRL_LPM_D_OVRD(base, value) (XCVR_RMW_PLL_LP_MOD_CTRL(base, (XCVR_PLL_LP_MOD_CTRL_LPM_D_OVRD_MASK | XCVR_PLL_LP_MOD_CTRL_LPFF_MASK), XCVR_PLL_LP_MOD_CTRL_LPM_D_OVRD(value)))
#define XCVR_BWR_PLL_LP_MOD_CTRL_LPM_D_OVRD(base, value) (BME_BFI32(&XCVR_PLL_LP_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_LP_MOD_CTRL_LPM_D_OVRD_SHIFT), XCVR_PLL_LP_MOD_CTRL_LPM_D_OVRD_SHIFT, XCVR_PLL_LP_MOD_CTRL_LPM_D_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LP_MOD_CTRL, field LPM_SCALE[27:24] (RW)
 *
 * This register controls the scaling of the Baseband Frequency Word and is used
 * to match the Modulation Frequency Deviation required to the Low Port Sigma
 * Delta Modulator LSB size in Hz.
 *
 * Values:
 * - 0b0000 - No Scaling
 * - 0b0001 - Multiply by 2
 * - 0b0010 - Multiply by 4
 * - 0b0011 - Multiply by 8
 * - 0b0100 - Multiply by 16
 * - 0b0101 - Multiply by 32
 * - 0b0110 - Multiply by 64
 * - 0b0111 - Multiply by 128
 * - 0b1000 - Multiply by 256
 * - 0b1001 - Multiply by 512
 * - 0b1010 - Multiply by 1024
 * - 0b1011 - Multiply by 2048
 * - 0b1100 - Reserved
 * - 0b1101 - Reserved
 * - 0b1110 - Reserved
 * - 0b1111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LP_MOD_CTRL_LPM_SCALE field. */
#define XCVR_RD_PLL_LP_MOD_CTRL_LPM_SCALE(base) ((XCVR_PLL_LP_MOD_CTRL_REG(base) & XCVR_PLL_LP_MOD_CTRL_LPM_SCALE_MASK) >> XCVR_PLL_LP_MOD_CTRL_LPM_SCALE_SHIFT)
#define XCVR_BRD_PLL_LP_MOD_CTRL_LPM_SCALE(base) (BME_UBFX32(&XCVR_PLL_LP_MOD_CTRL_REG(base), XCVR_PLL_LP_MOD_CTRL_LPM_SCALE_SHIFT, XCVR_PLL_LP_MOD_CTRL_LPM_SCALE_WIDTH))

/*! @brief Set the LPM_SCALE field to a new value. */
#define XCVR_WR_PLL_LP_MOD_CTRL_LPM_SCALE(base, value) (XCVR_RMW_PLL_LP_MOD_CTRL(base, (XCVR_PLL_LP_MOD_CTRL_LPM_SCALE_MASK | XCVR_PLL_LP_MOD_CTRL_LPFF_MASK), XCVR_PLL_LP_MOD_CTRL_LPM_SCALE(value)))
#define XCVR_BWR_PLL_LP_MOD_CTRL_LPM_SCALE(base, value) (BME_BFI32(&XCVR_PLL_LP_MOD_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_LP_MOD_CTRL_LPM_SCALE_SHIFT), XCVR_PLL_LP_MOD_CTRL_LPM_SCALE_SHIFT, XCVR_PLL_LP_MOD_CTRL_LPM_SCALE_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_LP_SDM_CTRL1 - PLL Low Port SDM Control 1
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_LP_SDM_CTRL1 - PLL Low Port SDM Control 1 (RW)
 *
 * Reset value: 0x00260026U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_LP_SDM_CTRL1 register
 */
/*@{*/
#define XCVR_RD_PLL_LP_SDM_CTRL1(base) (XCVR_PLL_LP_SDM_CTRL1_REG(base))
#define XCVR_WR_PLL_LP_SDM_CTRL1(base, value) (XCVR_PLL_LP_SDM_CTRL1_REG(base) = (value))
#define XCVR_RMW_PLL_LP_SDM_CTRL1(base, mask, value) (XCVR_WR_PLL_LP_SDM_CTRL1(base, (XCVR_RD_PLL_LP_SDM_CTRL1(base) & ~(mask)) | (value)))
#define XCVR_SET_PLL_LP_SDM_CTRL1(base, value) (BME_OR32(&XCVR_PLL_LP_SDM_CTRL1_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PLL_LP_SDM_CTRL1(base, value) (BME_AND32(&XCVR_PLL_LP_SDM_CTRL1_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PLL_LP_SDM_CTRL1(base, value) (BME_XOR32(&XCVR_PLL_LP_SDM_CTRL1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_LP_SDM_CTRL1 bitfields
 */

/*!
 * @name Register XCVR_PLL_LP_SDM_CTRL1, field LPM_INTG_SELECTED[6:0] (RO)
 *
 * This shows the integer value that is currently being applied to the low port
 * sigma delta modulator.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LP_SDM_CTRL1_LPM_INTG_SELECTED field. */
#define XCVR_RD_PLL_LP_SDM_CTRL1_LPM_INTG_SELECTED(base) ((XCVR_PLL_LP_SDM_CTRL1_REG(base) & XCVR_PLL_LP_SDM_CTRL1_LPM_INTG_SELECTED_MASK) >> XCVR_PLL_LP_SDM_CTRL1_LPM_INTG_SELECTED_SHIFT)
#define XCVR_BRD_PLL_LP_SDM_CTRL1_LPM_INTG_SELECTED(base) (BME_UBFX32(&XCVR_PLL_LP_SDM_CTRL1_REG(base), XCVR_PLL_LP_SDM_CTRL1_LPM_INTG_SELECTED_SHIFT, XCVR_PLL_LP_SDM_CTRL1_LPM_INTG_SELECTED_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LP_SDM_CTRL1, field LPM_INTG[22:16] (RW)
 *
 * If SDM_MAP_DIS is set, this register is the value that is applied to the Low
 * Port Sigma Delta Modulator for the Integer, the nominal range is 36 to 39 in
 * decimal.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LP_SDM_CTRL1_LPM_INTG field. */
#define XCVR_RD_PLL_LP_SDM_CTRL1_LPM_INTG(base) ((XCVR_PLL_LP_SDM_CTRL1_REG(base) & XCVR_PLL_LP_SDM_CTRL1_LPM_INTG_MASK) >> XCVR_PLL_LP_SDM_CTRL1_LPM_INTG_SHIFT)
#define XCVR_BRD_PLL_LP_SDM_CTRL1_LPM_INTG(base) (BME_UBFX32(&XCVR_PLL_LP_SDM_CTRL1_REG(base), XCVR_PLL_LP_SDM_CTRL1_LPM_INTG_SHIFT, XCVR_PLL_LP_SDM_CTRL1_LPM_INTG_WIDTH))

/*! @brief Set the LPM_INTG field to a new value. */
#define XCVR_WR_PLL_LP_SDM_CTRL1_LPM_INTG(base, value) (XCVR_RMW_PLL_LP_SDM_CTRL1(base, XCVR_PLL_LP_SDM_CTRL1_LPM_INTG_MASK, XCVR_PLL_LP_SDM_CTRL1_LPM_INTG(value)))
#define XCVR_BWR_PLL_LP_SDM_CTRL1_LPM_INTG(base, value) (BME_BFI32(&XCVR_PLL_LP_SDM_CTRL1_REG(base), ((uint32_t)(value) << XCVR_PLL_LP_SDM_CTRL1_LPM_INTG_SHIFT), XCVR_PLL_LP_SDM_CTRL1_LPM_INTG_SHIFT, XCVR_PLL_LP_SDM_CTRL1_LPM_INTG_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_LP_SDM_CTRL1, field SDM_MAP_DIS[31] (RW)
 *
 * If this bit is set, the Low Port Sigma Delta Modulator internal frequency
 * mapping based on Protocol specific channel numbers is disabled, and the Radio
 * Channel Frequency is selected by setting the LPM_INTG, LPM_NUM, and LPM_DENOM
 * registers to get a frequency that equals ((Reference Clock Frequency x 2) x
 * (LPM_INTG + (LPM_NUM / LPM_DENOM))
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LP_SDM_CTRL1_SDM_MAP_DIS field. */
#define XCVR_RD_PLL_LP_SDM_CTRL1_SDM_MAP_DIS(base) ((XCVR_PLL_LP_SDM_CTRL1_REG(base) & XCVR_PLL_LP_SDM_CTRL1_SDM_MAP_DIS_MASK) >> XCVR_PLL_LP_SDM_CTRL1_SDM_MAP_DIS_SHIFT)
#define XCVR_BRD_PLL_LP_SDM_CTRL1_SDM_MAP_DIS(base) (BME_UBFX32(&XCVR_PLL_LP_SDM_CTRL1_REG(base), XCVR_PLL_LP_SDM_CTRL1_SDM_MAP_DIS_SHIFT, XCVR_PLL_LP_SDM_CTRL1_SDM_MAP_DIS_WIDTH))

/*! @brief Set the SDM_MAP_DIS field to a new value. */
#define XCVR_WR_PLL_LP_SDM_CTRL1_SDM_MAP_DIS(base, value) (XCVR_RMW_PLL_LP_SDM_CTRL1(base, XCVR_PLL_LP_SDM_CTRL1_SDM_MAP_DIS_MASK, XCVR_PLL_LP_SDM_CTRL1_SDM_MAP_DIS(value)))
#define XCVR_BWR_PLL_LP_SDM_CTRL1_SDM_MAP_DIS(base, value) (BME_BFI32(&XCVR_PLL_LP_SDM_CTRL1_REG(base), ((uint32_t)(value) << XCVR_PLL_LP_SDM_CTRL1_SDM_MAP_DIS_SHIFT), XCVR_PLL_LP_SDM_CTRL1_SDM_MAP_DIS_SHIFT, XCVR_PLL_LP_SDM_CTRL1_SDM_MAP_DIS_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_LP_SDM_CTRL2 - PLL Low Port SDM Control 2
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_LP_SDM_CTRL2 - PLL Low Port SDM Control 2 (RW)
 *
 * Reset value: 0x02000000U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_LP_SDM_CTRL2 register
 */
/*@{*/
#define XCVR_RD_PLL_LP_SDM_CTRL2(base) (XCVR_PLL_LP_SDM_CTRL2_REG(base))
#define XCVR_WR_PLL_LP_SDM_CTRL2(base, value) (XCVR_PLL_LP_SDM_CTRL2_REG(base) = (value))
#define XCVR_RMW_PLL_LP_SDM_CTRL2(base, mask, value) (XCVR_WR_PLL_LP_SDM_CTRL2(base, (XCVR_RD_PLL_LP_SDM_CTRL2(base) & ~(mask)) | (value)))
#define XCVR_SET_PLL_LP_SDM_CTRL2(base, value) (BME_OR32(&XCVR_PLL_LP_SDM_CTRL2_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PLL_LP_SDM_CTRL2(base, value) (BME_AND32(&XCVR_PLL_LP_SDM_CTRL2_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PLL_LP_SDM_CTRL2(base, value) (BME_XOR32(&XCVR_PLL_LP_SDM_CTRL2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_LP_SDM_CTRL2 bitfields
 */

/*!
 * @name Register XCVR_PLL_LP_SDM_CTRL2, field LPM_NUM[27:0] (RW)
 *
 * If SDM_MAP_DIS is set, this register is the signed 27 bit value that is
 * applied to the Low Port Sigma Delta Modulator for the Numerator. For valid Sigma
 * Delta operation the resulting fraction NUM/DENOM must be in the range -0.6 to
 * +0.6
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LP_SDM_CTRL2_LPM_NUM field. */
#define XCVR_RD_PLL_LP_SDM_CTRL2_LPM_NUM(base) ((XCVR_PLL_LP_SDM_CTRL2_REG(base) & XCVR_PLL_LP_SDM_CTRL2_LPM_NUM_MASK) >> XCVR_PLL_LP_SDM_CTRL2_LPM_NUM_SHIFT)
#define XCVR_BRD_PLL_LP_SDM_CTRL2_LPM_NUM(base) (XCVR_RD_PLL_LP_SDM_CTRL2_LPM_NUM(base))

/*! @brief Set the LPM_NUM field to a new value. */
#define XCVR_WR_PLL_LP_SDM_CTRL2_LPM_NUM(base, value) (XCVR_RMW_PLL_LP_SDM_CTRL2(base, XCVR_PLL_LP_SDM_CTRL2_LPM_NUM_MASK, XCVR_PLL_LP_SDM_CTRL2_LPM_NUM(value)))
#define XCVR_BWR_PLL_LP_SDM_CTRL2_LPM_NUM(base, value) (XCVR_WR_PLL_LP_SDM_CTRL2_LPM_NUM(base, value))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_LP_SDM_CTRL3 - PLL Low Port SDM Control 3
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_LP_SDM_CTRL3 - PLL Low Port SDM Control 3 (RW)
 *
 * Reset value: 0x04000000U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_LP_SDM_CTRL3 register
 */
/*@{*/
#define XCVR_RD_PLL_LP_SDM_CTRL3(base) (XCVR_PLL_LP_SDM_CTRL3_REG(base))
#define XCVR_WR_PLL_LP_SDM_CTRL3(base, value) (XCVR_PLL_LP_SDM_CTRL3_REG(base) = (value))
#define XCVR_RMW_PLL_LP_SDM_CTRL3(base, mask, value) (XCVR_WR_PLL_LP_SDM_CTRL3(base, (XCVR_RD_PLL_LP_SDM_CTRL3(base) & ~(mask)) | (value)))
#define XCVR_SET_PLL_LP_SDM_CTRL3(base, value) (BME_OR32(&XCVR_PLL_LP_SDM_CTRL3_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PLL_LP_SDM_CTRL3(base, value) (BME_AND32(&XCVR_PLL_LP_SDM_CTRL3_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PLL_LP_SDM_CTRL3(base, value) (BME_XOR32(&XCVR_PLL_LP_SDM_CTRL3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_LP_SDM_CTRL3 bitfields
 */

/*!
 * @name Register XCVR_PLL_LP_SDM_CTRL3, field LPM_DENOM[27:0] (RW)
 *
 * If SDM_MAP_DIS is set, this register is the signed 27 bit value that is
 * applied to the Low Port Sigma Delta Modulator for the Denominator. For valid Sigma
 * Delta operation the resulting fraction NUM/DENOM must be in the range -0.6 to
 * +0.6 The Low Port Sigma Delta Modulator LSB in Hz can be calculated as
 * follows: LP SDM LSB Resolution = Reference Clock Frequency / LPM_DENOM value The
 * default value of LPM_DENOM for a 32 MHz reference is 2 raised to the 26th power,
 * so the SDM LSB is 0.4768 Hz
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LP_SDM_CTRL3_LPM_DENOM field. */
#define XCVR_RD_PLL_LP_SDM_CTRL3_LPM_DENOM(base) ((XCVR_PLL_LP_SDM_CTRL3_REG(base) & XCVR_PLL_LP_SDM_CTRL3_LPM_DENOM_MASK) >> XCVR_PLL_LP_SDM_CTRL3_LPM_DENOM_SHIFT)
#define XCVR_BRD_PLL_LP_SDM_CTRL3_LPM_DENOM(base) (XCVR_RD_PLL_LP_SDM_CTRL3_LPM_DENOM(base))

/*! @brief Set the LPM_DENOM field to a new value. */
#define XCVR_WR_PLL_LP_SDM_CTRL3_LPM_DENOM(base, value) (XCVR_RMW_PLL_LP_SDM_CTRL3(base, XCVR_PLL_LP_SDM_CTRL3_LPM_DENOM_MASK, XCVR_PLL_LP_SDM_CTRL3_LPM_DENOM(value)))
#define XCVR_BWR_PLL_LP_SDM_CTRL3_LPM_DENOM(base, value) (XCVR_WR_PLL_LP_SDM_CTRL3_LPM_DENOM(base, value))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_LP_SDM_NUM - PLL Low Port SDM Numerator Applied
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_LP_SDM_NUM - PLL Low Port SDM Numerator Applied (RO)
 *
 * Reset value: 0x0E200000U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_LP_SDM_NUM register
 */
/*@{*/
#define XCVR_RD_PLL_LP_SDM_NUM(base) (XCVR_PLL_LP_SDM_NUM_REG(base))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_LP_SDM_NUM bitfields
 */

/*!
 * @name Register XCVR_PLL_LP_SDM_NUM, field LPM_NUM_SELECTED[27:0] (RO)
 *
 * This is the value that is currently being applied to the sigma delta
 * modulator, for valid Sigma Delta operation the resulting fraction NUM/DENOM must be in
 * the range -0.6 to +0.6
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LP_SDM_NUM_LPM_NUM_SELECTED field. */
#define XCVR_RD_PLL_LP_SDM_NUM_LPM_NUM_SELECTED(base) ((XCVR_PLL_LP_SDM_NUM_REG(base) & XCVR_PLL_LP_SDM_NUM_LPM_NUM_SELECTED_MASK) >> XCVR_PLL_LP_SDM_NUM_LPM_NUM_SELECTED_SHIFT)
#define XCVR_BRD_PLL_LP_SDM_NUM_LPM_NUM_SELECTED(base) (XCVR_RD_PLL_LP_SDM_NUM_LPM_NUM_SELECTED(base))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_LP_SDM_DENOM - PLL Low Port SDM Denominator Applied
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_LP_SDM_DENOM - PLL Low Port SDM Denominator Applied (RO)
 *
 * Reset value: 0x04000000U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_LP_SDM_DENOM register
 */
/*@{*/
#define XCVR_RD_PLL_LP_SDM_DENOM(base) (XCVR_PLL_LP_SDM_DENOM_REG(base))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_LP_SDM_DENOM bitfields
 */

/*!
 * @name Register XCVR_PLL_LP_SDM_DENOM, field LPM_DENOM_SELECTED[27:0] (RO)
 *
 * This is the value that is currently being applied to the sigma delta
 * modulator, for valid Sigma Delta operation the resulting fraction NUM/DENOM must be in
 * the range -0.6 to +0.6
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_LP_SDM_DENOM_LPM_DENOM_SELECTED field. */
#define XCVR_RD_PLL_LP_SDM_DENOM_LPM_DENOM_SELECTED(base) ((XCVR_PLL_LP_SDM_DENOM_REG(base) & XCVR_PLL_LP_SDM_DENOM_LPM_DENOM_SELECTED_MASK) >> XCVR_PLL_LP_SDM_DENOM_LPM_DENOM_SELECTED_SHIFT)
#define XCVR_BRD_PLL_LP_SDM_DENOM_LPM_DENOM_SELECTED(base) (XCVR_RD_PLL_LP_SDM_DENOM_LPM_DENOM_SELECTED(base))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_DELAY_MATCH - PLL Delay Matching
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_DELAY_MATCH - PLL Delay Matching (RW)
 *
 * Reset value: 0x00000201U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_DELAY_MATCH register
 */
/*@{*/
#define XCVR_RD_PLL_DELAY_MATCH(base) (XCVR_PLL_DELAY_MATCH_REG(base))
#define XCVR_WR_PLL_DELAY_MATCH(base, value) (XCVR_PLL_DELAY_MATCH_REG(base) = (value))
#define XCVR_RMW_PLL_DELAY_MATCH(base, mask, value) (XCVR_WR_PLL_DELAY_MATCH(base, (XCVR_RD_PLL_DELAY_MATCH(base) & ~(mask)) | (value)))
#define XCVR_SET_PLL_DELAY_MATCH(base, value) (BME_OR32(&XCVR_PLL_DELAY_MATCH_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PLL_DELAY_MATCH(base, value) (BME_AND32(&XCVR_PLL_DELAY_MATCH_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PLL_DELAY_MATCH(base, value) (BME_XOR32(&XCVR_PLL_DELAY_MATCH_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_DELAY_MATCH bitfields
 */

/*!
 * @name Register XCVR_PLL_DELAY_MATCH, field LP_SDM_DELAY[3:0] (RW)
 *
 * This register selects the number of clock cycles of the (PLL Sigma Delta
 * Clock) to delay the Low Port Sigma Delta modulation of the PLL Loop Divider.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_DELAY_MATCH_LP_SDM_DELAY field. */
#define XCVR_RD_PLL_DELAY_MATCH_LP_SDM_DELAY(base) ((XCVR_PLL_DELAY_MATCH_REG(base) & XCVR_PLL_DELAY_MATCH_LP_SDM_DELAY_MASK) >> XCVR_PLL_DELAY_MATCH_LP_SDM_DELAY_SHIFT)
#define XCVR_BRD_PLL_DELAY_MATCH_LP_SDM_DELAY(base) (BME_UBFX32(&XCVR_PLL_DELAY_MATCH_REG(base), XCVR_PLL_DELAY_MATCH_LP_SDM_DELAY_SHIFT, XCVR_PLL_DELAY_MATCH_LP_SDM_DELAY_WIDTH))

/*! @brief Set the LP_SDM_DELAY field to a new value. */
#define XCVR_WR_PLL_DELAY_MATCH_LP_SDM_DELAY(base, value) (XCVR_RMW_PLL_DELAY_MATCH(base, XCVR_PLL_DELAY_MATCH_LP_SDM_DELAY_MASK, XCVR_PLL_DELAY_MATCH_LP_SDM_DELAY(value)))
#define XCVR_BWR_PLL_DELAY_MATCH_LP_SDM_DELAY(base, value) (BME_BFI32(&XCVR_PLL_DELAY_MATCH_REG(base), ((uint32_t)(value) << XCVR_PLL_DELAY_MATCH_LP_SDM_DELAY_SHIFT), XCVR_PLL_DELAY_MATCH_LP_SDM_DELAY_SHIFT, XCVR_PLL_DELAY_MATCH_LP_SDM_DELAY_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_DELAY_MATCH, field HPM_SDM_DELAY[11:8] (RW)
 *
 * This register selects the number of clock cycles of the (PLL Sigma Delta
 * Clock divided by 2) to delay the High Port Sigma Delta modulation of the VCO High
 * Port Bank LSB. Note that the High Port SDM is clocked by the (PLL Sigma Delta
 * Clock) but the modulation is based on a divide by 2 version of this same clock.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_DELAY_MATCH_HPM_SDM_DELAY field. */
#define XCVR_RD_PLL_DELAY_MATCH_HPM_SDM_DELAY(base) ((XCVR_PLL_DELAY_MATCH_REG(base) & XCVR_PLL_DELAY_MATCH_HPM_SDM_DELAY_MASK) >> XCVR_PLL_DELAY_MATCH_HPM_SDM_DELAY_SHIFT)
#define XCVR_BRD_PLL_DELAY_MATCH_HPM_SDM_DELAY(base) (BME_UBFX32(&XCVR_PLL_DELAY_MATCH_REG(base), XCVR_PLL_DELAY_MATCH_HPM_SDM_DELAY_SHIFT, XCVR_PLL_DELAY_MATCH_HPM_SDM_DELAY_WIDTH))

/*! @brief Set the HPM_SDM_DELAY field to a new value. */
#define XCVR_WR_PLL_DELAY_MATCH_HPM_SDM_DELAY(base, value) (XCVR_RMW_PLL_DELAY_MATCH(base, XCVR_PLL_DELAY_MATCH_HPM_SDM_DELAY_MASK, XCVR_PLL_DELAY_MATCH_HPM_SDM_DELAY(value)))
#define XCVR_BWR_PLL_DELAY_MATCH_HPM_SDM_DELAY(base, value) (BME_BFI32(&XCVR_PLL_DELAY_MATCH_REG(base), ((uint32_t)(value) << XCVR_PLL_DELAY_MATCH_HPM_SDM_DELAY_SHIFT), XCVR_PLL_DELAY_MATCH_HPM_SDM_DELAY_SHIFT, XCVR_PLL_DELAY_MATCH_HPM_SDM_DELAY_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_DELAY_MATCH, field HPM_BANK_DELAY[19:16] (RW)
 *
 * This register selects the number of clock cycles of the (PLL Sigma Delta
 * Clock divided by 2) to delay the High Port modulation of the VCO High Port Bank
 * Array.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_DELAY_MATCH_HPM_BANK_DELAY field. */
#define XCVR_RD_PLL_DELAY_MATCH_HPM_BANK_DELAY(base) ((XCVR_PLL_DELAY_MATCH_REG(base) & XCVR_PLL_DELAY_MATCH_HPM_BANK_DELAY_MASK) >> XCVR_PLL_DELAY_MATCH_HPM_BANK_DELAY_SHIFT)
#define XCVR_BRD_PLL_DELAY_MATCH_HPM_BANK_DELAY(base) (BME_UBFX32(&XCVR_PLL_DELAY_MATCH_REG(base), XCVR_PLL_DELAY_MATCH_HPM_BANK_DELAY_SHIFT, XCVR_PLL_DELAY_MATCH_HPM_BANK_DELAY_WIDTH))

/*! @brief Set the HPM_BANK_DELAY field to a new value. */
#define XCVR_WR_PLL_DELAY_MATCH_HPM_BANK_DELAY(base, value) (XCVR_RMW_PLL_DELAY_MATCH(base, XCVR_PLL_DELAY_MATCH_HPM_BANK_DELAY_MASK, XCVR_PLL_DELAY_MATCH_HPM_BANK_DELAY(value)))
#define XCVR_BWR_PLL_DELAY_MATCH_HPM_BANK_DELAY(base, value) (BME_BFI32(&XCVR_PLL_DELAY_MATCH_REG(base), ((uint32_t)(value) << XCVR_PLL_DELAY_MATCH_HPM_BANK_DELAY_SHIFT), XCVR_PLL_DELAY_MATCH_HPM_BANK_DELAY_SHIFT, XCVR_PLL_DELAY_MATCH_HPM_BANK_DELAY_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_CTUNE_CTRL - PLL Coarse Tune Control
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_CTUNE_CTRL - PLL Coarse Tune Control (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_CTUNE_CTRL register
 */
/*@{*/
#define XCVR_RD_PLL_CTUNE_CTRL(base) (XCVR_PLL_CTUNE_CTRL_REG(base))
#define XCVR_WR_PLL_CTUNE_CTRL(base, value) (XCVR_PLL_CTUNE_CTRL_REG(base) = (value))
#define XCVR_RMW_PLL_CTUNE_CTRL(base, mask, value) (XCVR_WR_PLL_CTUNE_CTRL(base, (XCVR_RD_PLL_CTUNE_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_PLL_CTUNE_CTRL(base, value) (BME_OR32(&XCVR_PLL_CTUNE_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PLL_CTUNE_CTRL(base, value) (BME_AND32(&XCVR_PLL_CTUNE_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PLL_CTUNE_CTRL(base, value) (BME_XOR32(&XCVR_PLL_CTUNE_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_CTUNE_CTRL bitfields
 */

/*!
 * @name Register XCVR_PLL_CTUNE_CTRL, field CTUNE_TARGET_MANUAL[11:0] (RW)
 *
 * If CTUNE_TD is set, this register is the value that is presented to the
 * Coarse Tune Calibrator as the Frequency Target in MHz. The nominal range of this
 * target is from 2360 to 2487 in decimal.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTUNE_CTRL_CTUNE_TARGET_MANUAL field. */
#define XCVR_RD_PLL_CTUNE_CTRL_CTUNE_TARGET_MANUAL(base) ((XCVR_PLL_CTUNE_CTRL_REG(base) & XCVR_PLL_CTUNE_CTRL_CTUNE_TARGET_MANUAL_MASK) >> XCVR_PLL_CTUNE_CTRL_CTUNE_TARGET_MANUAL_SHIFT)
#define XCVR_BRD_PLL_CTUNE_CTRL_CTUNE_TARGET_MANUAL(base) (BME_UBFX32(&XCVR_PLL_CTUNE_CTRL_REG(base), XCVR_PLL_CTUNE_CTRL_CTUNE_TARGET_MANUAL_SHIFT, XCVR_PLL_CTUNE_CTRL_CTUNE_TARGET_MANUAL_WIDTH))

/*! @brief Set the CTUNE_TARGET_MANUAL field to a new value. */
#define XCVR_WR_PLL_CTUNE_CTRL_CTUNE_TARGET_MANUAL(base, value) (XCVR_RMW_PLL_CTUNE_CTRL(base, XCVR_PLL_CTUNE_CTRL_CTUNE_TARGET_MANUAL_MASK, XCVR_PLL_CTUNE_CTRL_CTUNE_TARGET_MANUAL(value)))
#define XCVR_BWR_PLL_CTUNE_CTRL_CTUNE_TARGET_MANUAL(base, value) (BME_BFI32(&XCVR_PLL_CTUNE_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_CTUNE_CTRL_CTUNE_TARGET_MANUAL_SHIFT), XCVR_PLL_CTUNE_CTRL_CTUNE_TARGET_MANUAL_SHIFT, XCVR_PLL_CTUNE_CTRL_CTUNE_TARGET_MANUAL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CTUNE_CTRL, field CTUNE_TD[15] (RW)
 *
 * If this bit is set, the Frequency Target presented to the Coarse Tune
 * Calibrator comes from the CTUNE_TARGET_MANUAL register.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTUNE_CTRL_CTUNE_TD field. */
#define XCVR_RD_PLL_CTUNE_CTRL_CTUNE_TD(base) ((XCVR_PLL_CTUNE_CTRL_REG(base) & XCVR_PLL_CTUNE_CTRL_CTUNE_TD_MASK) >> XCVR_PLL_CTUNE_CTRL_CTUNE_TD_SHIFT)
#define XCVR_BRD_PLL_CTUNE_CTRL_CTUNE_TD(base) (BME_UBFX32(&XCVR_PLL_CTUNE_CTRL_REG(base), XCVR_PLL_CTUNE_CTRL_CTUNE_TD_SHIFT, XCVR_PLL_CTUNE_CTRL_CTUNE_TD_WIDTH))

/*! @brief Set the CTUNE_TD field to a new value. */
#define XCVR_WR_PLL_CTUNE_CTRL_CTUNE_TD(base, value) (XCVR_RMW_PLL_CTUNE_CTRL(base, XCVR_PLL_CTUNE_CTRL_CTUNE_TD_MASK, XCVR_PLL_CTUNE_CTRL_CTUNE_TD(value)))
#define XCVR_BWR_PLL_CTUNE_CTRL_CTUNE_TD(base, value) (BME_BFI32(&XCVR_PLL_CTUNE_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_CTUNE_CTRL_CTUNE_TD_SHIFT), XCVR_PLL_CTUNE_CTRL_CTUNE_TD_SHIFT, XCVR_PLL_CTUNE_CTRL_CTUNE_TD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CTUNE_CTRL, field CTUNE_ADJUST[19:16] (RW)
 *
 * The PLL 17-bit Ripple Counter count used in Coarse Tune Calibration will be
 * increased by the value of this register in order to allow for any consistent
 * under-counting that might present itself in the analog circuit.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTUNE_CTRL_CTUNE_ADJUST field. */
#define XCVR_RD_PLL_CTUNE_CTRL_CTUNE_ADJUST(base) ((XCVR_PLL_CTUNE_CTRL_REG(base) & XCVR_PLL_CTUNE_CTRL_CTUNE_ADJUST_MASK) >> XCVR_PLL_CTUNE_CTRL_CTUNE_ADJUST_SHIFT)
#define XCVR_BRD_PLL_CTUNE_CTRL_CTUNE_ADJUST(base) (BME_UBFX32(&XCVR_PLL_CTUNE_CTRL_REG(base), XCVR_PLL_CTUNE_CTRL_CTUNE_ADJUST_SHIFT, XCVR_PLL_CTUNE_CTRL_CTUNE_ADJUST_WIDTH))

/*! @brief Set the CTUNE_ADJUST field to a new value. */
#define XCVR_WR_PLL_CTUNE_CTRL_CTUNE_ADJUST(base, value) (XCVR_RMW_PLL_CTUNE_CTRL(base, XCVR_PLL_CTUNE_CTRL_CTUNE_ADJUST_MASK, XCVR_PLL_CTUNE_CTRL_CTUNE_ADJUST(value)))
#define XCVR_BWR_PLL_CTUNE_CTRL_CTUNE_ADJUST(base, value) (BME_BFI32(&XCVR_PLL_CTUNE_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_CTUNE_CTRL_CTUNE_ADJUST_SHIFT), XCVR_PLL_CTUNE_CTRL_CTUNE_ADJUST_SHIFT, XCVR_PLL_CTUNE_CTRL_CTUNE_ADJUST_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CTUNE_CTRL, field CTUNE_MANUAL[30:24] (RW)
 *
 * If CTUNE_DIS is set, this register is the value that is applied to the VCO as
 * the Coarse Tune Band.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTUNE_CTRL_CTUNE_MANUAL field. */
#define XCVR_RD_PLL_CTUNE_CTRL_CTUNE_MANUAL(base) ((XCVR_PLL_CTUNE_CTRL_REG(base) & XCVR_PLL_CTUNE_CTRL_CTUNE_MANUAL_MASK) >> XCVR_PLL_CTUNE_CTRL_CTUNE_MANUAL_SHIFT)
#define XCVR_BRD_PLL_CTUNE_CTRL_CTUNE_MANUAL(base) (BME_UBFX32(&XCVR_PLL_CTUNE_CTRL_REG(base), XCVR_PLL_CTUNE_CTRL_CTUNE_MANUAL_SHIFT, XCVR_PLL_CTUNE_CTRL_CTUNE_MANUAL_WIDTH))

/*! @brief Set the CTUNE_MANUAL field to a new value. */
#define XCVR_WR_PLL_CTUNE_CTRL_CTUNE_MANUAL(base, value) (XCVR_RMW_PLL_CTUNE_CTRL(base, XCVR_PLL_CTUNE_CTRL_CTUNE_MANUAL_MASK, XCVR_PLL_CTUNE_CTRL_CTUNE_MANUAL(value)))
#define XCVR_BWR_PLL_CTUNE_CTRL_CTUNE_MANUAL(base, value) (BME_BFI32(&XCVR_PLL_CTUNE_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_CTUNE_CTRL_CTUNE_MANUAL_SHIFT), XCVR_PLL_CTUNE_CTRL_CTUNE_MANUAL_SHIFT, XCVR_PLL_CTUNE_CTRL_CTUNE_MANUAL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CTUNE_CTRL, field CTUNE_DIS[31] (RW)
 *
 * If this bit is set, the Coarse Tune Band applied to the VCO comes from the
 * CTUNE_MANUAL register.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTUNE_CTRL_CTUNE_DIS field. */
#define XCVR_RD_PLL_CTUNE_CTRL_CTUNE_DIS(base) ((XCVR_PLL_CTUNE_CTRL_REG(base) & XCVR_PLL_CTUNE_CTRL_CTUNE_DIS_MASK) >> XCVR_PLL_CTUNE_CTRL_CTUNE_DIS_SHIFT)
#define XCVR_BRD_PLL_CTUNE_CTRL_CTUNE_DIS(base) (BME_UBFX32(&XCVR_PLL_CTUNE_CTRL_REG(base), XCVR_PLL_CTUNE_CTRL_CTUNE_DIS_SHIFT, XCVR_PLL_CTUNE_CTRL_CTUNE_DIS_WIDTH))

/*! @brief Set the CTUNE_DIS field to a new value. */
#define XCVR_WR_PLL_CTUNE_CTRL_CTUNE_DIS(base, value) (XCVR_RMW_PLL_CTUNE_CTRL(base, XCVR_PLL_CTUNE_CTRL_CTUNE_DIS_MASK, XCVR_PLL_CTUNE_CTRL_CTUNE_DIS(value)))
#define XCVR_BWR_PLL_CTUNE_CTRL_CTUNE_DIS(base, value) (BME_BFI32(&XCVR_PLL_CTUNE_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_CTUNE_CTRL_CTUNE_DIS_SHIFT), XCVR_PLL_CTUNE_CTRL_CTUNE_DIS_SHIFT, XCVR_PLL_CTUNE_CTRL_CTUNE_DIS_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_CTUNE_CNT6 - PLL Coarse Tune Count 6
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_CTUNE_CNT6 - PLL Coarse Tune Count 6 (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_CTUNE_CNT6 register
 */
/*@{*/
#define XCVR_RD_PLL_CTUNE_CNT6(base) (XCVR_PLL_CTUNE_CNT6_REG(base))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_CTUNE_CNT6 bitfields
 */

/*!
 * @name Register XCVR_PLL_CTUNE_CNT6, field CTUNE_COUNT_6[11:0] (RO)
 *
 * This is the Ripple counter value used to set coarse tune band bit 6.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTUNE_CNT6_CTUNE_COUNT_6 field. */
#define XCVR_RD_PLL_CTUNE_CNT6_CTUNE_COUNT_6(base) ((XCVR_PLL_CTUNE_CNT6_REG(base) & XCVR_PLL_CTUNE_CNT6_CTUNE_COUNT_6_MASK) >> XCVR_PLL_CTUNE_CNT6_CTUNE_COUNT_6_SHIFT)
#define XCVR_BRD_PLL_CTUNE_CNT6_CTUNE_COUNT_6(base) (BME_UBFX32(&XCVR_PLL_CTUNE_CNT6_REG(base), XCVR_PLL_CTUNE_CNT6_CTUNE_COUNT_6_SHIFT, XCVR_PLL_CTUNE_CNT6_CTUNE_COUNT_6_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_CTUNE_CNT5_4 - PLL Coarse Tune Counts 5 and 4
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_CTUNE_CNT5_4 - PLL Coarse Tune Counts 5 and 4 (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_CTUNE_CNT5_4 register
 */
/*@{*/
#define XCVR_RD_PLL_CTUNE_CNT5_4(base) (XCVR_PLL_CTUNE_CNT5_4_REG(base))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_CTUNE_CNT5_4 bitfields
 */

/*!
 * @name Register XCVR_PLL_CTUNE_CNT5_4, field CTUNE_COUNT_4[11:0] (RO)
 *
 * This is the Ripple counter value used to set coarse tune band bit 4.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTUNE_CNT5_4_CTUNE_COUNT_4 field. */
#define XCVR_RD_PLL_CTUNE_CNT5_4_CTUNE_COUNT_4(base) ((XCVR_PLL_CTUNE_CNT5_4_REG(base) & XCVR_PLL_CTUNE_CNT5_4_CTUNE_COUNT_4_MASK) >> XCVR_PLL_CTUNE_CNT5_4_CTUNE_COUNT_4_SHIFT)
#define XCVR_BRD_PLL_CTUNE_CNT5_4_CTUNE_COUNT_4(base) (BME_UBFX32(&XCVR_PLL_CTUNE_CNT5_4_REG(base), XCVR_PLL_CTUNE_CNT5_4_CTUNE_COUNT_4_SHIFT, XCVR_PLL_CTUNE_CNT5_4_CTUNE_COUNT_4_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CTUNE_CNT5_4, field CTUNE_COUNT_5[27:16] (RO)
 *
 * This is the Ripple counter value used to set coarse tune band bit 5.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTUNE_CNT5_4_CTUNE_COUNT_5 field. */
#define XCVR_RD_PLL_CTUNE_CNT5_4_CTUNE_COUNT_5(base) ((XCVR_PLL_CTUNE_CNT5_4_REG(base) & XCVR_PLL_CTUNE_CNT5_4_CTUNE_COUNT_5_MASK) >> XCVR_PLL_CTUNE_CNT5_4_CTUNE_COUNT_5_SHIFT)
#define XCVR_BRD_PLL_CTUNE_CNT5_4_CTUNE_COUNT_5(base) (BME_UBFX32(&XCVR_PLL_CTUNE_CNT5_4_REG(base), XCVR_PLL_CTUNE_CNT5_4_CTUNE_COUNT_5_SHIFT, XCVR_PLL_CTUNE_CNT5_4_CTUNE_COUNT_5_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_CTUNE_CNT3_2 - PLL Coarse Tune Counts 3 and 2
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_CTUNE_CNT3_2 - PLL Coarse Tune Counts 3 and 2 (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_CTUNE_CNT3_2 register
 */
/*@{*/
#define XCVR_RD_PLL_CTUNE_CNT3_2(base) (XCVR_PLL_CTUNE_CNT3_2_REG(base))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_CTUNE_CNT3_2 bitfields
 */

/*!
 * @name Register XCVR_PLL_CTUNE_CNT3_2, field CTUNE_COUNT_2[11:0] (RO)
 *
 * This is the Ripple counter value used to set coarse tune band bit 2.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTUNE_CNT3_2_CTUNE_COUNT_2 field. */
#define XCVR_RD_PLL_CTUNE_CNT3_2_CTUNE_COUNT_2(base) ((XCVR_PLL_CTUNE_CNT3_2_REG(base) & XCVR_PLL_CTUNE_CNT3_2_CTUNE_COUNT_2_MASK) >> XCVR_PLL_CTUNE_CNT3_2_CTUNE_COUNT_2_SHIFT)
#define XCVR_BRD_PLL_CTUNE_CNT3_2_CTUNE_COUNT_2(base) (BME_UBFX32(&XCVR_PLL_CTUNE_CNT3_2_REG(base), XCVR_PLL_CTUNE_CNT3_2_CTUNE_COUNT_2_SHIFT, XCVR_PLL_CTUNE_CNT3_2_CTUNE_COUNT_2_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CTUNE_CNT3_2, field CTUNE_COUNT_3[27:16] (RO)
 *
 * This is the Ripple counter value used to set coarse tune band bit 3.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTUNE_CNT3_2_CTUNE_COUNT_3 field. */
#define XCVR_RD_PLL_CTUNE_CNT3_2_CTUNE_COUNT_3(base) ((XCVR_PLL_CTUNE_CNT3_2_REG(base) & XCVR_PLL_CTUNE_CNT3_2_CTUNE_COUNT_3_MASK) >> XCVR_PLL_CTUNE_CNT3_2_CTUNE_COUNT_3_SHIFT)
#define XCVR_BRD_PLL_CTUNE_CNT3_2_CTUNE_COUNT_3(base) (BME_UBFX32(&XCVR_PLL_CTUNE_CNT3_2_REG(base), XCVR_PLL_CTUNE_CNT3_2_CTUNE_COUNT_3_SHIFT, XCVR_PLL_CTUNE_CNT3_2_CTUNE_COUNT_3_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_CTUNE_CNT1_0 - PLL Coarse Tune Counts 1 and 0
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_CTUNE_CNT1_0 - PLL Coarse Tune Counts 1 and 0 (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_CTUNE_CNT1_0 register
 */
/*@{*/
#define XCVR_RD_PLL_CTUNE_CNT1_0(base) (XCVR_PLL_CTUNE_CNT1_0_REG(base))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_CTUNE_CNT1_0 bitfields
 */

/*!
 * @name Register XCVR_PLL_CTUNE_CNT1_0, field CTUNE_COUNT_0[11:0] (RO)
 *
 * This is the Ripple counter value used to set coarse tune band bit 0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTUNE_CNT1_0_CTUNE_COUNT_0 field. */
#define XCVR_RD_PLL_CTUNE_CNT1_0_CTUNE_COUNT_0(base) ((XCVR_PLL_CTUNE_CNT1_0_REG(base) & XCVR_PLL_CTUNE_CNT1_0_CTUNE_COUNT_0_MASK) >> XCVR_PLL_CTUNE_CNT1_0_CTUNE_COUNT_0_SHIFT)
#define XCVR_BRD_PLL_CTUNE_CNT1_0_CTUNE_COUNT_0(base) (BME_UBFX32(&XCVR_PLL_CTUNE_CNT1_0_REG(base), XCVR_PLL_CTUNE_CNT1_0_CTUNE_COUNT_0_SHIFT, XCVR_PLL_CTUNE_CNT1_0_CTUNE_COUNT_0_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CTUNE_CNT1_0, field CTUNE_COUNT_1[27:16] (RO)
 *
 * This is the Ripple counter value used to set coarse tune band bit 1.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTUNE_CNT1_0_CTUNE_COUNT_1 field. */
#define XCVR_RD_PLL_CTUNE_CNT1_0_CTUNE_COUNT_1(base) ((XCVR_PLL_CTUNE_CNT1_0_REG(base) & XCVR_PLL_CTUNE_CNT1_0_CTUNE_COUNT_1_MASK) >> XCVR_PLL_CTUNE_CNT1_0_CTUNE_COUNT_1_SHIFT)
#define XCVR_BRD_PLL_CTUNE_CNT1_0_CTUNE_COUNT_1(base) (BME_UBFX32(&XCVR_PLL_CTUNE_CNT1_0_REG(base), XCVR_PLL_CTUNE_CNT1_0_CTUNE_COUNT_1_SHIFT, XCVR_PLL_CTUNE_CNT1_0_CTUNE_COUNT_1_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_CTUNE_RESULTS - PLL Coarse Tune Results
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_CTUNE_RESULTS - PLL Coarse Tune Results (RO)
 *
 * Reset value: 0x09620040U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_CTUNE_RESULTS register
 */
/*@{*/
#define XCVR_RD_PLL_CTUNE_RESULTS(base) (XCVR_PLL_CTUNE_RESULTS_REG(base))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_CTUNE_RESULTS bitfields
 */

/*!
 * @name Register XCVR_PLL_CTUNE_RESULTS, field CTUNE_SELECTED[6:0] (RO)
 *
 * This is the current VCO Coarse Tune setting, it is the result of the Coarse
 * Tune Calibration, unless overridden using CTUNE_DIS.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTUNE_RESULTS_CTUNE_SELECTED field. */
#define XCVR_RD_PLL_CTUNE_RESULTS_CTUNE_SELECTED(base) ((XCVR_PLL_CTUNE_RESULTS_REG(base) & XCVR_PLL_CTUNE_RESULTS_CTUNE_SELECTED_MASK) >> XCVR_PLL_CTUNE_RESULTS_CTUNE_SELECTED_SHIFT)
#define XCVR_BRD_PLL_CTUNE_RESULTS_CTUNE_SELECTED(base) (BME_UBFX32(&XCVR_PLL_CTUNE_RESULTS_REG(base), XCVR_PLL_CTUNE_RESULTS_CTUNE_SELECTED_SHIFT, XCVR_PLL_CTUNE_RESULTS_CTUNE_SELECTED_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CTUNE_RESULTS, field CTUNE_BEST_DIFF[15:8] (RO)
 *
 * This is the absolute value of the best difference found during Coarse Tune
 * between the targeted frequency count and the actual frequency count.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTUNE_RESULTS_CTUNE_BEST_DIFF field. */
#define XCVR_RD_PLL_CTUNE_RESULTS_CTUNE_BEST_DIFF(base) ((XCVR_PLL_CTUNE_RESULTS_REG(base) & XCVR_PLL_CTUNE_RESULTS_CTUNE_BEST_DIFF_MASK) >> XCVR_PLL_CTUNE_RESULTS_CTUNE_BEST_DIFF_SHIFT)
#define XCVR_BRD_PLL_CTUNE_RESULTS_CTUNE_BEST_DIFF(base) (BME_UBFX32(&XCVR_PLL_CTUNE_RESULTS_REG(base), XCVR_PLL_CTUNE_RESULTS_CTUNE_BEST_DIFF_SHIFT, XCVR_PLL_CTUNE_RESULTS_CTUNE_BEST_DIFF_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CTUNE_RESULTS, field CTUNE_FREQ_TARGET[27:16] (RO)
 *
 * This is the Frequency Target in MHz that is currently being presented to the
 * Coarse Tune Calibrator.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTUNE_RESULTS_CTUNE_FREQ_TARGET field. */
#define XCVR_RD_PLL_CTUNE_RESULTS_CTUNE_FREQ_TARGET(base) ((XCVR_PLL_CTUNE_RESULTS_REG(base) & XCVR_PLL_CTUNE_RESULTS_CTUNE_FREQ_TARGET_MASK) >> XCVR_PLL_CTUNE_RESULTS_CTUNE_FREQ_TARGET_SHIFT)
#define XCVR_BRD_PLL_CTUNE_RESULTS_CTUNE_FREQ_TARGET(base) (BME_UBFX32(&XCVR_PLL_CTUNE_RESULTS_REG(base), XCVR_PLL_CTUNE_RESULTS_CTUNE_FREQ_TARGET_SHIFT, XCVR_PLL_CTUNE_RESULTS_CTUNE_FREQ_TARGET_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_CTRL - Transceiver Control
 ******************************************************************************/

/*!
 * @brief XCVR_CTRL - Transceiver Control (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_CTRL register
 */
/*@{*/
#define XCVR_RD_CTRL(base)       (XCVR_CTRL_REG(base))
#define XCVR_WR_CTRL(base, value) (XCVR_CTRL_REG(base) = (value))
#define XCVR_RMW_CTRL(base, mask, value) (XCVR_WR_CTRL(base, (XCVR_RD_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_CTRL(base, value) (BME_OR32(&XCVR_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_CTRL(base, value) (BME_AND32(&XCVR_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_CTRL(base, value) (BME_XOR32(&XCVR_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_CTRL bitfields
 */

/*!
 * @name Register XCVR_CTRL, field PROTOCOL[2:0] (RW)
 *
 * This register selects the Radio Communication Protocol.
 *
 * Values:
 * - 0b000 - BLE
 * - 0b001 - BLE in MBAN
 * - 0b010 - BLE overlap MBAN
 * - 0b011 - Reserved
 * - 0b100 - Zigbee
 * - 0b101 - 802.15.4j
 * - 0b110 - 128 Channel FSK
 * - 0b111 - 128 Channel GFSK
 */
/*@{*/
/*! @brief Read current value of the XCVR_CTRL_PROTOCOL field. */
#define XCVR_RD_CTRL_PROTOCOL(base) ((XCVR_CTRL_REG(base) & XCVR_CTRL_PROTOCOL_MASK) >> XCVR_CTRL_PROTOCOL_SHIFT)
#define XCVR_BRD_CTRL_PROTOCOL(base) (BME_UBFX32(&XCVR_CTRL_REG(base), XCVR_CTRL_PROTOCOL_SHIFT, XCVR_CTRL_PROTOCOL_WIDTH))

/*! @brief Set the PROTOCOL field to a new value. */
#define XCVR_WR_CTRL_PROTOCOL(base, value) (XCVR_RMW_CTRL(base, XCVR_CTRL_PROTOCOL_MASK, XCVR_CTRL_PROTOCOL(value)))
#define XCVR_BWR_CTRL_PROTOCOL(base, value) (BME_BFI32(&XCVR_CTRL_REG(base), ((uint32_t)(value) << XCVR_CTRL_PROTOCOL_SHIFT), XCVR_CTRL_PROTOCOL_SHIFT, XCVR_CTRL_PROTOCOL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_CTRL, field TGT_PWR_SRC[5:4] (RW)
 *
 * For determining transmit power, the TGT_PWR_SRC[1:0] bits control target
 * power selection, according to the following table. TGT_PWR_SRC[1:0] TARGET POWER
 * SOURCE 00 PA_POWER[3:0] register (XCVR space) 01 BTLE Link Layer 10 Zigbee Link
 * Layer (PA_PWR[3:0] register in ZIGBEE space) 11 PROTOCOL[2:0] bits select
 * target power source
 */
/*@{*/
/*! @brief Read current value of the XCVR_CTRL_TGT_PWR_SRC field. */
#define XCVR_RD_CTRL_TGT_PWR_SRC(base) ((XCVR_CTRL_REG(base) & XCVR_CTRL_TGT_PWR_SRC_MASK) >> XCVR_CTRL_TGT_PWR_SRC_SHIFT)
#define XCVR_BRD_CTRL_TGT_PWR_SRC(base) (BME_UBFX32(&XCVR_CTRL_REG(base), XCVR_CTRL_TGT_PWR_SRC_SHIFT, XCVR_CTRL_TGT_PWR_SRC_WIDTH))

/*! @brief Set the TGT_PWR_SRC field to a new value. */
#define XCVR_WR_CTRL_TGT_PWR_SRC(base, value) (XCVR_RMW_CTRL(base, XCVR_CTRL_TGT_PWR_SRC_MASK, XCVR_CTRL_TGT_PWR_SRC(value)))
#define XCVR_BWR_CTRL_TGT_PWR_SRC(base, value) (BME_BFI32(&XCVR_CTRL_REG(base), ((uint32_t)(value) << XCVR_CTRL_TGT_PWR_SRC_SHIFT), XCVR_CTRL_TGT_PWR_SRC_SHIFT, XCVR_CTRL_TGT_PWR_SRC_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_CTRL, field REF_CLK_FREQ[7:6] (RW)
 *
 * This register selects the Reference Clock Frequency for the Radio.
 *
 * Values:
 * - 0b00 - 32 MHz
 * - 0b01 - Reserved
 * - 0b10 - Reserved
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the XCVR_CTRL_REF_CLK_FREQ field. */
#define XCVR_RD_CTRL_REF_CLK_FREQ(base) ((XCVR_CTRL_REG(base) & XCVR_CTRL_REF_CLK_FREQ_MASK) >> XCVR_CTRL_REF_CLK_FREQ_SHIFT)
#define XCVR_BRD_CTRL_REF_CLK_FREQ(base) (BME_UBFX32(&XCVR_CTRL_REG(base), XCVR_CTRL_REF_CLK_FREQ_SHIFT, XCVR_CTRL_REF_CLK_FREQ_WIDTH))

/*! @brief Set the REF_CLK_FREQ field to a new value. */
#define XCVR_WR_CTRL_REF_CLK_FREQ(base, value) (XCVR_RMW_CTRL(base, XCVR_CTRL_REF_CLK_FREQ_MASK, XCVR_CTRL_REF_CLK_FREQ(value)))
#define XCVR_BWR_CTRL_REF_CLK_FREQ(base, value) (BME_BFI32(&XCVR_CTRL_REG(base), ((uint32_t)(value) << XCVR_CTRL_REF_CLK_FREQ_SHIFT), XCVR_CTRL_REF_CLK_FREQ_SHIFT, XCVR_CTRL_REF_CLK_FREQ_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_STATUS - Transceiver Status
 ******************************************************************************/

/*!
 * @brief XCVR_STATUS - Transceiver Status (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_STATUS register
 */
/*@{*/
#define XCVR_RD_STATUS(base)     (XCVR_STATUS_REG(base))
/*@}*/

/*
 * Constants & macros for individual XCVR_STATUS bitfields
 */

/*!
 * @name Register XCVR_STATUS, field TSM_COUNT[7:0] (RO)
 *
 * Reflects the instantaneous value of the TSM counter.
 */
/*@{*/
/*! @brief Read current value of the XCVR_STATUS_TSM_COUNT field. */
#define XCVR_RD_STATUS_TSM_COUNT(base) ((XCVR_STATUS_REG(base) & XCVR_STATUS_TSM_COUNT_MASK) >> XCVR_STATUS_TSM_COUNT_SHIFT)
#define XCVR_BRD_STATUS_TSM_COUNT(base) (BME_UBFX32(&XCVR_STATUS_REG(base), XCVR_STATUS_TSM_COUNT_SHIFT, XCVR_STATUS_TSM_COUNT_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_STATUS, field PLL_SEQ_STATE[11:8] (RO)
 *
 * Reflects the state of the PLL digital state machine.
 *
 * Values:
 * - 0b0000 - PLL OFF
 * - 0b0010 - HPMCAL2
 */
/*@{*/
/*! @brief Read current value of the XCVR_STATUS_PLL_SEQ_STATE field. */
#define XCVR_RD_STATUS_PLL_SEQ_STATE(base) ((XCVR_STATUS_REG(base) & XCVR_STATUS_PLL_SEQ_STATE_MASK) >> XCVR_STATUS_PLL_SEQ_STATE_SHIFT)
#define XCVR_BRD_STATUS_PLL_SEQ_STATE(base) (BME_UBFX32(&XCVR_STATUS_REG(base), XCVR_STATUS_PLL_SEQ_STATE_SHIFT, XCVR_STATUS_PLL_SEQ_STATE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_STATUS, field RX_MODE[12] (RO)
 *
 * Indicates an RX transceiver operation is in progress.
 */
/*@{*/
/*! @brief Read current value of the XCVR_STATUS_RX_MODE field. */
#define XCVR_RD_STATUS_RX_MODE(base) ((XCVR_STATUS_REG(base) & XCVR_STATUS_RX_MODE_MASK) >> XCVR_STATUS_RX_MODE_SHIFT)
#define XCVR_BRD_STATUS_RX_MODE(base) (BME_UBFX32(&XCVR_STATUS_REG(base), XCVR_STATUS_RX_MODE_SHIFT, XCVR_STATUS_RX_MODE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_STATUS, field TX_MODE[13] (RO)
 *
 * Indicates an TX transceiver operation is in progress.
 */
/*@{*/
/*! @brief Read current value of the XCVR_STATUS_TX_MODE field. */
#define XCVR_RD_STATUS_TX_MODE(base) ((XCVR_STATUS_REG(base) & XCVR_STATUS_TX_MODE_MASK) >> XCVR_STATUS_TX_MODE_SHIFT)
#define XCVR_BRD_STATUS_TX_MODE(base) (BME_UBFX32(&XCVR_STATUS_REG(base), XCVR_STATUS_TX_MODE_SHIFT, XCVR_STATUS_TX_MODE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_STATUS, field BTLE_SYSCLK_REQ[16] (RO)
 *
 * Reflects the state of the BTLE oscillator request signal. BTLE_SYSCLK_REQ is
 * the BTLE control for the RF Oscillator. BTLE will deassert this signal upon
 * entering DSM (deep sleep mode) to request oscillator turn-off, and will
 * re-assert it prior to exiting DSM. The turn-on leadtime on this signal for exiting
 * DSM, is programmable with the BTLE block. This read-only bit can thus be queried
 * to ascertain the power-state of BTLE.
 */
/*@{*/
/*! @brief Read current value of the XCVR_STATUS_BTLE_SYSCLK_REQ field. */
#define XCVR_RD_STATUS_BTLE_SYSCLK_REQ(base) ((XCVR_STATUS_REG(base) & XCVR_STATUS_BTLE_SYSCLK_REQ_MASK) >> XCVR_STATUS_BTLE_SYSCLK_REQ_SHIFT)
#define XCVR_BRD_STATUS_BTLE_SYSCLK_REQ(base) (BME_UBFX32(&XCVR_STATUS_REG(base), XCVR_STATUS_BTLE_SYSCLK_REQ_SHIFT, XCVR_STATUS_BTLE_SYSCLK_REQ_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_STATUS, field RIF_LL_ACTIVE[17] (RO)
 *
 * Reflects the state of the BTLE "Link Layer Active" status bit. RIF_LL_ACTIVE
 * is to be used by the host as an 'early' indication to prevent host to do any
 * operations while BTLE IP is doing transceiver operations, so as to reduce the
 * peak power and noise.
 */
/*@{*/
/*! @brief Read current value of the XCVR_STATUS_RIF_LL_ACTIVE field. */
#define XCVR_RD_STATUS_RIF_LL_ACTIVE(base) ((XCVR_STATUS_REG(base) & XCVR_STATUS_RIF_LL_ACTIVE_MASK) >> XCVR_STATUS_RIF_LL_ACTIVE_SHIFT)
#define XCVR_BRD_STATUS_RIF_LL_ACTIVE(base) (BME_UBFX32(&XCVR_STATUS_REG(base), XCVR_STATUS_RIF_LL_ACTIVE_SHIFT, XCVR_STATUS_RIF_LL_ACTIVE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_STATUS, field XTAL_READY[18] (RO)
 *
 * Oscillator warmup count complete.
 *
 * Values:
 * - 0b0 - Indicates that the RF Oscillator is disabled or has not completed its
 *     warmup.
 * - 0b1 - Indicates that the RF Oscillator has completed its warmup count and
 *     is ready for use.
 */
/*@{*/
/*! @brief Read current value of the XCVR_STATUS_XTAL_READY field. */
#define XCVR_RD_STATUS_XTAL_READY(base) ((XCVR_STATUS_REG(base) & XCVR_STATUS_XTAL_READY_MASK) >> XCVR_STATUS_XTAL_READY_SHIFT)
#define XCVR_BRD_STATUS_XTAL_READY(base) (BME_UBFX32(&XCVR_STATUS_REG(base), XCVR_STATUS_XTAL_READY_SHIFT, XCVR_STATUS_XTAL_READY_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_STATUS, field SOC_USING_RF_OSC_CLK[19] (RO)
 *
 * SoC signal from the CLKGEN that asserts high when the MCG is configured to
 * use RF OSC clock as the SoC clock source
 */
/*@{*/
/*! @brief Read current value of the XCVR_STATUS_SOC_USING_RF_OSC_CLK field. */
#define XCVR_RD_STATUS_SOC_USING_RF_OSC_CLK(base) ((XCVR_STATUS_REG(base) & XCVR_STATUS_SOC_USING_RF_OSC_CLK_MASK) >> XCVR_STATUS_SOC_USING_RF_OSC_CLK_SHIFT)
#define XCVR_BRD_STATUS_SOC_USING_RF_OSC_CLK(base) (BME_UBFX32(&XCVR_STATUS_REG(base), XCVR_STATUS_SOC_USING_RF_OSC_CLK_SHIFT, XCVR_STATUS_SOC_USING_RF_OSC_CLK_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_SOFT_RESET - Soft Reset
 ******************************************************************************/

/*!
 * @brief XCVR_SOFT_RESET - Soft Reset (ROZ)
 *
 * Reset value: 0x00000000U
 *
 * Transceiver Soft Reset Note: Register not currently implemented.
 */
/*!
 * @name Constants and macros for entire XCVR_SOFT_RESET register
 */
/*@{*/
#define XCVR_RD_SOFT_RESET(base) (XCVR_SOFT_RESET_REG(base))
/*@}*/

/*******************************************************************************
 * XCVR_OVERWRITE_VER - Overwrite Version
 ******************************************************************************/

/*!
 * @brief XCVR_OVERWRITE_VER - Overwrite Version (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Overwrite Version allows software to store a version number of trim and
 * calibration values which are used to overwrite the chip default values in the
 * registers. Typically, software would perform the overwrite of the defaults in
 * transceiver registers and then write the version number from the file
 * containing the overwrite values into this register. This register has no hardware
 * connections, it is simply a designated storage location for a version number.
 */
/*!
 * @name Constants and macros for entire XCVR_OVERWRITE_VER register
 */
/*@{*/
#define XCVR_RD_OVERWRITE_VER(base) (XCVR_OVERWRITE_VER_REG(base))
#define XCVR_WR_OVERWRITE_VER(base, value) (XCVR_OVERWRITE_VER_REG(base) = (value))
#define XCVR_RMW_OVERWRITE_VER(base, mask, value) (XCVR_WR_OVERWRITE_VER(base, (XCVR_RD_OVERWRITE_VER(base) & ~(mask)) | (value)))
#define XCVR_SET_OVERWRITE_VER(base, value) (BME_OR32(&XCVR_OVERWRITE_VER_REG(base), (uint32_t)(value)))
#define XCVR_CLR_OVERWRITE_VER(base, value) (BME_AND32(&XCVR_OVERWRITE_VER_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_OVERWRITE_VER(base, value) (BME_XOR32(&XCVR_OVERWRITE_VER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_OVERWRITE_VER bitfields
 */

/*!
 * @name Register XCVR_OVERWRITE_VER, field OVERWRITE_VER[7:0] (RW)
 *
 * Points to the version number of the overwrites.h file used to initialize the
 * device; can be used by software to identify a version-controlled set of
 * non-default values to be written into the transceiver's register map.
 */
/*@{*/
/*! @brief Read current value of the XCVR_OVERWRITE_VER_OVERWRITE_VER field. */
#define XCVR_RD_OVERWRITE_VER_OVERWRITE_VER(base) ((XCVR_OVERWRITE_VER_REG(base) & XCVR_OVERWRITE_VER_OVERWRITE_VER_MASK) >> XCVR_OVERWRITE_VER_OVERWRITE_VER_SHIFT)
#define XCVR_BRD_OVERWRITE_VER_OVERWRITE_VER(base) (BME_UBFX32(&XCVR_OVERWRITE_VER_REG(base), XCVR_OVERWRITE_VER_OVERWRITE_VER_SHIFT, XCVR_OVERWRITE_VER_OVERWRITE_VER_WIDTH))

/*! @brief Set the OVERWRITE_VER field to a new value. */
#define XCVR_WR_OVERWRITE_VER_OVERWRITE_VER(base, value) (XCVR_RMW_OVERWRITE_VER(base, XCVR_OVERWRITE_VER_OVERWRITE_VER_MASK, XCVR_OVERWRITE_VER_OVERWRITE_VER(value)))
#define XCVR_BWR_OVERWRITE_VER_OVERWRITE_VER(base, value) (BME_BFI32(&XCVR_OVERWRITE_VER_REG(base), ((uint32_t)(value) << XCVR_OVERWRITE_VER_OVERWRITE_VER_SHIFT), XCVR_OVERWRITE_VER_OVERWRITE_VER_SHIFT, XCVR_OVERWRITE_VER_OVERWRITE_VER_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DMA_CTRL - DMA Control
 ******************************************************************************/

/*!
 * @brief XCVR_DMA_CTRL - DMA Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * Transceiver DMA per-channel enable register. Transceiver DMA is intended for
 * engineering evaluation only. If DMA_I_EN and DMA_Q_EN are both set, I channel
 * samples appear in register field DMA_DATA[DMA_DATA_11_0] (lower halfword), and
 * Q channel samples appears in DMA_DATA[DMA_DATA_27_16] (upper halfword).
 */
/*!
 * @name Constants and macros for entire XCVR_DMA_CTRL register
 */
/*@{*/
#define XCVR_RD_DMA_CTRL(base)   (XCVR_DMA_CTRL_REG(base))
#define XCVR_WR_DMA_CTRL(base, value) (XCVR_DMA_CTRL_REG(base) = (value))
#define XCVR_RMW_DMA_CTRL(base, mask, value) (XCVR_WR_DMA_CTRL(base, (XCVR_RD_DMA_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_DMA_CTRL(base, value) (BME_OR32(&XCVR_DMA_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_DMA_CTRL(base, value) (BME_AND32(&XCVR_DMA_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_DMA_CTRL(base, value) (BME_XOR32(&XCVR_DMA_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_DMA_CTRL bitfields
 */

/*!
 * @name Register XCVR_DMA_CTRL, field DMA_I_EN[0] (RW)
 *
 * DMA I Enable
 *
 * Values:
 * - 0b0 - Transceiver I channel DMA disabled.
 * - 0b1 - Enable the transceiver DMA engine to store RX_DIG I channel outputs
 *     to system memory.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DMA_CTRL_DMA_I_EN field. */
#define XCVR_RD_DMA_CTRL_DMA_I_EN(base) ((XCVR_DMA_CTRL_REG(base) & XCVR_DMA_CTRL_DMA_I_EN_MASK) >> XCVR_DMA_CTRL_DMA_I_EN_SHIFT)
#define XCVR_BRD_DMA_CTRL_DMA_I_EN(base) (BME_UBFX32(&XCVR_DMA_CTRL_REG(base), XCVR_DMA_CTRL_DMA_I_EN_SHIFT, XCVR_DMA_CTRL_DMA_I_EN_WIDTH))

/*! @brief Set the DMA_I_EN field to a new value. */
#define XCVR_WR_DMA_CTRL_DMA_I_EN(base, value) (XCVR_RMW_DMA_CTRL(base, XCVR_DMA_CTRL_DMA_I_EN_MASK, XCVR_DMA_CTRL_DMA_I_EN(value)))
#define XCVR_BWR_DMA_CTRL_DMA_I_EN(base, value) (BME_BFI32(&XCVR_DMA_CTRL_REG(base), ((uint32_t)(value) << XCVR_DMA_CTRL_DMA_I_EN_SHIFT), XCVR_DMA_CTRL_DMA_I_EN_SHIFT, XCVR_DMA_CTRL_DMA_I_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DMA_CTRL, field DMA_Q_EN[1] (RW)
 *
 * DMA Q Enable
 *
 * Values:
 * - 0b0 - Transceiver Q channel DMA disabled.
 * - 0b1 - Enable the transceiver DMA engine to store RX_DIG Q channel outputs
 *     to system memory.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DMA_CTRL_DMA_Q_EN field. */
#define XCVR_RD_DMA_CTRL_DMA_Q_EN(base) ((XCVR_DMA_CTRL_REG(base) & XCVR_DMA_CTRL_DMA_Q_EN_MASK) >> XCVR_DMA_CTRL_DMA_Q_EN_SHIFT)
#define XCVR_BRD_DMA_CTRL_DMA_Q_EN(base) (BME_UBFX32(&XCVR_DMA_CTRL_REG(base), XCVR_DMA_CTRL_DMA_Q_EN_SHIFT, XCVR_DMA_CTRL_DMA_Q_EN_WIDTH))

/*! @brief Set the DMA_Q_EN field to a new value. */
#define XCVR_WR_DMA_CTRL_DMA_Q_EN(base, value) (XCVR_RMW_DMA_CTRL(base, XCVR_DMA_CTRL_DMA_Q_EN_MASK, XCVR_DMA_CTRL_DMA_Q_EN(value)))
#define XCVR_BWR_DMA_CTRL_DMA_Q_EN(base, value) (BME_BFI32(&XCVR_DMA_CTRL_REG(base), ((uint32_t)(value) << XCVR_DMA_CTRL_DMA_Q_EN_SHIFT), XCVR_DMA_CTRL_DMA_Q_EN_SHIFT, XCVR_DMA_CTRL_DMA_Q_EN_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DMA_DATA - DMA Data
 ******************************************************************************/

/*!
 * @brief XCVR_DMA_DATA - DMA Data (RO)
 *
 * Reset value: 0x00000000U
 *
 * Transceiver DMA Data. Not intended to be read directly by application
 * software, this register is merely an address slot where the SoC DMA controller can
 * access the RX_DIG samples to be transferred to memory. After enabling
 * transceiver DMA, the first sample pair should be discarded due to DMA controller
 * latency; all subsequent samples are valid
 */
/*!
 * @name Constants and macros for entire XCVR_DMA_DATA register
 */
/*@{*/
#define XCVR_RD_DMA_DATA(base)   (XCVR_DMA_DATA_REG(base))
/*@}*/

/*
 * Constants & macros for individual XCVR_DMA_DATA bitfields
 */

/*!
 * @name Register XCVR_DMA_DATA, field DMA_DATA_11_0[11:0] (RO)
 *
 * Reflection of the RX_DIG DMA data to be stored to system memory. The
 * transceiver DMA engine acquires 12-bit samples from RX_DIG, and deposits them in this
 * register field. If DMA I channel is enabled, i.e. DMA_CTRL[DMA_I_EN]=1, then
 * this register field contains I channel samples; otherwise it contains Q channel
 * samples. For single-channel mode, this register field represents the first
 * consecutive RX_DIG sample of the sample-pair; for dual-channel mode, I and Q
 * samples are captured simultaneously.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DMA_DATA_DMA_DATA_11_0 field. */
#define XCVR_RD_DMA_DATA_DMA_DATA_11_0(base) ((XCVR_DMA_DATA_REG(base) & XCVR_DMA_DATA_DMA_DATA_11_0_MASK) >> XCVR_DMA_DATA_DMA_DATA_11_0_SHIFT)
#define XCVR_BRD_DMA_DATA_DMA_DATA_11_0(base) (BME_UBFX32(&XCVR_DMA_DATA_REG(base), XCVR_DMA_DATA_DMA_DATA_11_0_SHIFT, XCVR_DMA_DATA_DMA_DATA_11_0_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DMA_DATA, field DMA_DATA_27_16[27:16] (RO)
 *
 * Reflection of the RX_DIG DMA data to be stored to system memory. The
 * transceiver DMA engine acquires 12-bit samples from RX_DIG, and deposits them in this
 * register field. If DMA Q channel is enabled, i.e. DMA_CTRL[DMA_Q_EN]=1, then
 * this register field contains Q channel samples; otherwise it contains I channel
 * samples. For single-channel mode, this register field represents the second
 * consecutive RX_DIG sample of the sample-pair; for dual-channel mode, I and Q
 * samples are captured simultaneously.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DMA_DATA_DMA_DATA_27_16 field. */
#define XCVR_RD_DMA_DATA_DMA_DATA_27_16(base) ((XCVR_DMA_DATA_REG(base) & XCVR_DMA_DATA_DMA_DATA_27_16_MASK) >> XCVR_DMA_DATA_DMA_DATA_27_16_SHIFT)
#define XCVR_BRD_DMA_DATA_DMA_DATA_27_16(base) (BME_UBFX32(&XCVR_DMA_DATA_REG(base), XCVR_DMA_DATA_DMA_DATA_27_16_SHIFT, XCVR_DMA_DATA_DMA_DATA_27_16_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_DTEST_CTRL - Digital Test Control
 ******************************************************************************/

/*!
 * @brief XCVR_DTEST_CTRL - Digital Test Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * Digital Test Control. Allows selection and enablement of a page of DTEST
 * signals to appear on the SoC DTEST pins. This register configures only the
 * transceiver for DTEST mode; since DTEST pads on the SoC are multiplexed with other
 * functions, SoC Port Pin programming is also required for each DTEST output
 */
/*!
 * @name Constants and macros for entire XCVR_DTEST_CTRL register
 */
/*@{*/
#define XCVR_RD_DTEST_CTRL(base) (XCVR_DTEST_CTRL_REG(base))
#define XCVR_WR_DTEST_CTRL(base, value) (XCVR_DTEST_CTRL_REG(base) = (value))
#define XCVR_RMW_DTEST_CTRL(base, mask, value) (XCVR_WR_DTEST_CTRL(base, (XCVR_RD_DTEST_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_DTEST_CTRL(base, value) (BME_OR32(&XCVR_DTEST_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_DTEST_CTRL(base, value) (BME_AND32(&XCVR_DTEST_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_DTEST_CTRL(base, value) (BME_XOR32(&XCVR_DTEST_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_DTEST_CTRL bitfields
 */

/*!
 * @name Register XCVR_DTEST_CTRL, field DTEST_PAGE[5:0] (RW)
 *
 * DTEST Page signal assignments are defined in a spreadsheet located at
 * http://compass.freescale.net/livelink/livelink/open/231923338.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DTEST_CTRL_DTEST_PAGE field. */
#define XCVR_RD_DTEST_CTRL_DTEST_PAGE(base) ((XCVR_DTEST_CTRL_REG(base) & XCVR_DTEST_CTRL_DTEST_PAGE_MASK) >> XCVR_DTEST_CTRL_DTEST_PAGE_SHIFT)
#define XCVR_BRD_DTEST_CTRL_DTEST_PAGE(base) (BME_UBFX32(&XCVR_DTEST_CTRL_REG(base), XCVR_DTEST_CTRL_DTEST_PAGE_SHIFT, XCVR_DTEST_CTRL_DTEST_PAGE_WIDTH))

/*! @brief Set the DTEST_PAGE field to a new value. */
#define XCVR_WR_DTEST_CTRL_DTEST_PAGE(base, value) (XCVR_RMW_DTEST_CTRL(base, XCVR_DTEST_CTRL_DTEST_PAGE_MASK, XCVR_DTEST_CTRL_DTEST_PAGE(value)))
#define XCVR_BWR_DTEST_CTRL_DTEST_PAGE(base, value) (BME_BFI32(&XCVR_DTEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_DTEST_CTRL_DTEST_PAGE_SHIFT), XCVR_DTEST_CTRL_DTEST_PAGE_SHIFT, XCVR_DTEST_CTRL_DTEST_PAGE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DTEST_CTRL, field DTEST_EN[7] (RW)
 *
 * DTEST enable
 *
 * Values:
 * - 0b0 - Disables DTEST. The IC's DTEST pins assume their mission function.
 * - 0b1 - Enables DTEST. The contents of the selected page (DTEST_PAGE) will
 *     appear on the IC's DTEST output pins.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DTEST_CTRL_DTEST_EN field. */
#define XCVR_RD_DTEST_CTRL_DTEST_EN(base) ((XCVR_DTEST_CTRL_REG(base) & XCVR_DTEST_CTRL_DTEST_EN_MASK) >> XCVR_DTEST_CTRL_DTEST_EN_SHIFT)
#define XCVR_BRD_DTEST_CTRL_DTEST_EN(base) (BME_UBFX32(&XCVR_DTEST_CTRL_REG(base), XCVR_DTEST_CTRL_DTEST_EN_SHIFT, XCVR_DTEST_CTRL_DTEST_EN_WIDTH))

/*! @brief Set the DTEST_EN field to a new value. */
#define XCVR_WR_DTEST_CTRL_DTEST_EN(base, value) (XCVR_RMW_DTEST_CTRL(base, XCVR_DTEST_CTRL_DTEST_EN_MASK, XCVR_DTEST_CTRL_DTEST_EN(value)))
#define XCVR_BWR_DTEST_CTRL_DTEST_EN(base, value) (BME_BFI32(&XCVR_DTEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_DTEST_CTRL_DTEST_EN_SHIFT), XCVR_DTEST_CTRL_DTEST_EN_SHIFT, XCVR_DTEST_CTRL_DTEST_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DTEST_CTRL, field GPIO0_OVLAY_PIN[11:8] (RW)
 *
 * The TSM-controlled output GPIO0_TRIG_EN can be routed to any DTEST pin,
 * regardless of page selection (DTEST_PAGE), replacing the nominal page-selected
 * output for that pin. When TSM_GPIO_OVLAY_0 = 1, this register selects the DTEST
 * pin onto which GPIO0_TRIG_EN will appear, any of DTEST0 - DTEST13. When
 * TSM_GPIO_OVLAY_0 = 0, this register is ignored, and the DTEST Page Table dictates the
 * node that appears on each DTEST pin.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DTEST_CTRL_GPIO0_OVLAY_PIN field. */
#define XCVR_RD_DTEST_CTRL_GPIO0_OVLAY_PIN(base) ((XCVR_DTEST_CTRL_REG(base) & XCVR_DTEST_CTRL_GPIO0_OVLAY_PIN_MASK) >> XCVR_DTEST_CTRL_GPIO0_OVLAY_PIN_SHIFT)
#define XCVR_BRD_DTEST_CTRL_GPIO0_OVLAY_PIN(base) (BME_UBFX32(&XCVR_DTEST_CTRL_REG(base), XCVR_DTEST_CTRL_GPIO0_OVLAY_PIN_SHIFT, XCVR_DTEST_CTRL_GPIO0_OVLAY_PIN_WIDTH))

/*! @brief Set the GPIO0_OVLAY_PIN field to a new value. */
#define XCVR_WR_DTEST_CTRL_GPIO0_OVLAY_PIN(base, value) (XCVR_RMW_DTEST_CTRL(base, XCVR_DTEST_CTRL_GPIO0_OVLAY_PIN_MASK, XCVR_DTEST_CTRL_GPIO0_OVLAY_PIN(value)))
#define XCVR_BWR_DTEST_CTRL_GPIO0_OVLAY_PIN(base, value) (BME_BFI32(&XCVR_DTEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_DTEST_CTRL_GPIO0_OVLAY_PIN_SHIFT), XCVR_DTEST_CTRL_GPIO0_OVLAY_PIN_SHIFT, XCVR_DTEST_CTRL_GPIO0_OVLAY_PIN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DTEST_CTRL, field GPIO1_OVLAY_PIN[15:12] (RW)
 *
 * The TSM-controlled output GPIO1_TRIG_EN can be routed to any DTEST pin,
 * regardless of page selection (DTEST_PAGE), replacing the nominal page-selected
 * output for that pin. When TSM_GPIO_OVLAY_1 = 1, this register selects the DTEST
 * pin onto which GPIO1_TRIG_EN will appear, any of DTEST0 - DTEST13. When
 * TSM_GPIO_OVLAY_1 = 0, this register is ignored, and the DTEST Page Table dictates the
 * node that appears on each DTEST pin.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DTEST_CTRL_GPIO1_OVLAY_PIN field. */
#define XCVR_RD_DTEST_CTRL_GPIO1_OVLAY_PIN(base) ((XCVR_DTEST_CTRL_REG(base) & XCVR_DTEST_CTRL_GPIO1_OVLAY_PIN_MASK) >> XCVR_DTEST_CTRL_GPIO1_OVLAY_PIN_SHIFT)
#define XCVR_BRD_DTEST_CTRL_GPIO1_OVLAY_PIN(base) (BME_UBFX32(&XCVR_DTEST_CTRL_REG(base), XCVR_DTEST_CTRL_GPIO1_OVLAY_PIN_SHIFT, XCVR_DTEST_CTRL_GPIO1_OVLAY_PIN_WIDTH))

/*! @brief Set the GPIO1_OVLAY_PIN field to a new value. */
#define XCVR_WR_DTEST_CTRL_GPIO1_OVLAY_PIN(base, value) (XCVR_RMW_DTEST_CTRL(base, XCVR_DTEST_CTRL_GPIO1_OVLAY_PIN_MASK, XCVR_DTEST_CTRL_GPIO1_OVLAY_PIN(value)))
#define XCVR_BWR_DTEST_CTRL_GPIO1_OVLAY_PIN(base, value) (BME_BFI32(&XCVR_DTEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_DTEST_CTRL_GPIO1_OVLAY_PIN_SHIFT), XCVR_DTEST_CTRL_GPIO1_OVLAY_PIN_SHIFT, XCVR_DTEST_CTRL_GPIO1_OVLAY_PIN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DTEST_CTRL, field TSM_GPIO_OVLAY_0[16] (RW)
 *
 * The TSM-controlled output GPIO0_TRIG_EN can be routed to any DTEST pin,
 * regardless of page selection (DTEST_PAGE), replacing the nominal page-selected
 * output for that pin. When TSM_GPIO_OVLAY_0 = 1, the register GPIO0_OVLAY_PIN[3:0]
 * selects the DTEST pin on which GPIO0_TRIG_EN will appear, any of DTEST0 -
 * DTEST13. When TSM_GPIO_OVLAY_0 = 0, there is no overlay, and the DTEST Page Table
 * dictates the node that appears on each DTEST pin.
 *
 * Values:
 * - 0b0 - there is no overlay, and the DTEST Page Table dictates the node that
 *     appears on each DTEST pin.
 * - 0b1 - the register GPIO0_OVLAY_PIN[3:0] selects the DTEST pin on which
 *     GPIO0_TRIG_EN will appear.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_0 field. */
#define XCVR_RD_DTEST_CTRL_TSM_GPIO_OVLAY_0(base) ((XCVR_DTEST_CTRL_REG(base) & XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_0_MASK) >> XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_0_SHIFT)
#define XCVR_BRD_DTEST_CTRL_TSM_GPIO_OVLAY_0(base) (BME_UBFX32(&XCVR_DTEST_CTRL_REG(base), XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_0_SHIFT, XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_0_WIDTH))

/*! @brief Set the TSM_GPIO_OVLAY_0 field to a new value. */
#define XCVR_WR_DTEST_CTRL_TSM_GPIO_OVLAY_0(base, value) (XCVR_RMW_DTEST_CTRL(base, XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_0_MASK, XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_0(value)))
#define XCVR_BWR_DTEST_CTRL_TSM_GPIO_OVLAY_0(base, value) (BME_BFI32(&XCVR_DTEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_0_SHIFT), XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_0_SHIFT, XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_0_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DTEST_CTRL, field TSM_GPIO_OVLAY_1[17] (RW)
 *
 * The TSM-controlled output GPIO1_TRIG_EN can be routed to any DTEST pin,
 * regardless of page selection (DTEST_PAGE), replacing the nominal page-selected
 * output for that pin. When TSM_GPIO_OVLAY_1 = 1, the register GPIO1_OVLAY_PIN[3:0]
 * selects the DTEST pin on which GPIO1_TRIG_EN will appear, any of DTEST0 -
 * DTEST13. When TSM_GPIO_OVLAY_1 = 0, there is no overlay, and the DTEST Page Table
 * dictates the node that appears on each DTEST pin.
 *
 * Values:
 * - 0b0 - there is no overlay, and the DTEST Page Table dictates the node that
 *     appears on each DTEST pin.
 * - 0b1 - the register GPIO1_OVLAY_PIN[3:0] selects the DTEST pin on which
 *     GPIO1_TRIG_EN will appear.
 */
/*@{*/
/*! @brief Read current value of the XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_1 field. */
#define XCVR_RD_DTEST_CTRL_TSM_GPIO_OVLAY_1(base) ((XCVR_DTEST_CTRL_REG(base) & XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_1_MASK) >> XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_1_SHIFT)
#define XCVR_BRD_DTEST_CTRL_TSM_GPIO_OVLAY_1(base) (BME_UBFX32(&XCVR_DTEST_CTRL_REG(base), XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_1_SHIFT, XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_1_WIDTH))

/*! @brief Set the TSM_GPIO_OVLAY_1 field to a new value. */
#define XCVR_WR_DTEST_CTRL_TSM_GPIO_OVLAY_1(base, value) (XCVR_RMW_DTEST_CTRL(base, XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_1_MASK, XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_1(value)))
#define XCVR_BWR_DTEST_CTRL_TSM_GPIO_OVLAY_1(base, value) (BME_BFI32(&XCVR_DTEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_1_SHIFT), XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_1_SHIFT, XCVR_DTEST_CTRL_TSM_GPIO_OVLAY_1_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DTEST_CTRL, field DTEST_SHFT[26:24] (RW)
 *
 * This register field DTEST_SHFT[1:0] control the amount of "arithmetic shift",
 * which can optionally be applied to DTEST output busses. DTEST_SHFT affects
 * only 2 DTEST output busses: PLL_RIPPLE_COUNTER[16:0] on DTEST page: PLLRIPPLE
 * (0x02). Shift is to the left (magnitude increasing) RX_DIG_IQ[11:0] on DTEST
 * page: RXDIGIQ (0x0E). Shift is to the right (magnitude decreasing) The bits of
 * PLL_RIPPLE_COUNTER[16:0], an unsigned value, are shifted by DTEST_SHFT[1:0]
 * according to the following table DTEST_SHFT[1:0] THESE BITS APPEAR ON DTEST[13:0]
 * 00 PLL_RIPPLE_COUNTER[16:3] 01 PLL_RIPPLE_COUNTER[15:2] 10
 * PLL_RIPPLE_COUNTER[14:1] 11 PLL_RIPPLE_COUNTER[13:0] The bits of RX_DIG_IQ[11:0], a signed value,
 * are shifted/sign-extended by DTEST_SHFT[1:0] according to the following table
 * DTEST_SHFT[1:0] THESE BITS APPEAR ON DTEST[13:2] 00 RX_DIG_IQ[11:0] (no
 * shift) 01 RX_DIG_IQ[11],RX_DIG_IQ[11:1] (right shift by 1) 10
 * RX_DIG_IQ[11],RX_DIG_IQ[11],RX_DIG_IQ[11:2] (right shift by 2) 11 RX_DIG_IQ[11:0] (no shift)
 */
/*@{*/
/*! @brief Read current value of the XCVR_DTEST_CTRL_DTEST_SHFT field. */
#define XCVR_RD_DTEST_CTRL_DTEST_SHFT(base) ((XCVR_DTEST_CTRL_REG(base) & XCVR_DTEST_CTRL_DTEST_SHFT_MASK) >> XCVR_DTEST_CTRL_DTEST_SHFT_SHIFT)
#define XCVR_BRD_DTEST_CTRL_DTEST_SHFT(base) (BME_UBFX32(&XCVR_DTEST_CTRL_REG(base), XCVR_DTEST_CTRL_DTEST_SHFT_SHIFT, XCVR_DTEST_CTRL_DTEST_SHFT_WIDTH))

/*! @brief Set the DTEST_SHFT field to a new value. */
#define XCVR_WR_DTEST_CTRL_DTEST_SHFT(base, value) (XCVR_RMW_DTEST_CTRL(base, XCVR_DTEST_CTRL_DTEST_SHFT_MASK, XCVR_DTEST_CTRL_DTEST_SHFT(value)))
#define XCVR_BWR_DTEST_CTRL_DTEST_SHFT(base, value) (BME_BFI32(&XCVR_DTEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_DTEST_CTRL_DTEST_SHFT_SHIFT), XCVR_DTEST_CTRL_DTEST_SHFT_SHIFT, XCVR_DTEST_CTRL_DTEST_SHFT_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DTEST_CTRL, field RAW_MODE_I[28] (RW)
 *
 * DTEST I Channel Raw Mode allows raw, unfiltered ADC samples to be brought out
 * to DTEST pins on the RXDIGIQ DTEST page. In raw mode, 2 5-bit ADC samples are
 * concatenated into a single 12-bit DMA sample. DMA transfers these samples to
 * memory in the same way it transfers filtered samples. Raw mode is only
 * supported when the RX_DIG is programmed to decimate-by-2. The procedure to active Raw
 * mode on I channel is as follows: 1. RX_DIG_CTRL[RX_ADC_RAW_EN]=1 2.
 * RX_DIG_CTRL[RX_DEC_FILT_OSR]=0 3. DTEST_CTRL[DTEST_PAGE]=0x0E (RXDIGIQ) 4.
 * DTEST_CTRL[DTEST_EN]=1 5. DTEST_CTRL[RAW_MODE_I]=1
 */
/*@{*/
/*! @brief Read current value of the XCVR_DTEST_CTRL_RAW_MODE_I field. */
#define XCVR_RD_DTEST_CTRL_RAW_MODE_I(base) ((XCVR_DTEST_CTRL_REG(base) & XCVR_DTEST_CTRL_RAW_MODE_I_MASK) >> XCVR_DTEST_CTRL_RAW_MODE_I_SHIFT)
#define XCVR_BRD_DTEST_CTRL_RAW_MODE_I(base) (BME_UBFX32(&XCVR_DTEST_CTRL_REG(base), XCVR_DTEST_CTRL_RAW_MODE_I_SHIFT, XCVR_DTEST_CTRL_RAW_MODE_I_WIDTH))

/*! @brief Set the RAW_MODE_I field to a new value. */
#define XCVR_WR_DTEST_CTRL_RAW_MODE_I(base, value) (XCVR_RMW_DTEST_CTRL(base, XCVR_DTEST_CTRL_RAW_MODE_I_MASK, XCVR_DTEST_CTRL_RAW_MODE_I(value)))
#define XCVR_BWR_DTEST_CTRL_RAW_MODE_I(base, value) (BME_BFI32(&XCVR_DTEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_DTEST_CTRL_RAW_MODE_I_SHIFT), XCVR_DTEST_CTRL_RAW_MODE_I_SHIFT, XCVR_DTEST_CTRL_RAW_MODE_I_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_DTEST_CTRL, field RAW_MODE_Q[29] (RW)
 *
 * DTEST Q Channel Raw Mode allows raw, unfiltered ADC samples to be brought out
 * to DTEST pins on the RXDIGIQ DTEST page. In raw mode, 2 5-bit ADC samples are
 * concatenated into a single 12-bit DMA sample. DMA transfers these samples to
 * memory in the same way it transfers filtered samples. Raw mode is only
 * supported when the RX_DIG is programmed to decimate-by-2. The procedure to active Raw
 * mode on Q channel is as follows: 1. RX_DIG_CTRL[RX_ADC_RAW_EN]=1 2.
 * RX_DIG_CTRL[RX_DEC_FILT_OSR]=0 3. DTEST_CTRL[DTEST_PAGE]=0x0E (RXDIGIQ) 4.
 * DTEST_CTRL[DTEST_EN]=1 5. DTEST_CTRL[RAW_MODE_Q]=1
 */
/*@{*/
/*! @brief Read current value of the XCVR_DTEST_CTRL_RAW_MODE_Q field. */
#define XCVR_RD_DTEST_CTRL_RAW_MODE_Q(base) ((XCVR_DTEST_CTRL_REG(base) & XCVR_DTEST_CTRL_RAW_MODE_Q_MASK) >> XCVR_DTEST_CTRL_RAW_MODE_Q_SHIFT)
#define XCVR_BRD_DTEST_CTRL_RAW_MODE_Q(base) (BME_UBFX32(&XCVR_DTEST_CTRL_REG(base), XCVR_DTEST_CTRL_RAW_MODE_Q_SHIFT, XCVR_DTEST_CTRL_RAW_MODE_Q_WIDTH))

/*! @brief Set the RAW_MODE_Q field to a new value. */
#define XCVR_WR_DTEST_CTRL_RAW_MODE_Q(base, value) (XCVR_RMW_DTEST_CTRL(base, XCVR_DTEST_CTRL_RAW_MODE_Q_MASK, XCVR_DTEST_CTRL_RAW_MODE_Q(value)))
#define XCVR_BWR_DTEST_CTRL_RAW_MODE_Q(base, value) (BME_BFI32(&XCVR_DTEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_DTEST_CTRL_RAW_MODE_Q_SHIFT), XCVR_DTEST_CTRL_RAW_MODE_Q_SHIFT, XCVR_DTEST_CTRL_RAW_MODE_Q_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PB_CTRL - Packet Buffer Control Register
 ******************************************************************************/

/*!
 * @brief XCVR_PB_CTRL - Packet Buffer Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_PB_CTRL register
 */
/*@{*/
#define XCVR_RD_PB_CTRL(base)    (XCVR_PB_CTRL_REG(base))
#define XCVR_WR_PB_CTRL(base, value) (XCVR_PB_CTRL_REG(base) = (value))
#define XCVR_RMW_PB_CTRL(base, mask, value) (XCVR_WR_PB_CTRL(base, (XCVR_RD_PB_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_PB_CTRL(base, value) (BME_OR32(&XCVR_PB_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PB_CTRL(base, value) (BME_AND32(&XCVR_PB_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PB_CTRL(base, value) (BME_XOR32(&XCVR_PB_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PB_CTRL bitfields
 */

/*!
 * @name Register XCVR_PB_CTRL, field PB_PROTECT[0] (RW)
 *
 * Protect Packet Buffer contents against overwriting by the next received packet
 *
 * Values:
 * - 0b0 - Incoming received packets overwrite Packet Buffer contents (default)
 * - 0b1 - Incoming received packets are blocked from overwriting Packet Buffer
 *     contents
 */
/*@{*/
/*! @brief Read current value of the XCVR_PB_CTRL_PB_PROTECT field. */
#define XCVR_RD_PB_CTRL_PB_PROTECT(base) ((XCVR_PB_CTRL_REG(base) & XCVR_PB_CTRL_PB_PROTECT_MASK) >> XCVR_PB_CTRL_PB_PROTECT_SHIFT)
#define XCVR_BRD_PB_CTRL_PB_PROTECT(base) (BME_UBFX32(&XCVR_PB_CTRL_REG(base), XCVR_PB_CTRL_PB_PROTECT_SHIFT, XCVR_PB_CTRL_PB_PROTECT_WIDTH))

/*! @brief Set the PB_PROTECT field to a new value. */
#define XCVR_WR_PB_CTRL_PB_PROTECT(base, value) (XCVR_RMW_PB_CTRL(base, XCVR_PB_CTRL_PB_PROTECT_MASK, XCVR_PB_CTRL_PB_PROTECT(value)))
#define XCVR_BWR_PB_CTRL_PB_PROTECT(base, value) (BME_BFI32(&XCVR_PB_CTRL_REG(base), ((uint32_t)(value) << XCVR_PB_CTRL_PB_PROTECT_SHIFT), XCVR_PB_CTRL_PB_PROTECT_SHIFT, XCVR_PB_CTRL_PB_PROTECT_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_CTRL - Transceiver Sequence Manager Control
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_CTRL - Transceiver Sequence Manager Control (RW)
 *
 * Reset value: 0xFF000000U
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_CTRL register
 */
/*@{*/
#define XCVR_RD_TSM_CTRL(base)   (XCVR_TSM_CTRL_REG(base))
#define XCVR_WR_TSM_CTRL(base, value) (XCVR_TSM_CTRL_REG(base) = (value))
#define XCVR_RMW_TSM_CTRL(base, mask, value) (XCVR_WR_TSM_CTRL(base, (XCVR_RD_TSM_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_CTRL(base, value) (BME_OR32(&XCVR_TSM_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_CTRL(base, value) (BME_AND32(&XCVR_TSM_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_CTRL(base, value) (BME_XOR32(&XCVR_TSM_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_CTRL bitfields
 */

/*!
 * @name Register XCVR_TSM_CTRL, field FORCE_TX_EN[2] (RW)
 *
 * Direct software control to launch a TX TSM sequence. Initiates a TX Warmup
 * sequence on a 0 to 1 transition and a TX Warmdown sequence on a 1 to 0
 * transition.
 *
 * Values:
 * - 0b0 - TSM Idle
 * - 0b1 - TSM executes a TX sequence
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_CTRL_FORCE_TX_EN field. */
#define XCVR_RD_TSM_CTRL_FORCE_TX_EN(base) ((XCVR_TSM_CTRL_REG(base) & XCVR_TSM_CTRL_FORCE_TX_EN_MASK) >> XCVR_TSM_CTRL_FORCE_TX_EN_SHIFT)
#define XCVR_BRD_TSM_CTRL_FORCE_TX_EN(base) (BME_UBFX32(&XCVR_TSM_CTRL_REG(base), XCVR_TSM_CTRL_FORCE_TX_EN_SHIFT, XCVR_TSM_CTRL_FORCE_TX_EN_WIDTH))

/*! @brief Set the FORCE_TX_EN field to a new value. */
#define XCVR_WR_TSM_CTRL_FORCE_TX_EN(base, value) (XCVR_RMW_TSM_CTRL(base, XCVR_TSM_CTRL_FORCE_TX_EN_MASK, XCVR_TSM_CTRL_FORCE_TX_EN(value)))
#define XCVR_BWR_TSM_CTRL_FORCE_TX_EN(base, value) (BME_BFI32(&XCVR_TSM_CTRL_REG(base), ((uint32_t)(value) << XCVR_TSM_CTRL_FORCE_TX_EN_SHIFT), XCVR_TSM_CTRL_FORCE_TX_EN_SHIFT, XCVR_TSM_CTRL_FORCE_TX_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_CTRL, field FORCE_RX_EN[3] (RW)
 *
 * Direct software control to launch a RX TSM sequence. Initiates RX Warmup on a
 * 0 to 1 transition and RX Warmdown on a 1 to 0 transition.
 *
 * Values:
 * - 0b0 - TSM Idle
 * - 0b1 - TSM executes a RX sequence
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_CTRL_FORCE_RX_EN field. */
#define XCVR_RD_TSM_CTRL_FORCE_RX_EN(base) ((XCVR_TSM_CTRL_REG(base) & XCVR_TSM_CTRL_FORCE_RX_EN_MASK) >> XCVR_TSM_CTRL_FORCE_RX_EN_SHIFT)
#define XCVR_BRD_TSM_CTRL_FORCE_RX_EN(base) (BME_UBFX32(&XCVR_TSM_CTRL_REG(base), XCVR_TSM_CTRL_FORCE_RX_EN_SHIFT, XCVR_TSM_CTRL_FORCE_RX_EN_WIDTH))

/*! @brief Set the FORCE_RX_EN field to a new value. */
#define XCVR_WR_TSM_CTRL_FORCE_RX_EN(base, value) (XCVR_RMW_TSM_CTRL(base, XCVR_TSM_CTRL_FORCE_RX_EN_MASK, XCVR_TSM_CTRL_FORCE_RX_EN(value)))
#define XCVR_BWR_TSM_CTRL_FORCE_RX_EN(base, value) (BME_BFI32(&XCVR_TSM_CTRL_REG(base), ((uint32_t)(value) << XCVR_TSM_CTRL_FORCE_RX_EN_SHIFT), XCVR_TSM_CTRL_FORCE_RX_EN_SHIFT, XCVR_TSM_CTRL_FORCE_RX_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_CTRL, field PA_RAMP_SEL[5:4] (RW)
 *
 * Selects the ramp-rate, and thus the duration, for PA ramping. Ramp-rate is
 * the rate at which the PA ramping logic steps through the PA Bias Table. the
 * default TSM TX sequence needs to be adjusted (re-programmed) for a 4us or 8us
 * ramp. PA_RAMP_SEL[1:0] TOTAL RAMP DURATION DURATION OF EACH RAMP STEP 00 No ramp
 * No ramp 01 2us 0.25us 10 4us 0.5us 11 8us 1us
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_CTRL_PA_RAMP_SEL field. */
#define XCVR_RD_TSM_CTRL_PA_RAMP_SEL(base) ((XCVR_TSM_CTRL_REG(base) & XCVR_TSM_CTRL_PA_RAMP_SEL_MASK) >> XCVR_TSM_CTRL_PA_RAMP_SEL_SHIFT)
#define XCVR_BRD_TSM_CTRL_PA_RAMP_SEL(base) (BME_UBFX32(&XCVR_TSM_CTRL_REG(base), XCVR_TSM_CTRL_PA_RAMP_SEL_SHIFT, XCVR_TSM_CTRL_PA_RAMP_SEL_WIDTH))

/*! @brief Set the PA_RAMP_SEL field to a new value. */
#define XCVR_WR_TSM_CTRL_PA_RAMP_SEL(base, value) (XCVR_RMW_TSM_CTRL(base, XCVR_TSM_CTRL_PA_RAMP_SEL_MASK, XCVR_TSM_CTRL_PA_RAMP_SEL(value)))
#define XCVR_BWR_TSM_CTRL_PA_RAMP_SEL(base, value) (BME_BFI32(&XCVR_TSM_CTRL_REG(base), ((uint32_t)(value) << XCVR_TSM_CTRL_PA_RAMP_SEL_SHIFT), XCVR_TSM_CTRL_PA_RAMP_SEL_SHIFT, XCVR_TSM_CTRL_PA_RAMP_SEL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_CTRL, field DATA_PADDING_EN[6] (RW)
 *
 * Enables TX Data Padding. Data padding works in conjunction with PA ramping to
 * minimize spectral transients during PA turn-on and turn-off. The nature of
 * the data padding depends on the setting of XCVR_CTRL[PROTOCOL].
 *
 * Values:
 * - 0b0 - Disable TX Data Padding
 * - 0b1 - Enable TX Data Padding
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_CTRL_DATA_PADDING_EN field. */
#define XCVR_RD_TSM_CTRL_DATA_PADDING_EN(base) ((XCVR_TSM_CTRL_REG(base) & XCVR_TSM_CTRL_DATA_PADDING_EN_MASK) >> XCVR_TSM_CTRL_DATA_PADDING_EN_SHIFT)
#define XCVR_BRD_TSM_CTRL_DATA_PADDING_EN(base) (BME_UBFX32(&XCVR_TSM_CTRL_REG(base), XCVR_TSM_CTRL_DATA_PADDING_EN_SHIFT, XCVR_TSM_CTRL_DATA_PADDING_EN_WIDTH))

/*! @brief Set the DATA_PADDING_EN field to a new value. */
#define XCVR_WR_TSM_CTRL_DATA_PADDING_EN(base, value) (XCVR_RMW_TSM_CTRL(base, XCVR_TSM_CTRL_DATA_PADDING_EN_MASK, XCVR_TSM_CTRL_DATA_PADDING_EN(value)))
#define XCVR_BWR_TSM_CTRL_DATA_PADDING_EN(base, value) (BME_BFI32(&XCVR_TSM_CTRL_REG(base), ((uint32_t)(value) << XCVR_TSM_CTRL_DATA_PADDING_EN_SHIFT), XCVR_TSM_CTRL_DATA_PADDING_EN_SHIFT, XCVR_TSM_CTRL_DATA_PADDING_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_CTRL, field TX_ABORT_DIS[16] (RW)
 *
 * TX Abort disable. When set, prevents PLL unlock events during TX sequences
 * from aborting the sequence.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_CTRL_TX_ABORT_DIS field. */
#define XCVR_RD_TSM_CTRL_TX_ABORT_DIS(base) ((XCVR_TSM_CTRL_REG(base) & XCVR_TSM_CTRL_TX_ABORT_DIS_MASK) >> XCVR_TSM_CTRL_TX_ABORT_DIS_SHIFT)
#define XCVR_BRD_TSM_CTRL_TX_ABORT_DIS(base) (BME_UBFX32(&XCVR_TSM_CTRL_REG(base), XCVR_TSM_CTRL_TX_ABORT_DIS_SHIFT, XCVR_TSM_CTRL_TX_ABORT_DIS_WIDTH))

/*! @brief Set the TX_ABORT_DIS field to a new value. */
#define XCVR_WR_TSM_CTRL_TX_ABORT_DIS(base, value) (XCVR_RMW_TSM_CTRL(base, XCVR_TSM_CTRL_TX_ABORT_DIS_MASK, XCVR_TSM_CTRL_TX_ABORT_DIS(value)))
#define XCVR_BWR_TSM_CTRL_TX_ABORT_DIS(base, value) (BME_BFI32(&XCVR_TSM_CTRL_REG(base), ((uint32_t)(value) << XCVR_TSM_CTRL_TX_ABORT_DIS_SHIFT), XCVR_TSM_CTRL_TX_ABORT_DIS_SHIFT, XCVR_TSM_CTRL_TX_ABORT_DIS_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_CTRL, field RX_ABORT_DIS[17] (RW)
 *
 * RX Abort disable. When set, prevents PLL unlock events during RX sequences
 * from aborting the sequence.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_CTRL_RX_ABORT_DIS field. */
#define XCVR_RD_TSM_CTRL_RX_ABORT_DIS(base) ((XCVR_TSM_CTRL_REG(base) & XCVR_TSM_CTRL_RX_ABORT_DIS_MASK) >> XCVR_TSM_CTRL_RX_ABORT_DIS_SHIFT)
#define XCVR_BRD_TSM_CTRL_RX_ABORT_DIS(base) (BME_UBFX32(&XCVR_TSM_CTRL_REG(base), XCVR_TSM_CTRL_RX_ABORT_DIS_SHIFT, XCVR_TSM_CTRL_RX_ABORT_DIS_WIDTH))

/*! @brief Set the RX_ABORT_DIS field to a new value. */
#define XCVR_WR_TSM_CTRL_RX_ABORT_DIS(base, value) (XCVR_RMW_TSM_CTRL(base, XCVR_TSM_CTRL_RX_ABORT_DIS_MASK, XCVR_TSM_CTRL_RX_ABORT_DIS(value)))
#define XCVR_BWR_TSM_CTRL_RX_ABORT_DIS(base, value) (BME_BFI32(&XCVR_TSM_CTRL_REG(base), ((uint32_t)(value) << XCVR_TSM_CTRL_RX_ABORT_DIS_SHIFT), XCVR_TSM_CTRL_RX_ABORT_DIS_SHIFT, XCVR_TSM_CTRL_RX_ABORT_DIS_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_CTRL, field ABORT_ON_CTUNE[18] (RW)
 *
 * Values:
 * - 0b0 - don't allow TSM abort on Coarse Tune Unlock Detect
 * - 0b1 - allow TSM abort on Coarse Tune Unlock Detect
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_CTRL_ABORT_ON_CTUNE field. */
#define XCVR_RD_TSM_CTRL_ABORT_ON_CTUNE(base) ((XCVR_TSM_CTRL_REG(base) & XCVR_TSM_CTRL_ABORT_ON_CTUNE_MASK) >> XCVR_TSM_CTRL_ABORT_ON_CTUNE_SHIFT)
#define XCVR_BRD_TSM_CTRL_ABORT_ON_CTUNE(base) (BME_UBFX32(&XCVR_TSM_CTRL_REG(base), XCVR_TSM_CTRL_ABORT_ON_CTUNE_SHIFT, XCVR_TSM_CTRL_ABORT_ON_CTUNE_WIDTH))

/*! @brief Set the ABORT_ON_CTUNE field to a new value. */
#define XCVR_WR_TSM_CTRL_ABORT_ON_CTUNE(base, value) (XCVR_RMW_TSM_CTRL(base, XCVR_TSM_CTRL_ABORT_ON_CTUNE_MASK, XCVR_TSM_CTRL_ABORT_ON_CTUNE(value)))
#define XCVR_BWR_TSM_CTRL_ABORT_ON_CTUNE(base, value) (BME_BFI32(&XCVR_TSM_CTRL_REG(base), ((uint32_t)(value) << XCVR_TSM_CTRL_ABORT_ON_CTUNE_SHIFT), XCVR_TSM_CTRL_ABORT_ON_CTUNE_SHIFT, XCVR_TSM_CTRL_ABORT_ON_CTUNE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_CTRL, field ABORT_ON_CYCLE_SLIP[19] (RW)
 *
 * Values:
 * - 0b0 - don't allow TSM abort on Cycle Slip Unlock Detect
 * - 0b1 - allow TSM abort on Cycle Slip Unlock Detect
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_CTRL_ABORT_ON_CYCLE_SLIP field. */
#define XCVR_RD_TSM_CTRL_ABORT_ON_CYCLE_SLIP(base) ((XCVR_TSM_CTRL_REG(base) & XCVR_TSM_CTRL_ABORT_ON_CYCLE_SLIP_MASK) >> XCVR_TSM_CTRL_ABORT_ON_CYCLE_SLIP_SHIFT)
#define XCVR_BRD_TSM_CTRL_ABORT_ON_CYCLE_SLIP(base) (BME_UBFX32(&XCVR_TSM_CTRL_REG(base), XCVR_TSM_CTRL_ABORT_ON_CYCLE_SLIP_SHIFT, XCVR_TSM_CTRL_ABORT_ON_CYCLE_SLIP_WIDTH))

/*! @brief Set the ABORT_ON_CYCLE_SLIP field to a new value. */
#define XCVR_WR_TSM_CTRL_ABORT_ON_CYCLE_SLIP(base, value) (XCVR_RMW_TSM_CTRL(base, XCVR_TSM_CTRL_ABORT_ON_CYCLE_SLIP_MASK, XCVR_TSM_CTRL_ABORT_ON_CYCLE_SLIP(value)))
#define XCVR_BWR_TSM_CTRL_ABORT_ON_CYCLE_SLIP(base, value) (BME_BFI32(&XCVR_TSM_CTRL_REG(base), ((uint32_t)(value) << XCVR_TSM_CTRL_ABORT_ON_CYCLE_SLIP_SHIFT), XCVR_TSM_CTRL_ABORT_ON_CYCLE_SLIP_SHIFT, XCVR_TSM_CTRL_ABORT_ON_CYCLE_SLIP_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_CTRL, field ABORT_ON_FREQ_TARG[20] (RW)
 *
 * Values:
 * - 0b0 - don't allow TSM abort on Frequency Target Unlock Detect
 * - 0b1 - allow TSM abort on Frequency Target Unlock Detect
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_CTRL_ABORT_ON_FREQ_TARG field. */
#define XCVR_RD_TSM_CTRL_ABORT_ON_FREQ_TARG(base) ((XCVR_TSM_CTRL_REG(base) & XCVR_TSM_CTRL_ABORT_ON_FREQ_TARG_MASK) >> XCVR_TSM_CTRL_ABORT_ON_FREQ_TARG_SHIFT)
#define XCVR_BRD_TSM_CTRL_ABORT_ON_FREQ_TARG(base) (BME_UBFX32(&XCVR_TSM_CTRL_REG(base), XCVR_TSM_CTRL_ABORT_ON_FREQ_TARG_SHIFT, XCVR_TSM_CTRL_ABORT_ON_FREQ_TARG_WIDTH))

/*! @brief Set the ABORT_ON_FREQ_TARG field to a new value. */
#define XCVR_WR_TSM_CTRL_ABORT_ON_FREQ_TARG(base, value) (XCVR_RMW_TSM_CTRL(base, XCVR_TSM_CTRL_ABORT_ON_FREQ_TARG_MASK, XCVR_TSM_CTRL_ABORT_ON_FREQ_TARG(value)))
#define XCVR_BWR_TSM_CTRL_ABORT_ON_FREQ_TARG(base, value) (BME_BFI32(&XCVR_TSM_CTRL_REG(base), ((uint32_t)(value) << XCVR_TSM_CTRL_ABORT_ON_FREQ_TARG_SHIFT), XCVR_TSM_CTRL_ABORT_ON_FREQ_TARG_SHIFT, XCVR_TSM_CTRL_ABORT_ON_FREQ_TARG_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_CTRL, field BKPT[31:24] (RW)
 *
 * Temporarily halt a TSM sequence during the warmup or warmdown phase. When the
 * TSM counter matches the value of BKPT[7:0], breakpoint will take effect and
 * the TSM counter will stop and hold its count. Breakpoint will remain in effect
 * as long as BKPT[7:0] matches the TSM counter value. The TSM Breakpoint can be
 * lifted by modifying the contents of this register. The default value of this
 * register, 0xFF, is greater than the length of the longest possible sequence, so
 * a breakpoint will never be triggered unless BKPT[7:0] is programmed to a
 * value less than the length of sequence.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_CTRL_BKPT field. */
#define XCVR_RD_TSM_CTRL_BKPT(base) ((XCVR_TSM_CTRL_REG(base) & XCVR_TSM_CTRL_BKPT_MASK) >> XCVR_TSM_CTRL_BKPT_SHIFT)
#define XCVR_BRD_TSM_CTRL_BKPT(base) (BME_UBFX32(&XCVR_TSM_CTRL_REG(base), XCVR_TSM_CTRL_BKPT_SHIFT, XCVR_TSM_CTRL_BKPT_WIDTH))

/*! @brief Set the BKPT field to a new value. */
#define XCVR_WR_TSM_CTRL_BKPT(base, value) (XCVR_RMW_TSM_CTRL(base, XCVR_TSM_CTRL_BKPT_MASK, XCVR_TSM_CTRL_BKPT(value)))
#define XCVR_BWR_TSM_CTRL_BKPT(base, value) (BME_BFI32(&XCVR_TSM_CTRL_REG(base), ((uint32_t)(value) << XCVR_TSM_CTRL_BKPT_SHIFT), XCVR_TSM_CTRL_BKPT_SHIFT, XCVR_TSM_CTRL_BKPT_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_END_OF_SEQ - End of Sequence Control
 ******************************************************************************/

/*!
 * @brief XCVR_END_OF_SEQ - End of Sequence Control (RW)
 *
 * Reset value: 0x65646A67U
 */
/*!
 * @name Constants and macros for entire XCVR_END_OF_SEQ register
 */
/*@{*/
#define XCVR_RD_END_OF_SEQ(base) (XCVR_END_OF_SEQ_REG(base))
#define XCVR_WR_END_OF_SEQ(base, value) (XCVR_END_OF_SEQ_REG(base) = (value))
#define XCVR_RMW_END_OF_SEQ(base, mask, value) (XCVR_WR_END_OF_SEQ(base, (XCVR_RD_END_OF_SEQ(base) & ~(mask)) | (value)))
#define XCVR_SET_END_OF_SEQ(base, value) (BME_OR32(&XCVR_END_OF_SEQ_REG(base), (uint32_t)(value)))
#define XCVR_CLR_END_OF_SEQ(base, value) (BME_AND32(&XCVR_END_OF_SEQ_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_END_OF_SEQ(base, value) (BME_XOR32(&XCVR_END_OF_SEQ_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_END_OF_SEQ bitfields
 */

/*!
 * @name Register XCVR_END_OF_SEQ, field END_OF_TX_WU[7:0] (RW)
 *
 * This register defines the length of the TSM TX warmup sequence. After the
 * assertion of a TX sequence-initiating event, when the TSM counter reaches the
 * count matching this register, it will stop and hold its count, and the TSM will
 * transition from the WARMUP to the ON phase.
 */
/*@{*/
/*! @brief Read current value of the XCVR_END_OF_SEQ_END_OF_TX_WU field. */
#define XCVR_RD_END_OF_SEQ_END_OF_TX_WU(base) ((XCVR_END_OF_SEQ_REG(base) & XCVR_END_OF_SEQ_END_OF_TX_WU_MASK) >> XCVR_END_OF_SEQ_END_OF_TX_WU_SHIFT)
#define XCVR_BRD_END_OF_SEQ_END_OF_TX_WU(base) (BME_UBFX32(&XCVR_END_OF_SEQ_REG(base), XCVR_END_OF_SEQ_END_OF_TX_WU_SHIFT, XCVR_END_OF_SEQ_END_OF_TX_WU_WIDTH))

/*! @brief Set the END_OF_TX_WU field to a new value. */
#define XCVR_WR_END_OF_SEQ_END_OF_TX_WU(base, value) (XCVR_RMW_END_OF_SEQ(base, XCVR_END_OF_SEQ_END_OF_TX_WU_MASK, XCVR_END_OF_SEQ_END_OF_TX_WU(value)))
#define XCVR_BWR_END_OF_SEQ_END_OF_TX_WU(base, value) (BME_BFI32(&XCVR_END_OF_SEQ_REG(base), ((uint32_t)(value) << XCVR_END_OF_SEQ_END_OF_TX_WU_SHIFT), XCVR_END_OF_SEQ_END_OF_TX_WU_SHIFT, XCVR_END_OF_SEQ_END_OF_TX_WU_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_END_OF_SEQ, field END_OF_TX_WD[15:8] (RW)
 *
 * This register defines the point at which the TSM TX sequence warmdown
 * completes, and the TSM returns to idle. The duration of the TSM warmdown phase is
 * determined by: END_OF_TX_WD - END_OF_TX_WU. For example: the sequence register
 * defaults render the END_OF_TX_WD=0x69 and END_OF_TX_WU=0x66, so the duration of
 * the warmdown phase is 0x69 - 0x66 = 3 microseconds.
 */
/*@{*/
/*! @brief Read current value of the XCVR_END_OF_SEQ_END_OF_TX_WD field. */
#define XCVR_RD_END_OF_SEQ_END_OF_TX_WD(base) ((XCVR_END_OF_SEQ_REG(base) & XCVR_END_OF_SEQ_END_OF_TX_WD_MASK) >> XCVR_END_OF_SEQ_END_OF_TX_WD_SHIFT)
#define XCVR_BRD_END_OF_SEQ_END_OF_TX_WD(base) (BME_UBFX32(&XCVR_END_OF_SEQ_REG(base), XCVR_END_OF_SEQ_END_OF_TX_WD_SHIFT, XCVR_END_OF_SEQ_END_OF_TX_WD_WIDTH))

/*! @brief Set the END_OF_TX_WD field to a new value. */
#define XCVR_WR_END_OF_SEQ_END_OF_TX_WD(base, value) (XCVR_RMW_END_OF_SEQ(base, XCVR_END_OF_SEQ_END_OF_TX_WD_MASK, XCVR_END_OF_SEQ_END_OF_TX_WD(value)))
#define XCVR_BWR_END_OF_SEQ_END_OF_TX_WD(base, value) (BME_BFI32(&XCVR_END_OF_SEQ_REG(base), ((uint32_t)(value) << XCVR_END_OF_SEQ_END_OF_TX_WD_SHIFT), XCVR_END_OF_SEQ_END_OF_TX_WD_SHIFT, XCVR_END_OF_SEQ_END_OF_TX_WD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_END_OF_SEQ, field END_OF_RX_WU[23:16] (RW)
 *
 * This register defines the length of the TSM RX warmup sequence. After the
 * assertion of a RX sequence-initiating event, when the TSM counter reaches the
 * count matching this register, it will stop and hold its count, and the TSM will
 * transition from the WARMUP to the ON phase.
 */
/*@{*/
/*! @brief Read current value of the XCVR_END_OF_SEQ_END_OF_RX_WU field. */
#define XCVR_RD_END_OF_SEQ_END_OF_RX_WU(base) ((XCVR_END_OF_SEQ_REG(base) & XCVR_END_OF_SEQ_END_OF_RX_WU_MASK) >> XCVR_END_OF_SEQ_END_OF_RX_WU_SHIFT)
#define XCVR_BRD_END_OF_SEQ_END_OF_RX_WU(base) (BME_UBFX32(&XCVR_END_OF_SEQ_REG(base), XCVR_END_OF_SEQ_END_OF_RX_WU_SHIFT, XCVR_END_OF_SEQ_END_OF_RX_WU_WIDTH))

/*! @brief Set the END_OF_RX_WU field to a new value. */
#define XCVR_WR_END_OF_SEQ_END_OF_RX_WU(base, value) (XCVR_RMW_END_OF_SEQ(base, XCVR_END_OF_SEQ_END_OF_RX_WU_MASK, XCVR_END_OF_SEQ_END_OF_RX_WU(value)))
#define XCVR_BWR_END_OF_SEQ_END_OF_RX_WU(base, value) (BME_BFI32(&XCVR_END_OF_SEQ_REG(base), ((uint32_t)(value) << XCVR_END_OF_SEQ_END_OF_RX_WU_SHIFT), XCVR_END_OF_SEQ_END_OF_RX_WU_SHIFT, XCVR_END_OF_SEQ_END_OF_RX_WU_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_END_OF_SEQ, field END_OF_RX_WD[31:24] (RW)
 *
 * This register defines the point at which the TSM RX sequence warmdown
 * completes, and the TSM returns to idle. The duration of the TSM warmdown phase is
 * determined by: END_OF_RX_WD - END_OF_RX_WU. For example: the sequence register
 * defaults render the END_OF_RX_WD=0x33 and END_OF_RX_WU=0x32, so the duration of
 * the warmdown phase is 0x33 - 0x32 = 1 microseconds.
 */
/*@{*/
/*! @brief Read current value of the XCVR_END_OF_SEQ_END_OF_RX_WD field. */
#define XCVR_RD_END_OF_SEQ_END_OF_RX_WD(base) ((XCVR_END_OF_SEQ_REG(base) & XCVR_END_OF_SEQ_END_OF_RX_WD_MASK) >> XCVR_END_OF_SEQ_END_OF_RX_WD_SHIFT)
#define XCVR_BRD_END_OF_SEQ_END_OF_RX_WD(base) (BME_UBFX32(&XCVR_END_OF_SEQ_REG(base), XCVR_END_OF_SEQ_END_OF_RX_WD_SHIFT, XCVR_END_OF_SEQ_END_OF_RX_WD_WIDTH))

/*! @brief Set the END_OF_RX_WD field to a new value. */
#define XCVR_WR_END_OF_SEQ_END_OF_RX_WD(base, value) (XCVR_RMW_END_OF_SEQ(base, XCVR_END_OF_SEQ_END_OF_RX_WD_MASK, XCVR_END_OF_SEQ_END_OF_RX_WD(value)))
#define XCVR_BWR_END_OF_SEQ_END_OF_RX_WD(base, value) (BME_BFI32(&XCVR_END_OF_SEQ_REG(base), ((uint32_t)(value) << XCVR_END_OF_SEQ_END_OF_RX_WD_SHIFT), XCVR_END_OF_SEQ_END_OF_RX_WD_SHIFT, XCVR_END_OF_SEQ_END_OF_RX_WD_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_OVRD0 - TSM Override 0
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_OVRD0 - TSM Override 0 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_OVRD0 register
 */
/*@{*/
#define XCVR_RD_TSM_OVRD0(base)  (XCVR_TSM_OVRD0_REG(base))
#define XCVR_WR_TSM_OVRD0(base, value) (XCVR_TSM_OVRD0_REG(base) = (value))
#define XCVR_RMW_TSM_OVRD0(base, mask, value) (XCVR_WR_TSM_OVRD0(base, (XCVR_RD_TSM_OVRD0(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_OVRD0(base, value) (BME_OR32(&XCVR_TSM_OVRD0_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_OVRD0(base, value) (BME_AND32(&XCVR_TSM_OVRD0_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_OVRD0(base, value) (BME_XOR32(&XCVR_TSM_OVRD0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_OVRD0 bitfields
 */

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_REG_EN_OVRD_EN[0] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of PLL_REG_EN_OVRD to override the signal "pll_reg_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_REG_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD0_PLL_REG_EN_OVRD_EN(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_REG_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD0_PLL_REG_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_REG_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_REG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_REG_EN_OVRD_EN_WIDTH))

/*! @brief Set the PLL_REG_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_REG_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_REG_EN_OVRD_EN_MASK, XCVR_TSM_OVRD0_PLL_REG_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_REG_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_REG_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD0_PLL_REG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_REG_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_REG_EN_OVRD[1] (RW)
 *
 * When PLL_REG_EN_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "pll_reg_en". This bit is ignored when PLL_REG_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_REG_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD0_PLL_REG_EN_OVRD(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_REG_EN_OVRD_MASK) >> XCVR_TSM_OVRD0_PLL_REG_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_REG_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_REG_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_REG_EN_OVRD_WIDTH))

/*! @brief Set the PLL_REG_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_REG_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_REG_EN_OVRD_MASK, XCVR_TSM_OVRD0_PLL_REG_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_REG_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_REG_EN_OVRD_SHIFT), XCVR_TSM_OVRD0_PLL_REG_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_REG_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_VCO_REG_EN_OVRD_EN[2] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of PLL_VCO_REG_EN_OVRD to override the signal
 *     "pll_vco_reg_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_EN(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_EN_WIDTH))

/*! @brief Set the PLL_VCO_REG_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_EN_MASK, XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_VCO_REG_EN_OVRD[3] (RW)
 *
 * When PLL_VCO_REG_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "pll_vco_reg_en". This bit is ignored when
 * PLL_VCO_REG_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD0_PLL_VCO_REG_EN_OVRD(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_MASK) >> XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_VCO_REG_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_WIDTH))

/*! @brief Set the PLL_VCO_REG_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_MASK, XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_SHIFT), XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_REG_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field QGEN_REG_EN_OVRD_EN[4] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of QGEN_REG_EN_OVRD to override the signal
 *     "qgen_reg_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD0_QGEN_REG_EN_OVRD_EN(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD0_QGEN_REG_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD_EN_WIDTH))

/*! @brief Set the QGEN_REG_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD0_QGEN_REG_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD_EN_MASK, XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD0_QGEN_REG_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field QGEN_REG_EN_OVRD[5] (RW)
 *
 * When QGEN_REG_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "qgen_reg_en". This bit is ignored when QGEN_REG_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD0_QGEN_REG_EN_OVRD(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD_MASK) >> XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD0_QGEN_REG_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD_WIDTH))

/*! @brief Set the QGEN_REG_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD0_QGEN_REG_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD_MASK, XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD0_QGEN_REG_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD_SHIFT), XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_QGEN_REG_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field TCA_TX_REG_EN_OVRD_EN[6] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of TCA_TX_REG_EN_OVRD to override the signal
 *     "tca_tx_reg_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD0_TCA_TX_REG_EN_OVRD_EN(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD0_TCA_TX_REG_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_EN_WIDTH))

/*! @brief Set the TCA_TX_REG_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_EN_MASK, XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field TCA_TX_REG_EN_OVRD[7] (RW)
 *
 * When TCA_TX_REG_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "tca_tx_reg_en". This bit is ignored when TCA_TX_REG_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD0_TCA_TX_REG_EN_OVRD(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_MASK) >> XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD0_TCA_TX_REG_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_WIDTH))

/*! @brief Set the TCA_TX_REG_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD0_TCA_TX_REG_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_MASK, XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD0_TCA_TX_REG_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_SHIFT), XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_TCA_TX_REG_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field ADC_ANA_REG_EN_OVRD_EN[8] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of ADC_ANA_REG_EN_OVRD to override the signal
 *     "adc_ana_reg_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_EN(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_EN_WIDTH))

/*! @brief Set the ADC_ANA_REG_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_EN_MASK, XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field ADC_ANA_REG_EN_OVRD[9] (RW)
 *
 * When ADC_ANA_REG_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "adc_ana_reg_en". This bit is ignored when
 * ADC_ANA_REG_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD0_ADC_ANA_REG_EN_OVRD(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_MASK) >> XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD0_ADC_ANA_REG_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_WIDTH))

/*! @brief Set the ADC_ANA_REG_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_MASK, XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_SHIFT), XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_ADC_ANA_REG_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field ADC_DIG_REG_EN_OVRD_EN[10] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of ADC_DIG_REG_EN_OVRD to override the signal
 *     "adc_dig_reg_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_EN(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_EN_WIDTH))

/*! @brief Set the ADC_DIG_REG_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_EN_MASK, XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field ADC_DIG_REG_EN_OVRD[11] (RW)
 *
 * When ADC_DIG_REG_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "adc_dig_reg_en". This bit is ignored when
 * ADC_DIG_REG_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD0_ADC_DIG_REG_EN_OVRD(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_MASK) >> XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD0_ADC_DIG_REG_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_WIDTH))

/*! @brief Set the ADC_DIG_REG_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_MASK, XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_SHIFT), XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_ADC_DIG_REG_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field XTAL_PLL_REF_CLK_EN_OVRD_EN[12] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of XTAL_PLL_REF_CLK_EN_OVRD to override the signal
 *     "xtal_pll_ref_clk_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_EN(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_EN_WIDTH))

/*! @brief Set the XTAL_PLL_REF_CLK_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_EN_MASK, XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field XTAL_PLL_REF_CLK_EN_OVRD[13] (RW)
 *
 * When XTAL_PLL_REF_CLK_EN_OVRD_EN=1, this value overrides the mission mode
 * state of the signal "xtal_pll_ref_clk_en". This bit is ignored when
 * XTAL_PLL_REF_CLK_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_MASK) >> XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_WIDTH))

/*! @brief Set the XTAL_PLL_REF_CLK_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_MASK, XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_SHIFT), XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_XTAL_PLL_REF_CLK_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field XTAL_ADC_REF_CLK_EN_OVRD_EN[14] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of XTAL_ADC_REF_CLK_EN_OVRD to override the signal
 *     "xtal_adc_ref_clk_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_EN(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_EN_WIDTH))

/*! @brief Set the XTAL_ADC_REF_CLK_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_EN_MASK, XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field XTAL_ADC_REF_CLK_EN_OVRD[15] (RW)
 *
 * When XTAL_ADC_REF_CLK_EN_OVRD_EN=1, this value overrides the mission mode
 * state of the signal "xtal_adc_ref_clk_en". This bit is ignored when
 * XTAL_ADC_REF_CLK_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_MASK) >> XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_WIDTH))

/*! @brief Set the XTAL_ADC_REF_CLK_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_MASK, XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_SHIFT), XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_XTAL_ADC_REF_CLK_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_VCO_AUTOTUNE_EN_OVRD_EN[16] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of PLL_VCO_AUTOTUNE_EN_OVRD to override the signal
 *     "pll_vco_autotune_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_EN(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_EN_WIDTH))

/*! @brief Set the PLL_VCO_AUTOTUNE_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_EN_MASK, XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_VCO_AUTOTUNE_EN_OVRD[17] (RW)
 *
 * When PLL_VCO_AUTOTUNE_EN_OVRD_EN=1, this value overrides the mission mode
 * state of the signal "pll_vco_autotune_en". This bit is ignored when
 * PLL_VCO_AUTOTUNE_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_MASK) >> XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_WIDTH))

/*! @brief Set the PLL_VCO_AUTOTUNE_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_MASK, XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_SHIFT), XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_AUTOTUNE_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_CYCLE_SLIP_LD_EN_OVRD_EN[18] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of PLL_CYCLE_SLIP_LD_EN_OVRD to override the signal
 *     "pll_cycle_slip_ld_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_EN(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_EN_WIDTH))

/*! @brief Set the PLL_CYCLE_SLIP_LD_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_EN_MASK, XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_CYCLE_SLIP_LD_EN_OVRD[19] (RW)
 *
 * When PLL_CYCLE_SLIP_LD_EN_OVRD_EN=1, this value overrides the mission mode
 * state of the signal "pll_cycle_slip_ld_en". This bit is ignored when
 * PLL_CYCLE_SLIP_LD_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_MASK) >> XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_WIDTH))

/*! @brief Set the PLL_CYCLE_SLIP_LD_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_MASK, XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_SHIFT), XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_CYCLE_SLIP_LD_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_VCO_EN_OVRD_EN[20] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of PLL_VCO_EN_OVRD to override the signal "pll_vco_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD0_PLL_VCO_EN_OVRD_EN(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_VCO_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD_EN_WIDTH))

/*! @brief Set the PLL_VCO_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_VCO_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD_EN_MASK, XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_VCO_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_VCO_EN_OVRD[21] (RW)
 *
 * When PLL_VCO_EN_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "pll_vco_en". This bit is ignored when PLL_VCO_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD0_PLL_VCO_EN_OVRD(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD_MASK) >> XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_VCO_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD_WIDTH))

/*! @brief Set the PLL_VCO_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_VCO_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD_MASK, XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_VCO_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD_SHIFT), XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_VCO_BUF_RX_EN_OVRD_EN[22] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of PLL_VCO_BUF_RX_EN_OVRD to override the signal
 *     "pll_vco_buf_rx_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_EN(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_EN_WIDTH))

/*! @brief Set the PLL_VCO_BUF_RX_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_EN_MASK, XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_VCO_BUF_RX_EN_OVRD[23] (RW)
 *
 * When PLL_VCO_BUF_RX_EN_OVRD_EN=1, this value overrides the mission mode state
 * of the signal "pll_vco_buf_rx_en". This bit is ignored when
 * PLL_VCO_BUF_RX_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_MASK) >> XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_WIDTH))

/*! @brief Set the PLL_VCO_BUF_RX_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_MASK, XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_SHIFT), XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_BUF_RX_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_VCO_BUF_TX_EN_OVRD_EN[24] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of PLL_VCO_BUF_TX_EN_OVRD to override the signal
 *     "pll_vco_buf_tx_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_EN(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_EN_WIDTH))

/*! @brief Set the PLL_VCO_BUF_TX_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_EN_MASK, XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_VCO_BUF_TX_EN_OVRD[25] (RW)
 *
 * When PLL_VCO_BUF_TX_EN_OVRD_EN=1, this value overrides the mission mode state
 * of the signal "pll_vco_buf_tx_en". This bit is ignored when
 * PLL_VCO_BUF_TX_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_MASK) >> XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_WIDTH))

/*! @brief Set the PLL_VCO_BUF_TX_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_MASK, XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_SHIFT), XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_VCO_BUF_TX_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_PA_BUF_EN_OVRD_EN[26] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of PLL_PA_BUF_EN_OVRD to override the signal
 *     "pll_pa_buf_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_EN(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_EN_WIDTH))

/*! @brief Set the PLL_PA_BUF_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_EN_MASK, XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_PA_BUF_EN_OVRD[27] (RW)
 *
 * When PLL_PA_BUF_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "pll_pa_buf_en". This bit is ignored when PLL_PA_BUF_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD0_PLL_PA_BUF_EN_OVRD(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_MASK) >> XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_PA_BUF_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_WIDTH))

/*! @brief Set the PLL_PA_BUF_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_MASK, XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_SHIFT), XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_PA_BUF_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_LDV_EN_OVRD_EN[28] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of PLL_LDV_EN_OVRD to override the signal "pll_ldv_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD0_PLL_LDV_EN_OVRD_EN(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_LDV_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD_EN_WIDTH))

/*! @brief Set the PLL_LDV_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_LDV_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD_EN_MASK, XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_LDV_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_LDV_EN_OVRD[29] (RW)
 *
 * When PLL_LDV_EN_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "pll_ldv_en". This bit is ignored when PLL_LDV_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD0_PLL_LDV_EN_OVRD(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD_MASK) >> XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_LDV_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD_WIDTH))

/*! @brief Set the PLL_LDV_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_LDV_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD_MASK, XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_LDV_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD_SHIFT), XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_LDV_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN[30] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of PLL_RX_LDV_RIPPLE_MUX_EN_OVRD to override the signal
 *     "pll_rx_ldv_ripple_mux_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN_WIDTH))

/*! @brief Set the PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN_MASK, XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD0, field PLL_RX_LDV_RIPPLE_MUX_EN_OVRD[31] (RW)
 *
 * When PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN=1, this value overrides the mission
 * mode state of the signal "pll_rx_ldv_ripple_mux_en". This bit is ignored when
 * PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD(base) ((XCVR_TSM_OVRD0_REG(base) & XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_MASK) >> XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD0_REG(base), XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_WIDTH))

/*! @brief Set the PLL_RX_LDV_RIPPLE_MUX_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD0(base, XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_MASK, XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD0_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_SHIFT), XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_SHIFT, XCVR_TSM_OVRD0_PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_OVRD1 - TSM Override 1
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_OVRD1 - TSM Override 1 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_OVRD1 register
 */
/*@{*/
#define XCVR_RD_TSM_OVRD1(base)  (XCVR_TSM_OVRD1_REG(base))
#define XCVR_WR_TSM_OVRD1(base, value) (XCVR_TSM_OVRD1_REG(base) = (value))
#define XCVR_RMW_TSM_OVRD1(base, mask, value) (XCVR_WR_TSM_OVRD1(base, (XCVR_RD_TSM_OVRD1(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_OVRD1(base, value) (BME_OR32(&XCVR_TSM_OVRD1_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_OVRD1(base, value) (BME_AND32(&XCVR_TSM_OVRD1_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_OVRD1(base, value) (BME_XOR32(&XCVR_TSM_OVRD1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_OVRD1 bitfields
 */

/*!
 * @name Register XCVR_TSM_OVRD1, field PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN[0] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of PLL_TX_LDV_RIPPLE_MUX_EN_OVRD to override the signal
 *     "pll_tx_ldv_ripple_mux_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN_WIDTH))

/*! @brief Set the PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN_MASK, XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field PLL_TX_LDV_RIPPLE_MUX_EN_OVRD[1] (RW)
 *
 * When PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN=1, this value overrides the mission
 * mode state of the signal "pll_tx_ldv_ripple_mux_en". This bit is ignored when
 * PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_MASK) >> XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_WIDTH))

/*! @brief Set the PLL_TX_LDV_RIPPLE_MUX_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_MASK, XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_SHIFT), XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field PLL_FILTER_CHARGE_EN_OVRD_EN[2] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of PLL_FILTER_CHARGE_EN_OVRD to override the signal
 *     "pll_filter_charge_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_EN(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_EN_WIDTH))

/*! @brief Set the PLL_FILTER_CHARGE_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_EN_MASK, XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field PLL_FILTER_CHARGE_EN_OVRD[3] (RW)
 *
 * When PLL_FILTER_CHARGE_EN_OVRD_EN=1, this value overrides the mission mode
 * state of the signal "pll_filter_charge_en". This bit is ignored when
 * PLL_FILTER_CHARGE_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_MASK) >> XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_WIDTH))

/*! @brief Set the PLL_FILTER_CHARGE_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_MASK, XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_SHIFT), XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_PLL_FILTER_CHARGE_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field PLL_PHDET_EN_OVRD_EN[4] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of PLL_PHDET_EN_OVRD to override the signal
 *     "pll_phdet_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD1_PLL_PHDET_EN_OVRD_EN(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD1_PLL_PHDET_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD_EN_WIDTH))

/*! @brief Set the PLL_PHDET_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD1_PLL_PHDET_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD_EN_MASK, XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD1_PLL_PHDET_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field PLL_PHDET_EN_OVRD[5] (RW)
 *
 * When PLL_PHDET_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "pll_phdet_en". This bit is ignored when PLL_PHDET_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD1_PLL_PHDET_EN_OVRD(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD_MASK) >> XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD1_PLL_PHDET_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD_WIDTH))

/*! @brief Set the PLL_PHDET_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD1_PLL_PHDET_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD_MASK, XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD1_PLL_PHDET_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD_SHIFT), XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_PLL_PHDET_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field QGEN25_EN_OVRD_EN[6] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of QGEN25_EN_OVRD to override the signal "qgen25_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_QGEN25_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD1_QGEN25_EN_OVRD_EN(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_QGEN25_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD1_QGEN25_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD1_QGEN25_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_QGEN25_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_QGEN25_EN_OVRD_EN_WIDTH))

/*! @brief Set the QGEN25_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD1_QGEN25_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_QGEN25_EN_OVRD_EN_MASK, XCVR_TSM_OVRD1_QGEN25_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD1_QGEN25_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_QGEN25_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD1_QGEN25_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_QGEN25_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field QGEN25_EN_OVRD[7] (RW)
 *
 * When QGEN25_EN_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "qgen25_en". This bit is ignored when QGEN25_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_QGEN25_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD1_QGEN25_EN_OVRD(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_QGEN25_EN_OVRD_MASK) >> XCVR_TSM_OVRD1_QGEN25_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD1_QGEN25_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_QGEN25_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_QGEN25_EN_OVRD_WIDTH))

/*! @brief Set the QGEN25_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD1_QGEN25_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_QGEN25_EN_OVRD_MASK, XCVR_TSM_OVRD1_QGEN25_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD1_QGEN25_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_QGEN25_EN_OVRD_SHIFT), XCVR_TSM_OVRD1_QGEN25_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_QGEN25_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field TX_EN_OVRD_EN[8] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of TX_EN_OVRD to override the signal "tx_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_TX_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD1_TX_EN_OVRD_EN(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_TX_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD1_TX_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD1_TX_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_TX_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_TX_EN_OVRD_EN_WIDTH))

/*! @brief Set the TX_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD1_TX_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_TX_EN_OVRD_EN_MASK, XCVR_TSM_OVRD1_TX_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD1_TX_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_TX_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD1_TX_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_TX_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field TX_EN_OVRD[9] (RW)
 *
 * When TX_EN_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "tx_en". This bit is ignored when TX_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_TX_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD1_TX_EN_OVRD(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_TX_EN_OVRD_MASK) >> XCVR_TSM_OVRD1_TX_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD1_TX_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_TX_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_TX_EN_OVRD_WIDTH))

/*! @brief Set the TX_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD1_TX_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_TX_EN_OVRD_MASK, XCVR_TSM_OVRD1_TX_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD1_TX_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_TX_EN_OVRD_SHIFT), XCVR_TSM_OVRD1_TX_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_TX_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field ADC_EN_OVRD_EN[10] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of ADC_EN_OVRD to override the signal "adc_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_ADC_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD1_ADC_EN_OVRD_EN(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_ADC_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD1_ADC_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD1_ADC_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_ADC_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_ADC_EN_OVRD_EN_WIDTH))

/*! @brief Set the ADC_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD1_ADC_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_ADC_EN_OVRD_EN_MASK, XCVR_TSM_OVRD1_ADC_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD1_ADC_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_ADC_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD1_ADC_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_ADC_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field ADC_EN_OVRD[11] (RW)
 *
 * When ADC_EN_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "adc_en". This bit is ignored when ADC_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_ADC_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD1_ADC_EN_OVRD(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_ADC_EN_OVRD_MASK) >> XCVR_TSM_OVRD1_ADC_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD1_ADC_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_ADC_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_ADC_EN_OVRD_WIDTH))

/*! @brief Set the ADC_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD1_ADC_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_ADC_EN_OVRD_MASK, XCVR_TSM_OVRD1_ADC_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD1_ADC_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_ADC_EN_OVRD_SHIFT), XCVR_TSM_OVRD1_ADC_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_ADC_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field ADC_BIAS_EN_OVRD_EN[12] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of ADC_BIAS_EN_OVRD to override the signal
 *     "adc_bias_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD1_ADC_BIAS_EN_OVRD_EN(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD1_ADC_BIAS_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD_EN_WIDTH))

/*! @brief Set the ADC_BIAS_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD1_ADC_BIAS_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD_EN_MASK, XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD1_ADC_BIAS_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field ADC_BIAS_EN_OVRD[13] (RW)
 *
 * When ADC_BIAS_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "adc_bias_en". This bit is ignored when ADC_BIAS_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD1_ADC_BIAS_EN_OVRD(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD_MASK) >> XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD1_ADC_BIAS_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD_WIDTH))

/*! @brief Set the ADC_BIAS_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD1_ADC_BIAS_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD_MASK, XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD1_ADC_BIAS_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD_SHIFT), XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_ADC_BIAS_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field ADC_CLK_EN_OVRD_EN[14] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of ADC_CLK_EN_OVRD to override the signal "adc_clk_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD1_ADC_CLK_EN_OVRD_EN(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD1_ADC_CLK_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD_EN_WIDTH))

/*! @brief Set the ADC_CLK_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD1_ADC_CLK_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD_EN_MASK, XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD1_ADC_CLK_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field ADC_CLK_EN_OVRD[15] (RW)
 *
 * When ADC_CLK_EN_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "adc_clk_en". This bit is ignored when ADC_CLK_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD1_ADC_CLK_EN_OVRD(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD_MASK) >> XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD1_ADC_CLK_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD_WIDTH))

/*! @brief Set the ADC_CLK_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD1_ADC_CLK_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD_MASK, XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD1_ADC_CLK_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD_SHIFT), XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_ADC_CLK_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field ADC_I_ADC_EN_OVRD_EN[16] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of ADC_I_ADC_EN_OVRD to override the signal
 *     "adc_i_adc_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD1_ADC_I_ADC_EN_OVRD_EN(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD1_ADC_I_ADC_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_EN_WIDTH))

/*! @brief Set the ADC_I_ADC_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_EN_MASK, XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field ADC_I_ADC_EN_OVRD[17] (RW)
 *
 * When ADC_I_ADC_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "adc_i_adc_en". This bit is ignored when ADC_I_ADC_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD1_ADC_I_ADC_EN_OVRD(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_MASK) >> XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD1_ADC_I_ADC_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_WIDTH))

/*! @brief Set the ADC_I_ADC_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD1_ADC_I_ADC_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_MASK, XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD1_ADC_I_ADC_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_SHIFT), XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_ADC_I_ADC_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field ADC_Q_ADC_EN_OVRD_EN[18] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of ADC_Q_ADC_EN_OVRD to override the signal
 *     "adc_q_adc_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_EN(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_EN_WIDTH))

/*! @brief Set the ADC_Q_ADC_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_EN_MASK, XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field ADC_Q_ADC_EN_OVRD[19] (RW)
 *
 * When ADC_Q_ADC_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "adc_q_adc_en". This bit is ignored when ADC_Q_ADC_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD1_ADC_Q_ADC_EN_OVRD(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_MASK) >> XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD1_ADC_Q_ADC_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_WIDTH))

/*! @brief Set the ADC_Q_ADC_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_MASK, XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_SHIFT), XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_ADC_Q_ADC_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field ADC_DAC1_EN_OVRD_EN[20] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of ADC_DAC1_EN_OVRD to override the signal
 *     "adc_dac1_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD1_ADC_DAC1_EN_OVRD_EN(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD1_ADC_DAC1_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD_EN_WIDTH))

/*! @brief Set the ADC_DAC1_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD1_ADC_DAC1_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD_EN_MASK, XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD1_ADC_DAC1_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field ADC_DAC1_EN_OVRD[21] (RW)
 *
 * When ADC_DAC1_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "adc_dac1_en". This bit is ignored when ADC_DAC1_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD1_ADC_DAC1_EN_OVRD(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD_MASK) >> XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD1_ADC_DAC1_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD_WIDTH))

/*! @brief Set the ADC_DAC1_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD1_ADC_DAC1_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD_MASK, XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD1_ADC_DAC1_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD_SHIFT), XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_ADC_DAC1_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field ADC_DAC2_EN_OVRD_EN[22] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of ADC_DAC2_EN_OVRD to override the signal
 *     "adc_dac2_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD1_ADC_DAC2_EN_OVRD_EN(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD1_ADC_DAC2_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD_EN_WIDTH))

/*! @brief Set the ADC_DAC2_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD1_ADC_DAC2_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD_EN_MASK, XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD1_ADC_DAC2_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field ADC_DAC2_EN_OVRD[23] (RW)
 *
 * When ADC_DAC2_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "adc_dac2_en". This bit is ignored when ADC_DAC2_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD1_ADC_DAC2_EN_OVRD(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD_MASK) >> XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD1_ADC_DAC2_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD_WIDTH))

/*! @brief Set the ADC_DAC2_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD1_ADC_DAC2_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD_MASK, XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD1_ADC_DAC2_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD_SHIFT), XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_ADC_DAC2_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field ADC_RST_EN_OVRD_EN[24] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of ADC_RST_EN_OVRD to override the signal "adc_rst_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_ADC_RST_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD1_ADC_RST_EN_OVRD_EN(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_ADC_RST_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD1_ADC_RST_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD1_ADC_RST_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_ADC_RST_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_ADC_RST_EN_OVRD_EN_WIDTH))

/*! @brief Set the ADC_RST_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD1_ADC_RST_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_ADC_RST_EN_OVRD_EN_MASK, XCVR_TSM_OVRD1_ADC_RST_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD1_ADC_RST_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_ADC_RST_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD1_ADC_RST_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_ADC_RST_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field ADC_RST_EN_OVRD[25] (RW)
 *
 * When ADC_RST_EN_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "adc_rst_en". This bit is ignored when ADC_RST_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_ADC_RST_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD1_ADC_RST_EN_OVRD(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_ADC_RST_EN_OVRD_MASK) >> XCVR_TSM_OVRD1_ADC_RST_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD1_ADC_RST_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_ADC_RST_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_ADC_RST_EN_OVRD_WIDTH))

/*! @brief Set the ADC_RST_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD1_ADC_RST_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_ADC_RST_EN_OVRD_MASK, XCVR_TSM_OVRD1_ADC_RST_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD1_ADC_RST_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_ADC_RST_EN_OVRD_SHIFT), XCVR_TSM_OVRD1_ADC_RST_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_ADC_RST_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field BBF_I_EN_OVRD_EN[26] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of BBF_I_EN_OVRD to override the signal "bbf_i_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_BBF_I_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD1_BBF_I_EN_OVRD_EN(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_BBF_I_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD1_BBF_I_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD1_BBF_I_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_BBF_I_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_BBF_I_EN_OVRD_EN_WIDTH))

/*! @brief Set the BBF_I_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD1_BBF_I_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_BBF_I_EN_OVRD_EN_MASK, XCVR_TSM_OVRD1_BBF_I_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD1_BBF_I_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_BBF_I_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD1_BBF_I_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_BBF_I_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field BBF_I_EN_OVRD[27] (RW)
 *
 * When BBF_I_EN_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "bbf_i_en". This bit is ignored when BBF_I_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_BBF_I_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD1_BBF_I_EN_OVRD(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_BBF_I_EN_OVRD_MASK) >> XCVR_TSM_OVRD1_BBF_I_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD1_BBF_I_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_BBF_I_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_BBF_I_EN_OVRD_WIDTH))

/*! @brief Set the BBF_I_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD1_BBF_I_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_BBF_I_EN_OVRD_MASK, XCVR_TSM_OVRD1_BBF_I_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD1_BBF_I_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_BBF_I_EN_OVRD_SHIFT), XCVR_TSM_OVRD1_BBF_I_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_BBF_I_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field BBF_Q_EN_OVRD_EN[28] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of BBF_Q_EN_OVRD to override the signal "bbf_q_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_BBF_Q_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD1_BBF_Q_EN_OVRD_EN(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_BBF_Q_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD1_BBF_Q_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD1_BBF_Q_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_BBF_Q_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_BBF_Q_EN_OVRD_EN_WIDTH))

/*! @brief Set the BBF_Q_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD1_BBF_Q_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_BBF_Q_EN_OVRD_EN_MASK, XCVR_TSM_OVRD1_BBF_Q_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD1_BBF_Q_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_BBF_Q_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD1_BBF_Q_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_BBF_Q_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field BBF_Q_EN_OVRD[29] (RW)
 *
 * When BBF_Q_EN_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "bbf_q_en". This bit is ignored when BBF_Q_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_BBF_Q_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD1_BBF_Q_EN_OVRD(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_BBF_Q_EN_OVRD_MASK) >> XCVR_TSM_OVRD1_BBF_Q_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD1_BBF_Q_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_BBF_Q_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_BBF_Q_EN_OVRD_WIDTH))

/*! @brief Set the BBF_Q_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD1_BBF_Q_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_BBF_Q_EN_OVRD_MASK, XCVR_TSM_OVRD1_BBF_Q_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD1_BBF_Q_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_BBF_Q_EN_OVRD_SHIFT), XCVR_TSM_OVRD1_BBF_Q_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_BBF_Q_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field BBF_PDET_EN_OVRD_EN[30] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of BBF_PDET_EN_OVRD to override the signal
 *     "bbf_pdet_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD1_BBF_PDET_EN_OVRD_EN(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD1_BBF_PDET_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD_EN_WIDTH))

/*! @brief Set the BBF_PDET_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD1_BBF_PDET_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD_EN_MASK, XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD1_BBF_PDET_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD1, field BBF_PDET_EN_OVRD[31] (RW)
 *
 * When BBF_PDET_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "bbf_pdet_en". This bit is ignored when BBF_PDET_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD1_BBF_PDET_EN_OVRD(base) ((XCVR_TSM_OVRD1_REG(base) & XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD_MASK) >> XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD1_BBF_PDET_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD1_REG(base), XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD_WIDTH))

/*! @brief Set the BBF_PDET_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD1_BBF_PDET_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD1(base, XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD_MASK, XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD1_BBF_PDET_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD1_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD_SHIFT), XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD_SHIFT, XCVR_TSM_OVRD1_BBF_PDET_EN_OVRD_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_OVRD2 - TSM Override 2
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_OVRD2 - TSM Override 2 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_OVRD2 register
 */
/*@{*/
#define XCVR_RD_TSM_OVRD2(base)  (XCVR_TSM_OVRD2_REG(base))
#define XCVR_WR_TSM_OVRD2(base, value) (XCVR_TSM_OVRD2_REG(base) = (value))
#define XCVR_RMW_TSM_OVRD2(base, mask, value) (XCVR_WR_TSM_OVRD2(base, (XCVR_RD_TSM_OVRD2(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_OVRD2(base, value) (BME_OR32(&XCVR_TSM_OVRD2_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_OVRD2(base, value) (BME_AND32(&XCVR_TSM_OVRD2_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_OVRD2(base, value) (BME_XOR32(&XCVR_TSM_OVRD2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_OVRD2 bitfields
 */

/*!
 * @name Register XCVR_TSM_OVRD2, field BBF_DCOC_EN_OVRD_EN[0] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of BBF_DCOC_EN_OVRD to override the signal
 *     "bbf_dcoc_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD2_BBF_DCOC_EN_OVRD_EN(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD2_BBF_DCOC_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD_EN_WIDTH))

/*! @brief Set the BBF_DCOC_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD2_BBF_DCOC_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD_EN_MASK, XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD2_BBF_DCOC_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field BBF_DCOC_EN_OVRD[1] (RW)
 *
 * When BBF_DCOC_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "bbf_dcoc_en". This bit is ignored when BBF_DCOC_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD2_BBF_DCOC_EN_OVRD(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD_MASK) >> XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD2_BBF_DCOC_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD_WIDTH))

/*! @brief Set the BBF_DCOC_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD2_BBF_DCOC_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD_MASK, XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD2_BBF_DCOC_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD_SHIFT), XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_BBF_DCOC_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field TCA_EN_OVRD_EN[2] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of TCA_EN_OVRD to override the signal "tca_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_TCA_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD2_TCA_EN_OVRD_EN(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_TCA_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD2_TCA_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD2_TCA_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_TCA_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_TCA_EN_OVRD_EN_WIDTH))

/*! @brief Set the TCA_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD2_TCA_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_TCA_EN_OVRD_EN_MASK, XCVR_TSM_OVRD2_TCA_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD2_TCA_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_TCA_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD2_TCA_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_TCA_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field TCA_EN_OVRD[3] (RW)
 *
 * When TCA_EN_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "tca_en". This bit is ignored when TCA_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_TCA_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD2_TCA_EN_OVRD(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_TCA_EN_OVRD_MASK) >> XCVR_TSM_OVRD2_TCA_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD2_TCA_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_TCA_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_TCA_EN_OVRD_WIDTH))

/*! @brief Set the TCA_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD2_TCA_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_TCA_EN_OVRD_MASK, XCVR_TSM_OVRD2_TCA_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD2_TCA_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_TCA_EN_OVRD_SHIFT), XCVR_TSM_OVRD2_TCA_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_TCA_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field TZA_I_EN_OVRD_EN[4] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of TZA_I_EN_OVRD to override the signal "tza_i_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_TZA_I_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD2_TZA_I_EN_OVRD_EN(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_TZA_I_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD2_TZA_I_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD2_TZA_I_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_TZA_I_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_TZA_I_EN_OVRD_EN_WIDTH))

/*! @brief Set the TZA_I_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD2_TZA_I_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_TZA_I_EN_OVRD_EN_MASK, XCVR_TSM_OVRD2_TZA_I_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD2_TZA_I_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_TZA_I_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD2_TZA_I_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_TZA_I_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field TZA_I_EN_OVRD[5] (RW)
 *
 * When TZA_I_EN_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "tza_i_en". This bit is ignored when TZA_I_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_TZA_I_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD2_TZA_I_EN_OVRD(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_TZA_I_EN_OVRD_MASK) >> XCVR_TSM_OVRD2_TZA_I_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD2_TZA_I_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_TZA_I_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_TZA_I_EN_OVRD_WIDTH))

/*! @brief Set the TZA_I_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD2_TZA_I_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_TZA_I_EN_OVRD_MASK, XCVR_TSM_OVRD2_TZA_I_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD2_TZA_I_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_TZA_I_EN_OVRD_SHIFT), XCVR_TSM_OVRD2_TZA_I_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_TZA_I_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field TZA_Q_EN_OVRD_EN[6] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of TZA_Q_EN_OVRD to override the signal "tza_q_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_TZA_Q_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD2_TZA_Q_EN_OVRD_EN(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_TZA_Q_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD2_TZA_Q_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD2_TZA_Q_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_TZA_Q_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_TZA_Q_EN_OVRD_EN_WIDTH))

/*! @brief Set the TZA_Q_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD2_TZA_Q_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_TZA_Q_EN_OVRD_EN_MASK, XCVR_TSM_OVRD2_TZA_Q_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD2_TZA_Q_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_TZA_Q_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD2_TZA_Q_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_TZA_Q_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field TZA_Q_EN_OVRD[7] (RW)
 *
 * When TZA_Q_EN_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "tza_q_en". This bit is ignored when TZA_Q_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_TZA_Q_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD2_TZA_Q_EN_OVRD(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_TZA_Q_EN_OVRD_MASK) >> XCVR_TSM_OVRD2_TZA_Q_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD2_TZA_Q_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_TZA_Q_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_TZA_Q_EN_OVRD_WIDTH))

/*! @brief Set the TZA_Q_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD2_TZA_Q_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_TZA_Q_EN_OVRD_MASK, XCVR_TSM_OVRD2_TZA_Q_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD2_TZA_Q_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_TZA_Q_EN_OVRD_SHIFT), XCVR_TSM_OVRD2_TZA_Q_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_TZA_Q_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field TZA_PDET_EN_OVRD_EN[8] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of TZA_PDET_EN_OVRD to override the signal
 *     "tza_pdet_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD2_TZA_PDET_EN_OVRD_EN(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD2_TZA_PDET_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD_EN_WIDTH))

/*! @brief Set the TZA_PDET_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD2_TZA_PDET_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD_EN_MASK, XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD2_TZA_PDET_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field TZA_PDET_EN_OVRD[9] (RW)
 *
 * When TZA_PDET_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "tza_pdet_en". This bit is ignored when TZA_PDET_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD2_TZA_PDET_EN_OVRD(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD_MASK) >> XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD2_TZA_PDET_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD_WIDTH))

/*! @brief Set the TZA_PDET_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD2_TZA_PDET_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD_MASK, XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD2_TZA_PDET_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD_SHIFT), XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_TZA_PDET_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field TZA_DCOC_EN_OVRD_EN[10] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of TZA_DCOC_EN_OVRD to override the signal
 *     "tza_dcoc_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD2_TZA_DCOC_EN_OVRD_EN(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD2_TZA_DCOC_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD_EN_WIDTH))

/*! @brief Set the TZA_DCOC_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD2_TZA_DCOC_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD_EN_MASK, XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD2_TZA_DCOC_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field TZA_DCOC_EN_OVRD[11] (RW)
 *
 * When TZA_DCOC_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "tza_dcoc_en". This bit is ignored when TZA_DCOC_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD2_TZA_DCOC_EN_OVRD(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD_MASK) >> XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD2_TZA_DCOC_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD_WIDTH))

/*! @brief Set the TZA_DCOC_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD2_TZA_DCOC_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD_MASK, XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD2_TZA_DCOC_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD_SHIFT), XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_TZA_DCOC_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field PLL_DIG_EN_OVRD_EN[12] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of PLL_DIG_EN_OVRD to override the signal "pll_dig_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD2_PLL_DIG_EN_OVRD_EN(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD2_PLL_DIG_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD_EN_WIDTH))

/*! @brief Set the PLL_DIG_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD2_PLL_DIG_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD_EN_MASK, XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD2_PLL_DIG_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field PLL_DIG_EN_OVRD[13] (RW)
 *
 * When PLL_DIG_EN_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "pll_dig_en". This bit is ignored when PLL_DIG_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD2_PLL_DIG_EN_OVRD(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD_MASK) >> XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD2_PLL_DIG_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD_WIDTH))

/*! @brief Set the PLL_DIG_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD2_PLL_DIG_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD_MASK, XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD2_PLL_DIG_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD_SHIFT), XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_PLL_DIG_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field TX_DIG_EN_OVRD_EN[14] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of TX_DIG_EN_OVRD to override the signal "tx_dig_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_TX_DIG_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD2_TX_DIG_EN_OVRD_EN(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_TX_DIG_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD2_TX_DIG_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD2_TX_DIG_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_TX_DIG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_TX_DIG_EN_OVRD_EN_WIDTH))

/*! @brief Set the TX_DIG_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD2_TX_DIG_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_TX_DIG_EN_OVRD_EN_MASK, XCVR_TSM_OVRD2_TX_DIG_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD2_TX_DIG_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_TX_DIG_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD2_TX_DIG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_TX_DIG_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field TX_DIG_EN_OVRD[15] (RW)
 *
 * When TX_DIG_EN_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "tx_dig_en". This bit is ignored when TX_DIG_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_TX_DIG_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD2_TX_DIG_EN_OVRD(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_TX_DIG_EN_OVRD_MASK) >> XCVR_TSM_OVRD2_TX_DIG_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD2_TX_DIG_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_TX_DIG_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_TX_DIG_EN_OVRD_WIDTH))

/*! @brief Set the TX_DIG_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD2_TX_DIG_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_TX_DIG_EN_OVRD_MASK, XCVR_TSM_OVRD2_TX_DIG_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD2_TX_DIG_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_TX_DIG_EN_OVRD_SHIFT), XCVR_TSM_OVRD2_TX_DIG_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_TX_DIG_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field RX_DIG_EN_OVRD_EN[16] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of RX_DIG_EN_OVRD to override the signal "rx_dig_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_RX_DIG_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD2_RX_DIG_EN_OVRD_EN(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_RX_DIG_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD2_RX_DIG_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD2_RX_DIG_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_RX_DIG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_RX_DIG_EN_OVRD_EN_WIDTH))

/*! @brief Set the RX_DIG_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD2_RX_DIG_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_RX_DIG_EN_OVRD_EN_MASK, XCVR_TSM_OVRD2_RX_DIG_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD2_RX_DIG_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_RX_DIG_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD2_RX_DIG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_RX_DIG_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field RX_DIG_EN_OVRD[17] (RW)
 *
 * When RX_DIG_EN_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "rx_dig_en". This bit is ignored when RX_DIG_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_RX_DIG_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD2_RX_DIG_EN_OVRD(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_RX_DIG_EN_OVRD_MASK) >> XCVR_TSM_OVRD2_RX_DIG_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD2_RX_DIG_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_RX_DIG_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_RX_DIG_EN_OVRD_WIDTH))

/*! @brief Set the RX_DIG_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD2_RX_DIG_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_RX_DIG_EN_OVRD_MASK, XCVR_TSM_OVRD2_RX_DIG_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD2_RX_DIG_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_RX_DIG_EN_OVRD_SHIFT), XCVR_TSM_OVRD2_RX_DIG_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_RX_DIG_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field RX_INIT_OVRD_EN[18] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of RX_INIT_OVRD to override the signal "rx_init".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_RX_INIT_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD2_RX_INIT_OVRD_EN(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_RX_INIT_OVRD_EN_MASK) >> XCVR_TSM_OVRD2_RX_INIT_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD2_RX_INIT_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_RX_INIT_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_RX_INIT_OVRD_EN_WIDTH))

/*! @brief Set the RX_INIT_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD2_RX_INIT_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_RX_INIT_OVRD_EN_MASK, XCVR_TSM_OVRD2_RX_INIT_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD2_RX_INIT_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_RX_INIT_OVRD_EN_SHIFT), XCVR_TSM_OVRD2_RX_INIT_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_RX_INIT_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field RX_INIT_OVRD[19] (RW)
 *
 * When RX_INIT_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "rx_init". This bit is ignored when RX_INIT_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_RX_INIT_OVRD field. */
#define XCVR_RD_TSM_OVRD2_RX_INIT_OVRD(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_RX_INIT_OVRD_MASK) >> XCVR_TSM_OVRD2_RX_INIT_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD2_RX_INIT_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_RX_INIT_OVRD_SHIFT, XCVR_TSM_OVRD2_RX_INIT_OVRD_WIDTH))

/*! @brief Set the RX_INIT_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD2_RX_INIT_OVRD(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_RX_INIT_OVRD_MASK, XCVR_TSM_OVRD2_RX_INIT_OVRD(value)))
#define XCVR_BWR_TSM_OVRD2_RX_INIT_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_RX_INIT_OVRD_SHIFT), XCVR_TSM_OVRD2_RX_INIT_OVRD_SHIFT, XCVR_TSM_OVRD2_RX_INIT_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field SIGMA_DELTA_EN_OVRD_EN[20] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of SIGMA_DELTA_EN_OVRD to override the signal
 *     "sigma_delta_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_EN(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_EN_WIDTH))

/*! @brief Set the SIGMA_DELTA_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_EN_MASK, XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field SIGMA_DELTA_EN_OVRD[21] (RW)
 *
 * When SIGMA_DELTA_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "sigma_delta_en". This bit is ignored when
 * SIGMA_DELTA_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD2_SIGMA_DELTA_EN_OVRD(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_MASK) >> XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD2_SIGMA_DELTA_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_WIDTH))

/*! @brief Set the SIGMA_DELTA_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_MASK, XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_SHIFT), XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_SIGMA_DELTA_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field ZBDEM_RX_EN_OVRD_EN[22] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of ZBDEM_RX_EN_OVRD to override the signal
 *     "zbdem_rx_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD2_ZBDEM_RX_EN_OVRD_EN(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD2_ZBDEM_RX_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_EN_WIDTH))

/*! @brief Set the ZBDEM_RX_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_EN_MASK, XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field ZBDEM_RX_EN_OVRD[23] (RW)
 *
 * When ZBDEM_RX_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "zbdem_rx_en". This bit is ignored when ZBDEM_RX_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD2_ZBDEM_RX_EN_OVRD(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_MASK) >> XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD2_ZBDEM_RX_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_WIDTH))

/*! @brief Set the ZBDEM_RX_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD2_ZBDEM_RX_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_MASK, XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD2_ZBDEM_RX_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_SHIFT), XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_ZBDEM_RX_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field DCOC_EN_OVRD_EN[24] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of DCOC_EN_OVRD to override the signal "dcoc_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_DCOC_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD2_DCOC_EN_OVRD_EN(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_DCOC_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD2_DCOC_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD2_DCOC_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_DCOC_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_DCOC_EN_OVRD_EN_WIDTH))

/*! @brief Set the DCOC_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD2_DCOC_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_DCOC_EN_OVRD_EN_MASK, XCVR_TSM_OVRD2_DCOC_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD2_DCOC_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_DCOC_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD2_DCOC_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_DCOC_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field DCOC_EN_OVRD[25] (RW)
 *
 * When DCOC_EN_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "dcoc_en". This bit is ignored when DCOC_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_DCOC_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD2_DCOC_EN_OVRD(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_DCOC_EN_OVRD_MASK) >> XCVR_TSM_OVRD2_DCOC_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD2_DCOC_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_DCOC_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_DCOC_EN_OVRD_WIDTH))

/*! @brief Set the DCOC_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD2_DCOC_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_DCOC_EN_OVRD_MASK, XCVR_TSM_OVRD2_DCOC_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD2_DCOC_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_DCOC_EN_OVRD_SHIFT), XCVR_TSM_OVRD2_DCOC_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_DCOC_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field DCOC_INIT_OVRD_EN[26] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of DCOC_INIT_OVRD to override the signal "dcoc_init".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_DCOC_INIT_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD2_DCOC_INIT_OVRD_EN(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_DCOC_INIT_OVRD_EN_MASK) >> XCVR_TSM_OVRD2_DCOC_INIT_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD2_DCOC_INIT_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_DCOC_INIT_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_DCOC_INIT_OVRD_EN_WIDTH))

/*! @brief Set the DCOC_INIT_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD2_DCOC_INIT_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_DCOC_INIT_OVRD_EN_MASK, XCVR_TSM_OVRD2_DCOC_INIT_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD2_DCOC_INIT_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_DCOC_INIT_OVRD_EN_SHIFT), XCVR_TSM_OVRD2_DCOC_INIT_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_DCOC_INIT_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field DCOC_INIT_OVRD[27] (RW)
 *
 * When DCOC_INIT_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "dcoc_init". This bit is ignored when DCOC_INIT_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_DCOC_INIT_OVRD field. */
#define XCVR_RD_TSM_OVRD2_DCOC_INIT_OVRD(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_DCOC_INIT_OVRD_MASK) >> XCVR_TSM_OVRD2_DCOC_INIT_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD2_DCOC_INIT_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_DCOC_INIT_OVRD_SHIFT, XCVR_TSM_OVRD2_DCOC_INIT_OVRD_WIDTH))

/*! @brief Set the DCOC_INIT_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD2_DCOC_INIT_OVRD(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_DCOC_INIT_OVRD_MASK, XCVR_TSM_OVRD2_DCOC_INIT_OVRD(value)))
#define XCVR_BWR_TSM_OVRD2_DCOC_INIT_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_DCOC_INIT_OVRD_SHIFT), XCVR_TSM_OVRD2_DCOC_INIT_OVRD_SHIFT, XCVR_TSM_OVRD2_DCOC_INIT_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field FREQ_TARG_LD_EN_OVRD_EN[28] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of FREQ_TARG_LD_EN_OVRD to override the signal
 *     "freq_targ_ld_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_EN(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_EN_WIDTH))

/*! @brief Set the FREQ_TARG_LD_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_EN_MASK, XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field FREQ_TARG_LD_EN_OVRD[29] (RW)
 *
 * When FREQ_TARG_LD_EN_OVRD_EN=1, this value overrides the mission mode state
 * of the signal "freq_targ_ld_en". This bit is ignored when
 * FREQ_TARG_LD_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_MASK) >> XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_WIDTH))

/*! @brief Set the FREQ_TARG_LD_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_MASK, XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_SHIFT), XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_FREQ_TARG_LD_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field SAR_ADC_TRIG_EN_OVRD_EN[30] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of SAR_ADC_TRIG_EN_OVRD to override the signal
 *     "sar_adc_trig_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_EN(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_EN_WIDTH))

/*! @brief Set the SAR_ADC_TRIG_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_EN_MASK, XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD2, field SAR_ADC_TRIG_EN_OVRD[31] (RW)
 *
 * When SAR_ADC_TRIG_EN_OVRD_EN=1, this value overrides the mission mode state
 * of the signal "sar_adc_trig_en". This bit is ignored when
 * SAR_ADC_TRIG_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD(base) ((XCVR_TSM_OVRD2_REG(base) & XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_MASK) >> XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD2_REG(base), XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_WIDTH))

/*! @brief Set the SAR_ADC_TRIG_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD2(base, XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_MASK, XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD2_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_SHIFT), XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_SHIFT, XCVR_TSM_OVRD2_SAR_ADC_TRIG_EN_OVRD_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_OVRD3 - TSM Override 3
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_OVRD3 - TSM Override 3 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_OVRD3 register
 */
/*@{*/
#define XCVR_RD_TSM_OVRD3(base)  (XCVR_TSM_OVRD3_REG(base))
#define XCVR_WR_TSM_OVRD3(base, value) (XCVR_TSM_OVRD3_REG(base) = (value))
#define XCVR_RMW_TSM_OVRD3(base, mask, value) (XCVR_WR_TSM_OVRD3(base, (XCVR_RD_TSM_OVRD3(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_OVRD3(base, value) (BME_OR32(&XCVR_TSM_OVRD3_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_OVRD3(base, value) (BME_AND32(&XCVR_TSM_OVRD3_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_OVRD3(base, value) (BME_XOR32(&XCVR_TSM_OVRD3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_OVRD3 bitfields
 */

/*!
 * @name Register XCVR_TSM_OVRD3, field TSM_SPARE0_EN_OVRD_EN[0] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of TSM_SPARE0_EN_OVRD to override the signal
 *     "tsm_spare0_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD3_TSM_SPARE0_EN_OVRD_EN(base) ((XCVR_TSM_OVRD3_REG(base) & XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD3_TSM_SPARE0_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD3_REG(base), XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_EN_WIDTH))

/*! @brief Set the TSM_SPARE0_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD3(base, XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_EN_MASK, XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD3_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD3, field TSM_SPARE0_EN_OVRD[1] (RW)
 *
 * When TSM_SPARE0_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "tsm_spare0_en". This bit is ignored when TSM_SPARE0_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD3_TSM_SPARE0_EN_OVRD(base) ((XCVR_TSM_OVRD3_REG(base) & XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_MASK) >> XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD3_TSM_SPARE0_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD3_REG(base), XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_SHIFT, XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_WIDTH))

/*! @brief Set the TSM_SPARE0_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD3_TSM_SPARE0_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD3(base, XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_MASK, XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD3_TSM_SPARE0_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD3_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_SHIFT), XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_SHIFT, XCVR_TSM_OVRD3_TSM_SPARE0_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD3, field TSM_SPARE1_EN_OVRD_EN[2] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of TSM_SPARE1_EN_OVRD to override the signal
 *     "tsm_spare1_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD3_TSM_SPARE1_EN_OVRD_EN(base) ((XCVR_TSM_OVRD3_REG(base) & XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD3_TSM_SPARE1_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD3_REG(base), XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_EN_WIDTH))

/*! @brief Set the TSM_SPARE1_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD3(base, XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_EN_MASK, XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD3_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD3, field TSM_SPARE1_EN_OVRD[3] (RW)
 *
 * When TSM_SPARE1_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "tsm_spare1_en". This bit is ignored when TSM_SPARE1_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD3_TSM_SPARE1_EN_OVRD(base) ((XCVR_TSM_OVRD3_REG(base) & XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_MASK) >> XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD3_TSM_SPARE1_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD3_REG(base), XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_SHIFT, XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_WIDTH))

/*! @brief Set the TSM_SPARE1_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD3_TSM_SPARE1_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD3(base, XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_MASK, XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD3_TSM_SPARE1_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD3_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_SHIFT), XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_SHIFT, XCVR_TSM_OVRD3_TSM_SPARE1_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD3, field TSM_SPARE2_EN_OVRD_EN[4] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of TSM_SPARE2_EN_OVRD to override the signal
 *     "tsm_spare2_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD3_TSM_SPARE2_EN_OVRD_EN(base) ((XCVR_TSM_OVRD3_REG(base) & XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD3_TSM_SPARE2_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD3_REG(base), XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_EN_WIDTH))

/*! @brief Set the TSM_SPARE2_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD3(base, XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_EN_MASK, XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD3_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD3, field TSM_SPARE2_EN_OVRD[5] (RW)
 *
 * When TSM_SPARE2_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "tsm_spare2_en". This bit is ignored when TSM_SPARE2_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD3_TSM_SPARE2_EN_OVRD(base) ((XCVR_TSM_OVRD3_REG(base) & XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_MASK) >> XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD3_TSM_SPARE2_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD3_REG(base), XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_SHIFT, XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_WIDTH))

/*! @brief Set the TSM_SPARE2_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD3_TSM_SPARE2_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD3(base, XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_MASK, XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD3_TSM_SPARE2_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD3_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_SHIFT), XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_SHIFT, XCVR_TSM_OVRD3_TSM_SPARE2_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD3, field TSM_SPARE3_EN_OVRD_EN[6] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of TSM_SPARE3_EN_OVRD to override the signal
 *     "tsm_spare3_en".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD3_TSM_SPARE3_EN_OVRD_EN(base) ((XCVR_TSM_OVRD3_REG(base) & XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_EN_MASK) >> XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD3_TSM_SPARE3_EN_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD3_REG(base), XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_EN_WIDTH))

/*! @brief Set the TSM_SPARE3_EN_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD3(base, XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_EN_MASK, XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD3_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_EN_SHIFT), XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_EN_SHIFT, XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD3, field TSM_SPARE3_EN_OVRD[7] (RW)
 *
 * When TSM_SPARE3_EN_OVRD_EN=1, this value overrides the mission mode state of
 * the signal "tsm_spare3_en". This bit is ignored when TSM_SPARE3_EN_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD field. */
#define XCVR_RD_TSM_OVRD3_TSM_SPARE3_EN_OVRD(base) ((XCVR_TSM_OVRD3_REG(base) & XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_MASK) >> XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD3_TSM_SPARE3_EN_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD3_REG(base), XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_SHIFT, XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_WIDTH))

/*! @brief Set the TSM_SPARE3_EN_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD3_TSM_SPARE3_EN_OVRD(base, value) (XCVR_RMW_TSM_OVRD3(base, XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_MASK, XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD(value)))
#define XCVR_BWR_TSM_OVRD3_TSM_SPARE3_EN_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD3_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_SHIFT), XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_SHIFT, XCVR_TSM_OVRD3_TSM_SPARE3_EN_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD3, field TX_MODE_OVRD_EN[8] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of TX_MODE_OVRD to override the signal "tx_mode".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD3_TX_MODE_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD3_TX_MODE_OVRD_EN(base) ((XCVR_TSM_OVRD3_REG(base) & XCVR_TSM_OVRD3_TX_MODE_OVRD_EN_MASK) >> XCVR_TSM_OVRD3_TX_MODE_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD3_TX_MODE_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD3_REG(base), XCVR_TSM_OVRD3_TX_MODE_OVRD_EN_SHIFT, XCVR_TSM_OVRD3_TX_MODE_OVRD_EN_WIDTH))

/*! @brief Set the TX_MODE_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD3_TX_MODE_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD3(base, XCVR_TSM_OVRD3_TX_MODE_OVRD_EN_MASK, XCVR_TSM_OVRD3_TX_MODE_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD3_TX_MODE_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD3_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD3_TX_MODE_OVRD_EN_SHIFT), XCVR_TSM_OVRD3_TX_MODE_OVRD_EN_SHIFT, XCVR_TSM_OVRD3_TX_MODE_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD3, field TX_MODE_OVRD[9] (RW)
 *
 * When TX_MODE_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "tx_mode". This bit is ignored when TX_MODE_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD3_TX_MODE_OVRD field. */
#define XCVR_RD_TSM_OVRD3_TX_MODE_OVRD(base) ((XCVR_TSM_OVRD3_REG(base) & XCVR_TSM_OVRD3_TX_MODE_OVRD_MASK) >> XCVR_TSM_OVRD3_TX_MODE_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD3_TX_MODE_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD3_REG(base), XCVR_TSM_OVRD3_TX_MODE_OVRD_SHIFT, XCVR_TSM_OVRD3_TX_MODE_OVRD_WIDTH))

/*! @brief Set the TX_MODE_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD3_TX_MODE_OVRD(base, value) (XCVR_RMW_TSM_OVRD3(base, XCVR_TSM_OVRD3_TX_MODE_OVRD_MASK, XCVR_TSM_OVRD3_TX_MODE_OVRD(value)))
#define XCVR_BWR_TSM_OVRD3_TX_MODE_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD3_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD3_TX_MODE_OVRD_SHIFT), XCVR_TSM_OVRD3_TX_MODE_OVRD_SHIFT, XCVR_TSM_OVRD3_TX_MODE_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD3, field RX_MODE_OVRD_EN[10] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Use the state of RX_MODE_OVRD to override the signal "rx_mode".
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD3_RX_MODE_OVRD_EN field. */
#define XCVR_RD_TSM_OVRD3_RX_MODE_OVRD_EN(base) ((XCVR_TSM_OVRD3_REG(base) & XCVR_TSM_OVRD3_RX_MODE_OVRD_EN_MASK) >> XCVR_TSM_OVRD3_RX_MODE_OVRD_EN_SHIFT)
#define XCVR_BRD_TSM_OVRD3_RX_MODE_OVRD_EN(base) (BME_UBFX32(&XCVR_TSM_OVRD3_REG(base), XCVR_TSM_OVRD3_RX_MODE_OVRD_EN_SHIFT, XCVR_TSM_OVRD3_RX_MODE_OVRD_EN_WIDTH))

/*! @brief Set the RX_MODE_OVRD_EN field to a new value. */
#define XCVR_WR_TSM_OVRD3_RX_MODE_OVRD_EN(base, value) (XCVR_RMW_TSM_OVRD3(base, XCVR_TSM_OVRD3_RX_MODE_OVRD_EN_MASK, XCVR_TSM_OVRD3_RX_MODE_OVRD_EN(value)))
#define XCVR_BWR_TSM_OVRD3_RX_MODE_OVRD_EN(base, value) (BME_BFI32(&XCVR_TSM_OVRD3_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD3_RX_MODE_OVRD_EN_SHIFT), XCVR_TSM_OVRD3_RX_MODE_OVRD_EN_SHIFT, XCVR_TSM_OVRD3_RX_MODE_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_OVRD3, field RX_MODE_OVRD[11] (RW)
 *
 * When RX_MODE_OVRD_EN=1, this value overrides the mission mode state of the
 * signal "rx_mode". This bit is ignored when RX_MODE_OVRD_EN==0.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_OVRD3_RX_MODE_OVRD field. */
#define XCVR_RD_TSM_OVRD3_RX_MODE_OVRD(base) ((XCVR_TSM_OVRD3_REG(base) & XCVR_TSM_OVRD3_RX_MODE_OVRD_MASK) >> XCVR_TSM_OVRD3_RX_MODE_OVRD_SHIFT)
#define XCVR_BRD_TSM_OVRD3_RX_MODE_OVRD(base) (BME_UBFX32(&XCVR_TSM_OVRD3_REG(base), XCVR_TSM_OVRD3_RX_MODE_OVRD_SHIFT, XCVR_TSM_OVRD3_RX_MODE_OVRD_WIDTH))

/*! @brief Set the RX_MODE_OVRD field to a new value. */
#define XCVR_WR_TSM_OVRD3_RX_MODE_OVRD(base, value) (XCVR_RMW_TSM_OVRD3(base, XCVR_TSM_OVRD3_RX_MODE_OVRD_MASK, XCVR_TSM_OVRD3_RX_MODE_OVRD(value)))
#define XCVR_BWR_TSM_OVRD3_RX_MODE_OVRD(base, value) (BME_BFI32(&XCVR_TSM_OVRD3_REG(base), ((uint32_t)(value) << XCVR_TSM_OVRD3_RX_MODE_OVRD_SHIFT), XCVR_TSM_OVRD3_RX_MODE_OVRD_SHIFT, XCVR_TSM_OVRD3_RX_MODE_OVRD_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PA_POWER - PA Power
 ******************************************************************************/

/*!
 * @brief XCVR_PA_POWER - PA Power (RW)
 *
 * Reset value: 0x00000000U
 *
 * This contents of this register are used as PA target power when
 * XCVR_CTRL[TGT_PWR_SRC] = 00.
 */
/*!
 * @name Constants and macros for entire XCVR_PA_POWER register
 */
/*@{*/
#define XCVR_RD_PA_POWER(base)   (XCVR_PA_POWER_REG(base))
#define XCVR_WR_PA_POWER(base, value) (XCVR_PA_POWER_REG(base) = (value))
#define XCVR_RMW_PA_POWER(base, mask, value) (XCVR_WR_PA_POWER(base, (XCVR_RD_PA_POWER(base) & ~(mask)) | (value)))
#define XCVR_SET_PA_POWER(base, value) (BME_OR32(&XCVR_PA_POWER_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PA_POWER(base, value) (BME_AND32(&XCVR_PA_POWER_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PA_POWER(base, value) (BME_XOR32(&XCVR_PA_POWER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PA_POWER bitfields
 */

/*!
 * @name Register XCVR_PA_POWER, field PA_POWER[3:0] (RW)
 *
 * PA Target Power
 */
/*@{*/
/*! @brief Read current value of the XCVR_PA_POWER_PA_POWER field. */
#define XCVR_RD_PA_POWER_PA_POWER(base) ((XCVR_PA_POWER_REG(base) & XCVR_PA_POWER_PA_POWER_MASK) >> XCVR_PA_POWER_PA_POWER_SHIFT)
#define XCVR_BRD_PA_POWER_PA_POWER(base) (BME_UBFX32(&XCVR_PA_POWER_REG(base), XCVR_PA_POWER_PA_POWER_SHIFT, XCVR_PA_POWER_PA_POWER_WIDTH))

/*! @brief Set the PA_POWER field to a new value. */
#define XCVR_WR_PA_POWER_PA_POWER(base, value) (XCVR_RMW_PA_POWER(base, XCVR_PA_POWER_PA_POWER_MASK, XCVR_PA_POWER_PA_POWER(value)))
#define XCVR_BWR_PA_POWER_PA_POWER(base, value) (BME_BFI32(&XCVR_PA_POWER_REG(base), ((uint32_t)(value) << XCVR_PA_POWER_PA_POWER_SHIFT), XCVR_PA_POWER_PA_POWER_SHIFT, XCVR_PA_POWER_PA_POWER_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PA_BIAS_TBL0 - PA Bias Table 0
 ******************************************************************************/

/*!
 * @brief XCVR_PA_BIAS_TBL0 - PA Bias Table 0 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_PA_BIAS_TBL0 register
 */
/*@{*/
#define XCVR_RD_PA_BIAS_TBL0(base) (XCVR_PA_BIAS_TBL0_REG(base))
#define XCVR_WR_PA_BIAS_TBL0(base, value) (XCVR_PA_BIAS_TBL0_REG(base) = (value))
#define XCVR_RMW_PA_BIAS_TBL0(base, mask, value) (XCVR_WR_PA_BIAS_TBL0(base, (XCVR_RD_PA_BIAS_TBL0(base) & ~(mask)) | (value)))
#define XCVR_SET_PA_BIAS_TBL0(base, value) (BME_OR32(&XCVR_PA_BIAS_TBL0_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PA_BIAS_TBL0(base, value) (BME_AND32(&XCVR_PA_BIAS_TBL0_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PA_BIAS_TBL0(base, value) (BME_XOR32(&XCVR_PA_BIAS_TBL0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PA_BIAS_TBL0 bitfields
 */

/*!
 * @name Register XCVR_PA_BIAS_TBL0, field PA_BIAS0[3:0] (RW)
 *
 * If PA ramping is enabled (TSM_CTRL[PA_RAMP_SEL] > 00), the contents of this
 * register are presented to the PA during PA ramping, when TSM tx_en transitions
 * low to high, and then for the duration of the first ramp step. During PA ramp
 * down, the contents of this register are the PA power value during the final
 * ramp step. In both cases, PA_BIAS0 cannot exceed target power (enforced by PA
 * ramping logic). When PA ramping is enabled, the contents of PA_BIAS0 are also
 * presented to the PA during sequence-idle conditions.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PA_BIAS_TBL0_PA_BIAS0 field. */
#define XCVR_RD_PA_BIAS_TBL0_PA_BIAS0(base) ((XCVR_PA_BIAS_TBL0_REG(base) & XCVR_PA_BIAS_TBL0_PA_BIAS0_MASK) >> XCVR_PA_BIAS_TBL0_PA_BIAS0_SHIFT)
#define XCVR_BRD_PA_BIAS_TBL0_PA_BIAS0(base) (BME_UBFX32(&XCVR_PA_BIAS_TBL0_REG(base), XCVR_PA_BIAS_TBL0_PA_BIAS0_SHIFT, XCVR_PA_BIAS_TBL0_PA_BIAS0_WIDTH))

/*! @brief Set the PA_BIAS0 field to a new value. */
#define XCVR_WR_PA_BIAS_TBL0_PA_BIAS0(base, value) (XCVR_RMW_PA_BIAS_TBL0(base, XCVR_PA_BIAS_TBL0_PA_BIAS0_MASK, XCVR_PA_BIAS_TBL0_PA_BIAS0(value)))
#define XCVR_BWR_PA_BIAS_TBL0_PA_BIAS0(base, value) (BME_BFI32(&XCVR_PA_BIAS_TBL0_REG(base), ((uint32_t)(value) << XCVR_PA_BIAS_TBL0_PA_BIAS0_SHIFT), XCVR_PA_BIAS_TBL0_PA_BIAS0_SHIFT, XCVR_PA_BIAS_TBL0_PA_BIAS0_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PA_BIAS_TBL0, field PA_BIAS1[11:8] (RW)
 *
 * If PA ramping is enabled (TSM_CTRL[PA_RAMP_SEL] > 00), the contents of this
 * register are presented to the PA during PA ramping, for the duration of the
 * second ramp step. During PA ramp down, the contents of this register are the PA
 * power value during the second-to-last ramp step. In both cases, PA_BIAS1 cannot
 * exceed target power (enforced by PA ramping logic).
 */
/*@{*/
/*! @brief Read current value of the XCVR_PA_BIAS_TBL0_PA_BIAS1 field. */
#define XCVR_RD_PA_BIAS_TBL0_PA_BIAS1(base) ((XCVR_PA_BIAS_TBL0_REG(base) & XCVR_PA_BIAS_TBL0_PA_BIAS1_MASK) >> XCVR_PA_BIAS_TBL0_PA_BIAS1_SHIFT)
#define XCVR_BRD_PA_BIAS_TBL0_PA_BIAS1(base) (BME_UBFX32(&XCVR_PA_BIAS_TBL0_REG(base), XCVR_PA_BIAS_TBL0_PA_BIAS1_SHIFT, XCVR_PA_BIAS_TBL0_PA_BIAS1_WIDTH))

/*! @brief Set the PA_BIAS1 field to a new value. */
#define XCVR_WR_PA_BIAS_TBL0_PA_BIAS1(base, value) (XCVR_RMW_PA_BIAS_TBL0(base, XCVR_PA_BIAS_TBL0_PA_BIAS1_MASK, XCVR_PA_BIAS_TBL0_PA_BIAS1(value)))
#define XCVR_BWR_PA_BIAS_TBL0_PA_BIAS1(base, value) (BME_BFI32(&XCVR_PA_BIAS_TBL0_REG(base), ((uint32_t)(value) << XCVR_PA_BIAS_TBL0_PA_BIAS1_SHIFT), XCVR_PA_BIAS_TBL0_PA_BIAS1_SHIFT, XCVR_PA_BIAS_TBL0_PA_BIAS1_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PA_BIAS_TBL0, field PA_BIAS2[19:16] (RW)
 *
 * If PA ramping is enabled (TSM_CTRL[PA_RAMP_EN] > 00), the contents of this
 * register are presented to the PA during PA ramping, for the duration of the
 * third ramp step. During PA ramp down, the contents of this register are the PA
 * power value during the third-to-last ramp step. In both cases, PA_BIAS2 cannot
 * exceed target power (enforced by PA ramping logic).
 */
/*@{*/
/*! @brief Read current value of the XCVR_PA_BIAS_TBL0_PA_BIAS2 field. */
#define XCVR_RD_PA_BIAS_TBL0_PA_BIAS2(base) ((XCVR_PA_BIAS_TBL0_REG(base) & XCVR_PA_BIAS_TBL0_PA_BIAS2_MASK) >> XCVR_PA_BIAS_TBL0_PA_BIAS2_SHIFT)
#define XCVR_BRD_PA_BIAS_TBL0_PA_BIAS2(base) (BME_UBFX32(&XCVR_PA_BIAS_TBL0_REG(base), XCVR_PA_BIAS_TBL0_PA_BIAS2_SHIFT, XCVR_PA_BIAS_TBL0_PA_BIAS2_WIDTH))

/*! @brief Set the PA_BIAS2 field to a new value. */
#define XCVR_WR_PA_BIAS_TBL0_PA_BIAS2(base, value) (XCVR_RMW_PA_BIAS_TBL0(base, XCVR_PA_BIAS_TBL0_PA_BIAS2_MASK, XCVR_PA_BIAS_TBL0_PA_BIAS2(value)))
#define XCVR_BWR_PA_BIAS_TBL0_PA_BIAS2(base, value) (BME_BFI32(&XCVR_PA_BIAS_TBL0_REG(base), ((uint32_t)(value) << XCVR_PA_BIAS_TBL0_PA_BIAS2_SHIFT), XCVR_PA_BIAS_TBL0_PA_BIAS2_SHIFT, XCVR_PA_BIAS_TBL0_PA_BIAS2_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PA_BIAS_TBL0, field PA_BIAS3[27:24] (RW)
 *
 * If PA ramping is enabled (TSM_CTRL[PA_RAMP_EN] > 00), the contents of this
 * register are presented to the PA during PA ramping, for the duration of the
 * fourth ramp step. During PA ramp down, the contents of this register are the PA
 * power value during the fourth-to-last ramp step. In both cases, PA_BIAS3 cannot
 * exceed target power (enforced by PA ramping logic).
 */
/*@{*/
/*! @brief Read current value of the XCVR_PA_BIAS_TBL0_PA_BIAS3 field. */
#define XCVR_RD_PA_BIAS_TBL0_PA_BIAS3(base) ((XCVR_PA_BIAS_TBL0_REG(base) & XCVR_PA_BIAS_TBL0_PA_BIAS3_MASK) >> XCVR_PA_BIAS_TBL0_PA_BIAS3_SHIFT)
#define XCVR_BRD_PA_BIAS_TBL0_PA_BIAS3(base) (BME_UBFX32(&XCVR_PA_BIAS_TBL0_REG(base), XCVR_PA_BIAS_TBL0_PA_BIAS3_SHIFT, XCVR_PA_BIAS_TBL0_PA_BIAS3_WIDTH))

/*! @brief Set the PA_BIAS3 field to a new value. */
#define XCVR_WR_PA_BIAS_TBL0_PA_BIAS3(base, value) (XCVR_RMW_PA_BIAS_TBL0(base, XCVR_PA_BIAS_TBL0_PA_BIAS3_MASK, XCVR_PA_BIAS_TBL0_PA_BIAS3(value)))
#define XCVR_BWR_PA_BIAS_TBL0_PA_BIAS3(base, value) (BME_BFI32(&XCVR_PA_BIAS_TBL0_REG(base), ((uint32_t)(value) << XCVR_PA_BIAS_TBL0_PA_BIAS3_SHIFT), XCVR_PA_BIAS_TBL0_PA_BIAS3_SHIFT, XCVR_PA_BIAS_TBL0_PA_BIAS3_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PA_BIAS_TBL1 - PA Bias Table 1
 ******************************************************************************/

/*!
 * @brief XCVR_PA_BIAS_TBL1 - PA Bias Table 1 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_PA_BIAS_TBL1 register
 */
/*@{*/
#define XCVR_RD_PA_BIAS_TBL1(base) (XCVR_PA_BIAS_TBL1_REG(base))
#define XCVR_WR_PA_BIAS_TBL1(base, value) (XCVR_PA_BIAS_TBL1_REG(base) = (value))
#define XCVR_RMW_PA_BIAS_TBL1(base, mask, value) (XCVR_WR_PA_BIAS_TBL1(base, (XCVR_RD_PA_BIAS_TBL1(base) & ~(mask)) | (value)))
#define XCVR_SET_PA_BIAS_TBL1(base, value) (BME_OR32(&XCVR_PA_BIAS_TBL1_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PA_BIAS_TBL1(base, value) (BME_AND32(&XCVR_PA_BIAS_TBL1_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PA_BIAS_TBL1(base, value) (BME_XOR32(&XCVR_PA_BIAS_TBL1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PA_BIAS_TBL1 bitfields
 */

/*!
 * @name Register XCVR_PA_BIAS_TBL1, field PA_BIAS4[3:0] (RW)
 *
 * If PA ramping is enabled (TSM_CTRL[PA_RAMP_EN] > 00), the contents of this
 * register are presented to the PA during PA ramping, for the duration of the
 * fifth ramp step. During PA ramp down, the contents of this register are the PA
 * power value during the fifth-to-last ramp step. In both cases, PA_BIAS4 cannot
 * exceed target power (enforced by PA ramping logic).
 */
/*@{*/
/*! @brief Read current value of the XCVR_PA_BIAS_TBL1_PA_BIAS4 field. */
#define XCVR_RD_PA_BIAS_TBL1_PA_BIAS4(base) ((XCVR_PA_BIAS_TBL1_REG(base) & XCVR_PA_BIAS_TBL1_PA_BIAS4_MASK) >> XCVR_PA_BIAS_TBL1_PA_BIAS4_SHIFT)
#define XCVR_BRD_PA_BIAS_TBL1_PA_BIAS4(base) (BME_UBFX32(&XCVR_PA_BIAS_TBL1_REG(base), XCVR_PA_BIAS_TBL1_PA_BIAS4_SHIFT, XCVR_PA_BIAS_TBL1_PA_BIAS4_WIDTH))

/*! @brief Set the PA_BIAS4 field to a new value. */
#define XCVR_WR_PA_BIAS_TBL1_PA_BIAS4(base, value) (XCVR_RMW_PA_BIAS_TBL1(base, XCVR_PA_BIAS_TBL1_PA_BIAS4_MASK, XCVR_PA_BIAS_TBL1_PA_BIAS4(value)))
#define XCVR_BWR_PA_BIAS_TBL1_PA_BIAS4(base, value) (BME_BFI32(&XCVR_PA_BIAS_TBL1_REG(base), ((uint32_t)(value) << XCVR_PA_BIAS_TBL1_PA_BIAS4_SHIFT), XCVR_PA_BIAS_TBL1_PA_BIAS4_SHIFT, XCVR_PA_BIAS_TBL1_PA_BIAS4_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PA_BIAS_TBL1, field PA_BIAS5[11:8] (RW)
 *
 * If PA ramping is enabled (TSM_CTRL[PA_RAMP_EN] > 00), the contents of this
 * register are presented to the PA during PA ramping, for the duration of the
 * sixth ramp step. During PA ramp down, the contents of this register are the PA
 * power value during the sixth-to-last ramp step. In both cases, PA_BIAS5 cannot
 * exceed target power (enforced by PA ramping logic).
 */
/*@{*/
/*! @brief Read current value of the XCVR_PA_BIAS_TBL1_PA_BIAS5 field. */
#define XCVR_RD_PA_BIAS_TBL1_PA_BIAS5(base) ((XCVR_PA_BIAS_TBL1_REG(base) & XCVR_PA_BIAS_TBL1_PA_BIAS5_MASK) >> XCVR_PA_BIAS_TBL1_PA_BIAS5_SHIFT)
#define XCVR_BRD_PA_BIAS_TBL1_PA_BIAS5(base) (BME_UBFX32(&XCVR_PA_BIAS_TBL1_REG(base), XCVR_PA_BIAS_TBL1_PA_BIAS5_SHIFT, XCVR_PA_BIAS_TBL1_PA_BIAS5_WIDTH))

/*! @brief Set the PA_BIAS5 field to a new value. */
#define XCVR_WR_PA_BIAS_TBL1_PA_BIAS5(base, value) (XCVR_RMW_PA_BIAS_TBL1(base, XCVR_PA_BIAS_TBL1_PA_BIAS5_MASK, XCVR_PA_BIAS_TBL1_PA_BIAS5(value)))
#define XCVR_BWR_PA_BIAS_TBL1_PA_BIAS5(base, value) (BME_BFI32(&XCVR_PA_BIAS_TBL1_REG(base), ((uint32_t)(value) << XCVR_PA_BIAS_TBL1_PA_BIAS5_SHIFT), XCVR_PA_BIAS_TBL1_PA_BIAS5_SHIFT, XCVR_PA_BIAS_TBL1_PA_BIAS5_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PA_BIAS_TBL1, field PA_BIAS6[19:16] (RW)
 *
 * If PA ramping is enabled (TSM_CTRL[PA_RAMP_EN] > 00), the contents of this
 * register are presented to the PA during PA ramping, for the duration of the
 * seventh ramp step. During PA ramp down, the contents of this register are the PA
 * power value during the seventh-to-last ramp step. In both cases, PA_BIAS6
 * cannot exceed target power (enforced by PA ramping logic).
 */
/*@{*/
/*! @brief Read current value of the XCVR_PA_BIAS_TBL1_PA_BIAS6 field. */
#define XCVR_RD_PA_BIAS_TBL1_PA_BIAS6(base) ((XCVR_PA_BIAS_TBL1_REG(base) & XCVR_PA_BIAS_TBL1_PA_BIAS6_MASK) >> XCVR_PA_BIAS_TBL1_PA_BIAS6_SHIFT)
#define XCVR_BRD_PA_BIAS_TBL1_PA_BIAS6(base) (BME_UBFX32(&XCVR_PA_BIAS_TBL1_REG(base), XCVR_PA_BIAS_TBL1_PA_BIAS6_SHIFT, XCVR_PA_BIAS_TBL1_PA_BIAS6_WIDTH))

/*! @brief Set the PA_BIAS6 field to a new value. */
#define XCVR_WR_PA_BIAS_TBL1_PA_BIAS6(base, value) (XCVR_RMW_PA_BIAS_TBL1(base, XCVR_PA_BIAS_TBL1_PA_BIAS6_MASK, XCVR_PA_BIAS_TBL1_PA_BIAS6(value)))
#define XCVR_BWR_PA_BIAS_TBL1_PA_BIAS6(base, value) (BME_BFI32(&XCVR_PA_BIAS_TBL1_REG(base), ((uint32_t)(value) << XCVR_PA_BIAS_TBL1_PA_BIAS6_SHIFT), XCVR_PA_BIAS_TBL1_PA_BIAS6_SHIFT, XCVR_PA_BIAS_TBL1_PA_BIAS6_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PA_BIAS_TBL1, field PA_BIAS7[27:24] (RW)
 *
 * If PA ramping is enabled (TSM_CTRL[PA_RAMP_EN] > 00), the contents of this
 * register are presented to the PA during PA ramping, for the duration of the
 * eighth (final) ramp step. During PA ramp down, the contents of this register are
 * the PA power value during the eighth-to-last (first) ramp step. In both cases,
 * PA_BIAS7 cannot exceed target power (enforced by PA ramping logic).
 */
/*@{*/
/*! @brief Read current value of the XCVR_PA_BIAS_TBL1_PA_BIAS7 field. */
#define XCVR_RD_PA_BIAS_TBL1_PA_BIAS7(base) ((XCVR_PA_BIAS_TBL1_REG(base) & XCVR_PA_BIAS_TBL1_PA_BIAS7_MASK) >> XCVR_PA_BIAS_TBL1_PA_BIAS7_SHIFT)
#define XCVR_BRD_PA_BIAS_TBL1_PA_BIAS7(base) (BME_UBFX32(&XCVR_PA_BIAS_TBL1_REG(base), XCVR_PA_BIAS_TBL1_PA_BIAS7_SHIFT, XCVR_PA_BIAS_TBL1_PA_BIAS7_WIDTH))

/*! @brief Set the PA_BIAS7 field to a new value. */
#define XCVR_WR_PA_BIAS_TBL1_PA_BIAS7(base, value) (XCVR_RMW_PA_BIAS_TBL1(base, XCVR_PA_BIAS_TBL1_PA_BIAS7_MASK, XCVR_PA_BIAS_TBL1_PA_BIAS7(value)))
#define XCVR_BWR_PA_BIAS_TBL1_PA_BIAS7(base, value) (BME_BFI32(&XCVR_PA_BIAS_TBL1_REG(base), ((uint32_t)(value) << XCVR_PA_BIAS_TBL1_PA_BIAS7_SHIFT), XCVR_PA_BIAS_TBL1_PA_BIAS7_SHIFT, XCVR_PA_BIAS_TBL1_PA_BIAS7_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_RECYCLE_COUNT - Recycle Count Register
 ******************************************************************************/

/*!
 * @brief XCVR_RECYCLE_COUNT - Recycle Count Register (RW)
 *
 * Reset value: 0x00000826U
 */
/*!
 * @name Constants and macros for entire XCVR_RECYCLE_COUNT register
 */
/*@{*/
#define XCVR_RD_RECYCLE_COUNT(base) (XCVR_RECYCLE_COUNT_REG(base))
#define XCVR_WR_RECYCLE_COUNT(base, value) (XCVR_RECYCLE_COUNT_REG(base) = (value))
#define XCVR_RMW_RECYCLE_COUNT(base, mask, value) (XCVR_WR_RECYCLE_COUNT(base, (XCVR_RD_RECYCLE_COUNT(base) & ~(mask)) | (value)))
#define XCVR_SET_RECYCLE_COUNT(base, value) (BME_OR32(&XCVR_RECYCLE_COUNT_REG(base), (uint32_t)(value)))
#define XCVR_CLR_RECYCLE_COUNT(base, value) (BME_AND32(&XCVR_RECYCLE_COUNT_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_RECYCLE_COUNT(base, value) (BME_XOR32(&XCVR_RECYCLE_COUNT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_RECYCLE_COUNT bitfields
 */

/*!
 * @name Register XCVR_RECYCLE_COUNT, field RECYCLE_COUNT0[7:0] (RW)
 *
 * The RECYCLE_COUNT0[7:0] register determines the TSM count value to which the
 * TSM "recycles" when the Zigbee Sequence Manager (ZSM) state "RX_CYC" is
 * reached and the ZSM asserts tsm_recycle[0] to TSM. This register also determines the
 * TSM count value to which the TSM recycles when the ZSM state RX_CCCA is
 * reached because tsm_recycle[0] is also asserted in this state. The intention is for
 * this register to be programmed to a TSM count value such that the TSM
 * re-asserts its "rx_init" output, but there are no restrictions on programming this
 * register. An RX recycle is a command from ZSM to TSM to jump from the TSM ON
 * phase back to a programmable point in the WARMUP phase, and resume counting from
 * there. A recycle will result from the reception of a packet with bad CRC or
 * one which fails packet-filtering rules, or the end of a CCA operation in
 * Continuous CCA mode which results in a channel indicating "busy".
 */
/*@{*/
/*! @brief Read current value of the XCVR_RECYCLE_COUNT_RECYCLE_COUNT0 field. */
#define XCVR_RD_RECYCLE_COUNT_RECYCLE_COUNT0(base) ((XCVR_RECYCLE_COUNT_REG(base) & XCVR_RECYCLE_COUNT_RECYCLE_COUNT0_MASK) >> XCVR_RECYCLE_COUNT_RECYCLE_COUNT0_SHIFT)
#define XCVR_BRD_RECYCLE_COUNT_RECYCLE_COUNT0(base) (BME_UBFX32(&XCVR_RECYCLE_COUNT_REG(base), XCVR_RECYCLE_COUNT_RECYCLE_COUNT0_SHIFT, XCVR_RECYCLE_COUNT_RECYCLE_COUNT0_WIDTH))

/*! @brief Set the RECYCLE_COUNT0 field to a new value. */
#define XCVR_WR_RECYCLE_COUNT_RECYCLE_COUNT0(base, value) (XCVR_RMW_RECYCLE_COUNT(base, XCVR_RECYCLE_COUNT_RECYCLE_COUNT0_MASK, XCVR_RECYCLE_COUNT_RECYCLE_COUNT0(value)))
#define XCVR_BWR_RECYCLE_COUNT_RECYCLE_COUNT0(base, value) (BME_BFI32(&XCVR_RECYCLE_COUNT_REG(base), ((uint32_t)(value) << XCVR_RECYCLE_COUNT_RECYCLE_COUNT0_SHIFT), XCVR_RECYCLE_COUNT_RECYCLE_COUNT0_SHIFT, XCVR_RECYCLE_COUNT_RECYCLE_COUNT0_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RECYCLE_COUNT, field RECYCLE_COUNT1[15:8] (RW)
 *
 * The RECYCLE_COUNT1[7:0] register determines the TSM count value to which the
 * TSM "recycles" when the Zigbee Sequence Manager (ZSM) state "RX_PAN1" is
 * reached and the ZSM asserts tsm_recycle[1] to TSM. The intention is for this
 * register to be programmed to a TSM count value such that the TSM de-asserts, and
 * then re-asserts its "pll_dig_en" output, to effectuate a Dual PAN on-the-fly
 * channel change, but there are no restrictions on programming this register. An RX
 * recycle is a command from ZSM to TSM to jump from the TSM ON phase back to a
 * programmable point in the WARMUP phase, and resume counting from there. A
 * recycle will result from the expiration of the Dual PAN Dwell Timer, at which point
 * an RF-channel change is required. This necessitates the desassertion and
 * reassertion of pll_dig_en, hence the return to the WARMUP phase at the appropriate
 * point.
 */
/*@{*/
/*! @brief Read current value of the XCVR_RECYCLE_COUNT_RECYCLE_COUNT1 field. */
#define XCVR_RD_RECYCLE_COUNT_RECYCLE_COUNT1(base) ((XCVR_RECYCLE_COUNT_REG(base) & XCVR_RECYCLE_COUNT_RECYCLE_COUNT1_MASK) >> XCVR_RECYCLE_COUNT_RECYCLE_COUNT1_SHIFT)
#define XCVR_BRD_RECYCLE_COUNT_RECYCLE_COUNT1(base) (BME_UBFX32(&XCVR_RECYCLE_COUNT_REG(base), XCVR_RECYCLE_COUNT_RECYCLE_COUNT1_SHIFT, XCVR_RECYCLE_COUNT_RECYCLE_COUNT1_WIDTH))

/*! @brief Set the RECYCLE_COUNT1 field to a new value. */
#define XCVR_WR_RECYCLE_COUNT_RECYCLE_COUNT1(base, value) (XCVR_RMW_RECYCLE_COUNT(base, XCVR_RECYCLE_COUNT_RECYCLE_COUNT1_MASK, XCVR_RECYCLE_COUNT_RECYCLE_COUNT1(value)))
#define XCVR_BWR_RECYCLE_COUNT_RECYCLE_COUNT1(base, value) (BME_BFI32(&XCVR_RECYCLE_COUNT_REG(base), ((uint32_t)(value) << XCVR_RECYCLE_COUNT_RECYCLE_COUNT1_SHIFT), XCVR_RECYCLE_COUNT_RECYCLE_COUNT1_SHIFT, XCVR_RECYCLE_COUNT_RECYCLE_COUNT1_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING00 - TSM_TIMING00
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING00 - TSM_TIMING00 (RW)
 *
 * Reset value: 0x65006A00U
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the PLL_REG_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING00 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING00(base) (XCVR_TSM_TIMING00_REG(base))
#define XCVR_WR_TSM_TIMING00(base, value) (XCVR_TSM_TIMING00_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING00(base, mask, value) (XCVR_WR_TSM_TIMING00(base, (XCVR_RD_TSM_TIMING00(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING00(base, value) (BME_OR32(&XCVR_TSM_TIMING00_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING00(base, value) (BME_AND32(&XCVR_TSM_TIMING00_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING00(base, value) (BME_XOR32(&XCVR_TSM_TIMING00_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING00 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING00, field PLL_REG_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_REG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING00_PLL_REG_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING00_PLL_REG_EN_TX_HI(base) ((XCVR_TSM_TIMING00_REG(base) & XCVR_TSM_TIMING00_PLL_REG_EN_TX_HI_MASK) >> XCVR_TSM_TIMING00_PLL_REG_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING00_PLL_REG_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING00_REG(base), XCVR_TSM_TIMING00_PLL_REG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING00_PLL_REG_EN_TX_HI_WIDTH))

/*! @brief Set the PLL_REG_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING00_PLL_REG_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING00(base, XCVR_TSM_TIMING00_PLL_REG_EN_TX_HI_MASK, XCVR_TSM_TIMING00_PLL_REG_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING00_PLL_REG_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING00_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING00_PLL_REG_EN_TX_HI_SHIFT), XCVR_TSM_TIMING00_PLL_REG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING00_PLL_REG_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING00, field PLL_REG_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_REG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING00_PLL_REG_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING00_PLL_REG_EN_TX_LO(base) ((XCVR_TSM_TIMING00_REG(base) & XCVR_TSM_TIMING00_PLL_REG_EN_TX_LO_MASK) >> XCVR_TSM_TIMING00_PLL_REG_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING00_PLL_REG_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING00_REG(base), XCVR_TSM_TIMING00_PLL_REG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING00_PLL_REG_EN_TX_LO_WIDTH))

/*! @brief Set the PLL_REG_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING00_PLL_REG_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING00(base, XCVR_TSM_TIMING00_PLL_REG_EN_TX_LO_MASK, XCVR_TSM_TIMING00_PLL_REG_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING00_PLL_REG_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING00_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING00_PLL_REG_EN_TX_LO_SHIFT), XCVR_TSM_TIMING00_PLL_REG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING00_PLL_REG_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING00, field PLL_REG_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_REG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING00_PLL_REG_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING00_PLL_REG_EN_RX_HI(base) ((XCVR_TSM_TIMING00_REG(base) & XCVR_TSM_TIMING00_PLL_REG_EN_RX_HI_MASK) >> XCVR_TSM_TIMING00_PLL_REG_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING00_PLL_REG_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING00_REG(base), XCVR_TSM_TIMING00_PLL_REG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING00_PLL_REG_EN_RX_HI_WIDTH))

/*! @brief Set the PLL_REG_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING00_PLL_REG_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING00(base, XCVR_TSM_TIMING00_PLL_REG_EN_RX_HI_MASK, XCVR_TSM_TIMING00_PLL_REG_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING00_PLL_REG_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING00_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING00_PLL_REG_EN_RX_HI_SHIFT), XCVR_TSM_TIMING00_PLL_REG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING00_PLL_REG_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING00, field PLL_REG_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_REG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING00_PLL_REG_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING00_PLL_REG_EN_RX_LO(base) ((XCVR_TSM_TIMING00_REG(base) & XCVR_TSM_TIMING00_PLL_REG_EN_RX_LO_MASK) >> XCVR_TSM_TIMING00_PLL_REG_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING00_PLL_REG_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING00_REG(base), XCVR_TSM_TIMING00_PLL_REG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING00_PLL_REG_EN_RX_LO_WIDTH))

/*! @brief Set the PLL_REG_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING00_PLL_REG_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING00(base, XCVR_TSM_TIMING00_PLL_REG_EN_RX_LO_MASK, XCVR_TSM_TIMING00_PLL_REG_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING00_PLL_REG_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING00_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING00_PLL_REG_EN_RX_LO_SHIFT), XCVR_TSM_TIMING00_PLL_REG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING00_PLL_REG_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING01 - TSM_TIMING01
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING01 - TSM_TIMING01 (RW)
 *
 * Reset value: 0x65006A00U
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the PLL_VCO_REG_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING01 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING01(base) (XCVR_TSM_TIMING01_REG(base))
#define XCVR_WR_TSM_TIMING01(base, value) (XCVR_TSM_TIMING01_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING01(base, mask, value) (XCVR_WR_TSM_TIMING01(base, (XCVR_RD_TSM_TIMING01(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING01(base, value) (BME_OR32(&XCVR_TSM_TIMING01_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING01(base, value) (BME_AND32(&XCVR_TSM_TIMING01_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING01(base, value) (BME_XOR32(&XCVR_TSM_TIMING01_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING01 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING01, field PLL_VCO_REG_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_VCO_REG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING01_PLL_VCO_REG_EN_TX_HI(base) ((XCVR_TSM_TIMING01_REG(base) & XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_HI_MASK) >> XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING01_PLL_VCO_REG_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING01_REG(base), XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_HI_WIDTH))

/*! @brief Set the PLL_VCO_REG_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING01_PLL_VCO_REG_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING01(base, XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_HI_MASK, XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING01_PLL_VCO_REG_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING01_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_HI_SHIFT), XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING01, field PLL_VCO_REG_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_VCO_REG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING01_PLL_VCO_REG_EN_TX_LO(base) ((XCVR_TSM_TIMING01_REG(base) & XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_LO_MASK) >> XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING01_PLL_VCO_REG_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING01_REG(base), XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_LO_WIDTH))

/*! @brief Set the PLL_VCO_REG_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING01_PLL_VCO_REG_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING01(base, XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_LO_MASK, XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING01_PLL_VCO_REG_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING01_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_LO_SHIFT), XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING01_PLL_VCO_REG_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING01, field PLL_VCO_REG_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_VCO_REG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING01_PLL_VCO_REG_EN_RX_HI(base) ((XCVR_TSM_TIMING01_REG(base) & XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_HI_MASK) >> XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING01_PLL_VCO_REG_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING01_REG(base), XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_HI_WIDTH))

/*! @brief Set the PLL_VCO_REG_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING01_PLL_VCO_REG_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING01(base, XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_HI_MASK, XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING01_PLL_VCO_REG_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING01_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_HI_SHIFT), XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING01, field PLL_VCO_REG_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_VCO_REG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING01_PLL_VCO_REG_EN_RX_LO(base) ((XCVR_TSM_TIMING01_REG(base) & XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_LO_MASK) >> XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING01_PLL_VCO_REG_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING01_REG(base), XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_LO_WIDTH))

/*! @brief Set the PLL_VCO_REG_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING01_PLL_VCO_REG_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING01(base, XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_LO_MASK, XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING01_PLL_VCO_REG_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING01_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_LO_SHIFT), XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING01_PLL_VCO_REG_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING02 - TSM_TIMING02
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING02 - TSM_TIMING02 (RW)
 *
 * Reset value: 0x65006A00U
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the QGEN_REG_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING02 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING02(base) (XCVR_TSM_TIMING02_REG(base))
#define XCVR_WR_TSM_TIMING02(base, value) (XCVR_TSM_TIMING02_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING02(base, mask, value) (XCVR_WR_TSM_TIMING02(base, (XCVR_RD_TSM_TIMING02(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING02(base, value) (BME_OR32(&XCVR_TSM_TIMING02_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING02(base, value) (BME_AND32(&XCVR_TSM_TIMING02_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING02(base, value) (BME_XOR32(&XCVR_TSM_TIMING02_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING02 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING02, field QGEN_REG_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the QGEN_REG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING02_QGEN_REG_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING02_QGEN_REG_EN_TX_HI(base) ((XCVR_TSM_TIMING02_REG(base) & XCVR_TSM_TIMING02_QGEN_REG_EN_TX_HI_MASK) >> XCVR_TSM_TIMING02_QGEN_REG_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING02_QGEN_REG_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING02_REG(base), XCVR_TSM_TIMING02_QGEN_REG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING02_QGEN_REG_EN_TX_HI_WIDTH))

/*! @brief Set the QGEN_REG_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING02_QGEN_REG_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING02(base, XCVR_TSM_TIMING02_QGEN_REG_EN_TX_HI_MASK, XCVR_TSM_TIMING02_QGEN_REG_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING02_QGEN_REG_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING02_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING02_QGEN_REG_EN_TX_HI_SHIFT), XCVR_TSM_TIMING02_QGEN_REG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING02_QGEN_REG_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING02, field QGEN_REG_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the QGEN_REG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING02_QGEN_REG_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING02_QGEN_REG_EN_TX_LO(base) ((XCVR_TSM_TIMING02_REG(base) & XCVR_TSM_TIMING02_QGEN_REG_EN_TX_LO_MASK) >> XCVR_TSM_TIMING02_QGEN_REG_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING02_QGEN_REG_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING02_REG(base), XCVR_TSM_TIMING02_QGEN_REG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING02_QGEN_REG_EN_TX_LO_WIDTH))

/*! @brief Set the QGEN_REG_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING02_QGEN_REG_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING02(base, XCVR_TSM_TIMING02_QGEN_REG_EN_TX_LO_MASK, XCVR_TSM_TIMING02_QGEN_REG_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING02_QGEN_REG_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING02_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING02_QGEN_REG_EN_TX_LO_SHIFT), XCVR_TSM_TIMING02_QGEN_REG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING02_QGEN_REG_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING02, field QGEN_REG_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the QGEN_REG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING02_QGEN_REG_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING02_QGEN_REG_EN_RX_HI(base) ((XCVR_TSM_TIMING02_REG(base) & XCVR_TSM_TIMING02_QGEN_REG_EN_RX_HI_MASK) >> XCVR_TSM_TIMING02_QGEN_REG_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING02_QGEN_REG_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING02_REG(base), XCVR_TSM_TIMING02_QGEN_REG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING02_QGEN_REG_EN_RX_HI_WIDTH))

/*! @brief Set the QGEN_REG_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING02_QGEN_REG_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING02(base, XCVR_TSM_TIMING02_QGEN_REG_EN_RX_HI_MASK, XCVR_TSM_TIMING02_QGEN_REG_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING02_QGEN_REG_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING02_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING02_QGEN_REG_EN_RX_HI_SHIFT), XCVR_TSM_TIMING02_QGEN_REG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING02_QGEN_REG_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING02, field QGEN_REG_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the QGEN_REG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING02_QGEN_REG_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING02_QGEN_REG_EN_RX_LO(base) ((XCVR_TSM_TIMING02_REG(base) & XCVR_TSM_TIMING02_QGEN_REG_EN_RX_LO_MASK) >> XCVR_TSM_TIMING02_QGEN_REG_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING02_QGEN_REG_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING02_REG(base), XCVR_TSM_TIMING02_QGEN_REG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING02_QGEN_REG_EN_RX_LO_WIDTH))

/*! @brief Set the QGEN_REG_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING02_QGEN_REG_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING02(base, XCVR_TSM_TIMING02_QGEN_REG_EN_RX_LO_MASK, XCVR_TSM_TIMING02_QGEN_REG_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING02_QGEN_REG_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING02_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING02_QGEN_REG_EN_RX_LO_SHIFT), XCVR_TSM_TIMING02_QGEN_REG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING02_QGEN_REG_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING03 - TSM_TIMING03
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING03 - TSM_TIMING03 (RW)
 *
 * Reset value: 0x65006A00U
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the TCA_TX_REG_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING03 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING03(base) (XCVR_TSM_TIMING03_REG(base))
#define XCVR_WR_TSM_TIMING03(base, value) (XCVR_TSM_TIMING03_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING03(base, mask, value) (XCVR_WR_TSM_TIMING03(base, (XCVR_RD_TSM_TIMING03(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING03(base, value) (BME_OR32(&XCVR_TSM_TIMING03_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING03(base, value) (BME_AND32(&XCVR_TSM_TIMING03_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING03(base, value) (BME_XOR32(&XCVR_TSM_TIMING03_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING03 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING03, field TCA_TX_REG_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the TCA_TX_REG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING03_TCA_TX_REG_EN_TX_HI(base) ((XCVR_TSM_TIMING03_REG(base) & XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_HI_MASK) >> XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING03_TCA_TX_REG_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING03_REG(base), XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_HI_WIDTH))

/*! @brief Set the TCA_TX_REG_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING03_TCA_TX_REG_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING03(base, XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_HI_MASK, XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING03_TCA_TX_REG_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING03_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_HI_SHIFT), XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING03, field TCA_TX_REG_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the TCA_TX_REG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING03_TCA_TX_REG_EN_TX_LO(base) ((XCVR_TSM_TIMING03_REG(base) & XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_LO_MASK) >> XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING03_TCA_TX_REG_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING03_REG(base), XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_LO_WIDTH))

/*! @brief Set the TCA_TX_REG_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING03_TCA_TX_REG_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING03(base, XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_LO_MASK, XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING03_TCA_TX_REG_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING03_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_LO_SHIFT), XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING03_TCA_TX_REG_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING03, field TCA_TX_REG_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the TCA_TX_REG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING03_TCA_TX_REG_EN_RX_HI(base) ((XCVR_TSM_TIMING03_REG(base) & XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_HI_MASK) >> XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING03_TCA_TX_REG_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING03_REG(base), XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_HI_WIDTH))

/*! @brief Set the TCA_TX_REG_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING03_TCA_TX_REG_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING03(base, XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_HI_MASK, XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING03_TCA_TX_REG_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING03_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_HI_SHIFT), XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING03, field TCA_TX_REG_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the TCA_TX_REG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING03_TCA_TX_REG_EN_RX_LO(base) ((XCVR_TSM_TIMING03_REG(base) & XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_LO_MASK) >> XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING03_TCA_TX_REG_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING03_REG(base), XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_LO_WIDTH))

/*! @brief Set the TCA_TX_REG_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING03_TCA_TX_REG_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING03(base, XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_LO_MASK, XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING03_TCA_TX_REG_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING03_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_LO_SHIFT), XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING03_TCA_TX_REG_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING04 - TSM_TIMING04
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING04 - TSM_TIMING04 (RW)
 *
 * Reset value: 0x6500FFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the ADC_REG_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING04 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING04(base) (XCVR_TSM_TIMING04_REG(base))
#define XCVR_WR_TSM_TIMING04(base, value) (XCVR_TSM_TIMING04_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING04(base, mask, value) (XCVR_WR_TSM_TIMING04(base, (XCVR_RD_TSM_TIMING04(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING04(base, value) (BME_OR32(&XCVR_TSM_TIMING04_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING04(base, value) (BME_AND32(&XCVR_TSM_TIMING04_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING04(base, value) (BME_XOR32(&XCVR_TSM_TIMING04_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING04 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING04, field ADC_REG_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the ADC_REG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING04_ADC_REG_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING04_ADC_REG_EN_RX_HI(base) ((XCVR_TSM_TIMING04_REG(base) & XCVR_TSM_TIMING04_ADC_REG_EN_RX_HI_MASK) >> XCVR_TSM_TIMING04_ADC_REG_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING04_ADC_REG_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING04_REG(base), XCVR_TSM_TIMING04_ADC_REG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING04_ADC_REG_EN_RX_HI_WIDTH))

/*! @brief Set the ADC_REG_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING04_ADC_REG_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING04(base, XCVR_TSM_TIMING04_ADC_REG_EN_RX_HI_MASK, XCVR_TSM_TIMING04_ADC_REG_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING04_ADC_REG_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING04_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING04_ADC_REG_EN_RX_HI_SHIFT), XCVR_TSM_TIMING04_ADC_REG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING04_ADC_REG_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING04, field ADC_REG_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the ADC_REG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING04_ADC_REG_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING04_ADC_REG_EN_RX_LO(base) ((XCVR_TSM_TIMING04_REG(base) & XCVR_TSM_TIMING04_ADC_REG_EN_RX_LO_MASK) >> XCVR_TSM_TIMING04_ADC_REG_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING04_ADC_REG_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING04_REG(base), XCVR_TSM_TIMING04_ADC_REG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING04_ADC_REG_EN_RX_LO_WIDTH))

/*! @brief Set the ADC_REG_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING04_ADC_REG_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING04(base, XCVR_TSM_TIMING04_ADC_REG_EN_RX_LO_MASK, XCVR_TSM_TIMING04_ADC_REG_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING04_ADC_REG_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING04_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING04_ADC_REG_EN_RX_LO_SHIFT), XCVR_TSM_TIMING04_ADC_REG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING04_ADC_REG_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING05 - TSM_TIMING05
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING05 - TSM_TIMING05 (RW)
 *
 * Reset value: 0x650B6A3FU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the PLL_REF_CLK_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING05 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING05(base) (XCVR_TSM_TIMING05_REG(base))
#define XCVR_WR_TSM_TIMING05(base, value) (XCVR_TSM_TIMING05_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING05(base, mask, value) (XCVR_WR_TSM_TIMING05(base, (XCVR_RD_TSM_TIMING05(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING05(base, value) (BME_OR32(&XCVR_TSM_TIMING05_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING05(base, value) (BME_AND32(&XCVR_TSM_TIMING05_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING05(base, value) (BME_XOR32(&XCVR_TSM_TIMING05_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING05 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING05, field PLL_REF_CLK_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_REF_CLK_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING05_PLL_REF_CLK_EN_TX_HI(base) ((XCVR_TSM_TIMING05_REG(base) & XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_HI_MASK) >> XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING05_PLL_REF_CLK_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING05_REG(base), XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_HI_SHIFT, XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_HI_WIDTH))

/*! @brief Set the PLL_REF_CLK_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING05_PLL_REF_CLK_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING05(base, XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_HI_MASK, XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING05_PLL_REF_CLK_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING05_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_HI_SHIFT), XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_HI_SHIFT, XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING05, field PLL_REF_CLK_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_REF_CLK_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING05_PLL_REF_CLK_EN_TX_LO(base) ((XCVR_TSM_TIMING05_REG(base) & XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_LO_MASK) >> XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING05_PLL_REF_CLK_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING05_REG(base), XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_LO_SHIFT, XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_LO_WIDTH))

/*! @brief Set the PLL_REF_CLK_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING05_PLL_REF_CLK_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING05(base, XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_LO_MASK, XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING05_PLL_REF_CLK_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING05_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_LO_SHIFT), XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_LO_SHIFT, XCVR_TSM_TIMING05_PLL_REF_CLK_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING05, field PLL_REF_CLK_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_REF_CLK_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING05_PLL_REF_CLK_EN_RX_HI(base) ((XCVR_TSM_TIMING05_REG(base) & XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_HI_MASK) >> XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING05_PLL_REF_CLK_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING05_REG(base), XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_HI_SHIFT, XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_HI_WIDTH))

/*! @brief Set the PLL_REF_CLK_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING05_PLL_REF_CLK_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING05(base, XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_HI_MASK, XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING05_PLL_REF_CLK_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING05_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_HI_SHIFT), XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_HI_SHIFT, XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING05, field PLL_REF_CLK_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_REF_CLK_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING05_PLL_REF_CLK_EN_RX_LO(base) ((XCVR_TSM_TIMING05_REG(base) & XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_LO_MASK) >> XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING05_PLL_REF_CLK_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING05_REG(base), XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_LO_SHIFT, XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_LO_WIDTH))

/*! @brief Set the PLL_REF_CLK_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING05_PLL_REF_CLK_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING05(base, XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_LO_MASK, XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING05_PLL_REF_CLK_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING05_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_LO_SHIFT), XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_LO_SHIFT, XCVR_TSM_TIMING05_PLL_REF_CLK_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING06 - TSM_TIMING06
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING06 - TSM_TIMING06 (RW)
 *
 * Reset value: 0x651AFFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the ADC_CLK_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING06 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING06(base) (XCVR_TSM_TIMING06_REG(base))
#define XCVR_WR_TSM_TIMING06(base, value) (XCVR_TSM_TIMING06_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING06(base, mask, value) (XCVR_WR_TSM_TIMING06(base, (XCVR_RD_TSM_TIMING06(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING06(base, value) (BME_OR32(&XCVR_TSM_TIMING06_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING06(base, value) (BME_AND32(&XCVR_TSM_TIMING06_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING06(base, value) (BME_XOR32(&XCVR_TSM_TIMING06_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING06 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING06, field ADC_CLK_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the ADC_CLK_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING06_ADC_CLK_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING06_ADC_CLK_EN_RX_HI(base) ((XCVR_TSM_TIMING06_REG(base) & XCVR_TSM_TIMING06_ADC_CLK_EN_RX_HI_MASK) >> XCVR_TSM_TIMING06_ADC_CLK_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING06_ADC_CLK_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING06_REG(base), XCVR_TSM_TIMING06_ADC_CLK_EN_RX_HI_SHIFT, XCVR_TSM_TIMING06_ADC_CLK_EN_RX_HI_WIDTH))

/*! @brief Set the ADC_CLK_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING06_ADC_CLK_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING06(base, XCVR_TSM_TIMING06_ADC_CLK_EN_RX_HI_MASK, XCVR_TSM_TIMING06_ADC_CLK_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING06_ADC_CLK_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING06_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING06_ADC_CLK_EN_RX_HI_SHIFT), XCVR_TSM_TIMING06_ADC_CLK_EN_RX_HI_SHIFT, XCVR_TSM_TIMING06_ADC_CLK_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING06, field ADC_CLK_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the ADC_CLK_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING06_ADC_CLK_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING06_ADC_CLK_EN_RX_LO(base) ((XCVR_TSM_TIMING06_REG(base) & XCVR_TSM_TIMING06_ADC_CLK_EN_RX_LO_MASK) >> XCVR_TSM_TIMING06_ADC_CLK_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING06_ADC_CLK_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING06_REG(base), XCVR_TSM_TIMING06_ADC_CLK_EN_RX_LO_SHIFT, XCVR_TSM_TIMING06_ADC_CLK_EN_RX_LO_WIDTH))

/*! @brief Set the ADC_CLK_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING06_ADC_CLK_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING06(base, XCVR_TSM_TIMING06_ADC_CLK_EN_RX_LO_MASK, XCVR_TSM_TIMING06_ADC_CLK_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING06_ADC_CLK_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING06_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING06_ADC_CLK_EN_RX_LO_SHIFT), XCVR_TSM_TIMING06_ADC_CLK_EN_RX_LO_SHIFT, XCVR_TSM_TIMING06_ADC_CLK_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING07 - TSM_TIMING07
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING07 - TSM_TIMING07 (RW)
 *
 * Reset value: 0x1A004E00U
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the PLL_VCO_AUTOTUNE_EN TSM signal
 * or signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING07 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING07(base) (XCVR_TSM_TIMING07_REG(base))
#define XCVR_WR_TSM_TIMING07(base, value) (XCVR_TSM_TIMING07_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING07(base, mask, value) (XCVR_WR_TSM_TIMING07(base, (XCVR_RD_TSM_TIMING07(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING07(base, value) (BME_OR32(&XCVR_TSM_TIMING07_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING07(base, value) (BME_AND32(&XCVR_TSM_TIMING07_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING07(base, value) (BME_XOR32(&XCVR_TSM_TIMING07_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING07 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING07, field PLL_VCO_AUTOTUNE_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_VCO_AUTOTUNE_EN signal or group will transition from LO to
 * HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_HI(base) ((XCVR_TSM_TIMING07_REG(base) & XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_HI_MASK) >> XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING07_REG(base), XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_HI_SHIFT, XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_HI_WIDTH))

/*! @brief Set the PLL_VCO_AUTOTUNE_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING07(base, XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_HI_MASK, XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING07_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_HI_SHIFT), XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_HI_SHIFT, XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING07, field PLL_VCO_AUTOTUNE_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_VCO_AUTOTUNE_EN signal or group will transition from HI to
 * LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_LO(base) ((XCVR_TSM_TIMING07_REG(base) & XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_LO_MASK) >> XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING07_REG(base), XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_LO_SHIFT, XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_LO_WIDTH))

/*! @brief Set the PLL_VCO_AUTOTUNE_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING07(base, XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_LO_MASK, XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING07_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_LO_SHIFT), XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_LO_SHIFT, XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING07, field PLL_VCO_AUTOTUNE_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_VCO_AUTOTUNE_EN signal or group will transition from LO to
 * HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_HI(base) ((XCVR_TSM_TIMING07_REG(base) & XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_HI_MASK) >> XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING07_REG(base), XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_HI_SHIFT, XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_HI_WIDTH))

/*! @brief Set the PLL_VCO_AUTOTUNE_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING07(base, XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_HI_MASK, XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING07_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_HI_SHIFT), XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_HI_SHIFT, XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING07, field PLL_VCO_AUTOTUNE_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_VCO_AUTOTUNE_EN signal or group will transition from HI to
 * LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_LO(base) ((XCVR_TSM_TIMING07_REG(base) & XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_LO_MASK) >> XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING07_REG(base), XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_LO_SHIFT, XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_LO_WIDTH))

/*! @brief Set the PLL_VCO_AUTOTUNE_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING07(base, XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_LO_MASK, XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING07_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_LO_SHIFT), XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_LO_SHIFT, XCVR_TSM_TIMING07_PLL_VCO_AUTOTUNE_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING08 - TSM_TIMING08
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING08 - TSM_TIMING08 (RW)
 *
 * Reset value: 0x65336867U
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the PLL_CYCLE_SLIP_LD_EN TSM
 * signal or signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING08 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING08(base) (XCVR_TSM_TIMING08_REG(base))
#define XCVR_WR_TSM_TIMING08(base, value) (XCVR_TSM_TIMING08_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING08(base, mask, value) (XCVR_WR_TSM_TIMING08(base, (XCVR_RD_TSM_TIMING08(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING08(base, value) (BME_OR32(&XCVR_TSM_TIMING08_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING08(base, value) (BME_AND32(&XCVR_TSM_TIMING08_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING08(base, value) (BME_XOR32(&XCVR_TSM_TIMING08_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING08 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING08, field PLL_CYCLE_SLIP_LD_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_CYCLE_SLIP_LD_EN signal or group will transition from LO to
 * HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_HI(base) ((XCVR_TSM_TIMING08_REG(base) & XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_HI_MASK) >> XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING08_REG(base), XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_HI_SHIFT, XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_HI_WIDTH))

/*! @brief Set the PLL_CYCLE_SLIP_LD_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING08(base, XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_HI_MASK, XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING08_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_HI_SHIFT), XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_HI_SHIFT, XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING08, field PLL_CYCLE_SLIP_LD_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_CYCLE_SLIP_LD_EN signal or group will transition from HI to
 * LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_LO(base) ((XCVR_TSM_TIMING08_REG(base) & XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_LO_MASK) >> XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING08_REG(base), XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_LO_SHIFT, XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_LO_WIDTH))

/*! @brief Set the PLL_CYCLE_SLIP_LD_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING08(base, XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_LO_MASK, XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING08_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_LO_SHIFT), XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_LO_SHIFT, XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING08, field PLL_CYCLE_SLIP_LD_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_CYCLE_SLIP_LD_EN signal or group will transition from LO to
 * HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_HI(base) ((XCVR_TSM_TIMING08_REG(base) & XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_HI_MASK) >> XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING08_REG(base), XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_HI_SHIFT, XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_HI_WIDTH))

/*! @brief Set the PLL_CYCLE_SLIP_LD_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING08(base, XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_HI_MASK, XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING08_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_HI_SHIFT), XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_HI_SHIFT, XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING08, field PLL_CYCLE_SLIP_LD_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_CYCLE_SLIP_LD_EN signal or group will transition from HI to
 * LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_LO(base) ((XCVR_TSM_TIMING08_REG(base) & XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_LO_MASK) >> XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING08_REG(base), XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_LO_SHIFT, XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_LO_WIDTH))

/*! @brief Set the PLL_CYCLE_SLIP_LD_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING08(base, XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_LO_MASK, XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING08_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_LO_SHIFT), XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_LO_SHIFT, XCVR_TSM_TIMING08_PLL_CYCLE_SLIP_LD_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING09 - TSM_TIMING09
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING09 - TSM_TIMING09 (RW)
 *
 * Reset value: 0x65056A05U
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the PLL_VCO_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING09 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING09(base) (XCVR_TSM_TIMING09_REG(base))
#define XCVR_WR_TSM_TIMING09(base, value) (XCVR_TSM_TIMING09_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING09(base, mask, value) (XCVR_WR_TSM_TIMING09(base, (XCVR_RD_TSM_TIMING09(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING09(base, value) (BME_OR32(&XCVR_TSM_TIMING09_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING09(base, value) (BME_AND32(&XCVR_TSM_TIMING09_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING09(base, value) (BME_XOR32(&XCVR_TSM_TIMING09_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING09 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING09, field PLL_VCO_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_VCO_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING09_PLL_VCO_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING09_PLL_VCO_EN_TX_HI(base) ((XCVR_TSM_TIMING09_REG(base) & XCVR_TSM_TIMING09_PLL_VCO_EN_TX_HI_MASK) >> XCVR_TSM_TIMING09_PLL_VCO_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING09_PLL_VCO_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING09_REG(base), XCVR_TSM_TIMING09_PLL_VCO_EN_TX_HI_SHIFT, XCVR_TSM_TIMING09_PLL_VCO_EN_TX_HI_WIDTH))

/*! @brief Set the PLL_VCO_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING09_PLL_VCO_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING09(base, XCVR_TSM_TIMING09_PLL_VCO_EN_TX_HI_MASK, XCVR_TSM_TIMING09_PLL_VCO_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING09_PLL_VCO_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING09_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING09_PLL_VCO_EN_TX_HI_SHIFT), XCVR_TSM_TIMING09_PLL_VCO_EN_TX_HI_SHIFT, XCVR_TSM_TIMING09_PLL_VCO_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING09, field PLL_VCO_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_VCO_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING09_PLL_VCO_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING09_PLL_VCO_EN_TX_LO(base) ((XCVR_TSM_TIMING09_REG(base) & XCVR_TSM_TIMING09_PLL_VCO_EN_TX_LO_MASK) >> XCVR_TSM_TIMING09_PLL_VCO_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING09_PLL_VCO_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING09_REG(base), XCVR_TSM_TIMING09_PLL_VCO_EN_TX_LO_SHIFT, XCVR_TSM_TIMING09_PLL_VCO_EN_TX_LO_WIDTH))

/*! @brief Set the PLL_VCO_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING09_PLL_VCO_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING09(base, XCVR_TSM_TIMING09_PLL_VCO_EN_TX_LO_MASK, XCVR_TSM_TIMING09_PLL_VCO_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING09_PLL_VCO_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING09_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING09_PLL_VCO_EN_TX_LO_SHIFT), XCVR_TSM_TIMING09_PLL_VCO_EN_TX_LO_SHIFT, XCVR_TSM_TIMING09_PLL_VCO_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING09, field PLL_VCO_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_VCO_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING09_PLL_VCO_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING09_PLL_VCO_EN_RX_HI(base) ((XCVR_TSM_TIMING09_REG(base) & XCVR_TSM_TIMING09_PLL_VCO_EN_RX_HI_MASK) >> XCVR_TSM_TIMING09_PLL_VCO_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING09_PLL_VCO_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING09_REG(base), XCVR_TSM_TIMING09_PLL_VCO_EN_RX_HI_SHIFT, XCVR_TSM_TIMING09_PLL_VCO_EN_RX_HI_WIDTH))

/*! @brief Set the PLL_VCO_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING09_PLL_VCO_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING09(base, XCVR_TSM_TIMING09_PLL_VCO_EN_RX_HI_MASK, XCVR_TSM_TIMING09_PLL_VCO_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING09_PLL_VCO_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING09_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING09_PLL_VCO_EN_RX_HI_SHIFT), XCVR_TSM_TIMING09_PLL_VCO_EN_RX_HI_SHIFT, XCVR_TSM_TIMING09_PLL_VCO_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING09, field PLL_VCO_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_VCO_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING09_PLL_VCO_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING09_PLL_VCO_EN_RX_LO(base) ((XCVR_TSM_TIMING09_REG(base) & XCVR_TSM_TIMING09_PLL_VCO_EN_RX_LO_MASK) >> XCVR_TSM_TIMING09_PLL_VCO_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING09_PLL_VCO_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING09_REG(base), XCVR_TSM_TIMING09_PLL_VCO_EN_RX_LO_SHIFT, XCVR_TSM_TIMING09_PLL_VCO_EN_RX_LO_WIDTH))

/*! @brief Set the PLL_VCO_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING09_PLL_VCO_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING09(base, XCVR_TSM_TIMING09_PLL_VCO_EN_RX_LO_MASK, XCVR_TSM_TIMING09_PLL_VCO_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING09_PLL_VCO_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING09_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING09_PLL_VCO_EN_RX_LO_SHIFT), XCVR_TSM_TIMING09_PLL_VCO_EN_RX_LO_SHIFT, XCVR_TSM_TIMING09_PLL_VCO_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING10 - TSM_TIMING10
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING10 - TSM_TIMING10 (RW)
 *
 * Reset value: 0x6509FFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the PLL_VCO_BUF_RX_EN TSM signal
 * or signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING10 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING10(base) (XCVR_TSM_TIMING10_REG(base))
#define XCVR_WR_TSM_TIMING10(base, value) (XCVR_TSM_TIMING10_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING10(base, mask, value) (XCVR_WR_TSM_TIMING10(base, (XCVR_RD_TSM_TIMING10(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING10(base, value) (BME_OR32(&XCVR_TSM_TIMING10_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING10(base, value) (BME_AND32(&XCVR_TSM_TIMING10_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING10(base, value) (BME_XOR32(&XCVR_TSM_TIMING10_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING10 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING10, field PLL_VCO_BUF_RX_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_VCO_BUF_RX_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_HI(base) ((XCVR_TSM_TIMING10_REG(base) & XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_HI_MASK) >> XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING10_REG(base), XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_HI_SHIFT, XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_HI_WIDTH))

/*! @brief Set the PLL_VCO_BUF_RX_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING10(base, XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_HI_MASK, XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING10_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_HI_SHIFT), XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_HI_SHIFT, XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING10, field PLL_VCO_BUF_RX_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_VCO_BUF_RX_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_LO(base) ((XCVR_TSM_TIMING10_REG(base) & XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_LO_MASK) >> XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING10_REG(base), XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_LO_SHIFT, XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_LO_WIDTH))

/*! @brief Set the PLL_VCO_BUF_RX_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING10(base, XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_LO_MASK, XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING10_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_LO_SHIFT), XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_LO_SHIFT, XCVR_TSM_TIMING10_PLL_VCO_BUF_RX_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING11 - TSM_TIMING11
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING11 - TSM_TIMING11 (RW)
 *
 * Reset value: 0xFFFF6A09U
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the PLL_VCO_BUF_TX_EN TSM signal
 * or signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING11 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING11(base) (XCVR_TSM_TIMING11_REG(base))
#define XCVR_WR_TSM_TIMING11(base, value) (XCVR_TSM_TIMING11_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING11(base, mask, value) (XCVR_WR_TSM_TIMING11(base, (XCVR_RD_TSM_TIMING11(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING11(base, value) (BME_OR32(&XCVR_TSM_TIMING11_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING11(base, value) (BME_AND32(&XCVR_TSM_TIMING11_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING11(base, value) (BME_XOR32(&XCVR_TSM_TIMING11_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING11 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING11, field PLL_VCO_BUF_TX_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_VCO_BUF_TX_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_HI(base) ((XCVR_TSM_TIMING11_REG(base) & XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_HI_MASK) >> XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING11_REG(base), XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_HI_SHIFT, XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_HI_WIDTH))

/*! @brief Set the PLL_VCO_BUF_TX_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING11(base, XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_HI_MASK, XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING11_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_HI_SHIFT), XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_HI_SHIFT, XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING11, field PLL_VCO_BUF_TX_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_VCO_BUF_TX_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_LO(base) ((XCVR_TSM_TIMING11_REG(base) & XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_LO_MASK) >> XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING11_REG(base), XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_LO_SHIFT, XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_LO_WIDTH))

/*! @brief Set the PLL_VCO_BUF_TX_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING11(base, XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_LO_MASK, XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING11_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_LO_SHIFT), XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_LO_SHIFT, XCVR_TSM_TIMING11_PLL_VCO_BUF_TX_EN_TX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING12 - TSM_TIMING12
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING12 - TSM_TIMING12 (RW)
 *
 * Reset value: 0xFFFF6A64U
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the PLL_PA_BUF_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING12 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING12(base) (XCVR_TSM_TIMING12_REG(base))
#define XCVR_WR_TSM_TIMING12(base, value) (XCVR_TSM_TIMING12_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING12(base, mask, value) (XCVR_WR_TSM_TIMING12(base, (XCVR_RD_TSM_TIMING12(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING12(base, value) (BME_OR32(&XCVR_TSM_TIMING12_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING12(base, value) (BME_AND32(&XCVR_TSM_TIMING12_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING12(base, value) (BME_XOR32(&XCVR_TSM_TIMING12_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING12 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING12, field PLL_PA_BUF_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_PA_BUF_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING12_PLL_PA_BUF_EN_TX_HI(base) ((XCVR_TSM_TIMING12_REG(base) & XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_HI_MASK) >> XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING12_PLL_PA_BUF_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING12_REG(base), XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_HI_SHIFT, XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_HI_WIDTH))

/*! @brief Set the PLL_PA_BUF_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING12_PLL_PA_BUF_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING12(base, XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_HI_MASK, XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING12_PLL_PA_BUF_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING12_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_HI_SHIFT), XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_HI_SHIFT, XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING12, field PLL_PA_BUF_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_PA_BUF_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING12_PLL_PA_BUF_EN_TX_LO(base) ((XCVR_TSM_TIMING12_REG(base) & XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_LO_MASK) >> XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING12_PLL_PA_BUF_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING12_REG(base), XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_LO_SHIFT, XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_LO_WIDTH))

/*! @brief Set the PLL_PA_BUF_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING12_PLL_PA_BUF_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING12(base, XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_LO_MASK, XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING12_PLL_PA_BUF_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING12_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_LO_SHIFT), XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_LO_SHIFT, XCVR_TSM_TIMING12_PLL_PA_BUF_EN_TX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING13 - TSM_TIMING13
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING13 - TSM_TIMING13 (RW)
 *
 * Reset value: 0x651A6A4EU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the PLL_LDV_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING13 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING13(base) (XCVR_TSM_TIMING13_REG(base))
#define XCVR_WR_TSM_TIMING13(base, value) (XCVR_TSM_TIMING13_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING13(base, mask, value) (XCVR_WR_TSM_TIMING13(base, (XCVR_RD_TSM_TIMING13(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING13(base, value) (BME_OR32(&XCVR_TSM_TIMING13_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING13(base, value) (BME_AND32(&XCVR_TSM_TIMING13_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING13(base, value) (BME_XOR32(&XCVR_TSM_TIMING13_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING13 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING13, field PLL_LDV_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_LDV_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING13_PLL_LDV_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING13_PLL_LDV_EN_TX_HI(base) ((XCVR_TSM_TIMING13_REG(base) & XCVR_TSM_TIMING13_PLL_LDV_EN_TX_HI_MASK) >> XCVR_TSM_TIMING13_PLL_LDV_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING13_PLL_LDV_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING13_REG(base), XCVR_TSM_TIMING13_PLL_LDV_EN_TX_HI_SHIFT, XCVR_TSM_TIMING13_PLL_LDV_EN_TX_HI_WIDTH))

/*! @brief Set the PLL_LDV_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING13_PLL_LDV_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING13(base, XCVR_TSM_TIMING13_PLL_LDV_EN_TX_HI_MASK, XCVR_TSM_TIMING13_PLL_LDV_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING13_PLL_LDV_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING13_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING13_PLL_LDV_EN_TX_HI_SHIFT), XCVR_TSM_TIMING13_PLL_LDV_EN_TX_HI_SHIFT, XCVR_TSM_TIMING13_PLL_LDV_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING13, field PLL_LDV_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_LDV_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING13_PLL_LDV_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING13_PLL_LDV_EN_TX_LO(base) ((XCVR_TSM_TIMING13_REG(base) & XCVR_TSM_TIMING13_PLL_LDV_EN_TX_LO_MASK) >> XCVR_TSM_TIMING13_PLL_LDV_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING13_PLL_LDV_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING13_REG(base), XCVR_TSM_TIMING13_PLL_LDV_EN_TX_LO_SHIFT, XCVR_TSM_TIMING13_PLL_LDV_EN_TX_LO_WIDTH))

/*! @brief Set the PLL_LDV_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING13_PLL_LDV_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING13(base, XCVR_TSM_TIMING13_PLL_LDV_EN_TX_LO_MASK, XCVR_TSM_TIMING13_PLL_LDV_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING13_PLL_LDV_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING13_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING13_PLL_LDV_EN_TX_LO_SHIFT), XCVR_TSM_TIMING13_PLL_LDV_EN_TX_LO_SHIFT, XCVR_TSM_TIMING13_PLL_LDV_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING13, field PLL_LDV_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_LDV_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING13_PLL_LDV_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING13_PLL_LDV_EN_RX_HI(base) ((XCVR_TSM_TIMING13_REG(base) & XCVR_TSM_TIMING13_PLL_LDV_EN_RX_HI_MASK) >> XCVR_TSM_TIMING13_PLL_LDV_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING13_PLL_LDV_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING13_REG(base), XCVR_TSM_TIMING13_PLL_LDV_EN_RX_HI_SHIFT, XCVR_TSM_TIMING13_PLL_LDV_EN_RX_HI_WIDTH))

/*! @brief Set the PLL_LDV_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING13_PLL_LDV_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING13(base, XCVR_TSM_TIMING13_PLL_LDV_EN_RX_HI_MASK, XCVR_TSM_TIMING13_PLL_LDV_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING13_PLL_LDV_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING13_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING13_PLL_LDV_EN_RX_HI_SHIFT), XCVR_TSM_TIMING13_PLL_LDV_EN_RX_HI_SHIFT, XCVR_TSM_TIMING13_PLL_LDV_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING13, field PLL_LDV_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_LDV_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING13_PLL_LDV_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING13_PLL_LDV_EN_RX_LO(base) ((XCVR_TSM_TIMING13_REG(base) & XCVR_TSM_TIMING13_PLL_LDV_EN_RX_LO_MASK) >> XCVR_TSM_TIMING13_PLL_LDV_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING13_PLL_LDV_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING13_REG(base), XCVR_TSM_TIMING13_PLL_LDV_EN_RX_LO_SHIFT, XCVR_TSM_TIMING13_PLL_LDV_EN_RX_LO_WIDTH))

/*! @brief Set the PLL_LDV_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING13_PLL_LDV_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING13(base, XCVR_TSM_TIMING13_PLL_LDV_EN_RX_LO_MASK, XCVR_TSM_TIMING13_PLL_LDV_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING13_PLL_LDV_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING13_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING13_PLL_LDV_EN_RX_LO_SHIFT), XCVR_TSM_TIMING13_PLL_LDV_EN_RX_LO_SHIFT, XCVR_TSM_TIMING13_PLL_LDV_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING14 - TSM_TIMING14
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING14 - TSM_TIMING14 (RW)
 *
 * Reset value: 0x650AFFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the PLL_RX_LDV_RIPPLE_MUX_EN TSM
 * signal or signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING14 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING14(base) (XCVR_TSM_TIMING14_REG(base))
#define XCVR_WR_TSM_TIMING14(base, value) (XCVR_TSM_TIMING14_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING14(base, mask, value) (XCVR_WR_TSM_TIMING14(base, (XCVR_RD_TSM_TIMING14(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING14(base, value) (BME_OR32(&XCVR_TSM_TIMING14_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING14(base, value) (BME_AND32(&XCVR_TSM_TIMING14_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING14(base, value) (BME_XOR32(&XCVR_TSM_TIMING14_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING14 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING14, field PLL_RX_LDV_RIPPLE_MUX_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_RX_LDV_RIPPLE_MUX_EN signal or group will transition from LO
 * to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_HI(base) ((XCVR_TSM_TIMING14_REG(base) & XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_HI_MASK) >> XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING14_REG(base), XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_HI_SHIFT, XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_HI_WIDTH))

/*! @brief Set the PLL_RX_LDV_RIPPLE_MUX_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING14(base, XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_HI_MASK, XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING14_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_HI_SHIFT), XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_HI_SHIFT, XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING14, field PLL_RX_LDV_RIPPLE_MUX_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_RX_LDV_RIPPLE_MUX_EN signal or group will transition from HI
 * to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_LO(base) ((XCVR_TSM_TIMING14_REG(base) & XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_LO_MASK) >> XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING14_REG(base), XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_LO_SHIFT, XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_LO_WIDTH))

/*! @brief Set the PLL_RX_LDV_RIPPLE_MUX_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING14(base, XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_LO_MASK, XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING14_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_LO_SHIFT), XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_LO_SHIFT, XCVR_TSM_TIMING14_PLL_RX_LDV_RIPPLE_MUX_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING15 - TSM_TIMING15
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING15 - TSM_TIMING15 (RW)
 *
 * Reset value: 0xFFFF6A0AU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the PLL_TX_LDV_RIPPLE_MUX_EN TSM
 * signal or signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING15 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING15(base) (XCVR_TSM_TIMING15_REG(base))
#define XCVR_WR_TSM_TIMING15(base, value) (XCVR_TSM_TIMING15_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING15(base, mask, value) (XCVR_WR_TSM_TIMING15(base, (XCVR_RD_TSM_TIMING15(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING15(base, value) (BME_OR32(&XCVR_TSM_TIMING15_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING15(base, value) (BME_AND32(&XCVR_TSM_TIMING15_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING15(base, value) (BME_XOR32(&XCVR_TSM_TIMING15_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING15 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING15, field PLL_TX_LDV_RIPPLE_MUX_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_TX_LDV_RIPPLE_MUX_EN signal or group will transition from LO
 * to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_HI(base) ((XCVR_TSM_TIMING15_REG(base) & XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_HI_MASK) >> XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING15_REG(base), XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_HI_SHIFT, XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_HI_WIDTH))

/*! @brief Set the PLL_TX_LDV_RIPPLE_MUX_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING15(base, XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_HI_MASK, XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING15_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_HI_SHIFT), XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_HI_SHIFT, XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING15, field PLL_TX_LDV_RIPPLE_MUX_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_TX_LDV_RIPPLE_MUX_EN signal or group will transition from HI
 * to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_LO(base) ((XCVR_TSM_TIMING15_REG(base) & XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_LO_MASK) >> XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING15_REG(base), XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_LO_SHIFT, XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_LO_WIDTH))

/*! @brief Set the PLL_TX_LDV_RIPPLE_MUX_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING15(base, XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_LO_MASK, XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING15_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_LO_SHIFT), XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_LO_SHIFT, XCVR_TSM_TIMING15_PLL_TX_LDV_RIPPLE_MUX_EN_TX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING16 - TSM_TIMING16
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING16 - TSM_TIMING16 (RW)
 *
 * Reset value: 0x1A104E44U
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the PLL_FILTER_CHARGE_EN TSM
 * signal or signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING16 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING16(base) (XCVR_TSM_TIMING16_REG(base))
#define XCVR_WR_TSM_TIMING16(base, value) (XCVR_TSM_TIMING16_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING16(base, mask, value) (XCVR_WR_TSM_TIMING16(base, (XCVR_RD_TSM_TIMING16(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING16(base, value) (BME_OR32(&XCVR_TSM_TIMING16_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING16(base, value) (BME_AND32(&XCVR_TSM_TIMING16_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING16(base, value) (BME_XOR32(&XCVR_TSM_TIMING16_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING16 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING16, field PLL_FILTER_CHARGE_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_FILTER_CHARGE_EN signal or group will transition from LO to
 * HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_HI(base) ((XCVR_TSM_TIMING16_REG(base) & XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_HI_MASK) >> XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING16_REG(base), XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_HI_SHIFT, XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_HI_WIDTH))

/*! @brief Set the PLL_FILTER_CHARGE_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING16(base, XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_HI_MASK, XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING16_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_HI_SHIFT), XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_HI_SHIFT, XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING16, field PLL_FILTER_CHARGE_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_FILTER_CHARGE_EN signal or group will transition from HI to
 * LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_LO(base) ((XCVR_TSM_TIMING16_REG(base) & XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_LO_MASK) >> XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING16_REG(base), XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_LO_SHIFT, XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_LO_WIDTH))

/*! @brief Set the PLL_FILTER_CHARGE_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING16(base, XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_LO_MASK, XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING16_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_LO_SHIFT), XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_LO_SHIFT, XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING16, field PLL_FILTER_CHARGE_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_FILTER_CHARGE_EN signal or group will transition from LO to
 * HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_HI(base) ((XCVR_TSM_TIMING16_REG(base) & XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_HI_MASK) >> XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING16_REG(base), XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_HI_SHIFT, XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_HI_WIDTH))

/*! @brief Set the PLL_FILTER_CHARGE_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING16(base, XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_HI_MASK, XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING16_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_HI_SHIFT), XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_HI_SHIFT, XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING16, field PLL_FILTER_CHARGE_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_FILTER_CHARGE_EN signal or group will transition from HI to
 * LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_LO(base) ((XCVR_TSM_TIMING16_REG(base) & XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_LO_MASK) >> XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING16_REG(base), XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_LO_SHIFT, XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_LO_WIDTH))

/*! @brief Set the PLL_FILTER_CHARGE_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING16(base, XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_LO_MASK, XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING16_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_LO_SHIFT), XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_LO_SHIFT, XCVR_TSM_TIMING16_PLL_FILTER_CHARGE_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING17 - TSM_TIMING17
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING17 - TSM_TIMING17 (RW)
 *
 * Reset value: 0x65106A44U
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the PLL_PHDET_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING17 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING17(base) (XCVR_TSM_TIMING17_REG(base))
#define XCVR_WR_TSM_TIMING17(base, value) (XCVR_TSM_TIMING17_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING17(base, mask, value) (XCVR_WR_TSM_TIMING17(base, (XCVR_RD_TSM_TIMING17(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING17(base, value) (BME_OR32(&XCVR_TSM_TIMING17_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING17(base, value) (BME_AND32(&XCVR_TSM_TIMING17_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING17(base, value) (BME_XOR32(&XCVR_TSM_TIMING17_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING17 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING17, field PLL_PHDET_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_PHDET_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING17_PLL_PHDET_EN_TX_HI(base) ((XCVR_TSM_TIMING17_REG(base) & XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_HI_MASK) >> XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING17_PLL_PHDET_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING17_REG(base), XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_HI_SHIFT, XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_HI_WIDTH))

/*! @brief Set the PLL_PHDET_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING17_PLL_PHDET_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING17(base, XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_HI_MASK, XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING17_PLL_PHDET_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING17_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_HI_SHIFT), XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_HI_SHIFT, XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING17, field PLL_PHDET_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_PHDET_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING17_PLL_PHDET_EN_TX_LO(base) ((XCVR_TSM_TIMING17_REG(base) & XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_LO_MASK) >> XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING17_PLL_PHDET_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING17_REG(base), XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_LO_SHIFT, XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_LO_WIDTH))

/*! @brief Set the PLL_PHDET_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING17_PLL_PHDET_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING17(base, XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_LO_MASK, XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING17_PLL_PHDET_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING17_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_LO_SHIFT), XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_LO_SHIFT, XCVR_TSM_TIMING17_PLL_PHDET_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING17, field PLL_PHDET_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_PHDET_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING17_PLL_PHDET_EN_RX_HI(base) ((XCVR_TSM_TIMING17_REG(base) & XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_HI_MASK) >> XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING17_PLL_PHDET_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING17_REG(base), XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_HI_SHIFT, XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_HI_WIDTH))

/*! @brief Set the PLL_PHDET_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING17_PLL_PHDET_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING17(base, XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_HI_MASK, XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING17_PLL_PHDET_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING17_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_HI_SHIFT), XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_HI_SHIFT, XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING17, field PLL_PHDET_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_PHDET_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING17_PLL_PHDET_EN_RX_LO(base) ((XCVR_TSM_TIMING17_REG(base) & XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_LO_MASK) >> XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING17_PLL_PHDET_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING17_REG(base), XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_LO_SHIFT, XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_LO_WIDTH))

/*! @brief Set the PLL_PHDET_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING17_PLL_PHDET_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING17(base, XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_LO_MASK, XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING17_PLL_PHDET_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING17_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_LO_SHIFT), XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_LO_SHIFT, XCVR_TSM_TIMING17_PLL_PHDET_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING18 - TSM_TIMING18
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING18 - TSM_TIMING18 (RW)
 *
 * Reset value: 0x6505FFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the QGEN25_EN TSM signal or signal
 * group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING18 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING18(base) (XCVR_TSM_TIMING18_REG(base))
#define XCVR_WR_TSM_TIMING18(base, value) (XCVR_TSM_TIMING18_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING18(base, mask, value) (XCVR_WR_TSM_TIMING18(base, (XCVR_RD_TSM_TIMING18(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING18(base, value) (BME_OR32(&XCVR_TSM_TIMING18_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING18(base, value) (BME_AND32(&XCVR_TSM_TIMING18_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING18(base, value) (BME_XOR32(&XCVR_TSM_TIMING18_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING18 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING18, field QGEN25_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the QGEN25_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING18_QGEN25_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING18_QGEN25_EN_RX_HI(base) ((XCVR_TSM_TIMING18_REG(base) & XCVR_TSM_TIMING18_QGEN25_EN_RX_HI_MASK) >> XCVR_TSM_TIMING18_QGEN25_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING18_QGEN25_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING18_REG(base), XCVR_TSM_TIMING18_QGEN25_EN_RX_HI_SHIFT, XCVR_TSM_TIMING18_QGEN25_EN_RX_HI_WIDTH))

/*! @brief Set the QGEN25_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING18_QGEN25_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING18(base, XCVR_TSM_TIMING18_QGEN25_EN_RX_HI_MASK, XCVR_TSM_TIMING18_QGEN25_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING18_QGEN25_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING18_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING18_QGEN25_EN_RX_HI_SHIFT), XCVR_TSM_TIMING18_QGEN25_EN_RX_HI_SHIFT, XCVR_TSM_TIMING18_QGEN25_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING18, field QGEN25_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the QGEN25_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING18_QGEN25_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING18_QGEN25_EN_RX_LO(base) ((XCVR_TSM_TIMING18_REG(base) & XCVR_TSM_TIMING18_QGEN25_EN_RX_LO_MASK) >> XCVR_TSM_TIMING18_QGEN25_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING18_QGEN25_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING18_REG(base), XCVR_TSM_TIMING18_QGEN25_EN_RX_LO_SHIFT, XCVR_TSM_TIMING18_QGEN25_EN_RX_LO_WIDTH))

/*! @brief Set the QGEN25_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING18_QGEN25_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING18(base, XCVR_TSM_TIMING18_QGEN25_EN_RX_LO_MASK, XCVR_TSM_TIMING18_QGEN25_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING18_QGEN25_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING18_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING18_QGEN25_EN_RX_LO_SHIFT), XCVR_TSM_TIMING18_QGEN25_EN_RX_LO_SHIFT, XCVR_TSM_TIMING18_QGEN25_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING19 - TSM_TIMING19
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING19 - TSM_TIMING19 (RW)
 *
 * Reset value: 0xFFFF6864U
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the TX_EN TSM signal or signal
 * group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING19 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING19(base) (XCVR_TSM_TIMING19_REG(base))
#define XCVR_WR_TSM_TIMING19(base, value) (XCVR_TSM_TIMING19_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING19(base, mask, value) (XCVR_WR_TSM_TIMING19(base, (XCVR_RD_TSM_TIMING19(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING19(base, value) (BME_OR32(&XCVR_TSM_TIMING19_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING19(base, value) (BME_AND32(&XCVR_TSM_TIMING19_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING19(base, value) (BME_XOR32(&XCVR_TSM_TIMING19_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING19 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING19, field TX_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the TX_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING19_TX_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING19_TX_EN_TX_HI(base) ((XCVR_TSM_TIMING19_REG(base) & XCVR_TSM_TIMING19_TX_EN_TX_HI_MASK) >> XCVR_TSM_TIMING19_TX_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING19_TX_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING19_REG(base), XCVR_TSM_TIMING19_TX_EN_TX_HI_SHIFT, XCVR_TSM_TIMING19_TX_EN_TX_HI_WIDTH))

/*! @brief Set the TX_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING19_TX_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING19(base, XCVR_TSM_TIMING19_TX_EN_TX_HI_MASK, XCVR_TSM_TIMING19_TX_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING19_TX_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING19_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING19_TX_EN_TX_HI_SHIFT), XCVR_TSM_TIMING19_TX_EN_TX_HI_SHIFT, XCVR_TSM_TIMING19_TX_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING19, field TX_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the TX_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING19_TX_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING19_TX_EN_TX_LO(base) ((XCVR_TSM_TIMING19_REG(base) & XCVR_TSM_TIMING19_TX_EN_TX_LO_MASK) >> XCVR_TSM_TIMING19_TX_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING19_TX_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING19_REG(base), XCVR_TSM_TIMING19_TX_EN_TX_LO_SHIFT, XCVR_TSM_TIMING19_TX_EN_TX_LO_WIDTH))

/*! @brief Set the TX_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING19_TX_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING19(base, XCVR_TSM_TIMING19_TX_EN_TX_LO_MASK, XCVR_TSM_TIMING19_TX_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING19_TX_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING19_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING19_TX_EN_TX_LO_SHIFT), XCVR_TSM_TIMING19_TX_EN_TX_LO_SHIFT, XCVR_TSM_TIMING19_TX_EN_TX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING20 - TSM_TIMING20
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING20 - TSM_TIMING20 (RW)
 *
 * Reset value: 0x651AFFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the ADC_EN TSM signal or signal
 * group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING20 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING20(base) (XCVR_TSM_TIMING20_REG(base))
#define XCVR_WR_TSM_TIMING20(base, value) (XCVR_TSM_TIMING20_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING20(base, mask, value) (XCVR_WR_TSM_TIMING20(base, (XCVR_RD_TSM_TIMING20(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING20(base, value) (BME_OR32(&XCVR_TSM_TIMING20_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING20(base, value) (BME_AND32(&XCVR_TSM_TIMING20_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING20(base, value) (BME_XOR32(&XCVR_TSM_TIMING20_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING20 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING20, field ADC_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the ADC_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING20_ADC_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING20_ADC_EN_RX_HI(base) ((XCVR_TSM_TIMING20_REG(base) & XCVR_TSM_TIMING20_ADC_EN_RX_HI_MASK) >> XCVR_TSM_TIMING20_ADC_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING20_ADC_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING20_REG(base), XCVR_TSM_TIMING20_ADC_EN_RX_HI_SHIFT, XCVR_TSM_TIMING20_ADC_EN_RX_HI_WIDTH))

/*! @brief Set the ADC_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING20_ADC_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING20(base, XCVR_TSM_TIMING20_ADC_EN_RX_HI_MASK, XCVR_TSM_TIMING20_ADC_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING20_ADC_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING20_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING20_ADC_EN_RX_HI_SHIFT), XCVR_TSM_TIMING20_ADC_EN_RX_HI_SHIFT, XCVR_TSM_TIMING20_ADC_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING20, field ADC_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the ADC_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING20_ADC_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING20_ADC_EN_RX_LO(base) ((XCVR_TSM_TIMING20_REG(base) & XCVR_TSM_TIMING20_ADC_EN_RX_LO_MASK) >> XCVR_TSM_TIMING20_ADC_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING20_ADC_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING20_REG(base), XCVR_TSM_TIMING20_ADC_EN_RX_LO_SHIFT, XCVR_TSM_TIMING20_ADC_EN_RX_LO_WIDTH))

/*! @brief Set the ADC_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING20_ADC_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING20(base, XCVR_TSM_TIMING20_ADC_EN_RX_LO_MASK, XCVR_TSM_TIMING20_ADC_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING20_ADC_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING20_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING20_ADC_EN_RX_LO_SHIFT), XCVR_TSM_TIMING20_ADC_EN_RX_LO_SHIFT, XCVR_TSM_TIMING20_ADC_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING21 - TSM_TIMING21
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING21 - TSM_TIMING21 (RW)
 *
 * Reset value: 0x651AFFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the ADC_I_Q_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING21 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING21(base) (XCVR_TSM_TIMING21_REG(base))
#define XCVR_WR_TSM_TIMING21(base, value) (XCVR_TSM_TIMING21_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING21(base, mask, value) (XCVR_WR_TSM_TIMING21(base, (XCVR_RD_TSM_TIMING21(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING21(base, value) (BME_OR32(&XCVR_TSM_TIMING21_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING21(base, value) (BME_AND32(&XCVR_TSM_TIMING21_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING21(base, value) (BME_XOR32(&XCVR_TSM_TIMING21_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING21 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING21, field ADC_I_Q_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the ADC_I_Q_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING21_ADC_I_Q_EN_RX_HI(base) ((XCVR_TSM_TIMING21_REG(base) & XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_HI_MASK) >> XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING21_ADC_I_Q_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING21_REG(base), XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_HI_SHIFT, XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_HI_WIDTH))

/*! @brief Set the ADC_I_Q_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING21_ADC_I_Q_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING21(base, XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_HI_MASK, XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING21_ADC_I_Q_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING21_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_HI_SHIFT), XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_HI_SHIFT, XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING21, field ADC_I_Q_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the ADC_I_Q_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING21_ADC_I_Q_EN_RX_LO(base) ((XCVR_TSM_TIMING21_REG(base) & XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_LO_MASK) >> XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING21_ADC_I_Q_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING21_REG(base), XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_LO_SHIFT, XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_LO_WIDTH))

/*! @brief Set the ADC_I_Q_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING21_ADC_I_Q_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING21(base, XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_LO_MASK, XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING21_ADC_I_Q_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING21_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_LO_SHIFT), XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_LO_SHIFT, XCVR_TSM_TIMING21_ADC_I_Q_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING22 - TSM_TIMING22
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING22 - TSM_TIMING22 (RW)
 *
 * Reset value: 0x651AFFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the ADC_DAC_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING22 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING22(base) (XCVR_TSM_TIMING22_REG(base))
#define XCVR_WR_TSM_TIMING22(base, value) (XCVR_TSM_TIMING22_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING22(base, mask, value) (XCVR_WR_TSM_TIMING22(base, (XCVR_RD_TSM_TIMING22(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING22(base, value) (BME_OR32(&XCVR_TSM_TIMING22_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING22(base, value) (BME_AND32(&XCVR_TSM_TIMING22_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING22(base, value) (BME_XOR32(&XCVR_TSM_TIMING22_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING22 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING22, field ADC_DAC_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the ADC_DAC_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING22_ADC_DAC_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING22_ADC_DAC_EN_RX_HI(base) ((XCVR_TSM_TIMING22_REG(base) & XCVR_TSM_TIMING22_ADC_DAC_EN_RX_HI_MASK) >> XCVR_TSM_TIMING22_ADC_DAC_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING22_ADC_DAC_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING22_REG(base), XCVR_TSM_TIMING22_ADC_DAC_EN_RX_HI_SHIFT, XCVR_TSM_TIMING22_ADC_DAC_EN_RX_HI_WIDTH))

/*! @brief Set the ADC_DAC_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING22_ADC_DAC_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING22(base, XCVR_TSM_TIMING22_ADC_DAC_EN_RX_HI_MASK, XCVR_TSM_TIMING22_ADC_DAC_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING22_ADC_DAC_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING22_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING22_ADC_DAC_EN_RX_HI_SHIFT), XCVR_TSM_TIMING22_ADC_DAC_EN_RX_HI_SHIFT, XCVR_TSM_TIMING22_ADC_DAC_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING22, field ADC_DAC_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the ADC_DAC_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING22_ADC_DAC_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING22_ADC_DAC_EN_RX_LO(base) ((XCVR_TSM_TIMING22_REG(base) & XCVR_TSM_TIMING22_ADC_DAC_EN_RX_LO_MASK) >> XCVR_TSM_TIMING22_ADC_DAC_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING22_ADC_DAC_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING22_REG(base), XCVR_TSM_TIMING22_ADC_DAC_EN_RX_LO_SHIFT, XCVR_TSM_TIMING22_ADC_DAC_EN_RX_LO_WIDTH))

/*! @brief Set the ADC_DAC_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING22_ADC_DAC_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING22(base, XCVR_TSM_TIMING22_ADC_DAC_EN_RX_LO_MASK, XCVR_TSM_TIMING22_ADC_DAC_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING22_ADC_DAC_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING22_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING22_ADC_DAC_EN_RX_LO_SHIFT), XCVR_TSM_TIMING22_ADC_DAC_EN_RX_LO_SHIFT, XCVR_TSM_TIMING22_ADC_DAC_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING23 - TSM_TIMING23
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING23 - TSM_TIMING23 (RW)
 *
 * Reset value: 0x651AFFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the ADC_RST_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING23 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING23(base) (XCVR_TSM_TIMING23_REG(base))
#define XCVR_WR_TSM_TIMING23(base, value) (XCVR_TSM_TIMING23_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING23(base, mask, value) (XCVR_WR_TSM_TIMING23(base, (XCVR_RD_TSM_TIMING23(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING23(base, value) (BME_OR32(&XCVR_TSM_TIMING23_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING23(base, value) (BME_AND32(&XCVR_TSM_TIMING23_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING23(base, value) (BME_XOR32(&XCVR_TSM_TIMING23_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING23 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING23, field ADC_RST_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the ADC_RST_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING23_ADC_RST_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING23_ADC_RST_EN_RX_HI(base) ((XCVR_TSM_TIMING23_REG(base) & XCVR_TSM_TIMING23_ADC_RST_EN_RX_HI_MASK) >> XCVR_TSM_TIMING23_ADC_RST_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING23_ADC_RST_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING23_REG(base), XCVR_TSM_TIMING23_ADC_RST_EN_RX_HI_SHIFT, XCVR_TSM_TIMING23_ADC_RST_EN_RX_HI_WIDTH))

/*! @brief Set the ADC_RST_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING23_ADC_RST_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING23(base, XCVR_TSM_TIMING23_ADC_RST_EN_RX_HI_MASK, XCVR_TSM_TIMING23_ADC_RST_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING23_ADC_RST_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING23_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING23_ADC_RST_EN_RX_HI_SHIFT), XCVR_TSM_TIMING23_ADC_RST_EN_RX_HI_SHIFT, XCVR_TSM_TIMING23_ADC_RST_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING23, field ADC_RST_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the ADC_RST_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING23_ADC_RST_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING23_ADC_RST_EN_RX_LO(base) ((XCVR_TSM_TIMING23_REG(base) & XCVR_TSM_TIMING23_ADC_RST_EN_RX_LO_MASK) >> XCVR_TSM_TIMING23_ADC_RST_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING23_ADC_RST_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING23_REG(base), XCVR_TSM_TIMING23_ADC_RST_EN_RX_LO_SHIFT, XCVR_TSM_TIMING23_ADC_RST_EN_RX_LO_WIDTH))

/*! @brief Set the ADC_RST_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING23_ADC_RST_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING23(base, XCVR_TSM_TIMING23_ADC_RST_EN_RX_LO_MASK, XCVR_TSM_TIMING23_ADC_RST_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING23_ADC_RST_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING23_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING23_ADC_RST_EN_RX_LO_SHIFT), XCVR_TSM_TIMING23_ADC_RST_EN_RX_LO_SHIFT, XCVR_TSM_TIMING23_ADC_RST_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING24 - TSM_TIMING24
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING24 - TSM_TIMING24 (RW)
 *
 * Reset value: 0x6518FFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the BBF_EN TSM signal or signal
 * group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING24 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING24(base) (XCVR_TSM_TIMING24_REG(base))
#define XCVR_WR_TSM_TIMING24(base, value) (XCVR_TSM_TIMING24_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING24(base, mask, value) (XCVR_WR_TSM_TIMING24(base, (XCVR_RD_TSM_TIMING24(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING24(base, value) (BME_OR32(&XCVR_TSM_TIMING24_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING24(base, value) (BME_AND32(&XCVR_TSM_TIMING24_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING24(base, value) (BME_XOR32(&XCVR_TSM_TIMING24_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING24 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING24, field BBF_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the BBF_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING24_BBF_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING24_BBF_EN_RX_HI(base) ((XCVR_TSM_TIMING24_REG(base) & XCVR_TSM_TIMING24_BBF_EN_RX_HI_MASK) >> XCVR_TSM_TIMING24_BBF_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING24_BBF_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING24_REG(base), XCVR_TSM_TIMING24_BBF_EN_RX_HI_SHIFT, XCVR_TSM_TIMING24_BBF_EN_RX_HI_WIDTH))

/*! @brief Set the BBF_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING24_BBF_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING24(base, XCVR_TSM_TIMING24_BBF_EN_RX_HI_MASK, XCVR_TSM_TIMING24_BBF_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING24_BBF_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING24_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING24_BBF_EN_RX_HI_SHIFT), XCVR_TSM_TIMING24_BBF_EN_RX_HI_SHIFT, XCVR_TSM_TIMING24_BBF_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING24, field BBF_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the BBF_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING24_BBF_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING24_BBF_EN_RX_LO(base) ((XCVR_TSM_TIMING24_REG(base) & XCVR_TSM_TIMING24_BBF_EN_RX_LO_MASK) >> XCVR_TSM_TIMING24_BBF_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING24_BBF_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING24_REG(base), XCVR_TSM_TIMING24_BBF_EN_RX_LO_SHIFT, XCVR_TSM_TIMING24_BBF_EN_RX_LO_WIDTH))

/*! @brief Set the BBF_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING24_BBF_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING24(base, XCVR_TSM_TIMING24_BBF_EN_RX_LO_MASK, XCVR_TSM_TIMING24_BBF_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING24_BBF_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING24_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING24_BBF_EN_RX_LO_SHIFT), XCVR_TSM_TIMING24_BBF_EN_RX_LO_SHIFT, XCVR_TSM_TIMING24_BBF_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING25 - TSM_TIMING25
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING25 - TSM_TIMING25 (RW)
 *
 * Reset value: 0x6518FFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the TCA_EN TSM signal or signal
 * group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING25 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING25(base) (XCVR_TSM_TIMING25_REG(base))
#define XCVR_WR_TSM_TIMING25(base, value) (XCVR_TSM_TIMING25_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING25(base, mask, value) (XCVR_WR_TSM_TIMING25(base, (XCVR_RD_TSM_TIMING25(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING25(base, value) (BME_OR32(&XCVR_TSM_TIMING25_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING25(base, value) (BME_AND32(&XCVR_TSM_TIMING25_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING25(base, value) (BME_XOR32(&XCVR_TSM_TIMING25_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING25 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING25, field TCA_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the TCA_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING25_TCA_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING25_TCA_EN_RX_HI(base) ((XCVR_TSM_TIMING25_REG(base) & XCVR_TSM_TIMING25_TCA_EN_RX_HI_MASK) >> XCVR_TSM_TIMING25_TCA_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING25_TCA_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING25_REG(base), XCVR_TSM_TIMING25_TCA_EN_RX_HI_SHIFT, XCVR_TSM_TIMING25_TCA_EN_RX_HI_WIDTH))

/*! @brief Set the TCA_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING25_TCA_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING25(base, XCVR_TSM_TIMING25_TCA_EN_RX_HI_MASK, XCVR_TSM_TIMING25_TCA_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING25_TCA_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING25_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING25_TCA_EN_RX_HI_SHIFT), XCVR_TSM_TIMING25_TCA_EN_RX_HI_SHIFT, XCVR_TSM_TIMING25_TCA_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING25, field TCA_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the TCA_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING25_TCA_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING25_TCA_EN_RX_LO(base) ((XCVR_TSM_TIMING25_REG(base) & XCVR_TSM_TIMING25_TCA_EN_RX_LO_MASK) >> XCVR_TSM_TIMING25_TCA_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING25_TCA_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING25_REG(base), XCVR_TSM_TIMING25_TCA_EN_RX_LO_SHIFT, XCVR_TSM_TIMING25_TCA_EN_RX_LO_WIDTH))

/*! @brief Set the TCA_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING25_TCA_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING25(base, XCVR_TSM_TIMING25_TCA_EN_RX_LO_MASK, XCVR_TSM_TIMING25_TCA_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING25_TCA_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING25_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING25_TCA_EN_RX_LO_SHIFT), XCVR_TSM_TIMING25_TCA_EN_RX_LO_SHIFT, XCVR_TSM_TIMING25_TCA_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING26 - TSM_TIMING26
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING26 - TSM_TIMING26 (RW)
 *
 * Reset value: 0x65096A09U
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the PLL_DIG_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING26 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING26(base) (XCVR_TSM_TIMING26_REG(base))
#define XCVR_WR_TSM_TIMING26(base, value) (XCVR_TSM_TIMING26_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING26(base, mask, value) (XCVR_WR_TSM_TIMING26(base, (XCVR_RD_TSM_TIMING26(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING26(base, value) (BME_OR32(&XCVR_TSM_TIMING26_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING26(base, value) (BME_AND32(&XCVR_TSM_TIMING26_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING26(base, value) (BME_XOR32(&XCVR_TSM_TIMING26_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING26 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING26, field PLL_DIG_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_DIG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING26_PLL_DIG_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING26_PLL_DIG_EN_TX_HI(base) ((XCVR_TSM_TIMING26_REG(base) & XCVR_TSM_TIMING26_PLL_DIG_EN_TX_HI_MASK) >> XCVR_TSM_TIMING26_PLL_DIG_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING26_PLL_DIG_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING26_REG(base), XCVR_TSM_TIMING26_PLL_DIG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING26_PLL_DIG_EN_TX_HI_WIDTH))

/*! @brief Set the PLL_DIG_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING26_PLL_DIG_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING26(base, XCVR_TSM_TIMING26_PLL_DIG_EN_TX_HI_MASK, XCVR_TSM_TIMING26_PLL_DIG_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING26_PLL_DIG_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING26_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING26_PLL_DIG_EN_TX_HI_SHIFT), XCVR_TSM_TIMING26_PLL_DIG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING26_PLL_DIG_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING26, field PLL_DIG_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the PLL_DIG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING26_PLL_DIG_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING26_PLL_DIG_EN_TX_LO(base) ((XCVR_TSM_TIMING26_REG(base) & XCVR_TSM_TIMING26_PLL_DIG_EN_TX_LO_MASK) >> XCVR_TSM_TIMING26_PLL_DIG_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING26_PLL_DIG_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING26_REG(base), XCVR_TSM_TIMING26_PLL_DIG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING26_PLL_DIG_EN_TX_LO_WIDTH))

/*! @brief Set the PLL_DIG_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING26_PLL_DIG_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING26(base, XCVR_TSM_TIMING26_PLL_DIG_EN_TX_LO_MASK, XCVR_TSM_TIMING26_PLL_DIG_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING26_PLL_DIG_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING26_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING26_PLL_DIG_EN_TX_LO_SHIFT), XCVR_TSM_TIMING26_PLL_DIG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING26_PLL_DIG_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING26, field PLL_DIG_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_DIG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING26_PLL_DIG_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING26_PLL_DIG_EN_RX_HI(base) ((XCVR_TSM_TIMING26_REG(base) & XCVR_TSM_TIMING26_PLL_DIG_EN_RX_HI_MASK) >> XCVR_TSM_TIMING26_PLL_DIG_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING26_PLL_DIG_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING26_REG(base), XCVR_TSM_TIMING26_PLL_DIG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING26_PLL_DIG_EN_RX_HI_WIDTH))

/*! @brief Set the PLL_DIG_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING26_PLL_DIG_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING26(base, XCVR_TSM_TIMING26_PLL_DIG_EN_RX_HI_MASK, XCVR_TSM_TIMING26_PLL_DIG_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING26_PLL_DIG_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING26_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING26_PLL_DIG_EN_RX_HI_SHIFT), XCVR_TSM_TIMING26_PLL_DIG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING26_PLL_DIG_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING26, field PLL_DIG_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the PLL_DIG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING26_PLL_DIG_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING26_PLL_DIG_EN_RX_LO(base) ((XCVR_TSM_TIMING26_REG(base) & XCVR_TSM_TIMING26_PLL_DIG_EN_RX_LO_MASK) >> XCVR_TSM_TIMING26_PLL_DIG_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING26_PLL_DIG_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING26_REG(base), XCVR_TSM_TIMING26_PLL_DIG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING26_PLL_DIG_EN_RX_LO_WIDTH))

/*! @brief Set the PLL_DIG_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING26_PLL_DIG_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING26(base, XCVR_TSM_TIMING26_PLL_DIG_EN_RX_LO_MASK, XCVR_TSM_TIMING26_PLL_DIG_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING26_PLL_DIG_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING26_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING26_PLL_DIG_EN_RX_LO_SHIFT), XCVR_TSM_TIMING26_PLL_DIG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING26_PLL_DIG_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING27 - TSM_TIMING27
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING27 - TSM_TIMING27 (RW)
 *
 * Reset value: 0xFFFF6A67U
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the TX_DIG_EN TSM signal or signal
 * group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING27 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING27(base) (XCVR_TSM_TIMING27_REG(base))
#define XCVR_WR_TSM_TIMING27(base, value) (XCVR_TSM_TIMING27_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING27(base, mask, value) (XCVR_WR_TSM_TIMING27(base, (XCVR_RD_TSM_TIMING27(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING27(base, value) (BME_OR32(&XCVR_TSM_TIMING27_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING27(base, value) (BME_AND32(&XCVR_TSM_TIMING27_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING27(base, value) (BME_XOR32(&XCVR_TSM_TIMING27_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING27 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING27, field TX_DIG_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the TX_DIG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING27_TX_DIG_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING27_TX_DIG_EN_TX_HI(base) ((XCVR_TSM_TIMING27_REG(base) & XCVR_TSM_TIMING27_TX_DIG_EN_TX_HI_MASK) >> XCVR_TSM_TIMING27_TX_DIG_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING27_TX_DIG_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING27_REG(base), XCVR_TSM_TIMING27_TX_DIG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING27_TX_DIG_EN_TX_HI_WIDTH))

/*! @brief Set the TX_DIG_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING27_TX_DIG_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING27(base, XCVR_TSM_TIMING27_TX_DIG_EN_TX_HI_MASK, XCVR_TSM_TIMING27_TX_DIG_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING27_TX_DIG_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING27_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING27_TX_DIG_EN_TX_HI_SHIFT), XCVR_TSM_TIMING27_TX_DIG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING27_TX_DIG_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING27, field TX_DIG_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the TX_DIG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING27_TX_DIG_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING27_TX_DIG_EN_TX_LO(base) ((XCVR_TSM_TIMING27_REG(base) & XCVR_TSM_TIMING27_TX_DIG_EN_TX_LO_MASK) >> XCVR_TSM_TIMING27_TX_DIG_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING27_TX_DIG_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING27_REG(base), XCVR_TSM_TIMING27_TX_DIG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING27_TX_DIG_EN_TX_LO_WIDTH))

/*! @brief Set the TX_DIG_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING27_TX_DIG_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING27(base, XCVR_TSM_TIMING27_TX_DIG_EN_TX_LO_MASK, XCVR_TSM_TIMING27_TX_DIG_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING27_TX_DIG_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING27_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING27_TX_DIG_EN_TX_LO_SHIFT), XCVR_TSM_TIMING27_TX_DIG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING27_TX_DIG_EN_TX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING28 - TSM_TIMING28
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING28 - TSM_TIMING28 (RW)
 *
 * Reset value: 0x6562FFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the RX_DIG_EN TSM signal or signal
 * group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING28 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING28(base) (XCVR_TSM_TIMING28_REG(base))
#define XCVR_WR_TSM_TIMING28(base, value) (XCVR_TSM_TIMING28_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING28(base, mask, value) (XCVR_WR_TSM_TIMING28(base, (XCVR_RD_TSM_TIMING28(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING28(base, value) (BME_OR32(&XCVR_TSM_TIMING28_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING28(base, value) (BME_AND32(&XCVR_TSM_TIMING28_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING28(base, value) (BME_XOR32(&XCVR_TSM_TIMING28_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING28 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING28, field RX_DIG_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the RX_DIG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING28_RX_DIG_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING28_RX_DIG_EN_RX_HI(base) ((XCVR_TSM_TIMING28_REG(base) & XCVR_TSM_TIMING28_RX_DIG_EN_RX_HI_MASK) >> XCVR_TSM_TIMING28_RX_DIG_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING28_RX_DIG_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING28_REG(base), XCVR_TSM_TIMING28_RX_DIG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING28_RX_DIG_EN_RX_HI_WIDTH))

/*! @brief Set the RX_DIG_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING28_RX_DIG_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING28(base, XCVR_TSM_TIMING28_RX_DIG_EN_RX_HI_MASK, XCVR_TSM_TIMING28_RX_DIG_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING28_RX_DIG_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING28_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING28_RX_DIG_EN_RX_HI_SHIFT), XCVR_TSM_TIMING28_RX_DIG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING28_RX_DIG_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING28, field RX_DIG_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the RX_DIG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING28_RX_DIG_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING28_RX_DIG_EN_RX_LO(base) ((XCVR_TSM_TIMING28_REG(base) & XCVR_TSM_TIMING28_RX_DIG_EN_RX_LO_MASK) >> XCVR_TSM_TIMING28_RX_DIG_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING28_RX_DIG_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING28_REG(base), XCVR_TSM_TIMING28_RX_DIG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING28_RX_DIG_EN_RX_LO_WIDTH))

/*! @brief Set the RX_DIG_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING28_RX_DIG_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING28(base, XCVR_TSM_TIMING28_RX_DIG_EN_RX_LO_MASK, XCVR_TSM_TIMING28_RX_DIG_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING28_RX_DIG_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING28_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING28_RX_DIG_EN_RX_LO_SHIFT), XCVR_TSM_TIMING28_RX_DIG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING28_RX_DIG_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING29 - TSM_TIMING29
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING29 - TSM_TIMING29 (RW)
 *
 * Reset value: 0x6362FFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the RX_INIT TSM signal or signal
 * group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING29 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING29(base) (XCVR_TSM_TIMING29_REG(base))
#define XCVR_WR_TSM_TIMING29(base, value) (XCVR_TSM_TIMING29_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING29(base, mask, value) (XCVR_WR_TSM_TIMING29(base, (XCVR_RD_TSM_TIMING29(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING29(base, value) (BME_OR32(&XCVR_TSM_TIMING29_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING29(base, value) (BME_AND32(&XCVR_TSM_TIMING29_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING29(base, value) (BME_XOR32(&XCVR_TSM_TIMING29_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING29 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING29, field RX_INIT_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the RX_INIT signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING29_RX_INIT_RX_HI field. */
#define XCVR_RD_TSM_TIMING29_RX_INIT_RX_HI(base) ((XCVR_TSM_TIMING29_REG(base) & XCVR_TSM_TIMING29_RX_INIT_RX_HI_MASK) >> XCVR_TSM_TIMING29_RX_INIT_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING29_RX_INIT_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING29_REG(base), XCVR_TSM_TIMING29_RX_INIT_RX_HI_SHIFT, XCVR_TSM_TIMING29_RX_INIT_RX_HI_WIDTH))

/*! @brief Set the RX_INIT_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING29_RX_INIT_RX_HI(base, value) (XCVR_RMW_TSM_TIMING29(base, XCVR_TSM_TIMING29_RX_INIT_RX_HI_MASK, XCVR_TSM_TIMING29_RX_INIT_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING29_RX_INIT_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING29_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING29_RX_INIT_RX_HI_SHIFT), XCVR_TSM_TIMING29_RX_INIT_RX_HI_SHIFT, XCVR_TSM_TIMING29_RX_INIT_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING29, field RX_INIT_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the RX_INIT signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING29_RX_INIT_RX_LO field. */
#define XCVR_RD_TSM_TIMING29_RX_INIT_RX_LO(base) ((XCVR_TSM_TIMING29_REG(base) & XCVR_TSM_TIMING29_RX_INIT_RX_LO_MASK) >> XCVR_TSM_TIMING29_RX_INIT_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING29_RX_INIT_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING29_REG(base), XCVR_TSM_TIMING29_RX_INIT_RX_LO_SHIFT, XCVR_TSM_TIMING29_RX_INIT_RX_LO_WIDTH))

/*! @brief Set the RX_INIT_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING29_RX_INIT_RX_LO(base, value) (XCVR_RMW_TSM_TIMING29(base, XCVR_TSM_TIMING29_RX_INIT_RX_LO_MASK, XCVR_TSM_TIMING29_RX_INIT_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING29_RX_INIT_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING29_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING29_RX_INIT_RX_LO_SHIFT), XCVR_TSM_TIMING29_RX_INIT_RX_LO_SHIFT, XCVR_TSM_TIMING29_RX_INIT_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING30 - TSM_TIMING30
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING30 - TSM_TIMING30 (RW)
 *
 * Reset value: 0x65106A44U
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the SIGMA_DELTA_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING30 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING30(base) (XCVR_TSM_TIMING30_REG(base))
#define XCVR_WR_TSM_TIMING30(base, value) (XCVR_TSM_TIMING30_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING30(base, mask, value) (XCVR_WR_TSM_TIMING30(base, (XCVR_RD_TSM_TIMING30(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING30(base, value) (BME_OR32(&XCVR_TSM_TIMING30_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING30(base, value) (BME_AND32(&XCVR_TSM_TIMING30_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING30(base, value) (BME_XOR32(&XCVR_TSM_TIMING30_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING30 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING30, field SIGMA_DELTA_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the SIGMA_DELTA_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING30_SIGMA_DELTA_EN_TX_HI(base) ((XCVR_TSM_TIMING30_REG(base) & XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_HI_MASK) >> XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING30_SIGMA_DELTA_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING30_REG(base), XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_HI_SHIFT, XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_HI_WIDTH))

/*! @brief Set the SIGMA_DELTA_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING30_SIGMA_DELTA_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING30(base, XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_HI_MASK, XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING30_SIGMA_DELTA_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING30_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_HI_SHIFT), XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_HI_SHIFT, XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING30, field SIGMA_DELTA_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the SIGMA_DELTA_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING30_SIGMA_DELTA_EN_TX_LO(base) ((XCVR_TSM_TIMING30_REG(base) & XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_LO_MASK) >> XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING30_SIGMA_DELTA_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING30_REG(base), XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_LO_SHIFT, XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_LO_WIDTH))

/*! @brief Set the SIGMA_DELTA_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING30_SIGMA_DELTA_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING30(base, XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_LO_MASK, XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING30_SIGMA_DELTA_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING30_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_LO_SHIFT), XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_LO_SHIFT, XCVR_TSM_TIMING30_SIGMA_DELTA_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING30, field SIGMA_DELTA_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the SIGMA_DELTA_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING30_SIGMA_DELTA_EN_RX_HI(base) ((XCVR_TSM_TIMING30_REG(base) & XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_HI_MASK) >> XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING30_SIGMA_DELTA_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING30_REG(base), XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_HI_SHIFT, XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_HI_WIDTH))

/*! @brief Set the SIGMA_DELTA_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING30_SIGMA_DELTA_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING30(base, XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_HI_MASK, XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING30_SIGMA_DELTA_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING30_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_HI_SHIFT), XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_HI_SHIFT, XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING30, field SIGMA_DELTA_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the SIGMA_DELTA_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING30_SIGMA_DELTA_EN_RX_LO(base) ((XCVR_TSM_TIMING30_REG(base) & XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_LO_MASK) >> XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING30_SIGMA_DELTA_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING30_REG(base), XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_LO_SHIFT, XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_LO_WIDTH))

/*! @brief Set the SIGMA_DELTA_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING30_SIGMA_DELTA_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING30(base, XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_LO_MASK, XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING30_SIGMA_DELTA_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING30_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_LO_SHIFT), XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_LO_SHIFT, XCVR_TSM_TIMING30_SIGMA_DELTA_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING31 - TSM_TIMING31
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING31 - TSM_TIMING31 (RW)
 *
 * Reset value: 0x6562FFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the ZBDEM_RX_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING31 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING31(base) (XCVR_TSM_TIMING31_REG(base))
#define XCVR_WR_TSM_TIMING31(base, value) (XCVR_TSM_TIMING31_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING31(base, mask, value) (XCVR_WR_TSM_TIMING31(base, (XCVR_RD_TSM_TIMING31(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING31(base, value) (BME_OR32(&XCVR_TSM_TIMING31_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING31(base, value) (BME_AND32(&XCVR_TSM_TIMING31_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING31(base, value) (BME_XOR32(&XCVR_TSM_TIMING31_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING31 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING31, field ZBDEM_RX_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the ZBDEM_RX_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING31_ZBDEM_RX_EN_RX_HI(base) ((XCVR_TSM_TIMING31_REG(base) & XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_HI_MASK) >> XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING31_ZBDEM_RX_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING31_REG(base), XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_HI_SHIFT, XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_HI_WIDTH))

/*! @brief Set the ZBDEM_RX_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING31_ZBDEM_RX_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING31(base, XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_HI_MASK, XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING31_ZBDEM_RX_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING31_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_HI_SHIFT), XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_HI_SHIFT, XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING31, field ZBDEM_RX_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the ZBDEM_RX_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING31_ZBDEM_RX_EN_RX_LO(base) ((XCVR_TSM_TIMING31_REG(base) & XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_LO_MASK) >> XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING31_ZBDEM_RX_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING31_REG(base), XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_LO_SHIFT, XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_LO_WIDTH))

/*! @brief Set the ZBDEM_RX_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING31_ZBDEM_RX_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING31(base, XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_LO_MASK, XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING31_ZBDEM_RX_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING31_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_LO_SHIFT), XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_LO_SHIFT, XCVR_TSM_TIMING31_ZBDEM_RX_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING32 - TSM_TIMING32
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING32 - TSM_TIMING32 (RW)
 *
 * Reset value: 0x6526FFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the DCOC_EN TSM signal or signal
 * group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING32 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING32(base) (XCVR_TSM_TIMING32_REG(base))
#define XCVR_WR_TSM_TIMING32(base, value) (XCVR_TSM_TIMING32_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING32(base, mask, value) (XCVR_WR_TSM_TIMING32(base, (XCVR_RD_TSM_TIMING32(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING32(base, value) (BME_OR32(&XCVR_TSM_TIMING32_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING32(base, value) (BME_AND32(&XCVR_TSM_TIMING32_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING32(base, value) (BME_XOR32(&XCVR_TSM_TIMING32_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING32 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING32, field DCOC_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the DCOC_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING32_DCOC_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING32_DCOC_EN_RX_HI(base) ((XCVR_TSM_TIMING32_REG(base) & XCVR_TSM_TIMING32_DCOC_EN_RX_HI_MASK) >> XCVR_TSM_TIMING32_DCOC_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING32_DCOC_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING32_REG(base), XCVR_TSM_TIMING32_DCOC_EN_RX_HI_SHIFT, XCVR_TSM_TIMING32_DCOC_EN_RX_HI_WIDTH))

/*! @brief Set the DCOC_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING32_DCOC_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING32(base, XCVR_TSM_TIMING32_DCOC_EN_RX_HI_MASK, XCVR_TSM_TIMING32_DCOC_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING32_DCOC_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING32_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING32_DCOC_EN_RX_HI_SHIFT), XCVR_TSM_TIMING32_DCOC_EN_RX_HI_SHIFT, XCVR_TSM_TIMING32_DCOC_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING32, field DCOC_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the DCOC_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING32_DCOC_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING32_DCOC_EN_RX_LO(base) ((XCVR_TSM_TIMING32_REG(base) & XCVR_TSM_TIMING32_DCOC_EN_RX_LO_MASK) >> XCVR_TSM_TIMING32_DCOC_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING32_DCOC_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING32_REG(base), XCVR_TSM_TIMING32_DCOC_EN_RX_LO_SHIFT, XCVR_TSM_TIMING32_DCOC_EN_RX_LO_WIDTH))

/*! @brief Set the DCOC_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING32_DCOC_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING32(base, XCVR_TSM_TIMING32_DCOC_EN_RX_LO_MASK, XCVR_TSM_TIMING32_DCOC_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING32_DCOC_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING32_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING32_DCOC_EN_RX_LO_SHIFT), XCVR_TSM_TIMING32_DCOC_EN_RX_LO_SHIFT, XCVR_TSM_TIMING32_DCOC_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING33 - TSM_TIMING33
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING33 - TSM_TIMING33 (RW)
 *
 * Reset value: 0x2726FFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the DCOC_INIT TSM signal or signal
 * group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING33 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING33(base) (XCVR_TSM_TIMING33_REG(base))
#define XCVR_WR_TSM_TIMING33(base, value) (XCVR_TSM_TIMING33_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING33(base, mask, value) (XCVR_WR_TSM_TIMING33(base, (XCVR_RD_TSM_TIMING33(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING33(base, value) (BME_OR32(&XCVR_TSM_TIMING33_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING33(base, value) (BME_AND32(&XCVR_TSM_TIMING33_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING33(base, value) (BME_XOR32(&XCVR_TSM_TIMING33_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING33 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING33, field DCOC_INIT_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the DCOC_INIT signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING33_DCOC_INIT_RX_HI field. */
#define XCVR_RD_TSM_TIMING33_DCOC_INIT_RX_HI(base) ((XCVR_TSM_TIMING33_REG(base) & XCVR_TSM_TIMING33_DCOC_INIT_RX_HI_MASK) >> XCVR_TSM_TIMING33_DCOC_INIT_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING33_DCOC_INIT_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING33_REG(base), XCVR_TSM_TIMING33_DCOC_INIT_RX_HI_SHIFT, XCVR_TSM_TIMING33_DCOC_INIT_RX_HI_WIDTH))

/*! @brief Set the DCOC_INIT_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING33_DCOC_INIT_RX_HI(base, value) (XCVR_RMW_TSM_TIMING33(base, XCVR_TSM_TIMING33_DCOC_INIT_RX_HI_MASK, XCVR_TSM_TIMING33_DCOC_INIT_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING33_DCOC_INIT_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING33_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING33_DCOC_INIT_RX_HI_SHIFT), XCVR_TSM_TIMING33_DCOC_INIT_RX_HI_SHIFT, XCVR_TSM_TIMING33_DCOC_INIT_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING33, field DCOC_INIT_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the DCOC_INIT signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING33_DCOC_INIT_RX_LO field. */
#define XCVR_RD_TSM_TIMING33_DCOC_INIT_RX_LO(base) ((XCVR_TSM_TIMING33_REG(base) & XCVR_TSM_TIMING33_DCOC_INIT_RX_LO_MASK) >> XCVR_TSM_TIMING33_DCOC_INIT_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING33_DCOC_INIT_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING33_REG(base), XCVR_TSM_TIMING33_DCOC_INIT_RX_LO_SHIFT, XCVR_TSM_TIMING33_DCOC_INIT_RX_LO_WIDTH))

/*! @brief Set the DCOC_INIT_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING33_DCOC_INIT_RX_LO(base, value) (XCVR_RMW_TSM_TIMING33(base, XCVR_TSM_TIMING33_DCOC_INIT_RX_LO_MASK, XCVR_TSM_TIMING33_DCOC_INIT_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING33_DCOC_INIT_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING33_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING33_DCOC_INIT_RX_LO_SHIFT), XCVR_TSM_TIMING33_DCOC_INIT_RX_LO_SHIFT, XCVR_TSM_TIMING33_DCOC_INIT_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING34 - TSM_TIMING34
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING34 - TSM_TIMING34 (RW)
 *
 * Reset value: 0x65336865U
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the FREQ_TARG_LD_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING34 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING34(base) (XCVR_TSM_TIMING34_REG(base))
#define XCVR_WR_TSM_TIMING34(base, value) (XCVR_TSM_TIMING34_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING34(base, mask, value) (XCVR_WR_TSM_TIMING34(base, (XCVR_RD_TSM_TIMING34(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING34(base, value) (BME_OR32(&XCVR_TSM_TIMING34_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING34(base, value) (BME_AND32(&XCVR_TSM_TIMING34_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING34(base, value) (BME_XOR32(&XCVR_TSM_TIMING34_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING34 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING34, field FREQ_TARG_LD_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the FREQ_TARG_LD_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING34_FREQ_TARG_LD_EN_TX_HI(base) ((XCVR_TSM_TIMING34_REG(base) & XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_HI_MASK) >> XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING34_FREQ_TARG_LD_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING34_REG(base), XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_HI_SHIFT, XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_HI_WIDTH))

/*! @brief Set the FREQ_TARG_LD_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING34(base, XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_HI_MASK, XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING34_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_HI_SHIFT), XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_HI_SHIFT, XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING34, field FREQ_TARG_LD_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the FREQ_TARG_LD_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING34_FREQ_TARG_LD_EN_TX_LO(base) ((XCVR_TSM_TIMING34_REG(base) & XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_LO_MASK) >> XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING34_FREQ_TARG_LD_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING34_REG(base), XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_LO_SHIFT, XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_LO_WIDTH))

/*! @brief Set the FREQ_TARG_LD_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING34(base, XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_LO_MASK, XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING34_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_LO_SHIFT), XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_LO_SHIFT, XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING34, field FREQ_TARG_LD_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the FREQ_TARG_LD_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING34_FREQ_TARG_LD_EN_RX_HI(base) ((XCVR_TSM_TIMING34_REG(base) & XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_HI_MASK) >> XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING34_FREQ_TARG_LD_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING34_REG(base), XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_HI_SHIFT, XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_HI_WIDTH))

/*! @brief Set the FREQ_TARG_LD_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING34(base, XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_HI_MASK, XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING34_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_HI_SHIFT), XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_HI_SHIFT, XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING34, field FREQ_TARG_LD_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the FREQ_TARG_LD_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING34_FREQ_TARG_LD_EN_RX_LO(base) ((XCVR_TSM_TIMING34_REG(base) & XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_LO_MASK) >> XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING34_FREQ_TARG_LD_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING34_REG(base), XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_LO_SHIFT, XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_LO_WIDTH))

/*! @brief Set the FREQ_TARG_LD_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING34(base, XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_LO_MASK, XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING34_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_LO_SHIFT), XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_LO_SHIFT, XCVR_TSM_TIMING34_FREQ_TARG_LD_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING35 - TSM_TIMING35
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING35 - TSM_TIMING35 (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the SAR_ADC_TRIG_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING35 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING35(base) (XCVR_TSM_TIMING35_REG(base))
#define XCVR_WR_TSM_TIMING35(base, value) (XCVR_TSM_TIMING35_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING35(base, mask, value) (XCVR_WR_TSM_TIMING35(base, (XCVR_RD_TSM_TIMING35(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING35(base, value) (BME_OR32(&XCVR_TSM_TIMING35_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING35(base, value) (BME_AND32(&XCVR_TSM_TIMING35_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING35(base, value) (BME_XOR32(&XCVR_TSM_TIMING35_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING35 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING35, field SAR_ADC_TRIG_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the SAR_ADC_TRIG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_HI(base) ((XCVR_TSM_TIMING35_REG(base) & XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_HI_MASK) >> XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING35_REG(base), XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_HI_WIDTH))

/*! @brief Set the SAR_ADC_TRIG_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING35(base, XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_HI_MASK, XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING35_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_HI_SHIFT), XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING35, field SAR_ADC_TRIG_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the SAR_ADC_TRIG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_LO(base) ((XCVR_TSM_TIMING35_REG(base) & XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_LO_MASK) >> XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING35_REG(base), XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_LO_WIDTH))

/*! @brief Set the SAR_ADC_TRIG_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING35(base, XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_LO_MASK, XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING35_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_LO_SHIFT), XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING35, field SAR_ADC_TRIG_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the SAR_ADC_TRIG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_HI(base) ((XCVR_TSM_TIMING35_REG(base) & XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_HI_MASK) >> XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING35_REG(base), XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_HI_WIDTH))

/*! @brief Set the SAR_ADC_TRIG_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING35(base, XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_HI_MASK, XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING35_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_HI_SHIFT), XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING35, field SAR_ADC_TRIG_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the SAR_ADC_TRIG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_LO(base) ((XCVR_TSM_TIMING35_REG(base) & XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_LO_MASK) >> XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING35_REG(base), XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_LO_WIDTH))

/*! @brief Set the SAR_ADC_TRIG_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING35(base, XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_LO_MASK, XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING35_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_LO_SHIFT), XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING35_SAR_ADC_TRIG_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING36 - TSM_TIMING36
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING36 - TSM_TIMING36 (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the TSM_SPARE0_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING36 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING36(base) (XCVR_TSM_TIMING36_REG(base))
#define XCVR_WR_TSM_TIMING36(base, value) (XCVR_TSM_TIMING36_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING36(base, mask, value) (XCVR_WR_TSM_TIMING36(base, (XCVR_RD_TSM_TIMING36(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING36(base, value) (BME_OR32(&XCVR_TSM_TIMING36_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING36(base, value) (BME_AND32(&XCVR_TSM_TIMING36_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING36(base, value) (BME_XOR32(&XCVR_TSM_TIMING36_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING36 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING36, field TSM_SPARE0_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the TSM_SPARE0_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING36_TSM_SPARE0_EN_TX_HI(base) ((XCVR_TSM_TIMING36_REG(base) & XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_HI_MASK) >> XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING36_TSM_SPARE0_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING36_REG(base), XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_HI_SHIFT, XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_HI_WIDTH))

/*! @brief Set the TSM_SPARE0_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING36_TSM_SPARE0_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING36(base, XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_HI_MASK, XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING36_TSM_SPARE0_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING36_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_HI_SHIFT), XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_HI_SHIFT, XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING36, field TSM_SPARE0_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the TSM_SPARE0_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING36_TSM_SPARE0_EN_TX_LO(base) ((XCVR_TSM_TIMING36_REG(base) & XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_LO_MASK) >> XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING36_TSM_SPARE0_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING36_REG(base), XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_LO_SHIFT, XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_LO_WIDTH))

/*! @brief Set the TSM_SPARE0_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING36_TSM_SPARE0_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING36(base, XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_LO_MASK, XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING36_TSM_SPARE0_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING36_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_LO_SHIFT), XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_LO_SHIFT, XCVR_TSM_TIMING36_TSM_SPARE0_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING36, field TSM_SPARE0_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the TSM_SPARE0_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING36_TSM_SPARE0_EN_RX_HI(base) ((XCVR_TSM_TIMING36_REG(base) & XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_HI_MASK) >> XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING36_TSM_SPARE0_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING36_REG(base), XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_HI_SHIFT, XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_HI_WIDTH))

/*! @brief Set the TSM_SPARE0_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING36_TSM_SPARE0_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING36(base, XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_HI_MASK, XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING36_TSM_SPARE0_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING36_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_HI_SHIFT), XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_HI_SHIFT, XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING36, field TSM_SPARE0_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the TSM_SPARE0_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING36_TSM_SPARE0_EN_RX_LO(base) ((XCVR_TSM_TIMING36_REG(base) & XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_LO_MASK) >> XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING36_TSM_SPARE0_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING36_REG(base), XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_LO_SHIFT, XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_LO_WIDTH))

/*! @brief Set the TSM_SPARE0_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING36_TSM_SPARE0_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING36(base, XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_LO_MASK, XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING36_TSM_SPARE0_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING36_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_LO_SHIFT), XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_LO_SHIFT, XCVR_TSM_TIMING36_TSM_SPARE0_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING37 - TSM_TIMING37
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING37 - TSM_TIMING37 (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the TSM_SPARE1_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING37 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING37(base) (XCVR_TSM_TIMING37_REG(base))
#define XCVR_WR_TSM_TIMING37(base, value) (XCVR_TSM_TIMING37_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING37(base, mask, value) (XCVR_WR_TSM_TIMING37(base, (XCVR_RD_TSM_TIMING37(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING37(base, value) (BME_OR32(&XCVR_TSM_TIMING37_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING37(base, value) (BME_AND32(&XCVR_TSM_TIMING37_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING37(base, value) (BME_XOR32(&XCVR_TSM_TIMING37_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING37 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING37, field TSM_SPARE1_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the TSM_SPARE1_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING37_TSM_SPARE1_EN_TX_HI(base) ((XCVR_TSM_TIMING37_REG(base) & XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_HI_MASK) >> XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING37_TSM_SPARE1_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING37_REG(base), XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_HI_SHIFT, XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_HI_WIDTH))

/*! @brief Set the TSM_SPARE1_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING37_TSM_SPARE1_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING37(base, XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_HI_MASK, XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING37_TSM_SPARE1_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING37_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_HI_SHIFT), XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_HI_SHIFT, XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING37, field TSM_SPARE1_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the TSM_SPARE1_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING37_TSM_SPARE1_EN_TX_LO(base) ((XCVR_TSM_TIMING37_REG(base) & XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_LO_MASK) >> XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING37_TSM_SPARE1_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING37_REG(base), XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_LO_SHIFT, XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_LO_WIDTH))

/*! @brief Set the TSM_SPARE1_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING37_TSM_SPARE1_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING37(base, XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_LO_MASK, XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING37_TSM_SPARE1_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING37_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_LO_SHIFT), XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_LO_SHIFT, XCVR_TSM_TIMING37_TSM_SPARE1_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING37, field TSM_SPARE1_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the TSM_SPARE1_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING37_TSM_SPARE1_EN_RX_HI(base) ((XCVR_TSM_TIMING37_REG(base) & XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_HI_MASK) >> XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING37_TSM_SPARE1_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING37_REG(base), XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_HI_SHIFT, XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_HI_WIDTH))

/*! @brief Set the TSM_SPARE1_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING37_TSM_SPARE1_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING37(base, XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_HI_MASK, XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING37_TSM_SPARE1_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING37_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_HI_SHIFT), XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_HI_SHIFT, XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING37, field TSM_SPARE1_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the TSM_SPARE1_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING37_TSM_SPARE1_EN_RX_LO(base) ((XCVR_TSM_TIMING37_REG(base) & XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_LO_MASK) >> XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING37_TSM_SPARE1_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING37_REG(base), XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_LO_SHIFT, XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_LO_WIDTH))

/*! @brief Set the TSM_SPARE1_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING37_TSM_SPARE1_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING37(base, XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_LO_MASK, XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING37_TSM_SPARE1_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING37_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_LO_SHIFT), XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_LO_SHIFT, XCVR_TSM_TIMING37_TSM_SPARE1_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING38 - TSM_TIMING38
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING38 - TSM_TIMING38 (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the TSM_SPARE2_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING38 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING38(base) (XCVR_TSM_TIMING38_REG(base))
#define XCVR_WR_TSM_TIMING38(base, value) (XCVR_TSM_TIMING38_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING38(base, mask, value) (XCVR_WR_TSM_TIMING38(base, (XCVR_RD_TSM_TIMING38(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING38(base, value) (BME_OR32(&XCVR_TSM_TIMING38_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING38(base, value) (BME_AND32(&XCVR_TSM_TIMING38_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING38(base, value) (BME_XOR32(&XCVR_TSM_TIMING38_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING38 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING38, field TSM_SPARE2_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the TSM_SPARE2_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING38_TSM_SPARE2_EN_TX_HI(base) ((XCVR_TSM_TIMING38_REG(base) & XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_HI_MASK) >> XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING38_TSM_SPARE2_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING38_REG(base), XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_HI_SHIFT, XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_HI_WIDTH))

/*! @brief Set the TSM_SPARE2_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING38_TSM_SPARE2_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING38(base, XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_HI_MASK, XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING38_TSM_SPARE2_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING38_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_HI_SHIFT), XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_HI_SHIFT, XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING38, field TSM_SPARE2_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the TSM_SPARE2_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING38_TSM_SPARE2_EN_TX_LO(base) ((XCVR_TSM_TIMING38_REG(base) & XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_LO_MASK) >> XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING38_TSM_SPARE2_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING38_REG(base), XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_LO_SHIFT, XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_LO_WIDTH))

/*! @brief Set the TSM_SPARE2_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING38_TSM_SPARE2_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING38(base, XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_LO_MASK, XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING38_TSM_SPARE2_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING38_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_LO_SHIFT), XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_LO_SHIFT, XCVR_TSM_TIMING38_TSM_SPARE2_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING38, field TSM_SPARE2_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the TSM_SPARE2_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING38_TSM_SPARE2_EN_RX_HI(base) ((XCVR_TSM_TIMING38_REG(base) & XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_HI_MASK) >> XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING38_TSM_SPARE2_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING38_REG(base), XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_HI_SHIFT, XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_HI_WIDTH))

/*! @brief Set the TSM_SPARE2_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING38_TSM_SPARE2_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING38(base, XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_HI_MASK, XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING38_TSM_SPARE2_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING38_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_HI_SHIFT), XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_HI_SHIFT, XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING38, field TSM_SPARE2_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the TSM_SPARE2_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING38_TSM_SPARE2_EN_RX_LO(base) ((XCVR_TSM_TIMING38_REG(base) & XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_LO_MASK) >> XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING38_TSM_SPARE2_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING38_REG(base), XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_LO_SHIFT, XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_LO_WIDTH))

/*! @brief Set the TSM_SPARE2_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING38_TSM_SPARE2_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING38(base, XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_LO_MASK, XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING38_TSM_SPARE2_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING38_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_LO_SHIFT), XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_LO_SHIFT, XCVR_TSM_TIMING38_TSM_SPARE2_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING39 - TSM_TIMING39
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING39 - TSM_TIMING39 (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the TSM_SPARE3_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING39 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING39(base) (XCVR_TSM_TIMING39_REG(base))
#define XCVR_WR_TSM_TIMING39(base, value) (XCVR_TSM_TIMING39_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING39(base, mask, value) (XCVR_WR_TSM_TIMING39(base, (XCVR_RD_TSM_TIMING39(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING39(base, value) (BME_OR32(&XCVR_TSM_TIMING39_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING39(base, value) (BME_AND32(&XCVR_TSM_TIMING39_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING39(base, value) (BME_XOR32(&XCVR_TSM_TIMING39_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING39 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING39, field TSM_SPARE3_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the TSM_SPARE3_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING39_TSM_SPARE3_EN_TX_HI(base) ((XCVR_TSM_TIMING39_REG(base) & XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_HI_MASK) >> XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING39_TSM_SPARE3_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING39_REG(base), XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_HI_SHIFT, XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_HI_WIDTH))

/*! @brief Set the TSM_SPARE3_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING39_TSM_SPARE3_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING39(base, XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_HI_MASK, XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING39_TSM_SPARE3_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING39_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_HI_SHIFT), XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_HI_SHIFT, XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING39, field TSM_SPARE3_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the TSM_SPARE3_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING39_TSM_SPARE3_EN_TX_LO(base) ((XCVR_TSM_TIMING39_REG(base) & XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_LO_MASK) >> XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING39_TSM_SPARE3_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING39_REG(base), XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_LO_SHIFT, XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_LO_WIDTH))

/*! @brief Set the TSM_SPARE3_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING39_TSM_SPARE3_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING39(base, XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_LO_MASK, XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING39_TSM_SPARE3_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING39_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_LO_SHIFT), XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_LO_SHIFT, XCVR_TSM_TIMING39_TSM_SPARE3_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING39, field TSM_SPARE3_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the TSM_SPARE3_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING39_TSM_SPARE3_EN_RX_HI(base) ((XCVR_TSM_TIMING39_REG(base) & XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_HI_MASK) >> XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING39_TSM_SPARE3_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING39_REG(base), XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_HI_SHIFT, XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_HI_WIDTH))

/*! @brief Set the TSM_SPARE3_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING39_TSM_SPARE3_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING39(base, XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_HI_MASK, XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING39_TSM_SPARE3_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING39_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_HI_SHIFT), XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_HI_SHIFT, XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING39, field TSM_SPARE3_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the TSM_SPARE3_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING39_TSM_SPARE3_EN_RX_LO(base) ((XCVR_TSM_TIMING39_REG(base) & XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_LO_MASK) >> XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING39_TSM_SPARE3_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING39_REG(base), XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_LO_SHIFT, XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_LO_WIDTH))

/*! @brief Set the TSM_SPARE3_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING39_TSM_SPARE3_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING39(base, XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_LO_MASK, XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING39_TSM_SPARE3_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING39_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_LO_SHIFT), XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_LO_SHIFT, XCVR_TSM_TIMING39_TSM_SPARE3_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING40 - TSM_TIMING40
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING40 - TSM_TIMING40 (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the GPIO0_TRIG_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING40 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING40(base) (XCVR_TSM_TIMING40_REG(base))
#define XCVR_WR_TSM_TIMING40(base, value) (XCVR_TSM_TIMING40_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING40(base, mask, value) (XCVR_WR_TSM_TIMING40(base, (XCVR_RD_TSM_TIMING40(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING40(base, value) (BME_OR32(&XCVR_TSM_TIMING40_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING40(base, value) (BME_AND32(&XCVR_TSM_TIMING40_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING40(base, value) (BME_XOR32(&XCVR_TSM_TIMING40_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING40 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING40, field GPIO0_TRIG_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the GPIO0_TRIG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING40_GPIO0_TRIG_EN_TX_HI(base) ((XCVR_TSM_TIMING40_REG(base) & XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_HI_MASK) >> XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING40_GPIO0_TRIG_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING40_REG(base), XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_HI_WIDTH))

/*! @brief Set the GPIO0_TRIG_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING40_GPIO0_TRIG_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING40(base, XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_HI_MASK, XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING40_GPIO0_TRIG_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING40_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_HI_SHIFT), XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING40, field GPIO0_TRIG_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the GPIO0_TRIG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING40_GPIO0_TRIG_EN_TX_LO(base) ((XCVR_TSM_TIMING40_REG(base) & XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_LO_MASK) >> XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING40_GPIO0_TRIG_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING40_REG(base), XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_LO_WIDTH))

/*! @brief Set the GPIO0_TRIG_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING40_GPIO0_TRIG_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING40(base, XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_LO_MASK, XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING40_GPIO0_TRIG_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING40_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_LO_SHIFT), XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING40_GPIO0_TRIG_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING40, field GPIO0_TRIG_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the GPIO0_TRIG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING40_GPIO0_TRIG_EN_RX_HI(base) ((XCVR_TSM_TIMING40_REG(base) & XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_HI_MASK) >> XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING40_GPIO0_TRIG_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING40_REG(base), XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_HI_WIDTH))

/*! @brief Set the GPIO0_TRIG_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING40_GPIO0_TRIG_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING40(base, XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_HI_MASK, XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING40_GPIO0_TRIG_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING40_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_HI_SHIFT), XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING40, field GPIO0_TRIG_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the GPIO0_TRIG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING40_GPIO0_TRIG_EN_RX_LO(base) ((XCVR_TSM_TIMING40_REG(base) & XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_LO_MASK) >> XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING40_GPIO0_TRIG_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING40_REG(base), XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_LO_WIDTH))

/*! @brief Set the GPIO0_TRIG_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING40_GPIO0_TRIG_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING40(base, XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_LO_MASK, XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING40_GPIO0_TRIG_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING40_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_LO_SHIFT), XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING40_GPIO0_TRIG_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING41 - TSM_TIMING41
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING41 - TSM_TIMING41 (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the GPIO1_TRIG_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING41 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING41(base) (XCVR_TSM_TIMING41_REG(base))
#define XCVR_WR_TSM_TIMING41(base, value) (XCVR_TSM_TIMING41_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING41(base, mask, value) (XCVR_WR_TSM_TIMING41(base, (XCVR_RD_TSM_TIMING41(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING41(base, value) (BME_OR32(&XCVR_TSM_TIMING41_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING41(base, value) (BME_AND32(&XCVR_TSM_TIMING41_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING41(base, value) (BME_XOR32(&XCVR_TSM_TIMING41_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING41 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING41, field GPIO1_TRIG_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the GPIO1_TRIG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING41_GPIO1_TRIG_EN_TX_HI(base) ((XCVR_TSM_TIMING41_REG(base) & XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_HI_MASK) >> XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING41_GPIO1_TRIG_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING41_REG(base), XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_HI_WIDTH))

/*! @brief Set the GPIO1_TRIG_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING41_GPIO1_TRIG_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING41(base, XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_HI_MASK, XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING41_GPIO1_TRIG_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING41_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_HI_SHIFT), XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING41, field GPIO1_TRIG_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the GPIO1_TRIG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING41_GPIO1_TRIG_EN_TX_LO(base) ((XCVR_TSM_TIMING41_REG(base) & XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_LO_MASK) >> XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING41_GPIO1_TRIG_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING41_REG(base), XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_LO_WIDTH))

/*! @brief Set the GPIO1_TRIG_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING41_GPIO1_TRIG_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING41(base, XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_LO_MASK, XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING41_GPIO1_TRIG_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING41_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_LO_SHIFT), XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING41_GPIO1_TRIG_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING41, field GPIO1_TRIG_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the GPIO1_TRIG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING41_GPIO1_TRIG_EN_RX_HI(base) ((XCVR_TSM_TIMING41_REG(base) & XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_HI_MASK) >> XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING41_GPIO1_TRIG_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING41_REG(base), XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_HI_WIDTH))

/*! @brief Set the GPIO1_TRIG_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING41_GPIO1_TRIG_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING41(base, XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_HI_MASK, XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING41_GPIO1_TRIG_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING41_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_HI_SHIFT), XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING41, field GPIO1_TRIG_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the GPIO1_TRIG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING41_GPIO1_TRIG_EN_RX_LO(base) ((XCVR_TSM_TIMING41_REG(base) & XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_LO_MASK) >> XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING41_GPIO1_TRIG_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING41_REG(base), XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_LO_WIDTH))

/*! @brief Set the GPIO1_TRIG_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING41_GPIO1_TRIG_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING41(base, XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_LO_MASK, XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING41_GPIO1_TRIG_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING41_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_LO_SHIFT), XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING41_GPIO1_TRIG_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING42 - TSM_TIMING42
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING42 - TSM_TIMING42 (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the GPIO2_TRIG_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING42 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING42(base) (XCVR_TSM_TIMING42_REG(base))
#define XCVR_WR_TSM_TIMING42(base, value) (XCVR_TSM_TIMING42_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING42(base, mask, value) (XCVR_WR_TSM_TIMING42(base, (XCVR_RD_TSM_TIMING42(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING42(base, value) (BME_OR32(&XCVR_TSM_TIMING42_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING42(base, value) (BME_AND32(&XCVR_TSM_TIMING42_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING42(base, value) (BME_XOR32(&XCVR_TSM_TIMING42_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING42 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING42, field GPIO2_TRIG_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the GPIO2_TRIG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING42_GPIO2_TRIG_EN_TX_HI(base) ((XCVR_TSM_TIMING42_REG(base) & XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_HI_MASK) >> XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING42_GPIO2_TRIG_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING42_REG(base), XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_HI_WIDTH))

/*! @brief Set the GPIO2_TRIG_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING42_GPIO2_TRIG_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING42(base, XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_HI_MASK, XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING42_GPIO2_TRIG_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING42_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_HI_SHIFT), XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING42, field GPIO2_TRIG_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the GPIO2_TRIG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING42_GPIO2_TRIG_EN_TX_LO(base) ((XCVR_TSM_TIMING42_REG(base) & XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_LO_MASK) >> XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING42_GPIO2_TRIG_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING42_REG(base), XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_LO_WIDTH))

/*! @brief Set the GPIO2_TRIG_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING42_GPIO2_TRIG_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING42(base, XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_LO_MASK, XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING42_GPIO2_TRIG_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING42_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_LO_SHIFT), XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING42_GPIO2_TRIG_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING42, field GPIO2_TRIG_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the GPIO2_TRIG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING42_GPIO2_TRIG_EN_RX_HI(base) ((XCVR_TSM_TIMING42_REG(base) & XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_HI_MASK) >> XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING42_GPIO2_TRIG_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING42_REG(base), XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_HI_WIDTH))

/*! @brief Set the GPIO2_TRIG_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING42_GPIO2_TRIG_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING42(base, XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_HI_MASK, XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING42_GPIO2_TRIG_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING42_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_HI_SHIFT), XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING42, field GPIO2_TRIG_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the GPIO2_TRIG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING42_GPIO2_TRIG_EN_RX_LO(base) ((XCVR_TSM_TIMING42_REG(base) & XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_LO_MASK) >> XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING42_GPIO2_TRIG_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING42_REG(base), XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_LO_WIDTH))

/*! @brief Set the GPIO2_TRIG_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING42_GPIO2_TRIG_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING42(base, XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_LO_MASK, XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING42_GPIO2_TRIG_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING42_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_LO_SHIFT), XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING42_GPIO2_TRIG_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TSM_TIMING43 - TSM_TIMING43
 ******************************************************************************/

/*!
 * @brief XCVR_TSM_TIMING43 - TSM_TIMING43 (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * This register contains the timing values to control the assertion and
 * deassertion times for both TX and RX sequences for the GPIO3_TRIG_EN TSM signal or
 * signal group.
 */
/*!
 * @name Constants and macros for entire XCVR_TSM_TIMING43 register
 */
/*@{*/
#define XCVR_RD_TSM_TIMING43(base) (XCVR_TSM_TIMING43_REG(base))
#define XCVR_WR_TSM_TIMING43(base, value) (XCVR_TSM_TIMING43_REG(base) = (value))
#define XCVR_RMW_TSM_TIMING43(base, mask, value) (XCVR_WR_TSM_TIMING43(base, (XCVR_RD_TSM_TIMING43(base) & ~(mask)) | (value)))
#define XCVR_SET_TSM_TIMING43(base, value) (BME_OR32(&XCVR_TSM_TIMING43_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TSM_TIMING43(base, value) (BME_AND32(&XCVR_TSM_TIMING43_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TSM_TIMING43(base, value) (BME_XOR32(&XCVR_TSM_TIMING43_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TSM_TIMING43 bitfields
 */

/*!
 * @name Register XCVR_TSM_TIMING43, field GPIO3_TRIG_EN_TX_HI[7:0] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the GPIO3_TRIG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_HI field. */
#define XCVR_RD_TSM_TIMING43_GPIO3_TRIG_EN_TX_HI(base) ((XCVR_TSM_TIMING43_REG(base) & XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_HI_MASK) >> XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING43_GPIO3_TRIG_EN_TX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING43_REG(base), XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_HI_WIDTH))

/*! @brief Set the GPIO3_TRIG_EN_TX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING43_GPIO3_TRIG_EN_TX_HI(base, value) (XCVR_RMW_TSM_TIMING43(base, XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_HI_MASK, XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_HI(value)))
#define XCVR_BWR_TSM_TIMING43_GPIO3_TRIG_EN_TX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING43_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_HI_SHIFT), XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_HI_SHIFT, XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING43, field GPIO3_TRIG_EN_TX_LO[15:8] (RW)
 *
 * This field sets the point during a TSM TX sequence (the tsm_count[7:0] value)
 * at which the GPIO3_TRIG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_LO field. */
#define XCVR_RD_TSM_TIMING43_GPIO3_TRIG_EN_TX_LO(base) ((XCVR_TSM_TIMING43_REG(base) & XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_LO_MASK) >> XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING43_GPIO3_TRIG_EN_TX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING43_REG(base), XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_LO_WIDTH))

/*! @brief Set the GPIO3_TRIG_EN_TX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING43_GPIO3_TRIG_EN_TX_LO(base, value) (XCVR_RMW_TSM_TIMING43(base, XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_LO_MASK, XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_LO(value)))
#define XCVR_BWR_TSM_TIMING43_GPIO3_TRIG_EN_TX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING43_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_LO_SHIFT), XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_LO_SHIFT, XCVR_TSM_TIMING43_GPIO3_TRIG_EN_TX_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING43, field GPIO3_TRIG_EN_RX_HI[23:16] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the GPIO3_TRIG_EN signal or group will transition from LO to HI.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_HI field. */
#define XCVR_RD_TSM_TIMING43_GPIO3_TRIG_EN_RX_HI(base) ((XCVR_TSM_TIMING43_REG(base) & XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_HI_MASK) >> XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_HI_SHIFT)
#define XCVR_BRD_TSM_TIMING43_GPIO3_TRIG_EN_RX_HI(base) (BME_UBFX32(&XCVR_TSM_TIMING43_REG(base), XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_HI_WIDTH))

/*! @brief Set the GPIO3_TRIG_EN_RX_HI field to a new value. */
#define XCVR_WR_TSM_TIMING43_GPIO3_TRIG_EN_RX_HI(base, value) (XCVR_RMW_TSM_TIMING43(base, XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_HI_MASK, XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_HI(value)))
#define XCVR_BWR_TSM_TIMING43_GPIO3_TRIG_EN_RX_HI(base, value) (BME_BFI32(&XCVR_TSM_TIMING43_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_HI_SHIFT), XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_HI_SHIFT, XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TSM_TIMING43, field GPIO3_TRIG_EN_RX_LO[31:24] (RW)
 *
 * This field sets the point during a TSM RX sequence (the tsm_count[7:0] value)
 * at which the GPIO3_TRIG_EN signal or group will transition from HI to LO.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_LO field. */
#define XCVR_RD_TSM_TIMING43_GPIO3_TRIG_EN_RX_LO(base) ((XCVR_TSM_TIMING43_REG(base) & XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_LO_MASK) >> XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_LO_SHIFT)
#define XCVR_BRD_TSM_TIMING43_GPIO3_TRIG_EN_RX_LO(base) (BME_UBFX32(&XCVR_TSM_TIMING43_REG(base), XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_LO_WIDTH))

/*! @brief Set the GPIO3_TRIG_EN_RX_LO field to a new value. */
#define XCVR_WR_TSM_TIMING43_GPIO3_TRIG_EN_RX_LO(base, value) (XCVR_RMW_TSM_TIMING43(base, XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_LO_MASK, XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_LO(value)))
#define XCVR_BWR_TSM_TIMING43_GPIO3_TRIG_EN_RX_LO(base, value) (BME_BFI32(&XCVR_TSM_TIMING43_REG(base), ((uint32_t)(value) << XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_LO_SHIFT), XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_LO_SHIFT, XCVR_TSM_TIMING43_GPIO3_TRIG_EN_RX_LO_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_CORR_CTRL - CORR_CTRL
 ******************************************************************************/

/*!
 * @brief XCVR_CORR_CTRL - CORR_CTRL (RW)
 *
 * Reset value: 0x00000482U
 */
/*!
 * @name Constants and macros for entire XCVR_CORR_CTRL register
 */
/*@{*/
#define XCVR_RD_CORR_CTRL(base)  (XCVR_CORR_CTRL_REG(base))
#define XCVR_WR_CORR_CTRL(base, value) (XCVR_CORR_CTRL_REG(base) = (value))
#define XCVR_RMW_CORR_CTRL(base, mask, value) (XCVR_WR_CORR_CTRL(base, (XCVR_RD_CORR_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_CORR_CTRL(base, value) (BME_OR32(&XCVR_CORR_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_CORR_CTRL(base, value) (BME_AND32(&XCVR_CORR_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_CORR_CTRL(base, value) (BME_XOR32(&XCVR_CORR_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_CORR_CTRL bitfields
 */

/*!
 * @name Register XCVR_CORR_CTRL, field CORR_VT[7:0] (RW)
 *
 * Correlator threshold, defines the sensitivity of demod during the preamble
 * search state
 */
/*@{*/
/*! @brief Read current value of the XCVR_CORR_CTRL_CORR_VT field. */
#define XCVR_RD_CORR_CTRL_CORR_VT(base) ((XCVR_CORR_CTRL_REG(base) & XCVR_CORR_CTRL_CORR_VT_MASK) >> XCVR_CORR_CTRL_CORR_VT_SHIFT)
#define XCVR_BRD_CORR_CTRL_CORR_VT(base) (BME_UBFX32(&XCVR_CORR_CTRL_REG(base), XCVR_CORR_CTRL_CORR_VT_SHIFT, XCVR_CORR_CTRL_CORR_VT_WIDTH))

/*! @brief Set the CORR_VT field to a new value. */
#define XCVR_WR_CORR_CTRL_CORR_VT(base, value) (XCVR_RMW_CORR_CTRL(base, XCVR_CORR_CTRL_CORR_VT_MASK, XCVR_CORR_CTRL_CORR_VT(value)))
#define XCVR_BWR_CORR_CTRL_CORR_VT(base, value) (BME_BFI32(&XCVR_CORR_CTRL_REG(base), ((uint32_t)(value) << XCVR_CORR_CTRL_CORR_VT_SHIFT), XCVR_CORR_CTRL_CORR_VT_SHIFT, XCVR_CORR_CTRL_CORR_VT_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_CORR_CTRL, field CORR_NVAL[10:8] (RW)
 *
 * Number of consecutively detected zero-symbols required to declare a preamble
 * detected
 */
/*@{*/
/*! @brief Read current value of the XCVR_CORR_CTRL_CORR_NVAL field. */
#define XCVR_RD_CORR_CTRL_CORR_NVAL(base) ((XCVR_CORR_CTRL_REG(base) & XCVR_CORR_CTRL_CORR_NVAL_MASK) >> XCVR_CORR_CTRL_CORR_NVAL_SHIFT)
#define XCVR_BRD_CORR_CTRL_CORR_NVAL(base) (BME_UBFX32(&XCVR_CORR_CTRL_REG(base), XCVR_CORR_CTRL_CORR_NVAL_SHIFT, XCVR_CORR_CTRL_CORR_NVAL_WIDTH))

/*! @brief Set the CORR_NVAL field to a new value. */
#define XCVR_WR_CORR_CTRL_CORR_NVAL(base, value) (XCVR_RMW_CORR_CTRL(base, XCVR_CORR_CTRL_CORR_NVAL_MASK, XCVR_CORR_CTRL_CORR_NVAL(value)))
#define XCVR_BWR_CORR_CTRL_CORR_NVAL(base, value) (BME_BFI32(&XCVR_CORR_CTRL_REG(base), ((uint32_t)(value) << XCVR_CORR_CTRL_CORR_NVAL_SHIFT), XCVR_CORR_CTRL_CORR_NVAL_SHIFT, XCVR_CORR_CTRL_CORR_NVAL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_CORR_CTRL, field MAX_CORR_EN[11] (RW)
 *
 * Max correlator after preamble enable-- Enable the refresh of the max corr
 * register
 */
/*@{*/
/*! @brief Read current value of the XCVR_CORR_CTRL_MAX_CORR_EN field. */
#define XCVR_RD_CORR_CTRL_MAX_CORR_EN(base) ((XCVR_CORR_CTRL_REG(base) & XCVR_CORR_CTRL_MAX_CORR_EN_MASK) >> XCVR_CORR_CTRL_MAX_CORR_EN_SHIFT)
#define XCVR_BRD_CORR_CTRL_MAX_CORR_EN(base) (BME_UBFX32(&XCVR_CORR_CTRL_REG(base), XCVR_CORR_CTRL_MAX_CORR_EN_SHIFT, XCVR_CORR_CTRL_MAX_CORR_EN_WIDTH))

/*! @brief Set the MAX_CORR_EN field to a new value. */
#define XCVR_WR_CORR_CTRL_MAX_CORR_EN(base, value) (XCVR_RMW_CORR_CTRL(base, XCVR_CORR_CTRL_MAX_CORR_EN_MASK, XCVR_CORR_CTRL_MAX_CORR_EN(value)))
#define XCVR_BWR_CORR_CTRL_MAX_CORR_EN(base, value) (BME_BFI32(&XCVR_CORR_CTRL_REG(base), ((uint32_t)(value) << XCVR_CORR_CTRL_MAX_CORR_EN_SHIFT), XCVR_CORR_CTRL_MAX_CORR_EN_SHIFT, XCVR_CORR_CTRL_MAX_CORR_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_CORR_CTRL, field RX_MAX_CORR[23:16] (RO)
 *
 * Max correlator after preamble-- max correlator value found in packet after
 * the preamble (refreshed every symbol rate if MAX_CORR_EN=1).
 */
/*@{*/
/*! @brief Read current value of the XCVR_CORR_CTRL_RX_MAX_CORR field. */
#define XCVR_RD_CORR_CTRL_RX_MAX_CORR(base) ((XCVR_CORR_CTRL_REG(base) & XCVR_CORR_CTRL_RX_MAX_CORR_MASK) >> XCVR_CORR_CTRL_RX_MAX_CORR_SHIFT)
#define XCVR_BRD_CORR_CTRL_RX_MAX_CORR(base) (BME_UBFX32(&XCVR_CORR_CTRL_REG(base), XCVR_CORR_CTRL_RX_MAX_CORR_SHIFT, XCVR_CORR_CTRL_RX_MAX_CORR_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_CORR_CTRL, field RX_MAX_PREAMBLE[31:24] (RO)
 *
 * Max correlator during preamble-- max correlator value found during the
 * preamble.
 */
/*@{*/
/*! @brief Read current value of the XCVR_CORR_CTRL_RX_MAX_PREAMBLE field. */
#define XCVR_RD_CORR_CTRL_RX_MAX_PREAMBLE(base) ((XCVR_CORR_CTRL_REG(base) & XCVR_CORR_CTRL_RX_MAX_PREAMBLE_MASK) >> XCVR_CORR_CTRL_RX_MAX_PREAMBLE_SHIFT)
#define XCVR_BRD_CORR_CTRL_RX_MAX_PREAMBLE(base) (BME_UBFX32(&XCVR_CORR_CTRL_REG(base), XCVR_CORR_CTRL_RX_MAX_PREAMBLE_SHIFT, XCVR_CORR_CTRL_RX_MAX_PREAMBLE_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PN_TYPE - PN_TYPE
 ******************************************************************************/

/*!
 * @brief XCVR_PN_TYPE - PN_TYPE (RW)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire XCVR_PN_TYPE register
 */
/*@{*/
#define XCVR_RD_PN_TYPE(base)    (XCVR_PN_TYPE_REG(base))
#define XCVR_WR_PN_TYPE(base, value) (XCVR_PN_TYPE_REG(base) = (value))
#define XCVR_RMW_PN_TYPE(base, mask, value) (XCVR_WR_PN_TYPE(base, (XCVR_RD_PN_TYPE(base) & ~(mask)) | (value)))
#define XCVR_SET_PN_TYPE(base, value) (BME_OR32(&XCVR_PN_TYPE_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PN_TYPE(base, value) (BME_AND32(&XCVR_PN_TYPE_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PN_TYPE(base, value) (BME_XOR32(&XCVR_PN_TYPE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PN_TYPE bitfields
 */

/*!
 * @name Register XCVR_PN_TYPE, field PN_TYPE[0] (RW)
 *
 * PN Type - Pseudo Noise Chip Code Type (ZigBee=1)
 */
/*@{*/
/*! @brief Read current value of the XCVR_PN_TYPE_PN_TYPE field. */
#define XCVR_RD_PN_TYPE_PN_TYPE(base) ((XCVR_PN_TYPE_REG(base) & XCVR_PN_TYPE_PN_TYPE_MASK) >> XCVR_PN_TYPE_PN_TYPE_SHIFT)
#define XCVR_BRD_PN_TYPE_PN_TYPE(base) (BME_UBFX32(&XCVR_PN_TYPE_REG(base), XCVR_PN_TYPE_PN_TYPE_SHIFT, XCVR_PN_TYPE_PN_TYPE_WIDTH))

/*! @brief Set the PN_TYPE field to a new value. */
#define XCVR_WR_PN_TYPE_PN_TYPE(base, value) (XCVR_RMW_PN_TYPE(base, XCVR_PN_TYPE_PN_TYPE_MASK, XCVR_PN_TYPE_PN_TYPE(value)))
#define XCVR_BWR_PN_TYPE_PN_TYPE(base, value) (BME_BFI32(&XCVR_PN_TYPE_REG(base), ((uint32_t)(value) << XCVR_PN_TYPE_PN_TYPE_SHIFT), XCVR_PN_TYPE_PN_TYPE_SHIFT, XCVR_PN_TYPE_PN_TYPE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PN_TYPE, field TX_INV[1] (RW)
 *
 * test mode to invert the transmission
 */
/*@{*/
/*! @brief Read current value of the XCVR_PN_TYPE_TX_INV field. */
#define XCVR_RD_PN_TYPE_TX_INV(base) ((XCVR_PN_TYPE_REG(base) & XCVR_PN_TYPE_TX_INV_MASK) >> XCVR_PN_TYPE_TX_INV_SHIFT)
#define XCVR_BRD_PN_TYPE_TX_INV(base) (BME_UBFX32(&XCVR_PN_TYPE_REG(base), XCVR_PN_TYPE_TX_INV_SHIFT, XCVR_PN_TYPE_TX_INV_WIDTH))

/*! @brief Set the TX_INV field to a new value. */
#define XCVR_WR_PN_TYPE_TX_INV(base, value) (XCVR_RMW_PN_TYPE(base, XCVR_PN_TYPE_TX_INV_MASK, XCVR_PN_TYPE_TX_INV(value)))
#define XCVR_BWR_PN_TYPE_TX_INV(base, value) (BME_BFI32(&XCVR_PN_TYPE_REG(base), ((uint32_t)(value) << XCVR_PN_TYPE_TX_INV_SHIFT), XCVR_PN_TYPE_TX_INV_SHIFT, XCVR_PN_TYPE_TX_INV_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PN_CODE - PN_CODE
 ******************************************************************************/

/*!
 * @brief XCVR_PN_CODE - PN_CODE (RW)
 *
 * Reset value: 0x744AC39BU
 *
 * Pseudo Noise Chip Code Seed Value
 */
/*!
 * @name Constants and macros for entire XCVR_PN_CODE register
 */
/*@{*/
#define XCVR_RD_PN_CODE(base)    (XCVR_PN_CODE_REG(base))
#define XCVR_WR_PN_CODE(base, value) (XCVR_PN_CODE_REG(base) = (value))
#define XCVR_RMW_PN_CODE(base, mask, value) (XCVR_WR_PN_CODE(base, (XCVR_RD_PN_CODE(base) & ~(mask)) | (value)))
#define XCVR_SET_PN_CODE(base, value) (BME_OR32(&XCVR_PN_CODE_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PN_CODE(base, value) (BME_AND32(&XCVR_PN_CODE_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PN_CODE(base, value) (BME_XOR32(&XCVR_PN_CODE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PN_CODE bitfields
 */

/*!
 * @name Register XCVR_PN_CODE, field PN_LSB[15:0] (RW)
 *
 * PN_CODE LS half
 */
/*@{*/
/*! @brief Read current value of the XCVR_PN_CODE_PN_LSB field. */
#define XCVR_RD_PN_CODE_PN_LSB(base) ((XCVR_PN_CODE_REG(base) & XCVR_PN_CODE_PN_LSB_MASK) >> XCVR_PN_CODE_PN_LSB_SHIFT)
#define XCVR_BRD_PN_CODE_PN_LSB(base) (BME_UBFX32(&XCVR_PN_CODE_REG(base), XCVR_PN_CODE_PN_LSB_SHIFT, XCVR_PN_CODE_PN_LSB_WIDTH))

/*! @brief Set the PN_LSB field to a new value. */
#define XCVR_WR_PN_CODE_PN_LSB(base, value) (XCVR_RMW_PN_CODE(base, XCVR_PN_CODE_PN_LSB_MASK, XCVR_PN_CODE_PN_LSB(value)))
#define XCVR_BWR_PN_CODE_PN_LSB(base, value) (BME_BFI32(&XCVR_PN_CODE_REG(base), ((uint32_t)(value) << XCVR_PN_CODE_PN_LSB_SHIFT), XCVR_PN_CODE_PN_LSB_SHIFT, XCVR_PN_CODE_PN_LSB_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PN_CODE, field PN_MSB[31:16] (RW)
 *
 * PN_CODE MS half
 */
/*@{*/
/*! @brief Read current value of the XCVR_PN_CODE_PN_MSB field. */
#define XCVR_RD_PN_CODE_PN_MSB(base) ((XCVR_PN_CODE_REG(base) & XCVR_PN_CODE_PN_MSB_MASK) >> XCVR_PN_CODE_PN_MSB_SHIFT)
#define XCVR_BRD_PN_CODE_PN_MSB(base) (BME_UBFX32(&XCVR_PN_CODE_REG(base), XCVR_PN_CODE_PN_MSB_SHIFT, XCVR_PN_CODE_PN_MSB_WIDTH))

/*! @brief Set the PN_MSB field to a new value. */
#define XCVR_WR_PN_CODE_PN_MSB(base, value) (XCVR_RMW_PN_CODE(base, XCVR_PN_CODE_PN_MSB_MASK, XCVR_PN_CODE_PN_MSB(value)))
#define XCVR_BWR_PN_CODE_PN_MSB(base, value) (BME_BFI32(&XCVR_PN_CODE_REG(base), ((uint32_t)(value) << XCVR_PN_CODE_PN_MSB_SHIFT), XCVR_PN_CODE_PN_MSB_SHIFT, XCVR_PN_CODE_PN_MSB_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_SYNC_CTRL - Sync Control
 ******************************************************************************/

/*!
 * @brief XCVR_SYNC_CTRL - Sync Control (RW)
 *
 * Reset value: 0x00000008U
 */
/*!
 * @name Constants and macros for entire XCVR_SYNC_CTRL register
 */
/*@{*/
#define XCVR_RD_SYNC_CTRL(base)  (XCVR_SYNC_CTRL_REG(base))
#define XCVR_WR_SYNC_CTRL(base, value) (XCVR_SYNC_CTRL_REG(base) = (value))
#define XCVR_RMW_SYNC_CTRL(base, mask, value) (XCVR_WR_SYNC_CTRL(base, (XCVR_RD_SYNC_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_SYNC_CTRL(base, value) (BME_OR32(&XCVR_SYNC_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_SYNC_CTRL(base, value) (BME_AND32(&XCVR_SYNC_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_SYNC_CTRL(base, value) (BME_XOR32(&XCVR_SYNC_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_SYNC_CTRL bitfields
 */

/*!
 * @name Register XCVR_SYNC_CTRL, field SYNC_PER[2:0] (RW)
 *
 * determines update rate for symbol timing, per equation. An early/late
 * measurement is made every 2^SYNC_PER[2:0] symbols. Valid range of SYNC_PER[2:0] is 0
 * to 4.
 */
/*@{*/
/*! @brief Read current value of the XCVR_SYNC_CTRL_SYNC_PER field. */
#define XCVR_RD_SYNC_CTRL_SYNC_PER(base) ((XCVR_SYNC_CTRL_REG(base) & XCVR_SYNC_CTRL_SYNC_PER_MASK) >> XCVR_SYNC_CTRL_SYNC_PER_SHIFT)
#define XCVR_BRD_SYNC_CTRL_SYNC_PER(base) (BME_UBFX32(&XCVR_SYNC_CTRL_REG(base), XCVR_SYNC_CTRL_SYNC_PER_SHIFT, XCVR_SYNC_CTRL_SYNC_PER_WIDTH))

/*! @brief Set the SYNC_PER field to a new value. */
#define XCVR_WR_SYNC_CTRL_SYNC_PER(base, value) (XCVR_RMW_SYNC_CTRL(base, XCVR_SYNC_CTRL_SYNC_PER_MASK, XCVR_SYNC_CTRL_SYNC_PER(value)))
#define XCVR_BWR_SYNC_CTRL_SYNC_PER(base, value) (BME_BFI32(&XCVR_SYNC_CTRL_REG(base), ((uint32_t)(value) << XCVR_SYNC_CTRL_SYNC_PER_SHIFT), XCVR_SYNC_CTRL_SYNC_PER_SHIFT, XCVR_SYNC_CTRL_SYNC_PER_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_SYNC_CTRL, field TRACK_ENABLE[3] (RW)
 *
 * Values:
 * - 0b0 - symbol timing synchronization tracking disabled in Rx frontend
 * - 0b1 - symbol timing synchronization tracking enabled in Rx frontend
 *     (default)
 */
/*@{*/
/*! @brief Read current value of the XCVR_SYNC_CTRL_TRACK_ENABLE field. */
#define XCVR_RD_SYNC_CTRL_TRACK_ENABLE(base) ((XCVR_SYNC_CTRL_REG(base) & XCVR_SYNC_CTRL_TRACK_ENABLE_MASK) >> XCVR_SYNC_CTRL_TRACK_ENABLE_SHIFT)
#define XCVR_BRD_SYNC_CTRL_TRACK_ENABLE(base) (BME_UBFX32(&XCVR_SYNC_CTRL_REG(base), XCVR_SYNC_CTRL_TRACK_ENABLE_SHIFT, XCVR_SYNC_CTRL_TRACK_ENABLE_WIDTH))

/*! @brief Set the TRACK_ENABLE field to a new value. */
#define XCVR_WR_SYNC_CTRL_TRACK_ENABLE(base, value) (XCVR_RMW_SYNC_CTRL(base, XCVR_SYNC_CTRL_TRACK_ENABLE_MASK, XCVR_SYNC_CTRL_TRACK_ENABLE(value)))
#define XCVR_BWR_SYNC_CTRL_TRACK_ENABLE(base, value) (BME_BFI32(&XCVR_SYNC_CTRL_REG(base), ((uint32_t)(value) << XCVR_SYNC_CTRL_TRACK_ENABLE_SHIFT), XCVR_SYNC_CTRL_TRACK_ENABLE_SHIFT, XCVR_SYNC_CTRL_TRACK_ENABLE_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_SNF_THR - SNF_THR
 ******************************************************************************/

/*!
 * @brief XCVR_SNF_THR - SNF_THR (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_SNF_THR register
 */
/*@{*/
#define XCVR_RD_SNF_THR(base)    (XCVR_SNF_THR_REG(base))
#define XCVR_WR_SNF_THR(base, value) (XCVR_SNF_THR_REG(base) = (value))
#define XCVR_RMW_SNF_THR(base, mask, value) (XCVR_WR_SNF_THR(base, (XCVR_RD_SNF_THR(base) & ~(mask)) | (value)))
#define XCVR_SET_SNF_THR(base, value) (BME_OR32(&XCVR_SNF_THR_REG(base), (uint32_t)(value)))
#define XCVR_CLR_SNF_THR(base, value) (BME_AND32(&XCVR_SNF_THR_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_SNF_THR(base, value) (BME_XOR32(&XCVR_SNF_THR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_SNF_THR bitfields
 */

/*!
 * @name Register XCVR_SNF_THR, field SNF_THR[7:0] (RW)
 *
 * RSSI level at which the symbol demodulator will be started when
 * SNF_CTRL[SNF_EN]=1. The control bit SNF_CTRL[SNF_EN] is in Zigbee address space. Note:
 * SNIFF Mode not currently supported. SNF_THR has no effect
 */
/*@{*/
/*! @brief Read current value of the XCVR_SNF_THR_SNF_THR field. */
#define XCVR_RD_SNF_THR_SNF_THR(base) ((XCVR_SNF_THR_REG(base) & XCVR_SNF_THR_SNF_THR_MASK) >> XCVR_SNF_THR_SNF_THR_SHIFT)
#define XCVR_BRD_SNF_THR_SNF_THR(base) (BME_UBFX32(&XCVR_SNF_THR_REG(base), XCVR_SNF_THR_SNF_THR_SHIFT, XCVR_SNF_THR_SNF_THR_WIDTH))

/*! @brief Set the SNF_THR field to a new value. */
#define XCVR_WR_SNF_THR_SNF_THR(base, value) (XCVR_RMW_SNF_THR(base, XCVR_SNF_THR_SNF_THR_MASK, XCVR_SNF_THR_SNF_THR(value)))
#define XCVR_BWR_SNF_THR_SNF_THR(base, value) (BME_BFI32(&XCVR_SNF_THR_REG(base), ((uint32_t)(value) << XCVR_SNF_THR_SNF_THR_SHIFT), XCVR_SNF_THR_SNF_THR_SHIFT, XCVR_SNF_THR_SNF_THR_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_FAD_THR - FAD_THR
 ******************************************************************************/

/*!
 * @brief XCVR_FAD_THR - FAD_THR (RW)
 *
 * Reset value: 0x00000082U
 */
/*!
 * @name Constants and macros for entire XCVR_FAD_THR register
 */
/*@{*/
#define XCVR_RD_FAD_THR(base)    (XCVR_FAD_THR_REG(base))
#define XCVR_WR_FAD_THR(base, value) (XCVR_FAD_THR_REG(base) = (value))
#define XCVR_RMW_FAD_THR(base, mask, value) (XCVR_WR_FAD_THR(base, (XCVR_RD_FAD_THR(base) & ~(mask)) | (value)))
#define XCVR_SET_FAD_THR(base, value) (BME_OR32(&XCVR_FAD_THR_REG(base), (uint32_t)(value)))
#define XCVR_CLR_FAD_THR(base, value) (BME_AND32(&XCVR_FAD_THR_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_FAD_THR(base, value) (BME_XOR32(&XCVR_FAD_THR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_FAD_THR bitfields
 */

/*!
 * @name Register XCVR_FAD_THR, field FAD_THR[7:0] (RW)
 *
 * Correlator threshold at which the FAD will select the antenna.
 */
/*@{*/
/*! @brief Read current value of the XCVR_FAD_THR_FAD_THR field. */
#define XCVR_RD_FAD_THR_FAD_THR(base) ((XCVR_FAD_THR_REG(base) & XCVR_FAD_THR_FAD_THR_MASK) >> XCVR_FAD_THR_FAD_THR_SHIFT)
#define XCVR_BRD_FAD_THR_FAD_THR(base) (BME_UBFX32(&XCVR_FAD_THR_REG(base), XCVR_FAD_THR_FAD_THR_SHIFT, XCVR_FAD_THR_FAD_THR_WIDTH))

/*! @brief Set the FAD_THR field to a new value. */
#define XCVR_WR_FAD_THR_FAD_THR(base, value) (XCVR_RMW_FAD_THR(base, XCVR_FAD_THR_FAD_THR_MASK, XCVR_FAD_THR_FAD_THR(value)))
#define XCVR_BWR_FAD_THR_FAD_THR(base, value) (BME_BFI32(&XCVR_FAD_THR_REG(base), ((uint32_t)(value) << XCVR_FAD_THR_FAD_THR_SHIFT), XCVR_FAD_THR_FAD_THR_SHIFT, XCVR_FAD_THR_FAD_THR_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_ZBDEM_AFC - ZBDEM_AFC
 ******************************************************************************/

/*!
 * @brief XCVR_ZBDEM_AFC - ZBDEM_AFC (RW)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire XCVR_ZBDEM_AFC register
 */
/*@{*/
#define XCVR_RD_ZBDEM_AFC(base)  (XCVR_ZBDEM_AFC_REG(base))
#define XCVR_WR_ZBDEM_AFC(base, value) (XCVR_ZBDEM_AFC_REG(base) = (value))
#define XCVR_RMW_ZBDEM_AFC(base, mask, value) (XCVR_WR_ZBDEM_AFC(base, (XCVR_RD_ZBDEM_AFC(base) & ~(mask)) | (value)))
#define XCVR_SET_ZBDEM_AFC(base, value) (BME_OR32(&XCVR_ZBDEM_AFC_REG(base), (uint32_t)(value)))
#define XCVR_CLR_ZBDEM_AFC(base, value) (BME_AND32(&XCVR_ZBDEM_AFC_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_ZBDEM_AFC(base, value) (BME_XOR32(&XCVR_ZBDEM_AFC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_ZBDEM_AFC bitfields
 */

/*!
 * @name Register XCVR_ZBDEM_AFC, field AFC_EN[0] (RW)
 *
 * Enable the AFC Function
 */
/*@{*/
/*! @brief Read current value of the XCVR_ZBDEM_AFC_AFC_EN field. */
#define XCVR_RD_ZBDEM_AFC_AFC_EN(base) ((XCVR_ZBDEM_AFC_REG(base) & XCVR_ZBDEM_AFC_AFC_EN_MASK) >> XCVR_ZBDEM_AFC_AFC_EN_SHIFT)
#define XCVR_BRD_ZBDEM_AFC_AFC_EN(base) (BME_UBFX32(&XCVR_ZBDEM_AFC_REG(base), XCVR_ZBDEM_AFC_AFC_EN_SHIFT, XCVR_ZBDEM_AFC_AFC_EN_WIDTH))

/*! @brief Set the AFC_EN field to a new value. */
#define XCVR_WR_ZBDEM_AFC_AFC_EN(base, value) (XCVR_RMW_ZBDEM_AFC(base, XCVR_ZBDEM_AFC_AFC_EN_MASK, XCVR_ZBDEM_AFC_AFC_EN(value)))
#define XCVR_BWR_ZBDEM_AFC_AFC_EN(base, value) (BME_BFI32(&XCVR_ZBDEM_AFC_REG(base), ((uint32_t)(value) << XCVR_ZBDEM_AFC_AFC_EN_SHIFT), XCVR_ZBDEM_AFC_AFC_EN_SHIFT, XCVR_ZBDEM_AFC_AFC_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ZBDEM_AFC, field DCD_EN[1] (RW)
 *
 * Values:
 * - 0b0 - NCD Mode (default)
 * - 0b1 - DCD Mode
 */
/*@{*/
/*! @brief Read current value of the XCVR_ZBDEM_AFC_DCD_EN field. */
#define XCVR_RD_ZBDEM_AFC_DCD_EN(base) ((XCVR_ZBDEM_AFC_REG(base) & XCVR_ZBDEM_AFC_DCD_EN_MASK) >> XCVR_ZBDEM_AFC_DCD_EN_SHIFT)
#define XCVR_BRD_ZBDEM_AFC_DCD_EN(base) (BME_UBFX32(&XCVR_ZBDEM_AFC_REG(base), XCVR_ZBDEM_AFC_DCD_EN_SHIFT, XCVR_ZBDEM_AFC_DCD_EN_WIDTH))

/*! @brief Set the DCD_EN field to a new value. */
#define XCVR_WR_ZBDEM_AFC_DCD_EN(base, value) (XCVR_RMW_ZBDEM_AFC(base, XCVR_ZBDEM_AFC_DCD_EN_MASK, XCVR_ZBDEM_AFC_DCD_EN(value)))
#define XCVR_BWR_ZBDEM_AFC_DCD_EN(base, value) (BME_BFI32(&XCVR_ZBDEM_AFC_REG(base), ((uint32_t)(value) << XCVR_ZBDEM_AFC_DCD_EN_SHIFT), XCVR_ZBDEM_AFC_DCD_EN_SHIFT, XCVR_ZBDEM_AFC_DCD_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ZBDEM_AFC, field AFC_OUT[12:8] (RO)
 *
 * AFC Result, Signed Two's Complement
 */
/*@{*/
/*! @brief Read current value of the XCVR_ZBDEM_AFC_AFC_OUT field. */
#define XCVR_RD_ZBDEM_AFC_AFC_OUT(base) ((XCVR_ZBDEM_AFC_REG(base) & XCVR_ZBDEM_AFC_AFC_OUT_MASK) >> XCVR_ZBDEM_AFC_AFC_OUT_SHIFT)
#define XCVR_BRD_ZBDEM_AFC_AFC_OUT(base) (BME_UBFX32(&XCVR_ZBDEM_AFC_REG(base), XCVR_ZBDEM_AFC_AFC_OUT_SHIFT, XCVR_ZBDEM_AFC_AFC_OUT_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_LPPS_CTRL - LPPS Control Register
 ******************************************************************************/

/*!
 * @brief XCVR_LPPS_CTRL - LPPS Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_LPPS_CTRL register
 */
/*@{*/
#define XCVR_RD_LPPS_CTRL(base)  (XCVR_LPPS_CTRL_REG(base))
#define XCVR_WR_LPPS_CTRL(base, value) (XCVR_LPPS_CTRL_REG(base) = (value))
#define XCVR_RMW_LPPS_CTRL(base, mask, value) (XCVR_WR_LPPS_CTRL(base, (XCVR_RD_LPPS_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_LPPS_CTRL(base, value) (BME_OR32(&XCVR_LPPS_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_LPPS_CTRL(base, value) (BME_AND32(&XCVR_LPPS_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_LPPS_CTRL(base, value) (BME_XOR32(&XCVR_LPPS_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_LPPS_CTRL bitfields
 */

/*!
 * @name Register XCVR_LPPS_CTRL, field LPPS_ENABLE[0] (RW)
 *
 * Master enable for LPPS mode. Allows Zigbee correlators to be duty-cycled
 * during Preamble Search, and selected RF/Analog blocks to be duty-cycled
 * simultaneously.
 *
 * Values:
 * - 0b0 - LPPS mode disabled
 * - 0b1 - LPPS mode enabled
 */
/*@{*/
/*! @brief Read current value of the XCVR_LPPS_CTRL_LPPS_ENABLE field. */
#define XCVR_RD_LPPS_CTRL_LPPS_ENABLE(base) ((XCVR_LPPS_CTRL_REG(base) & XCVR_LPPS_CTRL_LPPS_ENABLE_MASK) >> XCVR_LPPS_CTRL_LPPS_ENABLE_SHIFT)
#define XCVR_BRD_LPPS_CTRL_LPPS_ENABLE(base) (BME_UBFX32(&XCVR_LPPS_CTRL_REG(base), XCVR_LPPS_CTRL_LPPS_ENABLE_SHIFT, XCVR_LPPS_CTRL_LPPS_ENABLE_WIDTH))

/*! @brief Set the LPPS_ENABLE field to a new value. */
#define XCVR_WR_LPPS_CTRL_LPPS_ENABLE(base, value) (XCVR_RMW_LPPS_CTRL(base, XCVR_LPPS_CTRL_LPPS_ENABLE_MASK, XCVR_LPPS_CTRL_LPPS_ENABLE(value)))
#define XCVR_BWR_LPPS_CTRL_LPPS_ENABLE(base, value) (BME_BFI32(&XCVR_LPPS_CTRL_REG(base), ((uint32_t)(value) << XCVR_LPPS_CTRL_LPPS_ENABLE_SHIFT), XCVR_LPPS_CTRL_LPPS_ENABLE_SHIFT, XCVR_LPPS_CTRL_LPPS_ENABLE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_LPPS_CTRL, field LPPS_QGEN25_ALLOW[1] (RW)
 *
 * Values:
 * - 0b0 - Disallow TSM output qgen25_en to be duty-cycled during LPPS
 * - 0b1 - Allow TSM output qgen25_en to be duty-cycled during LPPS
 */
/*@{*/
/*! @brief Read current value of the XCVR_LPPS_CTRL_LPPS_QGEN25_ALLOW field. */
#define XCVR_RD_LPPS_CTRL_LPPS_QGEN25_ALLOW(base) ((XCVR_LPPS_CTRL_REG(base) & XCVR_LPPS_CTRL_LPPS_QGEN25_ALLOW_MASK) >> XCVR_LPPS_CTRL_LPPS_QGEN25_ALLOW_SHIFT)
#define XCVR_BRD_LPPS_CTRL_LPPS_QGEN25_ALLOW(base) (BME_UBFX32(&XCVR_LPPS_CTRL_REG(base), XCVR_LPPS_CTRL_LPPS_QGEN25_ALLOW_SHIFT, XCVR_LPPS_CTRL_LPPS_QGEN25_ALLOW_WIDTH))

/*! @brief Set the LPPS_QGEN25_ALLOW field to a new value. */
#define XCVR_WR_LPPS_CTRL_LPPS_QGEN25_ALLOW(base, value) (XCVR_RMW_LPPS_CTRL(base, XCVR_LPPS_CTRL_LPPS_QGEN25_ALLOW_MASK, XCVR_LPPS_CTRL_LPPS_QGEN25_ALLOW(value)))
#define XCVR_BWR_LPPS_CTRL_LPPS_QGEN25_ALLOW(base, value) (BME_BFI32(&XCVR_LPPS_CTRL_REG(base), ((uint32_t)(value) << XCVR_LPPS_CTRL_LPPS_QGEN25_ALLOW_SHIFT), XCVR_LPPS_CTRL_LPPS_QGEN25_ALLOW_SHIFT, XCVR_LPPS_CTRL_LPPS_QGEN25_ALLOW_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_LPPS_CTRL, field LPPS_ADC_ALLOW[2] (RW)
 *
 * Values:
 * - 0b0 - Disallow ADC-related TSM outputs {adc_en, adc_bias_en} to be
 *     duty-cycled during LPPS.
 * - 0b1 - Allow ADC-related TSM outputs {adc_en, adc_bias_en} to be duty-cycled
 *     during LPPS.
 */
/*@{*/
/*! @brief Read current value of the XCVR_LPPS_CTRL_LPPS_ADC_ALLOW field. */
#define XCVR_RD_LPPS_CTRL_LPPS_ADC_ALLOW(base) ((XCVR_LPPS_CTRL_REG(base) & XCVR_LPPS_CTRL_LPPS_ADC_ALLOW_MASK) >> XCVR_LPPS_CTRL_LPPS_ADC_ALLOW_SHIFT)
#define XCVR_BRD_LPPS_CTRL_LPPS_ADC_ALLOW(base) (BME_UBFX32(&XCVR_LPPS_CTRL_REG(base), XCVR_LPPS_CTRL_LPPS_ADC_ALLOW_SHIFT, XCVR_LPPS_CTRL_LPPS_ADC_ALLOW_WIDTH))

/*! @brief Set the LPPS_ADC_ALLOW field to a new value. */
#define XCVR_WR_LPPS_CTRL_LPPS_ADC_ALLOW(base, value) (XCVR_RMW_LPPS_CTRL(base, XCVR_LPPS_CTRL_LPPS_ADC_ALLOW_MASK, XCVR_LPPS_CTRL_LPPS_ADC_ALLOW(value)))
#define XCVR_BWR_LPPS_CTRL_LPPS_ADC_ALLOW(base, value) (BME_BFI32(&XCVR_LPPS_CTRL_REG(base), ((uint32_t)(value) << XCVR_LPPS_CTRL_LPPS_ADC_ALLOW_SHIFT), XCVR_LPPS_CTRL_LPPS_ADC_ALLOW_SHIFT, XCVR_LPPS_CTRL_LPPS_ADC_ALLOW_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_LPPS_CTRL, field LPPS_ADC_CLK_ALLOW[3] (RW)
 *
 * Values:
 * - 0b0 - Disallow ADC-related TSM outputs {xtal_adc_ref_clk_en, adc_clk_en} to
 *     be duty-cycled during LPPS.
 * - 0b1 - Allow ADC_CLK-related TSM outputs {xtal_adc_ref_clk_en, adc_clk_en}
 *     to be duty-cycled during LPPS.
 */
/*@{*/
/*! @brief Read current value of the XCVR_LPPS_CTRL_LPPS_ADC_CLK_ALLOW field. */
#define XCVR_RD_LPPS_CTRL_LPPS_ADC_CLK_ALLOW(base) ((XCVR_LPPS_CTRL_REG(base) & XCVR_LPPS_CTRL_LPPS_ADC_CLK_ALLOW_MASK) >> XCVR_LPPS_CTRL_LPPS_ADC_CLK_ALLOW_SHIFT)
#define XCVR_BRD_LPPS_CTRL_LPPS_ADC_CLK_ALLOW(base) (BME_UBFX32(&XCVR_LPPS_CTRL_REG(base), XCVR_LPPS_CTRL_LPPS_ADC_CLK_ALLOW_SHIFT, XCVR_LPPS_CTRL_LPPS_ADC_CLK_ALLOW_WIDTH))

/*! @brief Set the LPPS_ADC_CLK_ALLOW field to a new value. */
#define XCVR_WR_LPPS_CTRL_LPPS_ADC_CLK_ALLOW(base, value) (XCVR_RMW_LPPS_CTRL(base, XCVR_LPPS_CTRL_LPPS_ADC_CLK_ALLOW_MASK, XCVR_LPPS_CTRL_LPPS_ADC_CLK_ALLOW(value)))
#define XCVR_BWR_LPPS_CTRL_LPPS_ADC_CLK_ALLOW(base, value) (BME_BFI32(&XCVR_LPPS_CTRL_REG(base), ((uint32_t)(value) << XCVR_LPPS_CTRL_LPPS_ADC_CLK_ALLOW_SHIFT), XCVR_LPPS_CTRL_LPPS_ADC_CLK_ALLOW_SHIFT, XCVR_LPPS_CTRL_LPPS_ADC_CLK_ALLOW_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_LPPS_CTRL, field LPPS_ADC_I_Q_ALLOW[4] (RW)
 *
 * Values:
 * - 0b0 - Disallow ADC_I/Q-related TSM outputs {adc_I_adc_en, adc_Q_adc_en} to
 *     be duty-cycled during LPPS.
 * - 0b1 - Allow ADC_I/Q-related TSM outputs {adc_I_adc_en, adc_Q_adc_en} to be
 *     duty-cycled during LPPS.
 */
/*@{*/
/*! @brief Read current value of the XCVR_LPPS_CTRL_LPPS_ADC_I_Q_ALLOW field. */
#define XCVR_RD_LPPS_CTRL_LPPS_ADC_I_Q_ALLOW(base) ((XCVR_LPPS_CTRL_REG(base) & XCVR_LPPS_CTRL_LPPS_ADC_I_Q_ALLOW_MASK) >> XCVR_LPPS_CTRL_LPPS_ADC_I_Q_ALLOW_SHIFT)
#define XCVR_BRD_LPPS_CTRL_LPPS_ADC_I_Q_ALLOW(base) (BME_UBFX32(&XCVR_LPPS_CTRL_REG(base), XCVR_LPPS_CTRL_LPPS_ADC_I_Q_ALLOW_SHIFT, XCVR_LPPS_CTRL_LPPS_ADC_I_Q_ALLOW_WIDTH))

/*! @brief Set the LPPS_ADC_I_Q_ALLOW field to a new value. */
#define XCVR_WR_LPPS_CTRL_LPPS_ADC_I_Q_ALLOW(base, value) (XCVR_RMW_LPPS_CTRL(base, XCVR_LPPS_CTRL_LPPS_ADC_I_Q_ALLOW_MASK, XCVR_LPPS_CTRL_LPPS_ADC_I_Q_ALLOW(value)))
#define XCVR_BWR_LPPS_CTRL_LPPS_ADC_I_Q_ALLOW(base, value) (BME_BFI32(&XCVR_LPPS_CTRL_REG(base), ((uint32_t)(value) << XCVR_LPPS_CTRL_LPPS_ADC_I_Q_ALLOW_SHIFT), XCVR_LPPS_CTRL_LPPS_ADC_I_Q_ALLOW_SHIFT, XCVR_LPPS_CTRL_LPPS_ADC_I_Q_ALLOW_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_LPPS_CTRL, field LPPS_ADC_DAC_ALLOW[5] (RW)
 *
 * Values:
 * - 0b0 - Disallow ADC_DAC-related TSM outputs {adc_dac1_en, adc_dac2_en} to be
 *     duty-cycled during LPPS.
 * - 0b1 - Allow ADC_DAC-related TSM outputs {adc_dac1_en, adc_dac2_en} to be
 *     duty-cycled during LPPS.
 */
/*@{*/
/*! @brief Read current value of the XCVR_LPPS_CTRL_LPPS_ADC_DAC_ALLOW field. */
#define XCVR_RD_LPPS_CTRL_LPPS_ADC_DAC_ALLOW(base) ((XCVR_LPPS_CTRL_REG(base) & XCVR_LPPS_CTRL_LPPS_ADC_DAC_ALLOW_MASK) >> XCVR_LPPS_CTRL_LPPS_ADC_DAC_ALLOW_SHIFT)
#define XCVR_BRD_LPPS_CTRL_LPPS_ADC_DAC_ALLOW(base) (BME_UBFX32(&XCVR_LPPS_CTRL_REG(base), XCVR_LPPS_CTRL_LPPS_ADC_DAC_ALLOW_SHIFT, XCVR_LPPS_CTRL_LPPS_ADC_DAC_ALLOW_WIDTH))

/*! @brief Set the LPPS_ADC_DAC_ALLOW field to a new value. */
#define XCVR_WR_LPPS_CTRL_LPPS_ADC_DAC_ALLOW(base, value) (XCVR_RMW_LPPS_CTRL(base, XCVR_LPPS_CTRL_LPPS_ADC_DAC_ALLOW_MASK, XCVR_LPPS_CTRL_LPPS_ADC_DAC_ALLOW(value)))
#define XCVR_BWR_LPPS_CTRL_LPPS_ADC_DAC_ALLOW(base, value) (BME_BFI32(&XCVR_LPPS_CTRL_REG(base), ((uint32_t)(value) << XCVR_LPPS_CTRL_LPPS_ADC_DAC_ALLOW_SHIFT), XCVR_LPPS_CTRL_LPPS_ADC_DAC_ALLOW_SHIFT, XCVR_LPPS_CTRL_LPPS_ADC_DAC_ALLOW_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_LPPS_CTRL, field LPPS_BBF_ALLOW[6] (RW)
 *
 * Values:
 * - 0b0 - Disallow BBF-related TSM outputs {bbf_i_en, bbf_q_en, bbf_pdet_en,
 *     bbf_dcoc_en} to be duty-cycled during LPPS.
 * - 0b1 - Allow BBF-related TSM outputs {bbf_i_en, bbf_q_en, bbf_pdet_en,
 *     bbf_dcoc_en} to be duty-cycled during LPPS.
 */
/*@{*/
/*! @brief Read current value of the XCVR_LPPS_CTRL_LPPS_BBF_ALLOW field. */
#define XCVR_RD_LPPS_CTRL_LPPS_BBF_ALLOW(base) ((XCVR_LPPS_CTRL_REG(base) & XCVR_LPPS_CTRL_LPPS_BBF_ALLOW_MASK) >> XCVR_LPPS_CTRL_LPPS_BBF_ALLOW_SHIFT)
#define XCVR_BRD_LPPS_CTRL_LPPS_BBF_ALLOW(base) (BME_UBFX32(&XCVR_LPPS_CTRL_REG(base), XCVR_LPPS_CTRL_LPPS_BBF_ALLOW_SHIFT, XCVR_LPPS_CTRL_LPPS_BBF_ALLOW_WIDTH))

/*! @brief Set the LPPS_BBF_ALLOW field to a new value. */
#define XCVR_WR_LPPS_CTRL_LPPS_BBF_ALLOW(base, value) (XCVR_RMW_LPPS_CTRL(base, XCVR_LPPS_CTRL_LPPS_BBF_ALLOW_MASK, XCVR_LPPS_CTRL_LPPS_BBF_ALLOW(value)))
#define XCVR_BWR_LPPS_CTRL_LPPS_BBF_ALLOW(base, value) (BME_BFI32(&XCVR_LPPS_CTRL_REG(base), ((uint32_t)(value) << XCVR_LPPS_CTRL_LPPS_BBF_ALLOW_SHIFT), XCVR_LPPS_CTRL_LPPS_BBF_ALLOW_SHIFT, XCVR_LPPS_CTRL_LPPS_BBF_ALLOW_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_LPPS_CTRL, field LPPS_TCA_ALLOW[7] (RW)
 *
 * Values:
 * - 0b0 - Disallow TCA-related TSM outputs {tca_en, tza_i_en, tza_q_en,
 *     tza_pdet_en, tza_dcoc_en} to be duty-cycled during LPPS.
 * - 0b1 - Allow TCA-related TSM outputs {tca_en, tza_i_en, tza_q_en,
 *     tza_pdet_en, tza_dcoc_en} to be duty-cycled during LPPS.
 */
/*@{*/
/*! @brief Read current value of the XCVR_LPPS_CTRL_LPPS_TCA_ALLOW field. */
#define XCVR_RD_LPPS_CTRL_LPPS_TCA_ALLOW(base) ((XCVR_LPPS_CTRL_REG(base) & XCVR_LPPS_CTRL_LPPS_TCA_ALLOW_MASK) >> XCVR_LPPS_CTRL_LPPS_TCA_ALLOW_SHIFT)
#define XCVR_BRD_LPPS_CTRL_LPPS_TCA_ALLOW(base) (BME_UBFX32(&XCVR_LPPS_CTRL_REG(base), XCVR_LPPS_CTRL_LPPS_TCA_ALLOW_SHIFT, XCVR_LPPS_CTRL_LPPS_TCA_ALLOW_WIDTH))

/*! @brief Set the LPPS_TCA_ALLOW field to a new value. */
#define XCVR_WR_LPPS_CTRL_LPPS_TCA_ALLOW(base, value) (XCVR_RMW_LPPS_CTRL(base, XCVR_LPPS_CTRL_LPPS_TCA_ALLOW_MASK, XCVR_LPPS_CTRL_LPPS_TCA_ALLOW(value)))
#define XCVR_BWR_LPPS_CTRL_LPPS_TCA_ALLOW(base, value) (BME_BFI32(&XCVR_LPPS_CTRL_REG(base), ((uint32_t)(value) << XCVR_LPPS_CTRL_LPPS_TCA_ALLOW_SHIFT), XCVR_LPPS_CTRL_LPPS_TCA_ALLOW_SHIFT, XCVR_LPPS_CTRL_LPPS_TCA_ALLOW_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_ADC_CTRL - ADC Control
 ******************************************************************************/

/*!
 * @brief XCVR_ADC_CTRL - ADC Control (RW)
 *
 * Reset value: 0xFFFF0001U
 */
/*!
 * @name Constants and macros for entire XCVR_ADC_CTRL register
 */
/*@{*/
#define XCVR_RD_ADC_CTRL(base)   (XCVR_ADC_CTRL_REG(base))
#define XCVR_WR_ADC_CTRL(base, value) (XCVR_ADC_CTRL_REG(base) = (value))
#define XCVR_RMW_ADC_CTRL(base, mask, value) (XCVR_WR_ADC_CTRL(base, (XCVR_RD_ADC_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_ADC_CTRL(base, value) (BME_OR32(&XCVR_ADC_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_ADC_CTRL(base, value) (BME_AND32(&XCVR_ADC_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_ADC_CTRL(base, value) (BME_XOR32(&XCVR_ADC_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_ADC_CTRL bitfields
 */

/*!
 * @name Register XCVR_ADC_CTRL, field ADC_32MHZ_SEL[0] (RW)
 *
 * Select settings for a 32MHz reference clock. If this bit is not set then
 * settings for a 36MHz clock is chosen. Only the 32Mhz option is enabled in this
 * version.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_CTRL_ADC_32MHZ_SEL field. */
#define XCVR_RD_ADC_CTRL_ADC_32MHZ_SEL(base) ((XCVR_ADC_CTRL_REG(base) & XCVR_ADC_CTRL_ADC_32MHZ_SEL_MASK) >> XCVR_ADC_CTRL_ADC_32MHZ_SEL_SHIFT)
#define XCVR_BRD_ADC_CTRL_ADC_32MHZ_SEL(base) (BME_UBFX32(&XCVR_ADC_CTRL_REG(base), XCVR_ADC_CTRL_ADC_32MHZ_SEL_SHIFT, XCVR_ADC_CTRL_ADC_32MHZ_SEL_WIDTH))

/*! @brief Set the ADC_32MHZ_SEL field to a new value. */
#define XCVR_WR_ADC_CTRL_ADC_32MHZ_SEL(base, value) (XCVR_RMW_ADC_CTRL(base, XCVR_ADC_CTRL_ADC_32MHZ_SEL_MASK, XCVR_ADC_CTRL_ADC_32MHZ_SEL(value)))
#define XCVR_BWR_ADC_CTRL_ADC_32MHZ_SEL(base, value) (BME_BFI32(&XCVR_ADC_CTRL_REG(base), ((uint32_t)(value) << XCVR_ADC_CTRL_ADC_32MHZ_SEL_SHIFT), XCVR_ADC_CTRL_ADC_32MHZ_SEL_SHIFT, XCVR_ADC_CTRL_ADC_32MHZ_SEL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_CTRL, field ADC_2X_CLK_SEL[2] (RW)
 *
 * Select 2x Clock option in the ADC. When this bit is enabled a clock of 64Mhz
 * is assumed. This option is not used in this version and reserved for future
 * use.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_CTRL_ADC_2X_CLK_SEL field. */
#define XCVR_RD_ADC_CTRL_ADC_2X_CLK_SEL(base) ((XCVR_ADC_CTRL_REG(base) & XCVR_ADC_CTRL_ADC_2X_CLK_SEL_MASK) >> XCVR_ADC_CTRL_ADC_2X_CLK_SEL_SHIFT)
#define XCVR_BRD_ADC_CTRL_ADC_2X_CLK_SEL(base) (BME_UBFX32(&XCVR_ADC_CTRL_REG(base), XCVR_ADC_CTRL_ADC_2X_CLK_SEL_SHIFT, XCVR_ADC_CTRL_ADC_2X_CLK_SEL_WIDTH))

/*! @brief Set the ADC_2X_CLK_SEL field to a new value. */
#define XCVR_WR_ADC_CTRL_ADC_2X_CLK_SEL(base, value) (XCVR_RMW_ADC_CTRL(base, XCVR_ADC_CTRL_ADC_2X_CLK_SEL_MASK, XCVR_ADC_CTRL_ADC_2X_CLK_SEL(value)))
#define XCVR_BWR_ADC_CTRL_ADC_2X_CLK_SEL(base, value) (BME_BFI32(&XCVR_ADC_CTRL_REG(base), ((uint32_t)(value) << XCVR_ADC_CTRL_ADC_2X_CLK_SEL_SHIFT), XCVR_ADC_CTRL_ADC_2X_CLK_SEL_SHIFT, XCVR_ADC_CTRL_ADC_2X_CLK_SEL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_CTRL, field ADC_DITHER_ON[9] (RW)
 *
 * Enables the dither circuit inside the ADC block. By enabling this bit
 * dithering of tones can be achieved.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_CTRL_ADC_DITHER_ON field. */
#define XCVR_RD_ADC_CTRL_ADC_DITHER_ON(base) ((XCVR_ADC_CTRL_REG(base) & XCVR_ADC_CTRL_ADC_DITHER_ON_MASK) >> XCVR_ADC_CTRL_ADC_DITHER_ON_SHIFT)
#define XCVR_BRD_ADC_CTRL_ADC_DITHER_ON(base) (BME_UBFX32(&XCVR_ADC_CTRL_REG(base), XCVR_ADC_CTRL_ADC_DITHER_ON_SHIFT, XCVR_ADC_CTRL_ADC_DITHER_ON_WIDTH))

/*! @brief Set the ADC_DITHER_ON field to a new value. */
#define XCVR_WR_ADC_CTRL_ADC_DITHER_ON(base, value) (XCVR_RMW_ADC_CTRL(base, XCVR_ADC_CTRL_ADC_DITHER_ON_MASK, XCVR_ADC_CTRL_ADC_DITHER_ON(value)))
#define XCVR_BWR_ADC_CTRL_ADC_DITHER_ON(base, value) (BME_BFI32(&XCVR_ADC_CTRL_REG(base), ((uint32_t)(value) << XCVR_ADC_CTRL_ADC_DITHER_ON_SHIFT), XCVR_ADC_CTRL_ADC_DITHER_ON_SHIFT, XCVR_ADC_CTRL_ADC_DITHER_ON_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_CTRL, field ADC_TEST_ON[10] (RW)
 *
 * When enabled (1) this bit puts the adc in test mode where different test
 * signals can be injected or measured. In normal mode this bit is diabled(0).
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_CTRL_ADC_TEST_ON field. */
#define XCVR_RD_ADC_CTRL_ADC_TEST_ON(base) ((XCVR_ADC_CTRL_REG(base) & XCVR_ADC_CTRL_ADC_TEST_ON_MASK) >> XCVR_ADC_CTRL_ADC_TEST_ON_SHIFT)
#define XCVR_BRD_ADC_CTRL_ADC_TEST_ON(base) (BME_UBFX32(&XCVR_ADC_CTRL_REG(base), XCVR_ADC_CTRL_ADC_TEST_ON_SHIFT, XCVR_ADC_CTRL_ADC_TEST_ON_WIDTH))

/*! @brief Set the ADC_TEST_ON field to a new value. */
#define XCVR_WR_ADC_CTRL_ADC_TEST_ON(base, value) (XCVR_RMW_ADC_CTRL(base, XCVR_ADC_CTRL_ADC_TEST_ON_MASK, XCVR_ADC_CTRL_ADC_TEST_ON(value)))
#define XCVR_BWR_ADC_CTRL_ADC_TEST_ON(base, value) (BME_BFI32(&XCVR_ADC_CTRL_REG(base), ((uint32_t)(value) << XCVR_ADC_CTRL_ADC_TEST_ON_SHIFT), XCVR_ADC_CTRL_ADC_TEST_ON_SHIFT, XCVR_ADC_CTRL_ADC_TEST_ON_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_CTRL, field ADC_COMP_ON[31:16] (RW)
 *
 * These bits enable or disable the individual comparators in the quantizer. In
 * the normal mode all these bits should be enabled. The disables are used for
 * testing purposes only
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_CTRL_ADC_COMP_ON field. */
#define XCVR_RD_ADC_CTRL_ADC_COMP_ON(base) ((XCVR_ADC_CTRL_REG(base) & XCVR_ADC_CTRL_ADC_COMP_ON_MASK) >> XCVR_ADC_CTRL_ADC_COMP_ON_SHIFT)
#define XCVR_BRD_ADC_CTRL_ADC_COMP_ON(base) (BME_UBFX32(&XCVR_ADC_CTRL_REG(base), XCVR_ADC_CTRL_ADC_COMP_ON_SHIFT, XCVR_ADC_CTRL_ADC_COMP_ON_WIDTH))

/*! @brief Set the ADC_COMP_ON field to a new value. */
#define XCVR_WR_ADC_CTRL_ADC_COMP_ON(base, value) (XCVR_RMW_ADC_CTRL(base, XCVR_ADC_CTRL_ADC_COMP_ON_MASK, XCVR_ADC_CTRL_ADC_COMP_ON(value)))
#define XCVR_BWR_ADC_CTRL_ADC_COMP_ON(base, value) (BME_BFI32(&XCVR_ADC_CTRL_REG(base), ((uint32_t)(value) << XCVR_ADC_CTRL_ADC_COMP_ON_SHIFT), XCVR_ADC_CTRL_ADC_COMP_ON_SHIFT, XCVR_ADC_CTRL_ADC_COMP_ON_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_ADC_TUNE - ADC Tuning
 ******************************************************************************/

/*!
 * @brief XCVR_ADC_TUNE - ADC Tuning (RW)
 *
 * Reset value: 0x00880033U
 */
/*!
 * @name Constants and macros for entire XCVR_ADC_TUNE register
 */
/*@{*/
#define XCVR_RD_ADC_TUNE(base)   (XCVR_ADC_TUNE_REG(base))
#define XCVR_WR_ADC_TUNE(base, value) (XCVR_ADC_TUNE_REG(base) = (value))
#define XCVR_RMW_ADC_TUNE(base, mask, value) (XCVR_WR_ADC_TUNE(base, (XCVR_RD_ADC_TUNE(base) & ~(mask)) | (value)))
#define XCVR_SET_ADC_TUNE(base, value) (BME_OR32(&XCVR_ADC_TUNE_REG(base), (uint32_t)(value)))
#define XCVR_CLR_ADC_TUNE(base, value) (BME_AND32(&XCVR_ADC_TUNE_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_ADC_TUNE(base, value) (BME_XOR32(&XCVR_ADC_TUNE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_ADC_TUNE bitfields
 */

/*!
 * @name Register XCVR_ADC_TUNE, field ADC_R1_TUNE[2:0] (RW)
 *
 * Allows to tune the resistor values of the first integrator +/- 15%. Default
 * setting is 0b011.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_TUNE_ADC_R1_TUNE field. */
#define XCVR_RD_ADC_TUNE_ADC_R1_TUNE(base) ((XCVR_ADC_TUNE_REG(base) & XCVR_ADC_TUNE_ADC_R1_TUNE_MASK) >> XCVR_ADC_TUNE_ADC_R1_TUNE_SHIFT)
#define XCVR_BRD_ADC_TUNE_ADC_R1_TUNE(base) (BME_UBFX32(&XCVR_ADC_TUNE_REG(base), XCVR_ADC_TUNE_ADC_R1_TUNE_SHIFT, XCVR_ADC_TUNE_ADC_R1_TUNE_WIDTH))

/*! @brief Set the ADC_R1_TUNE field to a new value. */
#define XCVR_WR_ADC_TUNE_ADC_R1_TUNE(base, value) (XCVR_RMW_ADC_TUNE(base, XCVR_ADC_TUNE_ADC_R1_TUNE_MASK, XCVR_ADC_TUNE_ADC_R1_TUNE(value)))
#define XCVR_BWR_ADC_TUNE_ADC_R1_TUNE(base, value) (BME_BFI32(&XCVR_ADC_TUNE_REG(base), ((uint32_t)(value) << XCVR_ADC_TUNE_ADC_R1_TUNE_SHIFT), XCVR_ADC_TUNE_ADC_R1_TUNE_SHIFT, XCVR_ADC_TUNE_ADC_R1_TUNE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_TUNE, field ADC_R2_TUNE[6:4] (RW)
 *
 * Allows to tune the resistor values of the second integrator +/- 15%. Default
 * setting is 0b011.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_TUNE_ADC_R2_TUNE field. */
#define XCVR_RD_ADC_TUNE_ADC_R2_TUNE(base) ((XCVR_ADC_TUNE_REG(base) & XCVR_ADC_TUNE_ADC_R2_TUNE_MASK) >> XCVR_ADC_TUNE_ADC_R2_TUNE_SHIFT)
#define XCVR_BRD_ADC_TUNE_ADC_R2_TUNE(base) (BME_UBFX32(&XCVR_ADC_TUNE_REG(base), XCVR_ADC_TUNE_ADC_R2_TUNE_SHIFT, XCVR_ADC_TUNE_ADC_R2_TUNE_WIDTH))

/*! @brief Set the ADC_R2_TUNE field to a new value. */
#define XCVR_WR_ADC_TUNE_ADC_R2_TUNE(base, value) (XCVR_RMW_ADC_TUNE(base, XCVR_ADC_TUNE_ADC_R2_TUNE_MASK, XCVR_ADC_TUNE_ADC_R2_TUNE(value)))
#define XCVR_BWR_ADC_TUNE_ADC_R2_TUNE(base, value) (BME_BFI32(&XCVR_ADC_TUNE_REG(base), ((uint32_t)(value) << XCVR_ADC_TUNE_ADC_R2_TUNE_SHIFT), XCVR_ADC_TUNE_ADC_R2_TUNE_SHIFT, XCVR_ADC_TUNE_ADC_R2_TUNE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_TUNE, field ADC_C1_TUNE[19:16] (RW)
 *
 * Allows to tune the capacitor values of the first integrator +/- 15%. Default
 * setting is 0b1000.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_TUNE_ADC_C1_TUNE field. */
#define XCVR_RD_ADC_TUNE_ADC_C1_TUNE(base) ((XCVR_ADC_TUNE_REG(base) & XCVR_ADC_TUNE_ADC_C1_TUNE_MASK) >> XCVR_ADC_TUNE_ADC_C1_TUNE_SHIFT)
#define XCVR_BRD_ADC_TUNE_ADC_C1_TUNE(base) (BME_UBFX32(&XCVR_ADC_TUNE_REG(base), XCVR_ADC_TUNE_ADC_C1_TUNE_SHIFT, XCVR_ADC_TUNE_ADC_C1_TUNE_WIDTH))

/*! @brief Set the ADC_C1_TUNE field to a new value. */
#define XCVR_WR_ADC_TUNE_ADC_C1_TUNE(base, value) (XCVR_RMW_ADC_TUNE(base, XCVR_ADC_TUNE_ADC_C1_TUNE_MASK, XCVR_ADC_TUNE_ADC_C1_TUNE(value)))
#define XCVR_BWR_ADC_TUNE_ADC_C1_TUNE(base, value) (BME_BFI32(&XCVR_ADC_TUNE_REG(base), ((uint32_t)(value) << XCVR_ADC_TUNE_ADC_C1_TUNE_SHIFT), XCVR_ADC_TUNE_ADC_C1_TUNE_SHIFT, XCVR_ADC_TUNE_ADC_C1_TUNE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_TUNE, field ADC_C2_TUNE[23:20] (RW)
 *
 * Allows to tune the capacitor values of the second integrator +/- 15%. Default
 * setting is 0b1000.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_TUNE_ADC_C2_TUNE field. */
#define XCVR_RD_ADC_TUNE_ADC_C2_TUNE(base) ((XCVR_ADC_TUNE_REG(base) & XCVR_ADC_TUNE_ADC_C2_TUNE_MASK) >> XCVR_ADC_TUNE_ADC_C2_TUNE_SHIFT)
#define XCVR_BRD_ADC_TUNE_ADC_C2_TUNE(base) (BME_UBFX32(&XCVR_ADC_TUNE_REG(base), XCVR_ADC_TUNE_ADC_C2_TUNE_SHIFT, XCVR_ADC_TUNE_ADC_C2_TUNE_WIDTH))

/*! @brief Set the ADC_C2_TUNE field to a new value. */
#define XCVR_WR_ADC_TUNE_ADC_C2_TUNE(base, value) (XCVR_RMW_ADC_TUNE(base, XCVR_ADC_TUNE_ADC_C2_TUNE_MASK, XCVR_ADC_TUNE_ADC_C2_TUNE(value)))
#define XCVR_BWR_ADC_TUNE_ADC_C2_TUNE(base, value) (BME_BFI32(&XCVR_ADC_TUNE_REG(base), ((uint32_t)(value) << XCVR_ADC_TUNE_ADC_C2_TUNE_SHIFT), XCVR_ADC_TUNE_ADC_C2_TUNE_SHIFT, XCVR_ADC_TUNE_ADC_C2_TUNE_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_ADC_ADJ - ADC Adjustment
 ******************************************************************************/

/*!
 * @brief XCVR_ADC_ADJ - ADC Adjustment (RW)
 *
 * Reset value: 0x43033033U
 */
/*!
 * @name Constants and macros for entire XCVR_ADC_ADJ register
 */
/*@{*/
#define XCVR_RD_ADC_ADJ(base)    (XCVR_ADC_ADJ_REG(base))
#define XCVR_WR_ADC_ADJ(base, value) (XCVR_ADC_ADJ_REG(base) = (value))
#define XCVR_RMW_ADC_ADJ(base, mask, value) (XCVR_WR_ADC_ADJ(base, (XCVR_RD_ADC_ADJ(base) & ~(mask)) | (value)))
#define XCVR_SET_ADC_ADJ(base, value) (BME_OR32(&XCVR_ADC_ADJ_REG(base), (uint32_t)(value)))
#define XCVR_CLR_ADC_ADJ(base, value) (BME_AND32(&XCVR_ADC_ADJ_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_ADC_ADJ(base, value) (BME_XOR32(&XCVR_ADC_ADJ_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_ADC_ADJ bitfields
 */

/*!
 * @name Register XCVR_ADC_ADJ, field ADC_IB_OPAMP1_ADJ[2:0] (RW)
 *
 * Adjusts the 1st integrator operational amplifier reference current +/-30%.
 * Default setting is 0b011.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_ADJ_ADC_IB_OPAMP1_ADJ field. */
#define XCVR_RD_ADC_ADJ_ADC_IB_OPAMP1_ADJ(base) ((XCVR_ADC_ADJ_REG(base) & XCVR_ADC_ADJ_ADC_IB_OPAMP1_ADJ_MASK) >> XCVR_ADC_ADJ_ADC_IB_OPAMP1_ADJ_SHIFT)
#define XCVR_BRD_ADC_ADJ_ADC_IB_OPAMP1_ADJ(base) (BME_UBFX32(&XCVR_ADC_ADJ_REG(base), XCVR_ADC_ADJ_ADC_IB_OPAMP1_ADJ_SHIFT, XCVR_ADC_ADJ_ADC_IB_OPAMP1_ADJ_WIDTH))

/*! @brief Set the ADC_IB_OPAMP1_ADJ field to a new value. */
#define XCVR_WR_ADC_ADJ_ADC_IB_OPAMP1_ADJ(base, value) (XCVR_RMW_ADC_ADJ(base, XCVR_ADC_ADJ_ADC_IB_OPAMP1_ADJ_MASK, XCVR_ADC_ADJ_ADC_IB_OPAMP1_ADJ(value)))
#define XCVR_BWR_ADC_ADJ_ADC_IB_OPAMP1_ADJ(base, value) (BME_BFI32(&XCVR_ADC_ADJ_REG(base), ((uint32_t)(value) << XCVR_ADC_ADJ_ADC_IB_OPAMP1_ADJ_SHIFT), XCVR_ADC_ADJ_ADC_IB_OPAMP1_ADJ_SHIFT, XCVR_ADC_ADJ_ADC_IB_OPAMP1_ADJ_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_ADJ, field ADC_IB_OPAMP2_ADJ[6:4] (RW)
 *
 * Adjusts the 2nd integrator operational amplifier reference current +/-30%.
 * Default setting is 0b011.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_ADJ_ADC_IB_OPAMP2_ADJ field. */
#define XCVR_RD_ADC_ADJ_ADC_IB_OPAMP2_ADJ(base) ((XCVR_ADC_ADJ_REG(base) & XCVR_ADC_ADJ_ADC_IB_OPAMP2_ADJ_MASK) >> XCVR_ADC_ADJ_ADC_IB_OPAMP2_ADJ_SHIFT)
#define XCVR_BRD_ADC_ADJ_ADC_IB_OPAMP2_ADJ(base) (BME_UBFX32(&XCVR_ADC_ADJ_REG(base), XCVR_ADC_ADJ_ADC_IB_OPAMP2_ADJ_SHIFT, XCVR_ADC_ADJ_ADC_IB_OPAMP2_ADJ_WIDTH))

/*! @brief Set the ADC_IB_OPAMP2_ADJ field to a new value. */
#define XCVR_WR_ADC_ADJ_ADC_IB_OPAMP2_ADJ(base, value) (XCVR_RMW_ADC_ADJ(base, XCVR_ADC_ADJ_ADC_IB_OPAMP2_ADJ_MASK, XCVR_ADC_ADJ_ADC_IB_OPAMP2_ADJ(value)))
#define XCVR_BWR_ADC_ADJ_ADC_IB_OPAMP2_ADJ(base, value) (BME_BFI32(&XCVR_ADC_ADJ_REG(base), ((uint32_t)(value) << XCVR_ADC_ADJ_ADC_IB_OPAMP2_ADJ_SHIFT), XCVR_ADC_ADJ_ADC_IB_OPAMP2_ADJ_SHIFT, XCVR_ADC_ADJ_ADC_IB_OPAMP2_ADJ_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_ADJ, field ADC_IB_DAC1_ADJ[14:12] (RW)
 *
 * Adjusts the DAC 1 current +/-30%. Default setting is 0b011.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_ADJ_ADC_IB_DAC1_ADJ field. */
#define XCVR_RD_ADC_ADJ_ADC_IB_DAC1_ADJ(base) ((XCVR_ADC_ADJ_REG(base) & XCVR_ADC_ADJ_ADC_IB_DAC1_ADJ_MASK) >> XCVR_ADC_ADJ_ADC_IB_DAC1_ADJ_SHIFT)
#define XCVR_BRD_ADC_ADJ_ADC_IB_DAC1_ADJ(base) (BME_UBFX32(&XCVR_ADC_ADJ_REG(base), XCVR_ADC_ADJ_ADC_IB_DAC1_ADJ_SHIFT, XCVR_ADC_ADJ_ADC_IB_DAC1_ADJ_WIDTH))

/*! @brief Set the ADC_IB_DAC1_ADJ field to a new value. */
#define XCVR_WR_ADC_ADJ_ADC_IB_DAC1_ADJ(base, value) (XCVR_RMW_ADC_ADJ(base, XCVR_ADC_ADJ_ADC_IB_DAC1_ADJ_MASK, XCVR_ADC_ADJ_ADC_IB_DAC1_ADJ(value)))
#define XCVR_BWR_ADC_ADJ_ADC_IB_DAC1_ADJ(base, value) (BME_BFI32(&XCVR_ADC_ADJ_REG(base), ((uint32_t)(value) << XCVR_ADC_ADJ_ADC_IB_DAC1_ADJ_SHIFT), XCVR_ADC_ADJ_ADC_IB_DAC1_ADJ_SHIFT, XCVR_ADC_ADJ_ADC_IB_DAC1_ADJ_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_ADJ, field ADC_IB_DAC2_ADJ[18:16] (RW)
 *
 * Adjusts the DAC 2 current +/-30%. Default setting is 0b011.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_ADJ_ADC_IB_DAC2_ADJ field. */
#define XCVR_RD_ADC_ADJ_ADC_IB_DAC2_ADJ(base) ((XCVR_ADC_ADJ_REG(base) & XCVR_ADC_ADJ_ADC_IB_DAC2_ADJ_MASK) >> XCVR_ADC_ADJ_ADC_IB_DAC2_ADJ_SHIFT)
#define XCVR_BRD_ADC_ADJ_ADC_IB_DAC2_ADJ(base) (BME_UBFX32(&XCVR_ADC_ADJ_REG(base), XCVR_ADC_ADJ_ADC_IB_DAC2_ADJ_SHIFT, XCVR_ADC_ADJ_ADC_IB_DAC2_ADJ_WIDTH))

/*! @brief Set the ADC_IB_DAC2_ADJ field to a new value. */
#define XCVR_WR_ADC_ADJ_ADC_IB_DAC2_ADJ(base, value) (XCVR_RMW_ADC_ADJ(base, XCVR_ADC_ADJ_ADC_IB_DAC2_ADJ_MASK, XCVR_ADC_ADJ_ADC_IB_DAC2_ADJ(value)))
#define XCVR_BWR_ADC_ADJ_ADC_IB_DAC2_ADJ(base, value) (BME_BFI32(&XCVR_ADC_ADJ_REG(base), ((uint32_t)(value) << XCVR_ADC_ADJ_ADC_IB_DAC2_ADJ_SHIFT), XCVR_ADC_ADJ_ADC_IB_DAC2_ADJ_SHIFT, XCVR_ADC_ADJ_ADC_IB_DAC2_ADJ_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_ADJ, field ADC_IB_FLSH_ADJ[26:24] (RW)
 *
 * Adjusts the quantizer preamplifier current plus/minus 30 percent. Default
 * setting is 0b011.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_ADJ_ADC_IB_FLSH_ADJ field. */
#define XCVR_RD_ADC_ADJ_ADC_IB_FLSH_ADJ(base) ((XCVR_ADC_ADJ_REG(base) & XCVR_ADC_ADJ_ADC_IB_FLSH_ADJ_MASK) >> XCVR_ADC_ADJ_ADC_IB_FLSH_ADJ_SHIFT)
#define XCVR_BRD_ADC_ADJ_ADC_IB_FLSH_ADJ(base) (BME_UBFX32(&XCVR_ADC_ADJ_REG(base), XCVR_ADC_ADJ_ADC_IB_FLSH_ADJ_SHIFT, XCVR_ADC_ADJ_ADC_IB_FLSH_ADJ_WIDTH))

/*! @brief Set the ADC_IB_FLSH_ADJ field to a new value. */
#define XCVR_WR_ADC_ADJ_ADC_IB_FLSH_ADJ(base, value) (XCVR_RMW_ADC_ADJ(base, XCVR_ADC_ADJ_ADC_IB_FLSH_ADJ_MASK, XCVR_ADC_ADJ_ADC_IB_FLSH_ADJ(value)))
#define XCVR_BWR_ADC_ADJ_ADC_IB_FLSH_ADJ(base, value) (BME_BFI32(&XCVR_ADC_ADJ_REG(base), ((uint32_t)(value) << XCVR_ADC_ADJ_ADC_IB_FLSH_ADJ_SHIFT), XCVR_ADC_ADJ_ADC_IB_FLSH_ADJ_SHIFT, XCVR_ADC_ADJ_ADC_IB_FLSH_ADJ_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_ADJ, field ADC_FLSH_RES_ADJ[30:28] (RW)
 *
 * Allows to adjust the value of the resistor ladder that is used to generate
 * the reference voltages for the quantizer. The defualt value is 100
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_ADJ_ADC_FLSH_RES_ADJ field. */
#define XCVR_RD_ADC_ADJ_ADC_FLSH_RES_ADJ(base) ((XCVR_ADC_ADJ_REG(base) & XCVR_ADC_ADJ_ADC_FLSH_RES_ADJ_MASK) >> XCVR_ADC_ADJ_ADC_FLSH_RES_ADJ_SHIFT)
#define XCVR_BRD_ADC_ADJ_ADC_FLSH_RES_ADJ(base) (BME_UBFX32(&XCVR_ADC_ADJ_REG(base), XCVR_ADC_ADJ_ADC_FLSH_RES_ADJ_SHIFT, XCVR_ADC_ADJ_ADC_FLSH_RES_ADJ_WIDTH))

/*! @brief Set the ADC_FLSH_RES_ADJ field to a new value. */
#define XCVR_WR_ADC_ADJ_ADC_FLSH_RES_ADJ(base, value) (XCVR_RMW_ADC_ADJ(base, XCVR_ADC_ADJ_ADC_FLSH_RES_ADJ_MASK, XCVR_ADC_ADJ_ADC_FLSH_RES_ADJ(value)))
#define XCVR_BWR_ADC_ADJ_ADC_FLSH_RES_ADJ(base, value) (BME_BFI32(&XCVR_ADC_ADJ_REG(base), ((uint32_t)(value) << XCVR_ADC_ADJ_ADC_FLSH_RES_ADJ_SHIFT), XCVR_ADC_ADJ_ADC_FLSH_RES_ADJ_SHIFT, XCVR_ADC_ADJ_ADC_FLSH_RES_ADJ_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_ADC_REGS - ADC Regulators
 ******************************************************************************/

/*!
 * @brief XCVR_ADC_REGS - ADC Regulators (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_ADC_REGS register
 */
/*@{*/
#define XCVR_RD_ADC_REGS(base)   (XCVR_ADC_REGS_REG(base))
#define XCVR_WR_ADC_REGS(base, value) (XCVR_ADC_REGS_REG(base) = (value))
#define XCVR_RMW_ADC_REGS(base, mask, value) (XCVR_WR_ADC_REGS(base, (XCVR_RD_ADC_REGS(base) & ~(mask)) | (value)))
#define XCVR_SET_ADC_REGS(base, value) (BME_OR32(&XCVR_ADC_REGS_REG(base), (uint32_t)(value)))
#define XCVR_CLR_ADC_REGS(base, value) (BME_AND32(&XCVR_ADC_REGS_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_ADC_REGS(base, value) (BME_XOR32(&XCVR_ADC_REGS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_ADC_REGS bitfields
 */

/*!
 * @name Register XCVR_ADC_REGS, field ADC_ANA_REG_SUPPLY[3:0] (RW)
 *
 * Regulator trim bits to change the output voltage from 1.05 to 1.4V
 *
 * Values:
 * - 0b0000 - 1.2V
 * - 0b0001 - 1.05V
 * - 0b0010 - 1.275V
 * - 0b0011 - 1.3V
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_REGS_ADC_ANA_REG_SUPPLY field. */
#define XCVR_RD_ADC_REGS_ADC_ANA_REG_SUPPLY(base) ((XCVR_ADC_REGS_REG(base) & XCVR_ADC_REGS_ADC_ANA_REG_SUPPLY_MASK) >> XCVR_ADC_REGS_ADC_ANA_REG_SUPPLY_SHIFT)
#define XCVR_BRD_ADC_REGS_ADC_ANA_REG_SUPPLY(base) (BME_UBFX32(&XCVR_ADC_REGS_REG(base), XCVR_ADC_REGS_ADC_ANA_REG_SUPPLY_SHIFT, XCVR_ADC_REGS_ADC_ANA_REG_SUPPLY_WIDTH))

/*! @brief Set the ADC_ANA_REG_SUPPLY field to a new value. */
#define XCVR_WR_ADC_REGS_ADC_ANA_REG_SUPPLY(base, value) (XCVR_RMW_ADC_REGS(base, XCVR_ADC_REGS_ADC_ANA_REG_SUPPLY_MASK, XCVR_ADC_REGS_ADC_ANA_REG_SUPPLY(value)))
#define XCVR_BWR_ADC_REGS_ADC_ANA_REG_SUPPLY(base, value) (BME_BFI32(&XCVR_ADC_REGS_REG(base), ((uint32_t)(value) << XCVR_ADC_REGS_ADC_ANA_REG_SUPPLY_SHIFT), XCVR_ADC_REGS_ADC_ANA_REG_SUPPLY_SHIFT, XCVR_ADC_REGS_ADC_ANA_REG_SUPPLY_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_REGS, field ADC_REG_DIG_SUPPLY[7:4] (RW)
 *
 * Regulator trim bits to change the output voltage from 1.05 to 1.4V
 *
 * Values:
 * - 0b0000 - 1.2V
 * - 0b0001 - 1.05V
 * - 0b0010 - 1.275V
 * - 0b0011 - 1.3V
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_REGS_ADC_REG_DIG_SUPPLY field. */
#define XCVR_RD_ADC_REGS_ADC_REG_DIG_SUPPLY(base) ((XCVR_ADC_REGS_REG(base) & XCVR_ADC_REGS_ADC_REG_DIG_SUPPLY_MASK) >> XCVR_ADC_REGS_ADC_REG_DIG_SUPPLY_SHIFT)
#define XCVR_BRD_ADC_REGS_ADC_REG_DIG_SUPPLY(base) (BME_UBFX32(&XCVR_ADC_REGS_REG(base), XCVR_ADC_REGS_ADC_REG_DIG_SUPPLY_SHIFT, XCVR_ADC_REGS_ADC_REG_DIG_SUPPLY_WIDTH))

/*! @brief Set the ADC_REG_DIG_SUPPLY field to a new value. */
#define XCVR_WR_ADC_REGS_ADC_REG_DIG_SUPPLY(base, value) (XCVR_RMW_ADC_REGS(base, XCVR_ADC_REGS_ADC_REG_DIG_SUPPLY_MASK, XCVR_ADC_REGS_ADC_REG_DIG_SUPPLY(value)))
#define XCVR_BWR_ADC_REGS_ADC_REG_DIG_SUPPLY(base, value) (BME_BFI32(&XCVR_ADC_REGS_REG(base), ((uint32_t)(value) << XCVR_ADC_REGS_ADC_REG_DIG_SUPPLY_SHIFT), XCVR_ADC_REGS_ADC_REG_DIG_SUPPLY_SHIFT, XCVR_ADC_REGS_ADC_REG_DIG_SUPPLY_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_REGS, field ADC_ANA_REG_BYPASS_ON[8] (RW)
 *
 * This register bit determines if the regulator is in bypass mode. When in
 * bypass mode, the external voltage applied to the input of the regulator is
 * presented at the regulator output.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_REGS_ADC_ANA_REG_BYPASS_ON field. */
#define XCVR_RD_ADC_REGS_ADC_ANA_REG_BYPASS_ON(base) ((XCVR_ADC_REGS_REG(base) & XCVR_ADC_REGS_ADC_ANA_REG_BYPASS_ON_MASK) >> XCVR_ADC_REGS_ADC_ANA_REG_BYPASS_ON_SHIFT)
#define XCVR_BRD_ADC_REGS_ADC_ANA_REG_BYPASS_ON(base) (BME_UBFX32(&XCVR_ADC_REGS_REG(base), XCVR_ADC_REGS_ADC_ANA_REG_BYPASS_ON_SHIFT, XCVR_ADC_REGS_ADC_ANA_REG_BYPASS_ON_WIDTH))

/*! @brief Set the ADC_ANA_REG_BYPASS_ON field to a new value. */
#define XCVR_WR_ADC_REGS_ADC_ANA_REG_BYPASS_ON(base, value) (XCVR_RMW_ADC_REGS(base, XCVR_ADC_REGS_ADC_ANA_REG_BYPASS_ON_MASK, XCVR_ADC_REGS_ADC_ANA_REG_BYPASS_ON(value)))
#define XCVR_BWR_ADC_REGS_ADC_ANA_REG_BYPASS_ON(base, value) (BME_BFI32(&XCVR_ADC_REGS_REG(base), ((uint32_t)(value) << XCVR_ADC_REGS_ADC_ANA_REG_BYPASS_ON_SHIFT), XCVR_ADC_REGS_ADC_ANA_REG_BYPASS_ON_SHIFT, XCVR_ADC_REGS_ADC_ANA_REG_BYPASS_ON_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_REGS, field ADC_DIG_REG_BYPASS_ON[9] (RW)
 *
 * This register bit determines if the regulator is in bypass mode. When in
 * bypass mode, the external voltage applied to the input of the regulator is
 * presented at the regulator output.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_REGS_ADC_DIG_REG_BYPASS_ON field. */
#define XCVR_RD_ADC_REGS_ADC_DIG_REG_BYPASS_ON(base) ((XCVR_ADC_REGS_REG(base) & XCVR_ADC_REGS_ADC_DIG_REG_BYPASS_ON_MASK) >> XCVR_ADC_REGS_ADC_DIG_REG_BYPASS_ON_SHIFT)
#define XCVR_BRD_ADC_REGS_ADC_DIG_REG_BYPASS_ON(base) (BME_UBFX32(&XCVR_ADC_REGS_REG(base), XCVR_ADC_REGS_ADC_DIG_REG_BYPASS_ON_SHIFT, XCVR_ADC_REGS_ADC_DIG_REG_BYPASS_ON_WIDTH))

/*! @brief Set the ADC_DIG_REG_BYPASS_ON field to a new value. */
#define XCVR_WR_ADC_REGS_ADC_DIG_REG_BYPASS_ON(base, value) (XCVR_RMW_ADC_REGS(base, XCVR_ADC_REGS_ADC_DIG_REG_BYPASS_ON_MASK, XCVR_ADC_REGS_ADC_DIG_REG_BYPASS_ON(value)))
#define XCVR_BWR_ADC_REGS_ADC_DIG_REG_BYPASS_ON(base, value) (BME_BFI32(&XCVR_ADC_REGS_REG(base), ((uint32_t)(value) << XCVR_ADC_REGS_ADC_DIG_REG_BYPASS_ON_SHIFT), XCVR_ADC_REGS_ADC_DIG_REG_BYPASS_ON_SHIFT, XCVR_ADC_REGS_ADC_DIG_REG_BYPASS_ON_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_REGS, field ADC_VCMREF_BYPASS_ON[15] (RW)
 *
 * Allows to use an external 0.6V reference instead of the internally generated
 * 0.6V. This mode should be used only in combination with analog test mode for
 * the ADC enabled and when supplying an external 0.6V reference voltage through
 * the test mux.This function is not used in this version of the chip
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_REGS_ADC_VCMREF_BYPASS_ON field. */
#define XCVR_RD_ADC_REGS_ADC_VCMREF_BYPASS_ON(base) ((XCVR_ADC_REGS_REG(base) & XCVR_ADC_REGS_ADC_VCMREF_BYPASS_ON_MASK) >> XCVR_ADC_REGS_ADC_VCMREF_BYPASS_ON_SHIFT)
#define XCVR_BRD_ADC_REGS_ADC_VCMREF_BYPASS_ON(base) (BME_UBFX32(&XCVR_ADC_REGS_REG(base), XCVR_ADC_REGS_ADC_VCMREF_BYPASS_ON_SHIFT, XCVR_ADC_REGS_ADC_VCMREF_BYPASS_ON_WIDTH))

/*! @brief Set the ADC_VCMREF_BYPASS_ON field to a new value. */
#define XCVR_WR_ADC_REGS_ADC_VCMREF_BYPASS_ON(base, value) (XCVR_RMW_ADC_REGS(base, XCVR_ADC_REGS_ADC_VCMREF_BYPASS_ON_MASK, XCVR_ADC_REGS_ADC_VCMREF_BYPASS_ON(value)))
#define XCVR_BWR_ADC_REGS_ADC_VCMREF_BYPASS_ON(base, value) (BME_BFI32(&XCVR_ADC_REGS_REG(base), ((uint32_t)(value) << XCVR_ADC_REGS_ADC_VCMREF_BYPASS_ON_SHIFT), XCVR_ADC_REGS_ADC_VCMREF_BYPASS_ON_SHIFT, XCVR_ADC_REGS_ADC_VCMREF_BYPASS_ON_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_REGS, field ADC_INTERNAL_IREF_BYPASS_ON[17] (RW)
 *
 * Bypass the internally generated 5uA reference current that is used for the
 * ADC to generate all the other reference currents for the ADC and use an external
 * reference current. This mode should be used only in combination with analog
 * test mode for the ADC enabled and when supplying an external current reference
 * through the test mux. This function is not used in this version of the chip
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_REGS_ADC_INTERNAL_IREF_BYPASS_ON field. */
#define XCVR_RD_ADC_REGS_ADC_INTERNAL_IREF_BYPASS_ON(base) ((XCVR_ADC_REGS_REG(base) & XCVR_ADC_REGS_ADC_INTERNAL_IREF_BYPASS_ON_MASK) >> XCVR_ADC_REGS_ADC_INTERNAL_IREF_BYPASS_ON_SHIFT)
#define XCVR_BRD_ADC_REGS_ADC_INTERNAL_IREF_BYPASS_ON(base) (BME_UBFX32(&XCVR_ADC_REGS_REG(base), XCVR_ADC_REGS_ADC_INTERNAL_IREF_BYPASS_ON_SHIFT, XCVR_ADC_REGS_ADC_INTERNAL_IREF_BYPASS_ON_WIDTH))

/*! @brief Set the ADC_INTERNAL_IREF_BYPASS_ON field to a new value. */
#define XCVR_WR_ADC_REGS_ADC_INTERNAL_IREF_BYPASS_ON(base, value) (XCVR_RMW_ADC_REGS(base, XCVR_ADC_REGS_ADC_INTERNAL_IREF_BYPASS_ON_MASK, XCVR_ADC_REGS_ADC_INTERNAL_IREF_BYPASS_ON(value)))
#define XCVR_BWR_ADC_REGS_ADC_INTERNAL_IREF_BYPASS_ON(base, value) (BME_BFI32(&XCVR_ADC_REGS_REG(base), ((uint32_t)(value) << XCVR_ADC_REGS_ADC_INTERNAL_IREF_BYPASS_ON_SHIFT), XCVR_ADC_REGS_ADC_INTERNAL_IREF_BYPASS_ON_SHIFT, XCVR_ADC_REGS_ADC_INTERNAL_IREF_BYPASS_ON_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_ADC_TRIMS - ADC Regulator Trims
 ******************************************************************************/

/*!
 * @brief XCVR_ADC_TRIMS - ADC Regulator Trims (RW)
 *
 * Reset value: 0x00000444U
 */
/*!
 * @name Constants and macros for entire XCVR_ADC_TRIMS register
 */
/*@{*/
#define XCVR_RD_ADC_TRIMS(base)  (XCVR_ADC_TRIMS_REG(base))
#define XCVR_WR_ADC_TRIMS(base, value) (XCVR_ADC_TRIMS_REG(base) = (value))
#define XCVR_RMW_ADC_TRIMS(base, mask, value) (XCVR_WR_ADC_TRIMS(base, (XCVR_RD_ADC_TRIMS(base) & ~(mask)) | (value)))
#define XCVR_SET_ADC_TRIMS(base, value) (BME_OR32(&XCVR_ADC_TRIMS_REG(base), (uint32_t)(value)))
#define XCVR_CLR_ADC_TRIMS(base, value) (BME_AND32(&XCVR_ADC_TRIMS_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_ADC_TRIMS(base, value) (BME_XOR32(&XCVR_ADC_TRIMS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_ADC_TRIMS bitfields
 */

/*!
 * @name Register XCVR_ADC_TRIMS, field ADC_IREF_OPAMPS_RES_TRIM[2:0] (RW)
 *
 * This allows to trim the resistor value used to generate the reference current
 * for the integrator's operational amplifiers. The resistor values can be
 * trimmed by plus/minus 15 percent.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_TRIMS_ADC_IREF_OPAMPS_RES_TRIM field. */
#define XCVR_RD_ADC_TRIMS_ADC_IREF_OPAMPS_RES_TRIM(base) ((XCVR_ADC_TRIMS_REG(base) & XCVR_ADC_TRIMS_ADC_IREF_OPAMPS_RES_TRIM_MASK) >> XCVR_ADC_TRIMS_ADC_IREF_OPAMPS_RES_TRIM_SHIFT)
#define XCVR_BRD_ADC_TRIMS_ADC_IREF_OPAMPS_RES_TRIM(base) (BME_UBFX32(&XCVR_ADC_TRIMS_REG(base), XCVR_ADC_TRIMS_ADC_IREF_OPAMPS_RES_TRIM_SHIFT, XCVR_ADC_TRIMS_ADC_IREF_OPAMPS_RES_TRIM_WIDTH))

/*! @brief Set the ADC_IREF_OPAMPS_RES_TRIM field to a new value. */
#define XCVR_WR_ADC_TRIMS_ADC_IREF_OPAMPS_RES_TRIM(base, value) (XCVR_RMW_ADC_TRIMS(base, XCVR_ADC_TRIMS_ADC_IREF_OPAMPS_RES_TRIM_MASK, XCVR_ADC_TRIMS_ADC_IREF_OPAMPS_RES_TRIM(value)))
#define XCVR_BWR_ADC_TRIMS_ADC_IREF_OPAMPS_RES_TRIM(base, value) (BME_BFI32(&XCVR_ADC_TRIMS_REG(base), ((uint32_t)(value) << XCVR_ADC_TRIMS_ADC_IREF_OPAMPS_RES_TRIM_SHIFT), XCVR_ADC_TRIMS_ADC_IREF_OPAMPS_RES_TRIM_SHIFT, XCVR_ADC_TRIMS_ADC_IREF_OPAMPS_RES_TRIM_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_TRIMS, field ADC_IREF_FLSH_RES_TRIM[6:4] (RW)
 *
 * This allows to trim the resistor value used to generate the reference current
 * for the quantizer. The resistor values can be trimmed by +/-15%.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_TRIMS_ADC_IREF_FLSH_RES_TRIM field. */
#define XCVR_RD_ADC_TRIMS_ADC_IREF_FLSH_RES_TRIM(base) ((XCVR_ADC_TRIMS_REG(base) & XCVR_ADC_TRIMS_ADC_IREF_FLSH_RES_TRIM_MASK) >> XCVR_ADC_TRIMS_ADC_IREF_FLSH_RES_TRIM_SHIFT)
#define XCVR_BRD_ADC_TRIMS_ADC_IREF_FLSH_RES_TRIM(base) (BME_UBFX32(&XCVR_ADC_TRIMS_REG(base), XCVR_ADC_TRIMS_ADC_IREF_FLSH_RES_TRIM_SHIFT, XCVR_ADC_TRIMS_ADC_IREF_FLSH_RES_TRIM_WIDTH))

/*! @brief Set the ADC_IREF_FLSH_RES_TRIM field to a new value. */
#define XCVR_WR_ADC_TRIMS_ADC_IREF_FLSH_RES_TRIM(base, value) (XCVR_RMW_ADC_TRIMS(base, XCVR_ADC_TRIMS_ADC_IREF_FLSH_RES_TRIM_MASK, XCVR_ADC_TRIMS_ADC_IREF_FLSH_RES_TRIM(value)))
#define XCVR_BWR_ADC_TRIMS_ADC_IREF_FLSH_RES_TRIM(base, value) (BME_BFI32(&XCVR_ADC_TRIMS_REG(base), ((uint32_t)(value) << XCVR_ADC_TRIMS_ADC_IREF_FLSH_RES_TRIM_SHIFT), XCVR_ADC_TRIMS_ADC_IREF_FLSH_RES_TRIM_SHIFT, XCVR_ADC_TRIMS_ADC_IREF_FLSH_RES_TRIM_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_TRIMS, field ADC_VCM_TRIM[10:8] (RW)
 *
 * This allows to trim the resistor value used to generate the reference current
 * for the DACs. These bits are mislabeled and should be called
 * ADC_IREF_DAC_RES_TRIM. The resistor values can be trimmed by +/-15%.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_TRIMS_ADC_VCM_TRIM field. */
#define XCVR_RD_ADC_TRIMS_ADC_VCM_TRIM(base) ((XCVR_ADC_TRIMS_REG(base) & XCVR_ADC_TRIMS_ADC_VCM_TRIM_MASK) >> XCVR_ADC_TRIMS_ADC_VCM_TRIM_SHIFT)
#define XCVR_BRD_ADC_TRIMS_ADC_VCM_TRIM(base) (BME_UBFX32(&XCVR_ADC_TRIMS_REG(base), XCVR_ADC_TRIMS_ADC_VCM_TRIM_SHIFT, XCVR_ADC_TRIMS_ADC_VCM_TRIM_WIDTH))

/*! @brief Set the ADC_VCM_TRIM field to a new value. */
#define XCVR_WR_ADC_TRIMS_ADC_VCM_TRIM(base, value) (XCVR_RMW_ADC_TRIMS(base, XCVR_ADC_TRIMS_ADC_VCM_TRIM_MASK, XCVR_ADC_TRIMS_ADC_VCM_TRIM(value)))
#define XCVR_BWR_ADC_TRIMS_ADC_VCM_TRIM(base, value) (BME_BFI32(&XCVR_ADC_TRIMS_REG(base), ((uint32_t)(value) << XCVR_ADC_TRIMS_ADC_VCM_TRIM_SHIFT), XCVR_ADC_TRIMS_ADC_VCM_TRIM_SHIFT, XCVR_ADC_TRIMS_ADC_VCM_TRIM_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_ADC_TEST_CTRL - ADC Test Control
 ******************************************************************************/

/*!
 * @brief XCVR_ADC_TEST_CTRL - ADC Test Control (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_ADC_TEST_CTRL register
 */
/*@{*/
#define XCVR_RD_ADC_TEST_CTRL(base) (XCVR_ADC_TEST_CTRL_REG(base))
#define XCVR_WR_ADC_TEST_CTRL(base, value) (XCVR_ADC_TEST_CTRL_REG(base) = (value))
#define XCVR_RMW_ADC_TEST_CTRL(base, mask, value) (XCVR_WR_ADC_TEST_CTRL(base, (XCVR_RD_ADC_TEST_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_ADC_TEST_CTRL(base, value) (BME_OR32(&XCVR_ADC_TEST_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_ADC_TEST_CTRL(base, value) (BME_AND32(&XCVR_ADC_TEST_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_ADC_TEST_CTRL(base, value) (BME_XOR32(&XCVR_ADC_TEST_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_ADC_TEST_CTRL bitfields
 */

/*!
 * @name Register XCVR_ADC_TEST_CTRL, field ADC_ATST_SEL[4:0] (RW)
 *
 * Allows to slect between the different ADC analog test modes.All other values
 * are reserved.
 *
 * Values:
 * - 0b00000 - Inject 5uA refrence current on ATST0 ,Inject 0.6V reference
 *     voltage on ATST1
 * - 0b00001 - Monitor Flash refrence currents on ATST3
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_TEST_CTRL_ADC_ATST_SEL field. */
#define XCVR_RD_ADC_TEST_CTRL_ADC_ATST_SEL(base) ((XCVR_ADC_TEST_CTRL_REG(base) & XCVR_ADC_TEST_CTRL_ADC_ATST_SEL_MASK) >> XCVR_ADC_TEST_CTRL_ADC_ATST_SEL_SHIFT)
#define XCVR_BRD_ADC_TEST_CTRL_ADC_ATST_SEL(base) (BME_UBFX32(&XCVR_ADC_TEST_CTRL_REG(base), XCVR_ADC_TEST_CTRL_ADC_ATST_SEL_SHIFT, XCVR_ADC_TEST_CTRL_ADC_ATST_SEL_WIDTH))

/*! @brief Set the ADC_ATST_SEL field to a new value. */
#define XCVR_WR_ADC_TEST_CTRL_ADC_ATST_SEL(base, value) (XCVR_RMW_ADC_TEST_CTRL(base, XCVR_ADC_TEST_CTRL_ADC_ATST_SEL_MASK, XCVR_ADC_TEST_CTRL_ADC_ATST_SEL(value)))
#define XCVR_BWR_ADC_TEST_CTRL_ADC_ATST_SEL(base, value) (BME_BFI32(&XCVR_ADC_TEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_ADC_TEST_CTRL_ADC_ATST_SEL_SHIFT), XCVR_ADC_TEST_CTRL_ADC_ATST_SEL_SHIFT, XCVR_ADC_TEST_CTRL_ADC_ATST_SEL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_TEST_CTRL, field ADC_DIG_REG_ATST_SEL[9:8] (RW)
 *
 * These bits control the what internal regualtor signals are connected to the
 * ATST bus. register setting ATST0 00 No Connect 01 vout 10 vin feedback 11 vbias
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_TEST_CTRL_ADC_DIG_REG_ATST_SEL field. */
#define XCVR_RD_ADC_TEST_CTRL_ADC_DIG_REG_ATST_SEL(base) ((XCVR_ADC_TEST_CTRL_REG(base) & XCVR_ADC_TEST_CTRL_ADC_DIG_REG_ATST_SEL_MASK) >> XCVR_ADC_TEST_CTRL_ADC_DIG_REG_ATST_SEL_SHIFT)
#define XCVR_BRD_ADC_TEST_CTRL_ADC_DIG_REG_ATST_SEL(base) (BME_UBFX32(&XCVR_ADC_TEST_CTRL_REG(base), XCVR_ADC_TEST_CTRL_ADC_DIG_REG_ATST_SEL_SHIFT, XCVR_ADC_TEST_CTRL_ADC_DIG_REG_ATST_SEL_WIDTH))

/*! @brief Set the ADC_DIG_REG_ATST_SEL field to a new value. */
#define XCVR_WR_ADC_TEST_CTRL_ADC_DIG_REG_ATST_SEL(base, value) (XCVR_RMW_ADC_TEST_CTRL(base, XCVR_ADC_TEST_CTRL_ADC_DIG_REG_ATST_SEL_MASK, XCVR_ADC_TEST_CTRL_ADC_DIG_REG_ATST_SEL(value)))
#define XCVR_BWR_ADC_TEST_CTRL_ADC_DIG_REG_ATST_SEL(base, value) (BME_BFI32(&XCVR_ADC_TEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_ADC_TEST_CTRL_ADC_DIG_REG_ATST_SEL_SHIFT), XCVR_ADC_TEST_CTRL_ADC_DIG_REG_ATST_SEL_SHIFT, XCVR_ADC_TEST_CTRL_ADC_DIG_REG_ATST_SEL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_TEST_CTRL, field ADC_ANA_REG_ATST_SEL[13:12] (RW)
 *
 * These bits control what internal signals are connected to the ATST bus.
 * register setting ATST0 00 No Connect 01 vout 10 vin feedback 11 vbias
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_TEST_CTRL_ADC_ANA_REG_ATST_SEL field. */
#define XCVR_RD_ADC_TEST_CTRL_ADC_ANA_REG_ATST_SEL(base) ((XCVR_ADC_TEST_CTRL_REG(base) & XCVR_ADC_TEST_CTRL_ADC_ANA_REG_ATST_SEL_MASK) >> XCVR_ADC_TEST_CTRL_ADC_ANA_REG_ATST_SEL_SHIFT)
#define XCVR_BRD_ADC_TEST_CTRL_ADC_ANA_REG_ATST_SEL(base) (BME_UBFX32(&XCVR_ADC_TEST_CTRL_REG(base), XCVR_ADC_TEST_CTRL_ADC_ANA_REG_ATST_SEL_SHIFT, XCVR_ADC_TEST_CTRL_ADC_ANA_REG_ATST_SEL_WIDTH))

/*! @brief Set the ADC_ANA_REG_ATST_SEL field to a new value. */
#define XCVR_WR_ADC_TEST_CTRL_ADC_ANA_REG_ATST_SEL(base, value) (XCVR_RMW_ADC_TEST_CTRL(base, XCVR_ADC_TEST_CTRL_ADC_ANA_REG_ATST_SEL_MASK, XCVR_ADC_TEST_CTRL_ADC_ANA_REG_ATST_SEL(value)))
#define XCVR_BWR_ADC_TEST_CTRL_ADC_ANA_REG_ATST_SEL(base, value) (BME_BFI32(&XCVR_ADC_TEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_ADC_TEST_CTRL_ADC_ANA_REG_ATST_SEL_SHIFT), XCVR_ADC_TEST_CTRL_ADC_ANA_REG_ATST_SEL_SHIFT, XCVR_ADC_TEST_CTRL_ADC_ANA_REG_ATST_SEL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_TEST_CTRL, field DCOC_ALPHA_RADIUS_GS_IDX[26:24] (RW)
 *
 * DCOC Alpha-R Scaling. This has the same definition as DCOC_ALPHA_RADIUS_IDX.
 * The tracking estimator will switch from DCOC_ALPHA_RADIUS_IDX to
 * DCOC_ALPHA_RADIUS_GS_IDX at the time specified by the DCOC_TRK_EST_GS_CNT.
 *
 * Values:
 * - 0b000 - 1
 * - 0b001 - 1/2
 * - 0b010 - 1/4
 * - 0b011 - 1/8
 * - 0b100 - 1/16
 * - 0b101 - 1/32
 * - 0b110 - 1/64
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_TEST_CTRL_DCOC_ALPHA_RADIUS_GS_IDX field. */
#define XCVR_RD_ADC_TEST_CTRL_DCOC_ALPHA_RADIUS_GS_IDX(base) ((XCVR_ADC_TEST_CTRL_REG(base) & XCVR_ADC_TEST_CTRL_DCOC_ALPHA_RADIUS_GS_IDX_MASK) >> XCVR_ADC_TEST_CTRL_DCOC_ALPHA_RADIUS_GS_IDX_SHIFT)
#define XCVR_BRD_ADC_TEST_CTRL_DCOC_ALPHA_RADIUS_GS_IDX(base) (BME_UBFX32(&XCVR_ADC_TEST_CTRL_REG(base), XCVR_ADC_TEST_CTRL_DCOC_ALPHA_RADIUS_GS_IDX_SHIFT, XCVR_ADC_TEST_CTRL_DCOC_ALPHA_RADIUS_GS_IDX_WIDTH))

/*! @brief Set the DCOC_ALPHA_RADIUS_GS_IDX field to a new value. */
#define XCVR_WR_ADC_TEST_CTRL_DCOC_ALPHA_RADIUS_GS_IDX(base, value) (XCVR_RMW_ADC_TEST_CTRL(base, XCVR_ADC_TEST_CTRL_DCOC_ALPHA_RADIUS_GS_IDX_MASK, XCVR_ADC_TEST_CTRL_DCOC_ALPHA_RADIUS_GS_IDX(value)))
#define XCVR_BWR_ADC_TEST_CTRL_DCOC_ALPHA_RADIUS_GS_IDX(base, value) (BME_BFI32(&XCVR_ADC_TEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_ADC_TEST_CTRL_DCOC_ALPHA_RADIUS_GS_IDX_SHIFT), XCVR_ADC_TEST_CTRL_DCOC_ALPHA_RADIUS_GS_IDX_SHIFT, XCVR_ADC_TEST_CTRL_DCOC_ALPHA_RADIUS_GS_IDX_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ADC_TEST_CTRL, field ADC_SPARE3[27] (RW)
 *
 * Spare Bit for future use
 */
/*@{*/
/*! @brief Read current value of the XCVR_ADC_TEST_CTRL_ADC_SPARE3 field. */
#define XCVR_RD_ADC_TEST_CTRL_ADC_SPARE3(base) ((XCVR_ADC_TEST_CTRL_REG(base) & XCVR_ADC_TEST_CTRL_ADC_SPARE3_MASK) >> XCVR_ADC_TEST_CTRL_ADC_SPARE3_SHIFT)
#define XCVR_BRD_ADC_TEST_CTRL_ADC_SPARE3(base) (BME_UBFX32(&XCVR_ADC_TEST_CTRL_REG(base), XCVR_ADC_TEST_CTRL_ADC_SPARE3_SHIFT, XCVR_ADC_TEST_CTRL_ADC_SPARE3_WIDTH))

/*! @brief Set the ADC_SPARE3 field to a new value. */
#define XCVR_WR_ADC_TEST_CTRL_ADC_SPARE3(base, value) (XCVR_RMW_ADC_TEST_CTRL(base, XCVR_ADC_TEST_CTRL_ADC_SPARE3_MASK, XCVR_ADC_TEST_CTRL_ADC_SPARE3(value)))
#define XCVR_BWR_ADC_TEST_CTRL_ADC_SPARE3(base, value) (BME_BFI32(&XCVR_ADC_TEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_ADC_TEST_CTRL_ADC_SPARE3_SHIFT), XCVR_ADC_TEST_CTRL_ADC_SPARE3_SHIFT, XCVR_ADC_TEST_CTRL_ADC_SPARE3_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_BBF_CTRL - Baseband Filter Control
 ******************************************************************************/

/*!
 * @brief XCVR_BBF_CTRL - Baseband Filter Control (RW)
 *
 * Reset value: 0x00000173U
 */
/*!
 * @name Constants and macros for entire XCVR_BBF_CTRL register
 */
/*@{*/
#define XCVR_RD_BBF_CTRL(base)   (XCVR_BBF_CTRL_REG(base))
#define XCVR_WR_BBF_CTRL(base, value) (XCVR_BBF_CTRL_REG(base) = (value))
#define XCVR_RMW_BBF_CTRL(base, mask, value) (XCVR_WR_BBF_CTRL(base, (XCVR_RD_BBF_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_BBF_CTRL(base, value) (BME_OR32(&XCVR_BBF_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_BBF_CTRL(base, value) (BME_AND32(&XCVR_BBF_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_BBF_CTRL(base, value) (BME_XOR32(&XCVR_BBF_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_BBF_CTRL bitfields
 */

/*!
 * @name Register XCVR_BBF_CTRL, field BBF_CAP_TUNE[3:0] (RW)
 *
 * This is programmbale capacitor values to change the corner frequency of the
 * first baseband filter. This bit in combination with bbf_res_tune and
 * tza_cap_tune determine the baseband filter response. The following table illustrates the
 * composite filter responces based on the bit settings tza_cap bba_cap bba_res2
 * f3db(KHz) 0 0 0 1180 0 0 2 1077 0 0 5 1007 0 0 7 873.1 0 2 0 1119 0 2 2 1030
 * 0 2 5 968 0 2 7 846.2 0 5 0 980.5 0 5 2 917.9 0 5 5 872.5 0 5 7 777.6 0 7 0
 * 836.8 0 7 2 795.8 0 7 5 764.3 0 7 7 695.3 2 0 0 1096 2 0 2 1009 2 0 5 949.8 2 0
 * 7 832.2 2 2 0 1044 2 2 2 968.6 2 2 5 915.7 2 2 7 808.3 2 5 0 924.9 2 5 2 871.2
 * 2 5 5 831.4 2 5 7 746.8 2 7 0 798.2 2 7 2 762.2 2 7 5 734.2 2 7 7 671.9 5 0 0
 * 934.5 5 0 2 875.7 5 0 5 833.6 5 0 7 745.9 5 2 0 898.9 5 2 2 846.7 5 2 5 808.5
 * 5 2 7 727.9 5 5 0 813.3 5 5 2 774.6 5 5 5 745 5 5 7 680 5 7 0 717.4 5 7 2
 * 690.4 5 7 5 669 5 7 7 619.7 7 0 0 788.5 7 0 2 750.1 7 0 5 721.3 7 0 7 658.5 7 2 0
 * 765 7 2 2 730.2 7 2 5 703.7 7 2 7 645.2 7 5 0 705.7 7 5 2 678.8 7 5 5 657.7 7
 * 5 7 609.4 7 7 0 635.6 7 7 2 616 7 7 5 600.2 7 7 7 562.6
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_CTRL_BBF_CAP_TUNE field. */
#define XCVR_RD_BBF_CTRL_BBF_CAP_TUNE(base) ((XCVR_BBF_CTRL_REG(base) & XCVR_BBF_CTRL_BBF_CAP_TUNE_MASK) >> XCVR_BBF_CTRL_BBF_CAP_TUNE_SHIFT)
#define XCVR_BRD_BBF_CTRL_BBF_CAP_TUNE(base) (BME_UBFX32(&XCVR_BBF_CTRL_REG(base), XCVR_BBF_CTRL_BBF_CAP_TUNE_SHIFT, XCVR_BBF_CTRL_BBF_CAP_TUNE_WIDTH))

/*! @brief Set the BBF_CAP_TUNE field to a new value. */
#define XCVR_WR_BBF_CTRL_BBF_CAP_TUNE(base, value) (XCVR_RMW_BBF_CTRL(base, XCVR_BBF_CTRL_BBF_CAP_TUNE_MASK, XCVR_BBF_CTRL_BBF_CAP_TUNE(value)))
#define XCVR_BWR_BBF_CTRL_BBF_CAP_TUNE(base, value) (BME_BFI32(&XCVR_BBF_CTRL_REG(base), ((uint32_t)(value) << XCVR_BBF_CTRL_BBF_CAP_TUNE_SHIFT), XCVR_BBF_CTRL_BBF_CAP_TUNE_SHIFT, XCVR_BBF_CTRL_BBF_CAP_TUNE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_CTRL, field BBF_RES_TUNE2[7:4] (RW)
 *
 * This is the programmable resistor to change the corner frquency of the
 * passive pole. The total f3db filter corner is determined by bbf_cap_tune and
 * tza_cap_tune.See the description for bbf_cap_tune BBF_CAP_TUNEBBF_CAP_TUNE for the
 * corner frequency values.
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_CTRL_BBF_RES_TUNE2 field. */
#define XCVR_RD_BBF_CTRL_BBF_RES_TUNE2(base) ((XCVR_BBF_CTRL_REG(base) & XCVR_BBF_CTRL_BBF_RES_TUNE2_MASK) >> XCVR_BBF_CTRL_BBF_RES_TUNE2_SHIFT)
#define XCVR_BRD_BBF_CTRL_BBF_RES_TUNE2(base) (BME_UBFX32(&XCVR_BBF_CTRL_REG(base), XCVR_BBF_CTRL_BBF_RES_TUNE2_SHIFT, XCVR_BBF_CTRL_BBF_RES_TUNE2_WIDTH))

/*! @brief Set the BBF_RES_TUNE2 field to a new value. */
#define XCVR_WR_BBF_CTRL_BBF_RES_TUNE2(base, value) (XCVR_RMW_BBF_CTRL(base, XCVR_BBF_CTRL_BBF_RES_TUNE2_MASK, XCVR_BBF_CTRL_BBF_RES_TUNE2(value)))
#define XCVR_BWR_BBF_CTRL_BBF_RES_TUNE2(base, value) (BME_BFI32(&XCVR_BBF_CTRL_REG(base), ((uint32_t)(value) << XCVR_BBF_CTRL_BBF_RES_TUNE2_SHIFT), XCVR_BBF_CTRL_BBF_RES_TUNE2_SHIFT, XCVR_BBF_CTRL_BBF_RES_TUNE2_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_CTRL, field BBF_CUR_CNTL[8] (RW)
 *
 * This bit controls the current in the BBF and default is 1. When the bit is
 * unset the total BBF current decreases by 350uA.
 *
 * Values:
 * - 0b0 - Low current setting.
 * - 0b1 - High current setting.
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_CTRL_BBF_CUR_CNTL field. */
#define XCVR_RD_BBF_CTRL_BBF_CUR_CNTL(base) ((XCVR_BBF_CTRL_REG(base) & XCVR_BBF_CTRL_BBF_CUR_CNTL_MASK) >> XCVR_BBF_CTRL_BBF_CUR_CNTL_SHIFT)
#define XCVR_BRD_BBF_CTRL_BBF_CUR_CNTL(base) (BME_UBFX32(&XCVR_BBF_CTRL_REG(base), XCVR_BBF_CTRL_BBF_CUR_CNTL_SHIFT, XCVR_BBF_CTRL_BBF_CUR_CNTL_WIDTH))

/*! @brief Set the BBF_CUR_CNTL field to a new value. */
#define XCVR_WR_BBF_CTRL_BBF_CUR_CNTL(base, value) (XCVR_RMW_BBF_CTRL(base, XCVR_BBF_CTRL_BBF_CUR_CNTL_MASK, XCVR_BBF_CTRL_BBF_CUR_CNTL(value)))
#define XCVR_BWR_BBF_CTRL_BBF_CUR_CNTL(base, value) (BME_BFI32(&XCVR_BBF_CTRL_REG(base), ((uint32_t)(value) << XCVR_BBF_CTRL_BBF_CUR_CNTL_SHIFT), XCVR_BBF_CTRL_BBF_CUR_CNTL_SHIFT, XCVR_BBF_CTRL_BBF_CUR_CNTL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_CTRL, field BBF_DCOC_ON[9] (RW)
 *
 * Not currently connected. Was intended to enable the DCOC at the output of BBF
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_CTRL_BBF_DCOC_ON field. */
#define XCVR_RD_BBF_CTRL_BBF_DCOC_ON(base) ((XCVR_BBF_CTRL_REG(base) & XCVR_BBF_CTRL_BBF_DCOC_ON_MASK) >> XCVR_BBF_CTRL_BBF_DCOC_ON_SHIFT)
#define XCVR_BRD_BBF_CTRL_BBF_DCOC_ON(base) (BME_UBFX32(&XCVR_BBF_CTRL_REG(base), XCVR_BBF_CTRL_BBF_DCOC_ON_SHIFT, XCVR_BBF_CTRL_BBF_DCOC_ON_WIDTH))

/*! @brief Set the BBF_DCOC_ON field to a new value. */
#define XCVR_WR_BBF_CTRL_BBF_DCOC_ON(base, value) (XCVR_RMW_BBF_CTRL(base, XCVR_BBF_CTRL_BBF_DCOC_ON_MASK, XCVR_BBF_CTRL_BBF_DCOC_ON(value)))
#define XCVR_BWR_BBF_CTRL_BBF_DCOC_ON(base, value) (BME_BFI32(&XCVR_BBF_CTRL_REG(base), ((uint32_t)(value) << XCVR_BBF_CTRL_BBF_DCOC_ON_SHIFT), XCVR_BBF_CTRL_BBF_DCOC_ON_SHIFT, XCVR_BBF_CTRL_BBF_DCOC_ON_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_CTRL, field BBF_TMUX_ON[11] (RW)
 *
 * This bit enables the test mode for the baseband filter block. The internal
 * signals are brought to the the ATST bus based on the values of the rx_atst_sel.
 * Refer to the description in the rx_atst_sel field.
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_CTRL_BBF_TMUX_ON field. */
#define XCVR_RD_BBF_CTRL_BBF_TMUX_ON(base) ((XCVR_BBF_CTRL_REG(base) & XCVR_BBF_CTRL_BBF_TMUX_ON_MASK) >> XCVR_BBF_CTRL_BBF_TMUX_ON_SHIFT)
#define XCVR_BRD_BBF_CTRL_BBF_TMUX_ON(base) (BME_UBFX32(&XCVR_BBF_CTRL_REG(base), XCVR_BBF_CTRL_BBF_TMUX_ON_SHIFT, XCVR_BBF_CTRL_BBF_TMUX_ON_WIDTH))

/*! @brief Set the BBF_TMUX_ON field to a new value. */
#define XCVR_WR_BBF_CTRL_BBF_TMUX_ON(base, value) (XCVR_RMW_BBF_CTRL(base, XCVR_BBF_CTRL_BBF_TMUX_ON_MASK, XCVR_BBF_CTRL_BBF_TMUX_ON(value)))
#define XCVR_BWR_BBF_CTRL_BBF_TMUX_ON(base, value) (BME_BFI32(&XCVR_BBF_CTRL_REG(base), ((uint32_t)(value) << XCVR_BBF_CTRL_BBF_TMUX_ON_SHIFT), XCVR_BBF_CTRL_BBF_TMUX_ON_SHIFT, XCVR_BBF_CTRL_BBF_TMUX_ON_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_CTRL, field DCOC_ALPHAC_SCALE_GS_IDX[13:12] (RW)
 *
 * DCOC Alpha-C Scaling. This has the same definition as DCOC_ALPHAC_SCALE_IDX.
 * The tracking estimator will switch from DCOC_ALPHAC_SCALE_IDX to
 * DCOC_ALPHAC_SCALE_GS_IDX at the time specified by the DCOC_TRK_EST_GS_CNT.
 *
 * Values:
 * - 0b00 - 1/2
 * - 0b01 - 1/4
 * - 0b10 - 1/8
 * - 0b11 - 1/16
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_CTRL_DCOC_ALPHAC_SCALE_GS_IDX field. */
#define XCVR_RD_BBF_CTRL_DCOC_ALPHAC_SCALE_GS_IDX(base) ((XCVR_BBF_CTRL_REG(base) & XCVR_BBF_CTRL_DCOC_ALPHAC_SCALE_GS_IDX_MASK) >> XCVR_BBF_CTRL_DCOC_ALPHAC_SCALE_GS_IDX_SHIFT)
#define XCVR_BRD_BBF_CTRL_DCOC_ALPHAC_SCALE_GS_IDX(base) (BME_UBFX32(&XCVR_BBF_CTRL_REG(base), XCVR_BBF_CTRL_DCOC_ALPHAC_SCALE_GS_IDX_SHIFT, XCVR_BBF_CTRL_DCOC_ALPHAC_SCALE_GS_IDX_WIDTH))

/*! @brief Set the DCOC_ALPHAC_SCALE_GS_IDX field to a new value. */
#define XCVR_WR_BBF_CTRL_DCOC_ALPHAC_SCALE_GS_IDX(base, value) (XCVR_RMW_BBF_CTRL(base, XCVR_BBF_CTRL_DCOC_ALPHAC_SCALE_GS_IDX_MASK, XCVR_BBF_CTRL_DCOC_ALPHAC_SCALE_GS_IDX(value)))
#define XCVR_BWR_BBF_CTRL_DCOC_ALPHAC_SCALE_GS_IDX(base, value) (BME_BFI32(&XCVR_BBF_CTRL_REG(base), ((uint32_t)(value) << XCVR_BBF_CTRL_DCOC_ALPHAC_SCALE_GS_IDX_SHIFT), XCVR_BBF_CTRL_DCOC_ALPHAC_SCALE_GS_IDX_SHIFT, XCVR_BBF_CTRL_DCOC_ALPHAC_SCALE_GS_IDX_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BBF_CTRL, field BBF_SPARE_3_2[15:14] (RW)
 *
 * Spare Bits for future use
 */
/*@{*/
/*! @brief Read current value of the XCVR_BBF_CTRL_BBF_SPARE_3_2 field. */
#define XCVR_RD_BBF_CTRL_BBF_SPARE_3_2(base) ((XCVR_BBF_CTRL_REG(base) & XCVR_BBF_CTRL_BBF_SPARE_3_2_MASK) >> XCVR_BBF_CTRL_BBF_SPARE_3_2_SHIFT)
#define XCVR_BRD_BBF_CTRL_BBF_SPARE_3_2(base) (BME_UBFX32(&XCVR_BBF_CTRL_REG(base), XCVR_BBF_CTRL_BBF_SPARE_3_2_SHIFT, XCVR_BBF_CTRL_BBF_SPARE_3_2_WIDTH))

/*! @brief Set the BBF_SPARE_3_2 field to a new value. */
#define XCVR_WR_BBF_CTRL_BBF_SPARE_3_2(base, value) (XCVR_RMW_BBF_CTRL(base, XCVR_BBF_CTRL_BBF_SPARE_3_2_MASK, XCVR_BBF_CTRL_BBF_SPARE_3_2(value)))
#define XCVR_BWR_BBF_CTRL_BBF_SPARE_3_2(base, value) (BME_BFI32(&XCVR_BBF_CTRL_REG(base), ((uint32_t)(value) << XCVR_BBF_CTRL_BBF_SPARE_3_2_SHIFT), XCVR_BBF_CTRL_BBF_SPARE_3_2_SHIFT, XCVR_BBF_CTRL_BBF_SPARE_3_2_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_RX_ANA_CTRL - RX Analog Control
 ******************************************************************************/

/*!
 * @brief XCVR_RX_ANA_CTRL - RX Analog Control (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_RX_ANA_CTRL register
 */
/*@{*/
#define XCVR_RD_RX_ANA_CTRL(base) (XCVR_RX_ANA_CTRL_REG(base))
#define XCVR_WR_RX_ANA_CTRL(base, value) (XCVR_RX_ANA_CTRL_REG(base) = (value))
#define XCVR_RMW_RX_ANA_CTRL(base, mask, value) (XCVR_WR_RX_ANA_CTRL(base, (XCVR_RD_RX_ANA_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_RX_ANA_CTRL(base, value) (BME_OR32(&XCVR_RX_ANA_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_RX_ANA_CTRL(base, value) (BME_AND32(&XCVR_RX_ANA_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_RX_ANA_CTRL(base, value) (BME_XOR32(&XCVR_RX_ANA_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_RX_ANA_CTRL bitfields
 */

/*!
 * @name Register XCVR_RX_ANA_CTRL, field RX_ATST_SEL[3:0] (RW)
 *
 * These bits select the different internal baseband signals to be made
 * available on the ATST bus. The following table indicates the specific connection. All
 * other combinations are not defined. The bit bbf_tmux_on BBF_TMUX_ONBBF_TMUX_ON
 * needs to be enabled for the test mode to work. rx_atst_sel ATST0 ATST1 ATST2
 * ATST3 0000 half supply voltage bbf opamp common mode voltatge bbf_I_out
 * bbf_I_ouxt 0001 bba_dcoc_I bba_dcoc_Ix bba_dcoc_Q bba_dcoc_Qx 0010 tza_out_I
 * tza_out_Ix tza_out_Q tza_out_Qx 0011 peak det ref hi peak det ref lo peak det bias
 * check tza common mode 0100 bbf_out_I bbf_out_Ix bbf_out_Q bbf_out_Qx 0101
 * tza_dcoc_I tza_dcoc_Ix tza_dcoc_Q tza_dcoc_Qx 0101 tza_in_I tza_in_Ix tza_out_I
 * tza_out_Ix
 */
/*@{*/
/*! @brief Read current value of the XCVR_RX_ANA_CTRL_RX_ATST_SEL field. */
#define XCVR_RD_RX_ANA_CTRL_RX_ATST_SEL(base) ((XCVR_RX_ANA_CTRL_REG(base) & XCVR_RX_ANA_CTRL_RX_ATST_SEL_MASK) >> XCVR_RX_ANA_CTRL_RX_ATST_SEL_SHIFT)
#define XCVR_BRD_RX_ANA_CTRL_RX_ATST_SEL(base) (BME_UBFX32(&XCVR_RX_ANA_CTRL_REG(base), XCVR_RX_ANA_CTRL_RX_ATST_SEL_SHIFT, XCVR_RX_ANA_CTRL_RX_ATST_SEL_WIDTH))

/*! @brief Set the RX_ATST_SEL field to a new value. */
#define XCVR_WR_RX_ANA_CTRL_RX_ATST_SEL(base, value) (XCVR_RMW_RX_ANA_CTRL(base, XCVR_RX_ANA_CTRL_RX_ATST_SEL_MASK, XCVR_RX_ANA_CTRL_RX_ATST_SEL(value)))
#define XCVR_BWR_RX_ANA_CTRL_RX_ATST_SEL(base, value) (BME_BFI32(&XCVR_RX_ANA_CTRL_REG(base), ((uint32_t)(value) << XCVR_RX_ANA_CTRL_RX_ATST_SEL_SHIFT), XCVR_RX_ANA_CTRL_RX_ATST_SEL_SHIFT, XCVR_RX_ANA_CTRL_RX_ATST_SEL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RX_ANA_CTRL, field IQMC_DC_GAIN_ADJ_EN[4] (RW)
 *
 * If set, the I/Q mismatch uses IQMC_DC_GAIN_ADJ during DCOC calibration. If
 * clear, the I/Q mismatch uses IQMC_GAIN_ADJ.
 */
/*@{*/
/*! @brief Read current value of the XCVR_RX_ANA_CTRL_IQMC_DC_GAIN_ADJ_EN field. */
#define XCVR_RD_RX_ANA_CTRL_IQMC_DC_GAIN_ADJ_EN(base) ((XCVR_RX_ANA_CTRL_REG(base) & XCVR_RX_ANA_CTRL_IQMC_DC_GAIN_ADJ_EN_MASK) >> XCVR_RX_ANA_CTRL_IQMC_DC_GAIN_ADJ_EN_SHIFT)
#define XCVR_BRD_RX_ANA_CTRL_IQMC_DC_GAIN_ADJ_EN(base) (BME_UBFX32(&XCVR_RX_ANA_CTRL_REG(base), XCVR_RX_ANA_CTRL_IQMC_DC_GAIN_ADJ_EN_SHIFT, XCVR_RX_ANA_CTRL_IQMC_DC_GAIN_ADJ_EN_WIDTH))

/*! @brief Set the IQMC_DC_GAIN_ADJ_EN field to a new value. */
#define XCVR_WR_RX_ANA_CTRL_IQMC_DC_GAIN_ADJ_EN(base, value) (XCVR_RMW_RX_ANA_CTRL(base, XCVR_RX_ANA_CTRL_IQMC_DC_GAIN_ADJ_EN_MASK, XCVR_RX_ANA_CTRL_IQMC_DC_GAIN_ADJ_EN(value)))
#define XCVR_BWR_RX_ANA_CTRL_IQMC_DC_GAIN_ADJ_EN(base, value) (BME_BFI32(&XCVR_RX_ANA_CTRL_REG(base), ((uint32_t)(value) << XCVR_RX_ANA_CTRL_IQMC_DC_GAIN_ADJ_EN_SHIFT), XCVR_RX_ANA_CTRL_IQMC_DC_GAIN_ADJ_EN_SHIFT, XCVR_RX_ANA_CTRL_IQMC_DC_GAIN_ADJ_EN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_RX_ANA_CTRL, field LNM_SPARE_3_2_1[7:5] (RW)
 *
 * Spare Bits for future use
 */
/*@{*/
/*! @brief Read current value of the XCVR_RX_ANA_CTRL_LNM_SPARE_3_2_1 field. */
#define XCVR_RD_RX_ANA_CTRL_LNM_SPARE_3_2_1(base) ((XCVR_RX_ANA_CTRL_REG(base) & XCVR_RX_ANA_CTRL_LNM_SPARE_3_2_1_MASK) >> XCVR_RX_ANA_CTRL_LNM_SPARE_3_2_1_SHIFT)
#define XCVR_BRD_RX_ANA_CTRL_LNM_SPARE_3_2_1(base) (BME_UBFX32(&XCVR_RX_ANA_CTRL_REG(base), XCVR_RX_ANA_CTRL_LNM_SPARE_3_2_1_SHIFT, XCVR_RX_ANA_CTRL_LNM_SPARE_3_2_1_WIDTH))

/*! @brief Set the LNM_SPARE_3_2_1 field to a new value. */
#define XCVR_WR_RX_ANA_CTRL_LNM_SPARE_3_2_1(base, value) (XCVR_RMW_RX_ANA_CTRL(base, XCVR_RX_ANA_CTRL_LNM_SPARE_3_2_1_MASK, XCVR_RX_ANA_CTRL_LNM_SPARE_3_2_1(value)))
#define XCVR_BWR_RX_ANA_CTRL_LNM_SPARE_3_2_1(base, value) (BME_BFI32(&XCVR_RX_ANA_CTRL_REG(base), ((uint32_t)(value) << XCVR_RX_ANA_CTRL_LNM_SPARE_3_2_1_SHIFT), XCVR_RX_ANA_CTRL_LNM_SPARE_3_2_1_SHIFT, XCVR_RX_ANA_CTRL_LNM_SPARE_3_2_1_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_XTAL_CTRL - Crystal Oscillator Control Register 1
 ******************************************************************************/

/*!
 * @brief XCVR_XTAL_CTRL - Crystal Oscillator Control Register 1 (RW)
 *
 * Reset value: 0x0ACAC177U
 */
/*!
 * @name Constants and macros for entire XCVR_XTAL_CTRL register
 */
/*@{*/
#define XCVR_RD_XTAL_CTRL(base)  (XCVR_XTAL_CTRL_REG(base))
#define XCVR_WR_XTAL_CTRL(base, value) (XCVR_XTAL_CTRL_REG(base) = (value))
#define XCVR_RMW_XTAL_CTRL(base, mask, value) (XCVR_WR_XTAL_CTRL(base, (XCVR_RD_XTAL_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_XTAL_CTRL(base, value) (BME_OR32(&XCVR_XTAL_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_XTAL_CTRL(base, value) (BME_AND32(&XCVR_XTAL_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_XTAL_CTRL(base, value) (BME_XOR32(&XCVR_XTAL_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_XTAL_CTRL bitfields
 */

/*!
 * @name Register XCVR_XTAL_CTRL, field XTAL_TRIM[7:0] (RW)
 *
 * Program the internal capacitor banks to trim the 32M Crytstal frequency. It
 * has a trim range of ~2Khz
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL_XTAL_TRIM field. */
#define XCVR_RD_XTAL_CTRL_XTAL_TRIM(base) ((XCVR_XTAL_CTRL_REG(base) & XCVR_XTAL_CTRL_XTAL_TRIM_MASK) >> XCVR_XTAL_CTRL_XTAL_TRIM_SHIFT)
#define XCVR_BRD_XTAL_CTRL_XTAL_TRIM(base) (BME_UBFX32(&XCVR_XTAL_CTRL_REG(base), XCVR_XTAL_CTRL_XTAL_TRIM_SHIFT, XCVR_XTAL_CTRL_XTAL_TRIM_WIDTH))

/*! @brief Set the XTAL_TRIM field to a new value. */
#define XCVR_WR_XTAL_CTRL_XTAL_TRIM(base, value) (XCVR_RMW_XTAL_CTRL(base, XCVR_XTAL_CTRL_XTAL_TRIM_MASK, XCVR_XTAL_CTRL_XTAL_TRIM(value)))
#define XCVR_BWR_XTAL_CTRL_XTAL_TRIM(base, value) (BME_BFI32(&XCVR_XTAL_CTRL_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL_XTAL_TRIM_SHIFT), XCVR_XTAL_CTRL_XTAL_TRIM_SHIFT, XCVR_XTAL_CTRL_XTAL_TRIM_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_XTAL_CTRL, field XTAL_GM[12:8] (RW)
 *
 * This is used adjust the gm of the Crystal core. All 0's is minimum gm and all
 * 1's is maximum gm
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL_XTAL_GM field. */
#define XCVR_RD_XTAL_CTRL_XTAL_GM(base) ((XCVR_XTAL_CTRL_REG(base) & XCVR_XTAL_CTRL_XTAL_GM_MASK) >> XCVR_XTAL_CTRL_XTAL_GM_SHIFT)
#define XCVR_BRD_XTAL_CTRL_XTAL_GM(base) (BME_UBFX32(&XCVR_XTAL_CTRL_REG(base), XCVR_XTAL_CTRL_XTAL_GM_SHIFT, XCVR_XTAL_CTRL_XTAL_GM_WIDTH))

/*! @brief Set the XTAL_GM field to a new value. */
#define XCVR_WR_XTAL_CTRL_XTAL_GM(base, value) (XCVR_RMW_XTAL_CTRL(base, XCVR_XTAL_CTRL_XTAL_GM_MASK, XCVR_XTAL_CTRL_XTAL_GM(value)))
#define XCVR_BWR_XTAL_CTRL_XTAL_GM(base, value) (BME_BFI32(&XCVR_XTAL_CTRL_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL_XTAL_GM_SHIFT), XCVR_XTAL_CTRL_XTAL_GM_SHIFT, XCVR_XTAL_CTRL_XTAL_GM_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_XTAL_CTRL, field XTAL_BYPASS[13] (RW)
 *
 * When this bit is set, the Crystal Oscillator is disabled and an external
 * clock signal applied on the EXTAL pin is selected as the clock source.
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL_XTAL_BYPASS field. */
#define XCVR_RD_XTAL_CTRL_XTAL_BYPASS(base) ((XCVR_XTAL_CTRL_REG(base) & XCVR_XTAL_CTRL_XTAL_BYPASS_MASK) >> XCVR_XTAL_CTRL_XTAL_BYPASS_SHIFT)
#define XCVR_BRD_XTAL_CTRL_XTAL_BYPASS(base) (BME_UBFX32(&XCVR_XTAL_CTRL_REG(base), XCVR_XTAL_CTRL_XTAL_BYPASS_SHIFT, XCVR_XTAL_CTRL_XTAL_BYPASS_WIDTH))

/*! @brief Set the XTAL_BYPASS field to a new value. */
#define XCVR_WR_XTAL_CTRL_XTAL_BYPASS(base, value) (XCVR_RMW_XTAL_CTRL(base, XCVR_XTAL_CTRL_XTAL_BYPASS_MASK, XCVR_XTAL_CTRL_XTAL_BYPASS(value)))
#define XCVR_BWR_XTAL_CTRL_XTAL_BYPASS(base, value) (BME_BFI32(&XCVR_XTAL_CTRL_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL_XTAL_BYPASS_SHIFT), XCVR_XTAL_CTRL_XTAL_BYPASS_SHIFT, XCVR_XTAL_CTRL_XTAL_BYPASS_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_XTAL_CTRL, field XTAL_READY_COUNT_SEL[15:14] (RW)
 *
 * This selects the number of count cycles before xtal_ready goes high
 *
 * Values:
 * - 0b00 - 1024 clock cycles
 * - 0b01 - 2048 clock cycles
 * - 0b10 - 4096 clock cycles
 * - 0b11 - 8192 clock cycles
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL_XTAL_READY_COUNT_SEL field. */
#define XCVR_RD_XTAL_CTRL_XTAL_READY_COUNT_SEL(base) ((XCVR_XTAL_CTRL_REG(base) & XCVR_XTAL_CTRL_XTAL_READY_COUNT_SEL_MASK) >> XCVR_XTAL_CTRL_XTAL_READY_COUNT_SEL_SHIFT)
#define XCVR_BRD_XTAL_CTRL_XTAL_READY_COUNT_SEL(base) (BME_UBFX32(&XCVR_XTAL_CTRL_REG(base), XCVR_XTAL_CTRL_XTAL_READY_COUNT_SEL_SHIFT, XCVR_XTAL_CTRL_XTAL_READY_COUNT_SEL_WIDTH))

/*! @brief Set the XTAL_READY_COUNT_SEL field to a new value. */
#define XCVR_WR_XTAL_CTRL_XTAL_READY_COUNT_SEL(base, value) (XCVR_RMW_XTAL_CTRL(base, XCVR_XTAL_CTRL_XTAL_READY_COUNT_SEL_MASK, XCVR_XTAL_CTRL_XTAL_READY_COUNT_SEL(value)))
#define XCVR_BWR_XTAL_CTRL_XTAL_READY_COUNT_SEL(base, value) (BME_BFI32(&XCVR_XTAL_CTRL_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL_XTAL_READY_COUNT_SEL_SHIFT), XCVR_XTAL_CTRL_XTAL_READY_COUNT_SEL_SHIFT, XCVR_XTAL_CTRL_XTAL_READY_COUNT_SEL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_XTAL_CTRL, field XTAL_COMP_BIAS_LO[20:16] (RW)
 *
 * These bits used to adjust the bias of the crystal Comparator when the
 * transceiver is IDLE
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL_XTAL_COMP_BIAS_LO field. */
#define XCVR_RD_XTAL_CTRL_XTAL_COMP_BIAS_LO(base) ((XCVR_XTAL_CTRL_REG(base) & XCVR_XTAL_CTRL_XTAL_COMP_BIAS_LO_MASK) >> XCVR_XTAL_CTRL_XTAL_COMP_BIAS_LO_SHIFT)
#define XCVR_BRD_XTAL_CTRL_XTAL_COMP_BIAS_LO(base) (BME_UBFX32(&XCVR_XTAL_CTRL_REG(base), XCVR_XTAL_CTRL_XTAL_COMP_BIAS_LO_SHIFT, XCVR_XTAL_CTRL_XTAL_COMP_BIAS_LO_WIDTH))

/*! @brief Set the XTAL_COMP_BIAS_LO field to a new value. */
#define XCVR_WR_XTAL_CTRL_XTAL_COMP_BIAS_LO(base, value) (XCVR_RMW_XTAL_CTRL(base, XCVR_XTAL_CTRL_XTAL_COMP_BIAS_LO_MASK, XCVR_XTAL_CTRL_XTAL_COMP_BIAS_LO(value)))
#define XCVR_BWR_XTAL_CTRL_XTAL_COMP_BIAS_LO(base, value) (BME_BFI32(&XCVR_XTAL_CTRL_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL_XTAL_COMP_BIAS_LO_SHIFT), XCVR_XTAL_CTRL_XTAL_COMP_BIAS_LO_SHIFT, XCVR_XTAL_CTRL_XTAL_COMP_BIAS_LO_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_XTAL_CTRL, field XTAL_ALC_START_512U[22] (RW)
 *
 * Values:
 * - 0b0 - Start XTAL ALC at 256usec
 * - 0b1 - Start XTAL ALC at 512usec
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL_XTAL_ALC_START_512U field. */
#define XCVR_RD_XTAL_CTRL_XTAL_ALC_START_512U(base) ((XCVR_XTAL_CTRL_REG(base) & XCVR_XTAL_CTRL_XTAL_ALC_START_512U_MASK) >> XCVR_XTAL_CTRL_XTAL_ALC_START_512U_SHIFT)
#define XCVR_BRD_XTAL_CTRL_XTAL_ALC_START_512U(base) (BME_UBFX32(&XCVR_XTAL_CTRL_REG(base), XCVR_XTAL_CTRL_XTAL_ALC_START_512U_SHIFT, XCVR_XTAL_CTRL_XTAL_ALC_START_512U_WIDTH))

/*! @brief Set the XTAL_ALC_START_512U field to a new value. */
#define XCVR_WR_XTAL_CTRL_XTAL_ALC_START_512U(base, value) (XCVR_RMW_XTAL_CTRL(base, XCVR_XTAL_CTRL_XTAL_ALC_START_512U_MASK, XCVR_XTAL_CTRL_XTAL_ALC_START_512U(value)))
#define XCVR_BWR_XTAL_CTRL_XTAL_ALC_START_512U(base, value) (BME_BFI32(&XCVR_XTAL_CTRL_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL_XTAL_ALC_START_512U_SHIFT), XCVR_XTAL_CTRL_XTAL_ALC_START_512U_SHIFT, XCVR_XTAL_CTRL_XTAL_ALC_START_512U_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_XTAL_CTRL, field XTAL_ALC_ON[23] (RW)
 *
 * enable the ALC for the xtal
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL_XTAL_ALC_ON field. */
#define XCVR_RD_XTAL_CTRL_XTAL_ALC_ON(base) ((XCVR_XTAL_CTRL_REG(base) & XCVR_XTAL_CTRL_XTAL_ALC_ON_MASK) >> XCVR_XTAL_CTRL_XTAL_ALC_ON_SHIFT)
#define XCVR_BRD_XTAL_CTRL_XTAL_ALC_ON(base) (BME_UBFX32(&XCVR_XTAL_CTRL_REG(base), XCVR_XTAL_CTRL_XTAL_ALC_ON_SHIFT, XCVR_XTAL_CTRL_XTAL_ALC_ON_WIDTH))

/*! @brief Set the XTAL_ALC_ON field to a new value. */
#define XCVR_WR_XTAL_CTRL_XTAL_ALC_ON(base, value) (XCVR_RMW_XTAL_CTRL(base, XCVR_XTAL_CTRL_XTAL_ALC_ON_MASK, XCVR_XTAL_CTRL_XTAL_ALC_ON(value)))
#define XCVR_BWR_XTAL_CTRL_XTAL_ALC_ON(base, value) (BME_BFI32(&XCVR_XTAL_CTRL_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL_XTAL_ALC_ON_SHIFT), XCVR_XTAL_CTRL_XTAL_ALC_ON_SHIFT, XCVR_XTAL_CTRL_XTAL_ALC_ON_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_XTAL_CTRL, field XTAL_COMP_BIAS_HI[28:24] (RW)
 *
 * These bits used to adjust the bias of the crystal Comparator when the
 * transceiver is ACTIVE
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL_XTAL_COMP_BIAS_HI field. */
#define XCVR_RD_XTAL_CTRL_XTAL_COMP_BIAS_HI(base) ((XCVR_XTAL_CTRL_REG(base) & XCVR_XTAL_CTRL_XTAL_COMP_BIAS_HI_MASK) >> XCVR_XTAL_CTRL_XTAL_COMP_BIAS_HI_SHIFT)
#define XCVR_BRD_XTAL_CTRL_XTAL_COMP_BIAS_HI(base) (BME_UBFX32(&XCVR_XTAL_CTRL_REG(base), XCVR_XTAL_CTRL_XTAL_COMP_BIAS_HI_SHIFT, XCVR_XTAL_CTRL_XTAL_COMP_BIAS_HI_WIDTH))

/*! @brief Set the XTAL_COMP_BIAS_HI field to a new value. */
#define XCVR_WR_XTAL_CTRL_XTAL_COMP_BIAS_HI(base, value) (XCVR_RMW_XTAL_CTRL(base, XCVR_XTAL_CTRL_XTAL_COMP_BIAS_HI_MASK, XCVR_XTAL_CTRL_XTAL_COMP_BIAS_HI(value)))
#define XCVR_BWR_XTAL_CTRL_XTAL_COMP_BIAS_HI(base, value) (BME_BFI32(&XCVR_XTAL_CTRL_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL_XTAL_COMP_BIAS_HI_SHIFT), XCVR_XTAL_CTRL_XTAL_COMP_BIAS_HI_SHIFT, XCVR_XTAL_CTRL_XTAL_COMP_BIAS_HI_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_XTAL_CTRL, field XTAL_READY[31] (RO)
 *
 * The signal goes high after a number of cycles determined by
 * xtal_ready_count_sel
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL_XTAL_READY field. */
#define XCVR_RD_XTAL_CTRL_XTAL_READY(base) ((XCVR_XTAL_CTRL_REG(base) & XCVR_XTAL_CTRL_XTAL_READY_MASK) >> XCVR_XTAL_CTRL_XTAL_READY_SHIFT)
#define XCVR_BRD_XTAL_CTRL_XTAL_READY(base) (BME_UBFX32(&XCVR_XTAL_CTRL_REG(base), XCVR_XTAL_CTRL_XTAL_READY_SHIFT, XCVR_XTAL_CTRL_XTAL_READY_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_XTAL_CTRL2 - Crystal Oscillator Control Register 2
 ******************************************************************************/

/*!
 * @brief XCVR_XTAL_CTRL2 - Crystal Oscillator Control Register 2 (RW)
 *
 * Reset value: 0x00001000U
 */
/*!
 * @name Constants and macros for entire XCVR_XTAL_CTRL2 register
 */
/*@{*/
#define XCVR_RD_XTAL_CTRL2(base) (XCVR_XTAL_CTRL2_REG(base))
#define XCVR_WR_XTAL_CTRL2(base, value) (XCVR_XTAL_CTRL2_REG(base) = (value))
#define XCVR_RMW_XTAL_CTRL2(base, mask, value) (XCVR_WR_XTAL_CTRL2(base, (XCVR_RD_XTAL_CTRL2(base) & ~(mask)) | (value)))
#define XCVR_SET_XTAL_CTRL2(base, value) (BME_OR32(&XCVR_XTAL_CTRL2_REG(base), (uint32_t)(value)))
#define XCVR_CLR_XTAL_CTRL2(base, value) (BME_AND32(&XCVR_XTAL_CTRL2_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_XTAL_CTRL2(base, value) (BME_XOR32(&XCVR_XTAL_CTRL2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_XTAL_CTRL2 bitfields
 */

/*!
 * @name Register XCVR_XTAL_CTRL2, field XTAL_REG_SUPPLY[3:0] (RW)
 *
 * Regulator trim bit to change the outputvoltage from 1.05 to 1.4V
 *
 * Values:
 * - 0b0000 - 1.2V
 * - 0b0001 - 1.05V
 * - 0b0010 - 1.275V
 * - 0b0011 - 1.3V
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL2_XTAL_REG_SUPPLY field. */
#define XCVR_RD_XTAL_CTRL2_XTAL_REG_SUPPLY(base) ((XCVR_XTAL_CTRL2_REG(base) & XCVR_XTAL_CTRL2_XTAL_REG_SUPPLY_MASK) >> XCVR_XTAL_CTRL2_XTAL_REG_SUPPLY_SHIFT)
#define XCVR_BRD_XTAL_CTRL2_XTAL_REG_SUPPLY(base) (BME_UBFX32(&XCVR_XTAL_CTRL2_REG(base), XCVR_XTAL_CTRL2_XTAL_REG_SUPPLY_SHIFT, XCVR_XTAL_CTRL2_XTAL_REG_SUPPLY_WIDTH))

/*! @brief Set the XTAL_REG_SUPPLY field to a new value. */
#define XCVR_WR_XTAL_CTRL2_XTAL_REG_SUPPLY(base, value) (XCVR_RMW_XTAL_CTRL2(base, XCVR_XTAL_CTRL2_XTAL_REG_SUPPLY_MASK, XCVR_XTAL_CTRL2_XTAL_REG_SUPPLY(value)))
#define XCVR_BWR_XTAL_CTRL2_XTAL_REG_SUPPLY(base, value) (BME_BFI32(&XCVR_XTAL_CTRL2_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL2_XTAL_REG_SUPPLY_SHIFT), XCVR_XTAL_CTRL2_XTAL_REG_SUPPLY_SHIFT, XCVR_XTAL_CTRL2_XTAL_REG_SUPPLY_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_XTAL_CTRL2, field XTAL_REG_BYPASS_ON[4] (RW)
 *
 * This register bit determines if the regulator is in bypass mode. When in
 * bypass mode, the external voltage applied to the input of the regulator is
 * presented at the regulator output.
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL2_XTAL_REG_BYPASS_ON field. */
#define XCVR_RD_XTAL_CTRL2_XTAL_REG_BYPASS_ON(base) ((XCVR_XTAL_CTRL2_REG(base) & XCVR_XTAL_CTRL2_XTAL_REG_BYPASS_ON_MASK) >> XCVR_XTAL_CTRL2_XTAL_REG_BYPASS_ON_SHIFT)
#define XCVR_BRD_XTAL_CTRL2_XTAL_REG_BYPASS_ON(base) (BME_UBFX32(&XCVR_XTAL_CTRL2_REG(base), XCVR_XTAL_CTRL2_XTAL_REG_BYPASS_ON_SHIFT, XCVR_XTAL_CTRL2_XTAL_REG_BYPASS_ON_WIDTH))

/*! @brief Set the XTAL_REG_BYPASS_ON field to a new value. */
#define XCVR_WR_XTAL_CTRL2_XTAL_REG_BYPASS_ON(base, value) (XCVR_RMW_XTAL_CTRL2(base, XCVR_XTAL_CTRL2_XTAL_REG_BYPASS_ON_MASK, XCVR_XTAL_CTRL2_XTAL_REG_BYPASS_ON(value)))
#define XCVR_BWR_XTAL_CTRL2_XTAL_REG_BYPASS_ON(base, value) (BME_BFI32(&XCVR_XTAL_CTRL2_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL2_XTAL_REG_BYPASS_ON_SHIFT), XCVR_XTAL_CTRL2_XTAL_REG_BYPASS_ON_SHIFT, XCVR_XTAL_CTRL2_XTAL_REG_BYPASS_ON_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_XTAL_CTRL2, field XTAL_REG_ON_OVRD_ON[8] (RW)
 *
 * Mux select for the crystal regulator enable between normal operation (0) and
 * test mode (1). The test signal is called xtal_reg_on_ovrd
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD_ON field. */
#define XCVR_RD_XTAL_CTRL2_XTAL_REG_ON_OVRD_ON(base) ((XCVR_XTAL_CTRL2_REG(base) & XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD_ON_MASK) >> XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD_ON_SHIFT)
#define XCVR_BRD_XTAL_CTRL2_XTAL_REG_ON_OVRD_ON(base) (BME_UBFX32(&XCVR_XTAL_CTRL2_REG(base), XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD_ON_SHIFT, XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD_ON_WIDTH))

/*! @brief Set the XTAL_REG_ON_OVRD_ON field to a new value. */
#define XCVR_WR_XTAL_CTRL2_XTAL_REG_ON_OVRD_ON(base, value) (XCVR_RMW_XTAL_CTRL2(base, XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD_ON_MASK, XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD_ON(value)))
#define XCVR_BWR_XTAL_CTRL2_XTAL_REG_ON_OVRD_ON(base, value) (BME_BFI32(&XCVR_XTAL_CTRL2_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD_ON_SHIFT), XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD_ON_SHIFT, XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD_ON_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_XTAL_CTRL2, field XTAL_REG_ON_OVRD[9] (RW)
 *
 * Enable for the xtal regulator in test mode (XTAL_REG_ON_OVRD_ON=1)
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD field. */
#define XCVR_RD_XTAL_CTRL2_XTAL_REG_ON_OVRD(base) ((XCVR_XTAL_CTRL2_REG(base) & XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD_MASK) >> XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD_SHIFT)
#define XCVR_BRD_XTAL_CTRL2_XTAL_REG_ON_OVRD(base) (BME_UBFX32(&XCVR_XTAL_CTRL2_REG(base), XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD_SHIFT, XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD_WIDTH))

/*! @brief Set the XTAL_REG_ON_OVRD field to a new value. */
#define XCVR_WR_XTAL_CTRL2_XTAL_REG_ON_OVRD(base, value) (XCVR_RMW_XTAL_CTRL2(base, XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD_MASK, XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD(value)))
#define XCVR_BWR_XTAL_CTRL2_XTAL_REG_ON_OVRD(base, value) (BME_BFI32(&XCVR_XTAL_CTRL2_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD_SHIFT), XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD_SHIFT, XCVR_XTAL_CTRL2_XTAL_REG_ON_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_XTAL_CTRL2, field XTAL_ON_OVRD_ON[10] (RW)
 *
 * mux select for the crystal enable between normal operation (0) and test mode
 * (1)
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL2_XTAL_ON_OVRD_ON field. */
#define XCVR_RD_XTAL_CTRL2_XTAL_ON_OVRD_ON(base) ((XCVR_XTAL_CTRL2_REG(base) & XCVR_XTAL_CTRL2_XTAL_ON_OVRD_ON_MASK) >> XCVR_XTAL_CTRL2_XTAL_ON_OVRD_ON_SHIFT)
#define XCVR_BRD_XTAL_CTRL2_XTAL_ON_OVRD_ON(base) (BME_UBFX32(&XCVR_XTAL_CTRL2_REG(base), XCVR_XTAL_CTRL2_XTAL_ON_OVRD_ON_SHIFT, XCVR_XTAL_CTRL2_XTAL_ON_OVRD_ON_WIDTH))

/*! @brief Set the XTAL_ON_OVRD_ON field to a new value. */
#define XCVR_WR_XTAL_CTRL2_XTAL_ON_OVRD_ON(base, value) (XCVR_RMW_XTAL_CTRL2(base, XCVR_XTAL_CTRL2_XTAL_ON_OVRD_ON_MASK, XCVR_XTAL_CTRL2_XTAL_ON_OVRD_ON(value)))
#define XCVR_BWR_XTAL_CTRL2_XTAL_ON_OVRD_ON(base, value) (BME_BFI32(&XCVR_XTAL_CTRL2_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL2_XTAL_ON_OVRD_ON_SHIFT), XCVR_XTAL_CTRL2_XTAL_ON_OVRD_ON_SHIFT, XCVR_XTAL_CTRL2_XTAL_ON_OVRD_ON_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_XTAL_CTRL2, field XTAL_ON_OVRD[11] (RW)
 *
 * enable for the xtal in test mode (XTAL_ON_OVRD_ON=1)
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL2_XTAL_ON_OVRD field. */
#define XCVR_RD_XTAL_CTRL2_XTAL_ON_OVRD(base) ((XCVR_XTAL_CTRL2_REG(base) & XCVR_XTAL_CTRL2_XTAL_ON_OVRD_MASK) >> XCVR_XTAL_CTRL2_XTAL_ON_OVRD_SHIFT)
#define XCVR_BRD_XTAL_CTRL2_XTAL_ON_OVRD(base) (BME_UBFX32(&XCVR_XTAL_CTRL2_REG(base), XCVR_XTAL_CTRL2_XTAL_ON_OVRD_SHIFT, XCVR_XTAL_CTRL2_XTAL_ON_OVRD_WIDTH))

/*! @brief Set the XTAL_ON_OVRD field to a new value. */
#define XCVR_WR_XTAL_CTRL2_XTAL_ON_OVRD(base, value) (XCVR_RMW_XTAL_CTRL2(base, XCVR_XTAL_CTRL2_XTAL_ON_OVRD_MASK, XCVR_XTAL_CTRL2_XTAL_ON_OVRD(value)))
#define XCVR_BWR_XTAL_CTRL2_XTAL_ON_OVRD(base, value) (BME_BFI32(&XCVR_XTAL_CTRL2_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL2_XTAL_ON_OVRD_SHIFT), XCVR_XTAL_CTRL2_XTAL_ON_OVRD_SHIFT, XCVR_XTAL_CTRL2_XTAL_ON_OVRD_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_XTAL_CTRL2, field XTAL_DIG_CLK_OUT_ON[12] (RW)
 *
 * This bit gates the Crystal clock output
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL2_XTAL_DIG_CLK_OUT_ON field. */
#define XCVR_RD_XTAL_CTRL2_XTAL_DIG_CLK_OUT_ON(base) ((XCVR_XTAL_CTRL2_REG(base) & XCVR_XTAL_CTRL2_XTAL_DIG_CLK_OUT_ON_MASK) >> XCVR_XTAL_CTRL2_XTAL_DIG_CLK_OUT_ON_SHIFT)
#define XCVR_BRD_XTAL_CTRL2_XTAL_DIG_CLK_OUT_ON(base) (BME_UBFX32(&XCVR_XTAL_CTRL2_REG(base), XCVR_XTAL_CTRL2_XTAL_DIG_CLK_OUT_ON_SHIFT, XCVR_XTAL_CTRL2_XTAL_DIG_CLK_OUT_ON_WIDTH))

/*! @brief Set the XTAL_DIG_CLK_OUT_ON field to a new value. */
#define XCVR_WR_XTAL_CTRL2_XTAL_DIG_CLK_OUT_ON(base, value) (XCVR_RMW_XTAL_CTRL2(base, XCVR_XTAL_CTRL2_XTAL_DIG_CLK_OUT_ON_MASK, XCVR_XTAL_CTRL2_XTAL_DIG_CLK_OUT_ON(value)))
#define XCVR_BWR_XTAL_CTRL2_XTAL_DIG_CLK_OUT_ON(base, value) (BME_BFI32(&XCVR_XTAL_CTRL2_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL2_XTAL_DIG_CLK_OUT_ON_SHIFT), XCVR_XTAL_CTRL2_XTAL_DIG_CLK_OUT_ON_SHIFT, XCVR_XTAL_CTRL2_XTAL_DIG_CLK_OUT_ON_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_XTAL_CTRL2, field XTAL_REG_ATST_SEL[17:16] (RW)
 *
 * These bits control the what internal regualtor signals are connected to the
 * ATST bus. register setting ATST0 00 No Connect 01 vout 10 vin feedback 11 vbias
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL2_XTAL_REG_ATST_SEL field. */
#define XCVR_RD_XTAL_CTRL2_XTAL_REG_ATST_SEL(base) ((XCVR_XTAL_CTRL2_REG(base) & XCVR_XTAL_CTRL2_XTAL_REG_ATST_SEL_MASK) >> XCVR_XTAL_CTRL2_XTAL_REG_ATST_SEL_SHIFT)
#define XCVR_BRD_XTAL_CTRL2_XTAL_REG_ATST_SEL(base) (BME_UBFX32(&XCVR_XTAL_CTRL2_REG(base), XCVR_XTAL_CTRL2_XTAL_REG_ATST_SEL_SHIFT, XCVR_XTAL_CTRL2_XTAL_REG_ATST_SEL_WIDTH))

/*! @brief Set the XTAL_REG_ATST_SEL field to a new value. */
#define XCVR_WR_XTAL_CTRL2_XTAL_REG_ATST_SEL(base, value) (XCVR_RMW_XTAL_CTRL2(base, XCVR_XTAL_CTRL2_XTAL_REG_ATST_SEL_MASK, XCVR_XTAL_CTRL2_XTAL_REG_ATST_SEL(value)))
#define XCVR_BWR_XTAL_CTRL2_XTAL_REG_ATST_SEL(base, value) (BME_BFI32(&XCVR_XTAL_CTRL2_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL2_XTAL_REG_ATST_SEL_SHIFT), XCVR_XTAL_CTRL2_XTAL_REG_ATST_SEL_SHIFT, XCVR_XTAL_CTRL2_XTAL_REG_ATST_SEL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_XTAL_CTRL2, field XTAL_ATST_SEL[25:24] (RW)
 *
 * These bits are not used in this version of the chip. Since only one signal is
 * brought out for test purposes, xtal_atst_on is used as the enable and sel
 * signal
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL2_XTAL_ATST_SEL field. */
#define XCVR_RD_XTAL_CTRL2_XTAL_ATST_SEL(base) ((XCVR_XTAL_CTRL2_REG(base) & XCVR_XTAL_CTRL2_XTAL_ATST_SEL_MASK) >> XCVR_XTAL_CTRL2_XTAL_ATST_SEL_SHIFT)
#define XCVR_BRD_XTAL_CTRL2_XTAL_ATST_SEL(base) (BME_UBFX32(&XCVR_XTAL_CTRL2_REG(base), XCVR_XTAL_CTRL2_XTAL_ATST_SEL_SHIFT, XCVR_XTAL_CTRL2_XTAL_ATST_SEL_WIDTH))

/*! @brief Set the XTAL_ATST_SEL field to a new value. */
#define XCVR_WR_XTAL_CTRL2_XTAL_ATST_SEL(base, value) (XCVR_RMW_XTAL_CTRL2(base, XCVR_XTAL_CTRL2_XTAL_ATST_SEL_MASK, XCVR_XTAL_CTRL2_XTAL_ATST_SEL(value)))
#define XCVR_BWR_XTAL_CTRL2_XTAL_ATST_SEL(base, value) (BME_BFI32(&XCVR_XTAL_CTRL2_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL2_XTAL_ATST_SEL_SHIFT), XCVR_XTAL_CTRL2_XTAL_ATST_SEL_SHIFT, XCVR_XTAL_CTRL2_XTAL_ATST_SEL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_XTAL_CTRL2, field XTAL_ATST_ON[26] (RW)
 *
 * This is the test mode for the xtal block. When this bit is set 32M clock is
 * put on ATST2
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL2_XTAL_ATST_ON field. */
#define XCVR_RD_XTAL_CTRL2_XTAL_ATST_ON(base) ((XCVR_XTAL_CTRL2_REG(base) & XCVR_XTAL_CTRL2_XTAL_ATST_ON_MASK) >> XCVR_XTAL_CTRL2_XTAL_ATST_ON_SHIFT)
#define XCVR_BRD_XTAL_CTRL2_XTAL_ATST_ON(base) (BME_UBFX32(&XCVR_XTAL_CTRL2_REG(base), XCVR_XTAL_CTRL2_XTAL_ATST_ON_SHIFT, XCVR_XTAL_CTRL2_XTAL_ATST_ON_WIDTH))

/*! @brief Set the XTAL_ATST_ON field to a new value. */
#define XCVR_WR_XTAL_CTRL2_XTAL_ATST_ON(base, value) (XCVR_RMW_XTAL_CTRL2(base, XCVR_XTAL_CTRL2_XTAL_ATST_ON_MASK, XCVR_XTAL_CTRL2_XTAL_ATST_ON(value)))
#define XCVR_BWR_XTAL_CTRL2_XTAL_ATST_ON(base, value) (BME_BFI32(&XCVR_XTAL_CTRL2_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL2_XTAL_ATST_ON_SHIFT), XCVR_XTAL_CTRL2_XTAL_ATST_ON_SHIFT, XCVR_XTAL_CTRL2_XTAL_ATST_ON_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_XTAL_CTRL2, field XTAL_SPARE[31:28] (RW)
 *
 * Spare Bits for future use
 */
/*@{*/
/*! @brief Read current value of the XCVR_XTAL_CTRL2_XTAL_SPARE field. */
#define XCVR_RD_XTAL_CTRL2_XTAL_SPARE(base) ((XCVR_XTAL_CTRL2_REG(base) & XCVR_XTAL_CTRL2_XTAL_SPARE_MASK) >> XCVR_XTAL_CTRL2_XTAL_SPARE_SHIFT)
#define XCVR_BRD_XTAL_CTRL2_XTAL_SPARE(base) (BME_UBFX32(&XCVR_XTAL_CTRL2_REG(base), XCVR_XTAL_CTRL2_XTAL_SPARE_SHIFT, XCVR_XTAL_CTRL2_XTAL_SPARE_WIDTH))

/*! @brief Set the XTAL_SPARE field to a new value. */
#define XCVR_WR_XTAL_CTRL2_XTAL_SPARE(base, value) (XCVR_RMW_XTAL_CTRL2(base, XCVR_XTAL_CTRL2_XTAL_SPARE_MASK, XCVR_XTAL_CTRL2_XTAL_SPARE(value)))
#define XCVR_BWR_XTAL_CTRL2_XTAL_SPARE(base, value) (BME_BFI32(&XCVR_XTAL_CTRL2_REG(base), ((uint32_t)(value) << XCVR_XTAL_CTRL2_XTAL_SPARE_SHIFT), XCVR_XTAL_CTRL2_XTAL_SPARE_SHIFT, XCVR_XTAL_CTRL2_XTAL_SPARE_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_BGAP_CTRL - Bandgap Control
 ******************************************************************************/

/*!
 * @brief XCVR_BGAP_CTRL - Bandgap Control (RW)
 *
 * Reset value: 0x00000087U
 */
/*!
 * @name Constants and macros for entire XCVR_BGAP_CTRL register
 */
/*@{*/
#define XCVR_RD_BGAP_CTRL(base)  (XCVR_BGAP_CTRL_REG(base))
#define XCVR_WR_BGAP_CTRL(base, value) (XCVR_BGAP_CTRL_REG(base) = (value))
#define XCVR_RMW_BGAP_CTRL(base, mask, value) (XCVR_WR_BGAP_CTRL(base, (XCVR_RD_BGAP_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_BGAP_CTRL(base, value) (BME_OR32(&XCVR_BGAP_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_BGAP_CTRL(base, value) (BME_AND32(&XCVR_BGAP_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_BGAP_CTRL(base, value) (BME_XOR32(&XCVR_BGAP_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_BGAP_CTRL bitfields
 */

/*!
 * @name Register XCVR_BGAP_CTRL, field BGAP_CURRENT_TRIM[3:0] (RW)
 *
 * Trim the 1uA bandgap current
 */
/*@{*/
/*! @brief Read current value of the XCVR_BGAP_CTRL_BGAP_CURRENT_TRIM field. */
#define XCVR_RD_BGAP_CTRL_BGAP_CURRENT_TRIM(base) ((XCVR_BGAP_CTRL_REG(base) & XCVR_BGAP_CTRL_BGAP_CURRENT_TRIM_MASK) >> XCVR_BGAP_CTRL_BGAP_CURRENT_TRIM_SHIFT)
#define XCVR_BRD_BGAP_CTRL_BGAP_CURRENT_TRIM(base) (BME_UBFX32(&XCVR_BGAP_CTRL_REG(base), XCVR_BGAP_CTRL_BGAP_CURRENT_TRIM_SHIFT, XCVR_BGAP_CTRL_BGAP_CURRENT_TRIM_WIDTH))

/*! @brief Set the BGAP_CURRENT_TRIM field to a new value. */
#define XCVR_WR_BGAP_CTRL_BGAP_CURRENT_TRIM(base, value) (XCVR_RMW_BGAP_CTRL(base, XCVR_BGAP_CTRL_BGAP_CURRENT_TRIM_MASK, XCVR_BGAP_CTRL_BGAP_CURRENT_TRIM(value)))
#define XCVR_BWR_BGAP_CTRL_BGAP_CURRENT_TRIM(base, value) (BME_BFI32(&XCVR_BGAP_CTRL_REG(base), ((uint32_t)(value) << XCVR_BGAP_CTRL_BGAP_CURRENT_TRIM_SHIFT), XCVR_BGAP_CTRL_BGAP_CURRENT_TRIM_SHIFT, XCVR_BGAP_CTRL_BGAP_CURRENT_TRIM_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BGAP_CTRL, field BGAP_VOLTAGE_TRIM[7:4] (RW)
 *
 * Trim the bandgap voltage to 1V in 4mV steps
 */
/*@{*/
/*! @brief Read current value of the XCVR_BGAP_CTRL_BGAP_VOLTAGE_TRIM field. */
#define XCVR_RD_BGAP_CTRL_BGAP_VOLTAGE_TRIM(base) ((XCVR_BGAP_CTRL_REG(base) & XCVR_BGAP_CTRL_BGAP_VOLTAGE_TRIM_MASK) >> XCVR_BGAP_CTRL_BGAP_VOLTAGE_TRIM_SHIFT)
#define XCVR_BRD_BGAP_CTRL_BGAP_VOLTAGE_TRIM(base) (BME_UBFX32(&XCVR_BGAP_CTRL_REG(base), XCVR_BGAP_CTRL_BGAP_VOLTAGE_TRIM_SHIFT, XCVR_BGAP_CTRL_BGAP_VOLTAGE_TRIM_WIDTH))

/*! @brief Set the BGAP_VOLTAGE_TRIM field to a new value. */
#define XCVR_WR_BGAP_CTRL_BGAP_VOLTAGE_TRIM(base, value) (XCVR_RMW_BGAP_CTRL(base, XCVR_BGAP_CTRL_BGAP_VOLTAGE_TRIM_MASK, XCVR_BGAP_CTRL_BGAP_VOLTAGE_TRIM(value)))
#define XCVR_BWR_BGAP_CTRL_BGAP_VOLTAGE_TRIM(base, value) (BME_BFI32(&XCVR_BGAP_CTRL_REG(base), ((uint32_t)(value) << XCVR_BGAP_CTRL_BGAP_VOLTAGE_TRIM_SHIFT), XCVR_BGAP_CTRL_BGAP_VOLTAGE_TRIM_SHIFT, XCVR_BGAP_CTRL_BGAP_VOLTAGE_TRIM_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BGAP_CTRL, field BGAP_ATST_SEL[11:8] (RW)
 *
 * Select what internal signals to bring out to ATST bus. bgap_atst_sel ATST2
 * ATST3 0000 1ua Unfiltered bgap Output 0001 2uA Internal X1 node of Bgap 0010 5uA
 * Internal X2 node of Bgap 0011 10uA No Connect 0100 1uA ptat No Connect
 */
/*@{*/
/*! @brief Read current value of the XCVR_BGAP_CTRL_BGAP_ATST_SEL field. */
#define XCVR_RD_BGAP_CTRL_BGAP_ATST_SEL(base) ((XCVR_BGAP_CTRL_REG(base) & XCVR_BGAP_CTRL_BGAP_ATST_SEL_MASK) >> XCVR_BGAP_CTRL_BGAP_ATST_SEL_SHIFT)
#define XCVR_BRD_BGAP_CTRL_BGAP_ATST_SEL(base) (BME_UBFX32(&XCVR_BGAP_CTRL_REG(base), XCVR_BGAP_CTRL_BGAP_ATST_SEL_SHIFT, XCVR_BGAP_CTRL_BGAP_ATST_SEL_WIDTH))

/*! @brief Set the BGAP_ATST_SEL field to a new value. */
#define XCVR_WR_BGAP_CTRL_BGAP_ATST_SEL(base, value) (XCVR_RMW_BGAP_CTRL(base, XCVR_BGAP_CTRL_BGAP_ATST_SEL_MASK, XCVR_BGAP_CTRL_BGAP_ATST_SEL(value)))
#define XCVR_BWR_BGAP_CTRL_BGAP_ATST_SEL(base, value) (BME_BFI32(&XCVR_BGAP_CTRL_REG(base), ((uint32_t)(value) << XCVR_BGAP_CTRL_BGAP_ATST_SEL_SHIFT), XCVR_BGAP_CTRL_BGAP_ATST_SEL_SHIFT, XCVR_BGAP_CTRL_BGAP_ATST_SEL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_BGAP_CTRL, field BGAP_ATST_ON[12] (RW)
 *
 * This bit enables the test mux for the bangap block. The different internal
 * nodes of bandgap are connected to the ATST bus based on bgap_atst_sel bits.
 */
/*@{*/
/*! @brief Read current value of the XCVR_BGAP_CTRL_BGAP_ATST_ON field. */
#define XCVR_RD_BGAP_CTRL_BGAP_ATST_ON(base) ((XCVR_BGAP_CTRL_REG(base) & XCVR_BGAP_CTRL_BGAP_ATST_ON_MASK) >> XCVR_BGAP_CTRL_BGAP_ATST_ON_SHIFT)
#define XCVR_BRD_BGAP_CTRL_BGAP_ATST_ON(base) (BME_UBFX32(&XCVR_BGAP_CTRL_REG(base), XCVR_BGAP_CTRL_BGAP_ATST_ON_SHIFT, XCVR_BGAP_CTRL_BGAP_ATST_ON_WIDTH))

/*! @brief Set the BGAP_ATST_ON field to a new value. */
#define XCVR_WR_BGAP_CTRL_BGAP_ATST_ON(base, value) (XCVR_RMW_BGAP_CTRL(base, XCVR_BGAP_CTRL_BGAP_ATST_ON_MASK, XCVR_BGAP_CTRL_BGAP_ATST_ON(value)))
#define XCVR_BWR_BGAP_CTRL_BGAP_ATST_ON(base, value) (BME_BFI32(&XCVR_BGAP_CTRL_REG(base), ((uint32_t)(value) << XCVR_BGAP_CTRL_BGAP_ATST_ON_SHIFT), XCVR_BGAP_CTRL_BGAP_ATST_ON_SHIFT, XCVR_BGAP_CTRL_BGAP_ATST_ON_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_CTRL - PLL Control Register
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_CTRL - PLL Control Register (RW)
 *
 * Reset value: 0x00000023U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_CTRL register
 */
/*@{*/
#define XCVR_RD_PLL_CTRL(base)   (XCVR_PLL_CTRL_REG(base))
#define XCVR_WR_PLL_CTRL(base, value) (XCVR_PLL_CTRL_REG(base) = (value))
#define XCVR_RMW_PLL_CTRL(base, mask, value) (XCVR_WR_PLL_CTRL(base, (XCVR_RD_PLL_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_PLL_CTRL(base, value) (BME_OR32(&XCVR_PLL_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PLL_CTRL(base, value) (BME_AND32(&XCVR_PLL_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PLL_CTRL(base, value) (BME_XOR32(&XCVR_PLL_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_CTRL bitfields
 */

/*!
 * @name Register XCVR_PLL_CTRL, field PLL_VCO_BIAS[2:0] (RW)
 *
 * Progammable current control for the VCO. The VCO current varies from 1.5mA to
 * 2.1mA
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTRL_PLL_VCO_BIAS field. */
#define XCVR_RD_PLL_CTRL_PLL_VCO_BIAS(base) ((XCVR_PLL_CTRL_REG(base) & XCVR_PLL_CTRL_PLL_VCO_BIAS_MASK) >> XCVR_PLL_CTRL_PLL_VCO_BIAS_SHIFT)
#define XCVR_BRD_PLL_CTRL_PLL_VCO_BIAS(base) (BME_UBFX32(&XCVR_PLL_CTRL_REG(base), XCVR_PLL_CTRL_PLL_VCO_BIAS_SHIFT, XCVR_PLL_CTRL_PLL_VCO_BIAS_WIDTH))

/*! @brief Set the PLL_VCO_BIAS field to a new value. */
#define XCVR_WR_PLL_CTRL_PLL_VCO_BIAS(base, value) (XCVR_RMW_PLL_CTRL(base, XCVR_PLL_CTRL_PLL_VCO_BIAS_MASK, XCVR_PLL_CTRL_PLL_VCO_BIAS(value)))
#define XCVR_BWR_PLL_CTRL_PLL_VCO_BIAS(base, value) (BME_BFI32(&XCVR_PLL_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_CTRL_PLL_VCO_BIAS_SHIFT), XCVR_PLL_CTRL_PLL_VCO_BIAS_SHIFT, XCVR_PLL_CTRL_PLL_VCO_BIAS_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CTRL, field PLL_LFILT_CNTL[6:4] (RW)
 *
 * Program the resistors in the loop filter to control the bandwith.
 * Pll_lfilt_cntl First Pole Resistor Second Pole Resistor 000 25.6K 26K 001 20.8K 26K 010
 * 15.4K 26K 011 10.3K 26K 100 25.6K 100 101 20.8K 100 110 15.4K 100 111 10.3K 100
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTRL_PLL_LFILT_CNTL field. */
#define XCVR_RD_PLL_CTRL_PLL_LFILT_CNTL(base) ((XCVR_PLL_CTRL_REG(base) & XCVR_PLL_CTRL_PLL_LFILT_CNTL_MASK) >> XCVR_PLL_CTRL_PLL_LFILT_CNTL_SHIFT)
#define XCVR_BRD_PLL_CTRL_PLL_LFILT_CNTL(base) (BME_UBFX32(&XCVR_PLL_CTRL_REG(base), XCVR_PLL_CTRL_PLL_LFILT_CNTL_SHIFT, XCVR_PLL_CTRL_PLL_LFILT_CNTL_WIDTH))

/*! @brief Set the PLL_LFILT_CNTL field to a new value. */
#define XCVR_WR_PLL_CTRL_PLL_LFILT_CNTL(base, value) (XCVR_RMW_PLL_CTRL(base, XCVR_PLL_CTRL_PLL_LFILT_CNTL_MASK, XCVR_PLL_CTRL_PLL_LFILT_CNTL(value)))
#define XCVR_BWR_PLL_CTRL_PLL_LFILT_CNTL(base, value) (BME_BFI32(&XCVR_PLL_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_CTRL_PLL_LFILT_CNTL_SHIFT), XCVR_PLL_CTRL_PLL_LFILT_CNTL_SHIFT, XCVR_PLL_CTRL_PLL_LFILT_CNTL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CTRL, field PLL_REG_SUPPLY[11:8] (RW)
 *
 * Regulator trim bit to change the outputvoltage from 1.05 to 1.4V
 *
 * Values:
 * - 0b0000 - 1.2V
 * - 0b0001 - 1.05V
 * - 0b0010 - 1.275V
 * - 0b0011 - 1.3V
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTRL_PLL_REG_SUPPLY field. */
#define XCVR_RD_PLL_CTRL_PLL_REG_SUPPLY(base) ((XCVR_PLL_CTRL_REG(base) & XCVR_PLL_CTRL_PLL_REG_SUPPLY_MASK) >> XCVR_PLL_CTRL_PLL_REG_SUPPLY_SHIFT)
#define XCVR_BRD_PLL_CTRL_PLL_REG_SUPPLY(base) (BME_UBFX32(&XCVR_PLL_CTRL_REG(base), XCVR_PLL_CTRL_PLL_REG_SUPPLY_SHIFT, XCVR_PLL_CTRL_PLL_REG_SUPPLY_WIDTH))

/*! @brief Set the PLL_REG_SUPPLY field to a new value. */
#define XCVR_WR_PLL_CTRL_PLL_REG_SUPPLY(base, value) (XCVR_RMW_PLL_CTRL(base, XCVR_PLL_CTRL_PLL_REG_SUPPLY_MASK, XCVR_PLL_CTRL_PLL_REG_SUPPLY(value)))
#define XCVR_BWR_PLL_CTRL_PLL_REG_SUPPLY(base, value) (BME_BFI32(&XCVR_PLL_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_CTRL_PLL_REG_SUPPLY_SHIFT), XCVR_PLL_CTRL_PLL_REG_SUPPLY_SHIFT, XCVR_PLL_CTRL_PLL_REG_SUPPLY_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CTRL, field PLL_REG_BYPASS_ON[16] (RW)
 *
 * This register bit determines if the regulator is in bypass mode. When in
 * bypass mode, the external voltage applied to the input of the regulator is
 * presented at the regulator output.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTRL_PLL_REG_BYPASS_ON field. */
#define XCVR_RD_PLL_CTRL_PLL_REG_BYPASS_ON(base) ((XCVR_PLL_CTRL_REG(base) & XCVR_PLL_CTRL_PLL_REG_BYPASS_ON_MASK) >> XCVR_PLL_CTRL_PLL_REG_BYPASS_ON_SHIFT)
#define XCVR_BRD_PLL_CTRL_PLL_REG_BYPASS_ON(base) (BME_UBFX32(&XCVR_PLL_CTRL_REG(base), XCVR_PLL_CTRL_PLL_REG_BYPASS_ON_SHIFT, XCVR_PLL_CTRL_PLL_REG_BYPASS_ON_WIDTH))

/*! @brief Set the PLL_REG_BYPASS_ON field to a new value. */
#define XCVR_WR_PLL_CTRL_PLL_REG_BYPASS_ON(base, value) (XCVR_RMW_PLL_CTRL(base, XCVR_PLL_CTRL_PLL_REG_BYPASS_ON_MASK, XCVR_PLL_CTRL_PLL_REG_BYPASS_ON(value)))
#define XCVR_BWR_PLL_CTRL_PLL_REG_BYPASS_ON(base, value) (BME_BFI32(&XCVR_PLL_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_CTRL_PLL_REG_BYPASS_ON_SHIFT), XCVR_PLL_CTRL_PLL_REG_BYPASS_ON_SHIFT, XCVR_PLL_CTRL_PLL_REG_BYPASS_ON_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CTRL, field PLL_VCO_LDO_BYPASS[17] (RW)
 *
 * This register bit determines if the regulator is in bypass mode. When in
 * bypass mode, the external voltage applied to the input of the regulator is
 * presented at the regulator output.
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTRL_PLL_VCO_LDO_BYPASS field. */
#define XCVR_RD_PLL_CTRL_PLL_VCO_LDO_BYPASS(base) ((XCVR_PLL_CTRL_REG(base) & XCVR_PLL_CTRL_PLL_VCO_LDO_BYPASS_MASK) >> XCVR_PLL_CTRL_PLL_VCO_LDO_BYPASS_SHIFT)
#define XCVR_BRD_PLL_CTRL_PLL_VCO_LDO_BYPASS(base) (BME_UBFX32(&XCVR_PLL_CTRL_REG(base), XCVR_PLL_CTRL_PLL_VCO_LDO_BYPASS_SHIFT, XCVR_PLL_CTRL_PLL_VCO_LDO_BYPASS_WIDTH))

/*! @brief Set the PLL_VCO_LDO_BYPASS field to a new value. */
#define XCVR_WR_PLL_CTRL_PLL_VCO_LDO_BYPASS(base, value) (XCVR_RMW_PLL_CTRL(base, XCVR_PLL_CTRL_PLL_VCO_LDO_BYPASS_MASK, XCVR_PLL_CTRL_PLL_VCO_LDO_BYPASS(value)))
#define XCVR_BWR_PLL_CTRL_PLL_VCO_LDO_BYPASS(base, value) (BME_BFI32(&XCVR_PLL_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_CTRL_PLL_VCO_LDO_BYPASS_SHIFT), XCVR_PLL_CTRL_PLL_VCO_LDO_BYPASS_SHIFT, XCVR_PLL_CTRL_PLL_VCO_LDO_BYPASS_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CTRL, field HPM_BIAS[30:24] (RW)
 *
 * Provides a (-64/+63 x 976.56 Hz) range of steps to adjust the HPM Array
 * Mid-Point during modulation
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTRL_HPM_BIAS field. */
#define XCVR_RD_PLL_CTRL_HPM_BIAS(base) ((XCVR_PLL_CTRL_REG(base) & XCVR_PLL_CTRL_HPM_BIAS_MASK) >> XCVR_PLL_CTRL_HPM_BIAS_SHIFT)
#define XCVR_BRD_PLL_CTRL_HPM_BIAS(base) (BME_UBFX32(&XCVR_PLL_CTRL_REG(base), XCVR_PLL_CTRL_HPM_BIAS_SHIFT, XCVR_PLL_CTRL_HPM_BIAS_WIDTH))

/*! @brief Set the HPM_BIAS field to a new value. */
#define XCVR_WR_PLL_CTRL_HPM_BIAS(base, value) (XCVR_RMW_PLL_CTRL(base, XCVR_PLL_CTRL_HPM_BIAS_MASK, XCVR_PLL_CTRL_HPM_BIAS(value)))
#define XCVR_BWR_PLL_CTRL_HPM_BIAS(base, value) (BME_BFI32(&XCVR_PLL_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_CTRL_HPM_BIAS_SHIFT), XCVR_PLL_CTRL_HPM_BIAS_SHIFT, XCVR_PLL_CTRL_HPM_BIAS_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CTRL, field PLL_VCO_SPARE7[31] (RW)
 *
 * Spare Bit for future use
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTRL_PLL_VCO_SPARE7 field. */
#define XCVR_RD_PLL_CTRL_PLL_VCO_SPARE7(base) ((XCVR_PLL_CTRL_REG(base) & XCVR_PLL_CTRL_PLL_VCO_SPARE7_MASK) >> XCVR_PLL_CTRL_PLL_VCO_SPARE7_SHIFT)
#define XCVR_BRD_PLL_CTRL_PLL_VCO_SPARE7(base) (BME_UBFX32(&XCVR_PLL_CTRL_REG(base), XCVR_PLL_CTRL_PLL_VCO_SPARE7_SHIFT, XCVR_PLL_CTRL_PLL_VCO_SPARE7_WIDTH))

/*! @brief Set the PLL_VCO_SPARE7 field to a new value. */
#define XCVR_WR_PLL_CTRL_PLL_VCO_SPARE7(base, value) (XCVR_RMW_PLL_CTRL(base, XCVR_PLL_CTRL_PLL_VCO_SPARE7_MASK, XCVR_PLL_CTRL_PLL_VCO_SPARE7(value)))
#define XCVR_BWR_PLL_CTRL_PLL_VCO_SPARE7(base, value) (BME_BFI32(&XCVR_PLL_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_CTRL_PLL_VCO_SPARE7_SHIFT), XCVR_PLL_CTRL_PLL_VCO_SPARE7_SHIFT, XCVR_PLL_CTRL_PLL_VCO_SPARE7_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_CTRL2 - PLL Control Register 2
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_CTRL2 - PLL Control Register 2 (RW)
 *
 * Reset value: 0x00000004U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_CTRL2 register
 */
/*@{*/
#define XCVR_RD_PLL_CTRL2(base)  (XCVR_PLL_CTRL2_REG(base))
#define XCVR_WR_PLL_CTRL2(base, value) (XCVR_PLL_CTRL2_REG(base) = (value))
#define XCVR_RMW_PLL_CTRL2(base, mask, value) (XCVR_WR_PLL_CTRL2(base, (XCVR_RD_PLL_CTRL2(base) & ~(mask)) | (value)))
#define XCVR_SET_PLL_CTRL2(base, value) (BME_OR32(&XCVR_PLL_CTRL2_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PLL_CTRL2(base, value) (BME_AND32(&XCVR_PLL_CTRL2_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PLL_CTRL2(base, value) (BME_XOR32(&XCVR_PLL_CTRL2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_CTRL2 bitfields
 */

/*!
 * @name Register XCVR_PLL_CTRL2, field PLL_VCO_KV[2:0] (RW)
 *
 * These bits control the gain of the VCO. This is an additioanl knob to control
 * the loop bandwitch of the PLL. All 0's correspond to minimum KV and all 1's
 * correspond to max KV programmable
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTRL2_PLL_VCO_KV field. */
#define XCVR_RD_PLL_CTRL2_PLL_VCO_KV(base) ((XCVR_PLL_CTRL2_REG(base) & XCVR_PLL_CTRL2_PLL_VCO_KV_MASK) >> XCVR_PLL_CTRL2_PLL_VCO_KV_SHIFT)
#define XCVR_BRD_PLL_CTRL2_PLL_VCO_KV(base) (BME_UBFX32(&XCVR_PLL_CTRL2_REG(base), XCVR_PLL_CTRL2_PLL_VCO_KV_SHIFT, XCVR_PLL_CTRL2_PLL_VCO_KV_WIDTH))

/*! @brief Set the PLL_VCO_KV field to a new value. */
#define XCVR_WR_PLL_CTRL2_PLL_VCO_KV(base, value) (XCVR_RMW_PLL_CTRL2(base, XCVR_PLL_CTRL2_PLL_VCO_KV_MASK, XCVR_PLL_CTRL2_PLL_VCO_KV(value)))
#define XCVR_BWR_PLL_CTRL2_PLL_VCO_KV(base, value) (BME_BFI32(&XCVR_PLL_CTRL2_REG(base), ((uint32_t)(value) << XCVR_PLL_CTRL2_PLL_VCO_KV_SHIFT), XCVR_PLL_CTRL2_PLL_VCO_KV_SHIFT, XCVR_PLL_CTRL2_PLL_VCO_KV_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CTRL2, field PLL_KMOD_SLOPE[3] (RW)
 *
 * This bit controls the slope of the highport capacitor bank. When this bit is
 * set the Kmod slope changes from 10Khz to 15Khz
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTRL2_PLL_KMOD_SLOPE field. */
#define XCVR_RD_PLL_CTRL2_PLL_KMOD_SLOPE(base) ((XCVR_PLL_CTRL2_REG(base) & XCVR_PLL_CTRL2_PLL_KMOD_SLOPE_MASK) >> XCVR_PLL_CTRL2_PLL_KMOD_SLOPE_SHIFT)
#define XCVR_BRD_PLL_CTRL2_PLL_KMOD_SLOPE(base) (BME_UBFX32(&XCVR_PLL_CTRL2_REG(base), XCVR_PLL_CTRL2_PLL_KMOD_SLOPE_SHIFT, XCVR_PLL_CTRL2_PLL_KMOD_SLOPE_WIDTH))

/*! @brief Set the PLL_KMOD_SLOPE field to a new value. */
#define XCVR_WR_PLL_CTRL2_PLL_KMOD_SLOPE(base, value) (XCVR_RMW_PLL_CTRL2(base, XCVR_PLL_CTRL2_PLL_KMOD_SLOPE_MASK, XCVR_PLL_CTRL2_PLL_KMOD_SLOPE(value)))
#define XCVR_BWR_PLL_CTRL2_PLL_KMOD_SLOPE(base, value) (BME_BFI32(&XCVR_PLL_CTRL2_REG(base), ((uint32_t)(value) << XCVR_PLL_CTRL2_PLL_KMOD_SLOPE_SHIFT), XCVR_PLL_CTRL2_PLL_KMOD_SLOPE_SHIFT, XCVR_PLL_CTRL2_PLL_KMOD_SLOPE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CTRL2, field PLL_VCO_REG_SUPPLY[5:4] (RW)
 *
 * Regulator trim bits to change the outputvoltage from 1.15 to 1.3V
 *
 * Values:
 * - 0b00 - 1.15V
 * - 0b01 - 1.2V
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTRL2_PLL_VCO_REG_SUPPLY field. */
#define XCVR_RD_PLL_CTRL2_PLL_VCO_REG_SUPPLY(base) ((XCVR_PLL_CTRL2_REG(base) & XCVR_PLL_CTRL2_PLL_VCO_REG_SUPPLY_MASK) >> XCVR_PLL_CTRL2_PLL_VCO_REG_SUPPLY_SHIFT)
#define XCVR_BRD_PLL_CTRL2_PLL_VCO_REG_SUPPLY(base) (BME_UBFX32(&XCVR_PLL_CTRL2_REG(base), XCVR_PLL_CTRL2_PLL_VCO_REG_SUPPLY_SHIFT, XCVR_PLL_CTRL2_PLL_VCO_REG_SUPPLY_WIDTH))

/*! @brief Set the PLL_VCO_REG_SUPPLY field to a new value. */
#define XCVR_WR_PLL_CTRL2_PLL_VCO_REG_SUPPLY(base, value) (XCVR_RMW_PLL_CTRL2(base, XCVR_PLL_CTRL2_PLL_VCO_REG_SUPPLY_MASK, XCVR_PLL_CTRL2_PLL_VCO_REG_SUPPLY(value)))
#define XCVR_BWR_PLL_CTRL2_PLL_VCO_REG_SUPPLY(base, value) (BME_BFI32(&XCVR_PLL_CTRL2_REG(base), ((uint32_t)(value) << XCVR_PLL_CTRL2_PLL_VCO_REG_SUPPLY_SHIFT), XCVR_PLL_CTRL2_PLL_VCO_REG_SUPPLY_SHIFT, XCVR_PLL_CTRL2_PLL_VCO_REG_SUPPLY_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_CTRL2, field PLL_TMUX_ON[8] (RW)
 *
 * This bit enables the testmux inside the PLL and the different internal nodes
 * are connected to ATST bus based on the pll_tmux_sel settings
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_CTRL2_PLL_TMUX_ON field. */
#define XCVR_RD_PLL_CTRL2_PLL_TMUX_ON(base) ((XCVR_PLL_CTRL2_REG(base) & XCVR_PLL_CTRL2_PLL_TMUX_ON_MASK) >> XCVR_PLL_CTRL2_PLL_TMUX_ON_SHIFT)
#define XCVR_BRD_PLL_CTRL2_PLL_TMUX_ON(base) (BME_UBFX32(&XCVR_PLL_CTRL2_REG(base), XCVR_PLL_CTRL2_PLL_TMUX_ON_SHIFT, XCVR_PLL_CTRL2_PLL_TMUX_ON_WIDTH))

/*! @brief Set the PLL_TMUX_ON field to a new value. */
#define XCVR_WR_PLL_CTRL2_PLL_TMUX_ON(base, value) (XCVR_RMW_PLL_CTRL2(base, XCVR_PLL_CTRL2_PLL_TMUX_ON_MASK, XCVR_PLL_CTRL2_PLL_TMUX_ON(value)))
#define XCVR_BWR_PLL_CTRL2_PLL_TMUX_ON(base, value) (BME_BFI32(&XCVR_PLL_CTRL2_REG(base), ((uint32_t)(value) << XCVR_PLL_CTRL2_PLL_TMUX_ON_SHIFT), XCVR_PLL_CTRL2_PLL_TMUX_ON_SHIFT, XCVR_PLL_CTRL2_PLL_TMUX_ON_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_PLL_TEST_CTRL - PLL Test Control
 ******************************************************************************/

/*!
 * @brief XCVR_PLL_TEST_CTRL - PLL Test Control (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_PLL_TEST_CTRL register
 */
/*@{*/
#define XCVR_RD_PLL_TEST_CTRL(base) (XCVR_PLL_TEST_CTRL_REG(base))
#define XCVR_WR_PLL_TEST_CTRL(base, value) (XCVR_PLL_TEST_CTRL_REG(base) = (value))
#define XCVR_RMW_PLL_TEST_CTRL(base, mask, value) (XCVR_WR_PLL_TEST_CTRL(base, (XCVR_RD_PLL_TEST_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_PLL_TEST_CTRL(base, value) (BME_OR32(&XCVR_PLL_TEST_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_PLL_TEST_CTRL(base, value) (BME_AND32(&XCVR_PLL_TEST_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_PLL_TEST_CTRL(base, value) (BME_XOR32(&XCVR_PLL_TEST_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_PLL_TEST_CTRL bitfields
 */

/*!
 * @name Register XCVR_PLL_TEST_CTRL, field PLL_TMUX_SEL[1:0] (RW)
 *
 * Select what internal signals to bring out to ATST pins. PLL_TMUX_ON needs to
 * be set. register setting ATST0 ATST1 ATST2 ATST3 00 precharge_filt xor_out
 * pll_ref_xtal pll_ref_xtal_b 01 pll_sigma_delta_clk pll_loop_div_count[0]
 * pll_loop_div_count[1] pll_loop_div_count[2] 10 pll_loop_div_count[3]
 * pll_loop_div_count[4] pll_loop_div_count[8] No Connect 11 pll_ripple_counter_override_clk No
 * Connect No Connect No Connect
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_TEST_CTRL_PLL_TMUX_SEL field. */
#define XCVR_RD_PLL_TEST_CTRL_PLL_TMUX_SEL(base) ((XCVR_PLL_TEST_CTRL_REG(base) & XCVR_PLL_TEST_CTRL_PLL_TMUX_SEL_MASK) >> XCVR_PLL_TEST_CTRL_PLL_TMUX_SEL_SHIFT)
#define XCVR_BRD_PLL_TEST_CTRL_PLL_TMUX_SEL(base) (BME_UBFX32(&XCVR_PLL_TEST_CTRL_REG(base), XCVR_PLL_TEST_CTRL_PLL_TMUX_SEL_SHIFT, XCVR_PLL_TEST_CTRL_PLL_TMUX_SEL_WIDTH))

/*! @brief Set the PLL_TMUX_SEL field to a new value. */
#define XCVR_WR_PLL_TEST_CTRL_PLL_TMUX_SEL(base, value) (XCVR_RMW_PLL_TEST_CTRL(base, XCVR_PLL_TEST_CTRL_PLL_TMUX_SEL_MASK, XCVR_PLL_TEST_CTRL_PLL_TMUX_SEL(value)))
#define XCVR_BWR_PLL_TEST_CTRL_PLL_TMUX_SEL(base, value) (BME_BFI32(&XCVR_PLL_TEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_TEST_CTRL_PLL_TMUX_SEL_SHIFT), XCVR_PLL_TEST_CTRL_PLL_TMUX_SEL_SHIFT, XCVR_PLL_TEST_CTRL_PLL_TMUX_SEL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_TEST_CTRL, field PLL_VCO_REG_ATST[5:4] (RW)
 *
 * These bits determine what internal signals are connected to the ATST bus
 * register setting ATST0 00 No Connect 01 vout 10 vin feedback 11 vbias
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_TEST_CTRL_PLL_VCO_REG_ATST field. */
#define XCVR_RD_PLL_TEST_CTRL_PLL_VCO_REG_ATST(base) ((XCVR_PLL_TEST_CTRL_REG(base) & XCVR_PLL_TEST_CTRL_PLL_VCO_REG_ATST_MASK) >> XCVR_PLL_TEST_CTRL_PLL_VCO_REG_ATST_SHIFT)
#define XCVR_BRD_PLL_TEST_CTRL_PLL_VCO_REG_ATST(base) (BME_UBFX32(&XCVR_PLL_TEST_CTRL_REG(base), XCVR_PLL_TEST_CTRL_PLL_VCO_REG_ATST_SHIFT, XCVR_PLL_TEST_CTRL_PLL_VCO_REG_ATST_WIDTH))

/*! @brief Set the PLL_VCO_REG_ATST field to a new value. */
#define XCVR_WR_PLL_TEST_CTRL_PLL_VCO_REG_ATST(base, value) (XCVR_RMW_PLL_TEST_CTRL(base, XCVR_PLL_TEST_CTRL_PLL_VCO_REG_ATST_MASK, XCVR_PLL_TEST_CTRL_PLL_VCO_REG_ATST(value)))
#define XCVR_BWR_PLL_TEST_CTRL_PLL_VCO_REG_ATST(base, value) (BME_BFI32(&XCVR_PLL_TEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_TEST_CTRL_PLL_VCO_REG_ATST_SHIFT), XCVR_PLL_TEST_CTRL_PLL_VCO_REG_ATST_SHIFT, XCVR_PLL_TEST_CTRL_PLL_VCO_REG_ATST_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_TEST_CTRL, field PLL_REG_ATST_SEL[9:8] (RW)
 *
 * These bits control the what internal regualtor signals are connected to the
 * ATST bus. register setting ATST0 00 No Connect 01 vout 10 vin feedback 11 vbias
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_TEST_CTRL_PLL_REG_ATST_SEL field. */
#define XCVR_RD_PLL_TEST_CTRL_PLL_REG_ATST_SEL(base) ((XCVR_PLL_TEST_CTRL_REG(base) & XCVR_PLL_TEST_CTRL_PLL_REG_ATST_SEL_MASK) >> XCVR_PLL_TEST_CTRL_PLL_REG_ATST_SEL_SHIFT)
#define XCVR_BRD_PLL_TEST_CTRL_PLL_REG_ATST_SEL(base) (BME_UBFX32(&XCVR_PLL_TEST_CTRL_REG(base), XCVR_PLL_TEST_CTRL_PLL_REG_ATST_SEL_SHIFT, XCVR_PLL_TEST_CTRL_PLL_REG_ATST_SEL_WIDTH))

/*! @brief Set the PLL_REG_ATST_SEL field to a new value. */
#define XCVR_WR_PLL_TEST_CTRL_PLL_REG_ATST_SEL(base, value) (XCVR_RMW_PLL_TEST_CTRL(base, XCVR_PLL_TEST_CTRL_PLL_REG_ATST_SEL_MASK, XCVR_PLL_TEST_CTRL_PLL_REG_ATST_SEL(value)))
#define XCVR_BWR_PLL_TEST_CTRL_PLL_REG_ATST_SEL(base, value) (BME_BFI32(&XCVR_PLL_TEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_TEST_CTRL_PLL_REG_ATST_SEL_SHIFT), XCVR_PLL_TEST_CTRL_PLL_REG_ATST_SEL_SHIFT, XCVR_PLL_TEST_CTRL_PLL_REG_ATST_SEL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_TEST_CTRL, field PLL_VCO_TEST_CLK_MODE[12] (RW)
 *
 * test mode for the VCO
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_TEST_CTRL_PLL_VCO_TEST_CLK_MODE field. */
#define XCVR_RD_PLL_TEST_CTRL_PLL_VCO_TEST_CLK_MODE(base) ((XCVR_PLL_TEST_CTRL_REG(base) & XCVR_PLL_TEST_CTRL_PLL_VCO_TEST_CLK_MODE_MASK) >> XCVR_PLL_TEST_CTRL_PLL_VCO_TEST_CLK_MODE_SHIFT)
#define XCVR_BRD_PLL_TEST_CTRL_PLL_VCO_TEST_CLK_MODE(base) (BME_UBFX32(&XCVR_PLL_TEST_CTRL_REG(base), XCVR_PLL_TEST_CTRL_PLL_VCO_TEST_CLK_MODE_SHIFT, XCVR_PLL_TEST_CTRL_PLL_VCO_TEST_CLK_MODE_WIDTH))

/*! @brief Set the PLL_VCO_TEST_CLK_MODE field to a new value. */
#define XCVR_WR_PLL_TEST_CTRL_PLL_VCO_TEST_CLK_MODE(base, value) (XCVR_RMW_PLL_TEST_CTRL(base, XCVR_PLL_TEST_CTRL_PLL_VCO_TEST_CLK_MODE_MASK, XCVR_PLL_TEST_CTRL_PLL_VCO_TEST_CLK_MODE(value)))
#define XCVR_BWR_PLL_TEST_CTRL_PLL_VCO_TEST_CLK_MODE(base, value) (BME_BFI32(&XCVR_PLL_TEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_TEST_CTRL_PLL_VCO_TEST_CLK_MODE_SHIFT), XCVR_PLL_TEST_CTRL_PLL_VCO_TEST_CLK_MODE_SHIFT, XCVR_PLL_TEST_CTRL_PLL_VCO_TEST_CLK_MODE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_TEST_CTRL, field PLL_FORCE_VTUNE_EXTERNALLY[13] (RW)
 *
 * Force VTUNE externally
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_TEST_CTRL_PLL_FORCE_VTUNE_EXTERNALLY field. */
#define XCVR_RD_PLL_TEST_CTRL_PLL_FORCE_VTUNE_EXTERNALLY(base) ((XCVR_PLL_TEST_CTRL_REG(base) & XCVR_PLL_TEST_CTRL_PLL_FORCE_VTUNE_EXTERNALLY_MASK) >> XCVR_PLL_TEST_CTRL_PLL_FORCE_VTUNE_EXTERNALLY_SHIFT)
#define XCVR_BRD_PLL_TEST_CTRL_PLL_FORCE_VTUNE_EXTERNALLY(base) (BME_UBFX32(&XCVR_PLL_TEST_CTRL_REG(base), XCVR_PLL_TEST_CTRL_PLL_FORCE_VTUNE_EXTERNALLY_SHIFT, XCVR_PLL_TEST_CTRL_PLL_FORCE_VTUNE_EXTERNALLY_WIDTH))

/*! @brief Set the PLL_FORCE_VTUNE_EXTERNALLY field to a new value. */
#define XCVR_WR_PLL_TEST_CTRL_PLL_FORCE_VTUNE_EXTERNALLY(base, value) (XCVR_RMW_PLL_TEST_CTRL(base, XCVR_PLL_TEST_CTRL_PLL_FORCE_VTUNE_EXTERNALLY_MASK, XCVR_PLL_TEST_CTRL_PLL_FORCE_VTUNE_EXTERNALLY(value)))
#define XCVR_BWR_PLL_TEST_CTRL_PLL_FORCE_VTUNE_EXTERNALLY(base, value) (BME_BFI32(&XCVR_PLL_TEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_TEST_CTRL_PLL_FORCE_VTUNE_EXTERNALLY_SHIFT), XCVR_PLL_TEST_CTRL_PLL_FORCE_VTUNE_EXTERNALLY_SHIFT, XCVR_PLL_TEST_CTRL_PLL_FORCE_VTUNE_EXTERNALLY_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_PLL_TEST_CTRL, field PLL_RIPPLE_COUNTER_TEST_MODE[14] (RW)
 *
 * PLL Ripple Counter Test Mode
 */
/*@{*/
/*! @brief Read current value of the XCVR_PLL_TEST_CTRL_PLL_RIPPLE_COUNTER_TEST_MODE field. */
#define XCVR_RD_PLL_TEST_CTRL_PLL_RIPPLE_COUNTER_TEST_MODE(base) ((XCVR_PLL_TEST_CTRL_REG(base) & XCVR_PLL_TEST_CTRL_PLL_RIPPLE_COUNTER_TEST_MODE_MASK) >> XCVR_PLL_TEST_CTRL_PLL_RIPPLE_COUNTER_TEST_MODE_SHIFT)
#define XCVR_BRD_PLL_TEST_CTRL_PLL_RIPPLE_COUNTER_TEST_MODE(base) (BME_UBFX32(&XCVR_PLL_TEST_CTRL_REG(base), XCVR_PLL_TEST_CTRL_PLL_RIPPLE_COUNTER_TEST_MODE_SHIFT, XCVR_PLL_TEST_CTRL_PLL_RIPPLE_COUNTER_TEST_MODE_WIDTH))

/*! @brief Set the PLL_RIPPLE_COUNTER_TEST_MODE field to a new value. */
#define XCVR_WR_PLL_TEST_CTRL_PLL_RIPPLE_COUNTER_TEST_MODE(base, value) (XCVR_RMW_PLL_TEST_CTRL(base, XCVR_PLL_TEST_CTRL_PLL_RIPPLE_COUNTER_TEST_MODE_MASK, XCVR_PLL_TEST_CTRL_PLL_RIPPLE_COUNTER_TEST_MODE(value)))
#define XCVR_BWR_PLL_TEST_CTRL_PLL_RIPPLE_COUNTER_TEST_MODE(base, value) (BME_BFI32(&XCVR_PLL_TEST_CTRL_REG(base), ((uint32_t)(value) << XCVR_PLL_TEST_CTRL_PLL_RIPPLE_COUNTER_TEST_MODE_SHIFT), XCVR_PLL_TEST_CTRL_PLL_RIPPLE_COUNTER_TEST_MODE_SHIFT, XCVR_PLL_TEST_CTRL_PLL_RIPPLE_COUNTER_TEST_MODE_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_QGEN_CTRL - QGEN Control
 ******************************************************************************/

/*!
 * @brief XCVR_QGEN_CTRL - QGEN Control (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_QGEN_CTRL register
 */
/*@{*/
#define XCVR_RD_QGEN_CTRL(base)  (XCVR_QGEN_CTRL_REG(base))
#define XCVR_WR_QGEN_CTRL(base, value) (XCVR_QGEN_CTRL_REG(base) = (value))
#define XCVR_RMW_QGEN_CTRL(base, mask, value) (XCVR_WR_QGEN_CTRL(base, (XCVR_RD_QGEN_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_QGEN_CTRL(base, value) (BME_OR32(&XCVR_QGEN_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_QGEN_CTRL(base, value) (BME_AND32(&XCVR_QGEN_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_QGEN_CTRL(base, value) (BME_XOR32(&XCVR_QGEN_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_QGEN_CTRL bitfields
 */

/*!
 * @name Register XCVR_QGEN_CTRL, field QGEN_REG_SUPPLY[3:0] (RW)
 *
 * Regulator trim bits to change the output voltage from 1.05 to 1.4V
 *
 * Values:
 * - 0b0000 - 1.2V
 * - 0b0001 - 1.05V
 * - 0b0010 - 1.275V
 * - 0b0011 - 1.3V
 */
/*@{*/
/*! @brief Read current value of the XCVR_QGEN_CTRL_QGEN_REG_SUPPLY field. */
#define XCVR_RD_QGEN_CTRL_QGEN_REG_SUPPLY(base) ((XCVR_QGEN_CTRL_REG(base) & XCVR_QGEN_CTRL_QGEN_REG_SUPPLY_MASK) >> XCVR_QGEN_CTRL_QGEN_REG_SUPPLY_SHIFT)
#define XCVR_BRD_QGEN_CTRL_QGEN_REG_SUPPLY(base) (BME_UBFX32(&XCVR_QGEN_CTRL_REG(base), XCVR_QGEN_CTRL_QGEN_REG_SUPPLY_SHIFT, XCVR_QGEN_CTRL_QGEN_REG_SUPPLY_WIDTH))

/*! @brief Set the QGEN_REG_SUPPLY field to a new value. */
#define XCVR_WR_QGEN_CTRL_QGEN_REG_SUPPLY(base, value) (XCVR_RMW_QGEN_CTRL(base, XCVR_QGEN_CTRL_QGEN_REG_SUPPLY_MASK, XCVR_QGEN_CTRL_QGEN_REG_SUPPLY(value)))
#define XCVR_BWR_QGEN_CTRL_QGEN_REG_SUPPLY(base, value) (BME_BFI32(&XCVR_QGEN_CTRL_REG(base), ((uint32_t)(value) << XCVR_QGEN_CTRL_QGEN_REG_SUPPLY_SHIFT), XCVR_QGEN_CTRL_QGEN_REG_SUPPLY_SHIFT, XCVR_QGEN_CTRL_QGEN_REG_SUPPLY_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_QGEN_CTRL, field QGEN_REG_ATST_SEL[7:4] (RW)
 *
 * These bits control the what internal regualtor signals are connected to the
 * ATST bus. register setting ATST0 00 No Connect 01 vout 10 vin feedback 11 vbias
 */
/*@{*/
/*! @brief Read current value of the XCVR_QGEN_CTRL_QGEN_REG_ATST_SEL field. */
#define XCVR_RD_QGEN_CTRL_QGEN_REG_ATST_SEL(base) ((XCVR_QGEN_CTRL_REG(base) & XCVR_QGEN_CTRL_QGEN_REG_ATST_SEL_MASK) >> XCVR_QGEN_CTRL_QGEN_REG_ATST_SEL_SHIFT)
#define XCVR_BRD_QGEN_CTRL_QGEN_REG_ATST_SEL(base) (BME_UBFX32(&XCVR_QGEN_CTRL_REG(base), XCVR_QGEN_CTRL_QGEN_REG_ATST_SEL_SHIFT, XCVR_QGEN_CTRL_QGEN_REG_ATST_SEL_WIDTH))

/*! @brief Set the QGEN_REG_ATST_SEL field to a new value. */
#define XCVR_WR_QGEN_CTRL_QGEN_REG_ATST_SEL(base, value) (XCVR_RMW_QGEN_CTRL(base, XCVR_QGEN_CTRL_QGEN_REG_ATST_SEL_MASK, XCVR_QGEN_CTRL_QGEN_REG_ATST_SEL(value)))
#define XCVR_BWR_QGEN_CTRL_QGEN_REG_ATST_SEL(base, value) (BME_BFI32(&XCVR_QGEN_CTRL_REG(base), ((uint32_t)(value) << XCVR_QGEN_CTRL_QGEN_REG_ATST_SEL_SHIFT), XCVR_QGEN_CTRL_QGEN_REG_ATST_SEL_SHIFT, XCVR_QGEN_CTRL_QGEN_REG_ATST_SEL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_QGEN_CTRL, field QGEN_REG_BYPASS_ON[8] (RW)
 *
 * This register bit determines if the regulator is in bypass mode. When in
 * bypass mode, the external voltage applied to the input of the regulator is
 * presented at the regulator output.
 */
/*@{*/
/*! @brief Read current value of the XCVR_QGEN_CTRL_QGEN_REG_BYPASS_ON field. */
#define XCVR_RD_QGEN_CTRL_QGEN_REG_BYPASS_ON(base) ((XCVR_QGEN_CTRL_REG(base) & XCVR_QGEN_CTRL_QGEN_REG_BYPASS_ON_MASK) >> XCVR_QGEN_CTRL_QGEN_REG_BYPASS_ON_SHIFT)
#define XCVR_BRD_QGEN_CTRL_QGEN_REG_BYPASS_ON(base) (BME_UBFX32(&XCVR_QGEN_CTRL_REG(base), XCVR_QGEN_CTRL_QGEN_REG_BYPASS_ON_SHIFT, XCVR_QGEN_CTRL_QGEN_REG_BYPASS_ON_WIDTH))

/*! @brief Set the QGEN_REG_BYPASS_ON field to a new value. */
#define XCVR_WR_QGEN_CTRL_QGEN_REG_BYPASS_ON(base, value) (XCVR_RMW_QGEN_CTRL(base, XCVR_QGEN_CTRL_QGEN_REG_BYPASS_ON_MASK, XCVR_QGEN_CTRL_QGEN_REG_BYPASS_ON(value)))
#define XCVR_BWR_QGEN_CTRL_QGEN_REG_BYPASS_ON(base, value) (BME_BFI32(&XCVR_QGEN_CTRL_REG(base), ((uint32_t)(value) << XCVR_QGEN_CTRL_QGEN_REG_BYPASS_ON_SHIFT), XCVR_QGEN_CTRL_QGEN_REG_BYPASS_ON_SHIFT, XCVR_QGEN_CTRL_QGEN_REG_BYPASS_ON_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TCA_CTRL - TCA Control
 ******************************************************************************/

/*!
 * @brief XCVR_TCA_CTRL - TCA Control (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_TCA_CTRL register
 */
/*@{*/
#define XCVR_RD_TCA_CTRL(base)   (XCVR_TCA_CTRL_REG(base))
#define XCVR_WR_TCA_CTRL(base, value) (XCVR_TCA_CTRL_REG(base) = (value))
#define XCVR_RMW_TCA_CTRL(base, mask, value) (XCVR_WR_TCA_CTRL(base, (XCVR_RD_TCA_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_TCA_CTRL(base, value) (BME_OR32(&XCVR_TCA_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TCA_CTRL(base, value) (BME_AND32(&XCVR_TCA_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TCA_CTRL(base, value) (BME_XOR32(&XCVR_TCA_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TCA_CTRL bitfields
 */

/*!
 * @name Register XCVR_TCA_CTRL, field TCA_BIAS_CURR[1:0] (RW)
 *
 * Programmable bias currrent for the TCA
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_CTRL_TCA_BIAS_CURR field. */
#define XCVR_RD_TCA_CTRL_TCA_BIAS_CURR(base) ((XCVR_TCA_CTRL_REG(base) & XCVR_TCA_CTRL_TCA_BIAS_CURR_MASK) >> XCVR_TCA_CTRL_TCA_BIAS_CURR_SHIFT)
#define XCVR_BRD_TCA_CTRL_TCA_BIAS_CURR(base) (BME_UBFX32(&XCVR_TCA_CTRL_REG(base), XCVR_TCA_CTRL_TCA_BIAS_CURR_SHIFT, XCVR_TCA_CTRL_TCA_BIAS_CURR_WIDTH))

/*! @brief Set the TCA_BIAS_CURR field to a new value. */
#define XCVR_WR_TCA_CTRL_TCA_BIAS_CURR(base, value) (XCVR_RMW_TCA_CTRL(base, XCVR_TCA_CTRL_TCA_BIAS_CURR_MASK, XCVR_TCA_CTRL_TCA_BIAS_CURR(value)))
#define XCVR_BWR_TCA_CTRL_TCA_BIAS_CURR(base, value) (BME_BFI32(&XCVR_TCA_CTRL_REG(base), ((uint32_t)(value) << XCVR_TCA_CTRL_TCA_BIAS_CURR_SHIFT), XCVR_TCA_CTRL_TCA_BIAS_CURR_SHIFT, XCVR_TCA_CTRL_TCA_BIAS_CURR_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TCA_CTRL, field TCA_LOW_PWR_ON[2] (RW)
 *
 * Enable the tca low power mode
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_CTRL_TCA_LOW_PWR_ON field. */
#define XCVR_RD_TCA_CTRL_TCA_LOW_PWR_ON(base) ((XCVR_TCA_CTRL_REG(base) & XCVR_TCA_CTRL_TCA_LOW_PWR_ON_MASK) >> XCVR_TCA_CTRL_TCA_LOW_PWR_ON_SHIFT)
#define XCVR_BRD_TCA_CTRL_TCA_LOW_PWR_ON(base) (BME_UBFX32(&XCVR_TCA_CTRL_REG(base), XCVR_TCA_CTRL_TCA_LOW_PWR_ON_SHIFT, XCVR_TCA_CTRL_TCA_LOW_PWR_ON_WIDTH))

/*! @brief Set the TCA_LOW_PWR_ON field to a new value. */
#define XCVR_WR_TCA_CTRL_TCA_LOW_PWR_ON(base, value) (XCVR_RMW_TCA_CTRL(base, XCVR_TCA_CTRL_TCA_LOW_PWR_ON_MASK, XCVR_TCA_CTRL_TCA_LOW_PWR_ON(value)))
#define XCVR_BWR_TCA_CTRL_TCA_LOW_PWR_ON(base, value) (BME_BFI32(&XCVR_TCA_CTRL_REG(base), ((uint32_t)(value) << XCVR_TCA_CTRL_TCA_LOW_PWR_ON_SHIFT), XCVR_TCA_CTRL_TCA_LOW_PWR_ON_SHIFT, XCVR_TCA_CTRL_TCA_LOW_PWR_ON_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TCA_CTRL, field TCA_TX_REG_BYPASS_ON[3] (RW)
 *
 * This register bit determines if the regulator is in bypass mode. When in
 * bypass mode, the external voltage applied to the input of the regulator is
 * presented at the regulator output.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_CTRL_TCA_TX_REG_BYPASS_ON field. */
#define XCVR_RD_TCA_CTRL_TCA_TX_REG_BYPASS_ON(base) ((XCVR_TCA_CTRL_REG(base) & XCVR_TCA_CTRL_TCA_TX_REG_BYPASS_ON_MASK) >> XCVR_TCA_CTRL_TCA_TX_REG_BYPASS_ON_SHIFT)
#define XCVR_BRD_TCA_CTRL_TCA_TX_REG_BYPASS_ON(base) (BME_UBFX32(&XCVR_TCA_CTRL_REG(base), XCVR_TCA_CTRL_TCA_TX_REG_BYPASS_ON_SHIFT, XCVR_TCA_CTRL_TCA_TX_REG_BYPASS_ON_WIDTH))

/*! @brief Set the TCA_TX_REG_BYPASS_ON field to a new value. */
#define XCVR_WR_TCA_CTRL_TCA_TX_REG_BYPASS_ON(base, value) (XCVR_RMW_TCA_CTRL(base, XCVR_TCA_CTRL_TCA_TX_REG_BYPASS_ON_MASK, XCVR_TCA_CTRL_TCA_TX_REG_BYPASS_ON(value)))
#define XCVR_BWR_TCA_CTRL_TCA_TX_REG_BYPASS_ON(base, value) (BME_BFI32(&XCVR_TCA_CTRL_REG(base), ((uint32_t)(value) << XCVR_TCA_CTRL_TCA_TX_REG_BYPASS_ON_SHIFT), XCVR_TCA_CTRL_TCA_TX_REG_BYPASS_ON_SHIFT, XCVR_TCA_CTRL_TCA_TX_REG_BYPASS_ON_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TCA_CTRL, field TCA_TX_REG_SUPPLY[7:4] (RW)
 *
 * Regulator trim bit to change the outputvoltage from 1.05 to 1.4V
 *
 * Values:
 * - 0b0000 - 1.2V
 * - 0b0001 - 1.05V
 * - 0b0010 - 1.275V
 * - 0b0011 - 1.3V
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_CTRL_TCA_TX_REG_SUPPLY field. */
#define XCVR_RD_TCA_CTRL_TCA_TX_REG_SUPPLY(base) ((XCVR_TCA_CTRL_REG(base) & XCVR_TCA_CTRL_TCA_TX_REG_SUPPLY_MASK) >> XCVR_TCA_CTRL_TCA_TX_REG_SUPPLY_SHIFT)
#define XCVR_BRD_TCA_CTRL_TCA_TX_REG_SUPPLY(base) (BME_UBFX32(&XCVR_TCA_CTRL_REG(base), XCVR_TCA_CTRL_TCA_TX_REG_SUPPLY_SHIFT, XCVR_TCA_CTRL_TCA_TX_REG_SUPPLY_WIDTH))

/*! @brief Set the TCA_TX_REG_SUPPLY field to a new value. */
#define XCVR_WR_TCA_CTRL_TCA_TX_REG_SUPPLY(base, value) (XCVR_RMW_TCA_CTRL(base, XCVR_TCA_CTRL_TCA_TX_REG_SUPPLY_MASK, XCVR_TCA_CTRL_TCA_TX_REG_SUPPLY(value)))
#define XCVR_BWR_TCA_CTRL_TCA_TX_REG_SUPPLY(base, value) (BME_BFI32(&XCVR_TCA_CTRL_REG(base), ((uint32_t)(value) << XCVR_TCA_CTRL_TCA_TX_REG_SUPPLY_SHIFT), XCVR_TCA_CTRL_TCA_TX_REG_SUPPLY_SHIFT, XCVR_TCA_CTRL_TCA_TX_REG_SUPPLY_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TCA_CTRL, field TCA_TX_REG_ATST_SEL[9:8] (RW)
 *
 * These bits determine what internal signals to connect to ATST bus register
 * setting ATST0 00 No Connect 01 vout 10 vin feedback 11 vbias
 */
/*@{*/
/*! @brief Read current value of the XCVR_TCA_CTRL_TCA_TX_REG_ATST_SEL field. */
#define XCVR_RD_TCA_CTRL_TCA_TX_REG_ATST_SEL(base) ((XCVR_TCA_CTRL_REG(base) & XCVR_TCA_CTRL_TCA_TX_REG_ATST_SEL_MASK) >> XCVR_TCA_CTRL_TCA_TX_REG_ATST_SEL_SHIFT)
#define XCVR_BRD_TCA_CTRL_TCA_TX_REG_ATST_SEL(base) (BME_UBFX32(&XCVR_TCA_CTRL_REG(base), XCVR_TCA_CTRL_TCA_TX_REG_ATST_SEL_SHIFT, XCVR_TCA_CTRL_TCA_TX_REG_ATST_SEL_WIDTH))

/*! @brief Set the TCA_TX_REG_ATST_SEL field to a new value. */
#define XCVR_WR_TCA_CTRL_TCA_TX_REG_ATST_SEL(base, value) (XCVR_RMW_TCA_CTRL(base, XCVR_TCA_CTRL_TCA_TX_REG_ATST_SEL_MASK, XCVR_TCA_CTRL_TCA_TX_REG_ATST_SEL(value)))
#define XCVR_BWR_TCA_CTRL_TCA_TX_REG_ATST_SEL(base, value) (BME_BFI32(&XCVR_TCA_CTRL_REG(base), ((uint32_t)(value) << XCVR_TCA_CTRL_TCA_TX_REG_ATST_SEL_SHIFT), XCVR_TCA_CTRL_TCA_TX_REG_ATST_SEL_SHIFT, XCVR_TCA_CTRL_TCA_TX_REG_ATST_SEL_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TZA_CTRL - TZA Control
 ******************************************************************************/

/*!
 * @brief XCVR_TZA_CTRL - TZA Control (RW)
 *
 * Reset value: 0x00000044U
 */
/*!
 * @name Constants and macros for entire XCVR_TZA_CTRL register
 */
/*@{*/
#define XCVR_RD_TZA_CTRL(base)   (XCVR_TZA_CTRL_REG(base))
#define XCVR_WR_TZA_CTRL(base, value) (XCVR_TZA_CTRL_REG(base) = (value))
#define XCVR_RMW_TZA_CTRL(base, mask, value) (XCVR_WR_TZA_CTRL(base, (XCVR_RD_TZA_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_TZA_CTRL(base, value) (BME_OR32(&XCVR_TZA_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TZA_CTRL(base, value) (BME_AND32(&XCVR_TZA_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TZA_CTRL(base, value) (BME_XOR32(&XCVR_TZA_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TZA_CTRL bitfields
 */

/*!
 * @name Register XCVR_TZA_CTRL, field TZA_CAP_TUNE[3:0] (RW)
 *
 * The bits sets the f3dB filter corner for the TZA block. This in combination
 * with bbf_cap_tune and bbf_res_tune2 determine the baseband filter response.Look
 * for the f3db corner here BBF_CAP_TUNEBBF_CAP_TUNE
 */
/*@{*/
/*! @brief Read current value of the XCVR_TZA_CTRL_TZA_CAP_TUNE field. */
#define XCVR_RD_TZA_CTRL_TZA_CAP_TUNE(base) ((XCVR_TZA_CTRL_REG(base) & XCVR_TZA_CTRL_TZA_CAP_TUNE_MASK) >> XCVR_TZA_CTRL_TZA_CAP_TUNE_SHIFT)
#define XCVR_BRD_TZA_CTRL_TZA_CAP_TUNE(base) (BME_UBFX32(&XCVR_TZA_CTRL_REG(base), XCVR_TZA_CTRL_TZA_CAP_TUNE_SHIFT, XCVR_TZA_CTRL_TZA_CAP_TUNE_WIDTH))

/*! @brief Set the TZA_CAP_TUNE field to a new value. */
#define XCVR_WR_TZA_CTRL_TZA_CAP_TUNE(base, value) (XCVR_RMW_TZA_CTRL(base, XCVR_TZA_CTRL_TZA_CAP_TUNE_MASK, XCVR_TZA_CTRL_TZA_CAP_TUNE(value)))
#define XCVR_BWR_TZA_CTRL_TZA_CAP_TUNE(base, value) (BME_BFI32(&XCVR_TZA_CTRL_REG(base), ((uint32_t)(value) << XCVR_TZA_CTRL_TZA_CAP_TUNE_SHIFT), XCVR_TZA_CTRL_TZA_CAP_TUNE_SHIFT, XCVR_TZA_CTRL_TZA_CAP_TUNE_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TZA_CTRL, field TZA_GAIN[4] (RW)
 *
 * Change the TZA gain. It is not used in this version of silicon.
 */
/*@{*/
/*! @brief Read current value of the XCVR_TZA_CTRL_TZA_GAIN field. */
#define XCVR_RD_TZA_CTRL_TZA_GAIN(base) ((XCVR_TZA_CTRL_REG(base) & XCVR_TZA_CTRL_TZA_GAIN_MASK) >> XCVR_TZA_CTRL_TZA_GAIN_SHIFT)
#define XCVR_BRD_TZA_CTRL_TZA_GAIN(base) (BME_UBFX32(&XCVR_TZA_CTRL_REG(base), XCVR_TZA_CTRL_TZA_GAIN_SHIFT, XCVR_TZA_CTRL_TZA_GAIN_WIDTH))

/*! @brief Set the TZA_GAIN field to a new value. */
#define XCVR_WR_TZA_CTRL_TZA_GAIN(base, value) (XCVR_RMW_TZA_CTRL(base, XCVR_TZA_CTRL_TZA_GAIN_MASK, XCVR_TZA_CTRL_TZA_GAIN(value)))
#define XCVR_BWR_TZA_CTRL_TZA_GAIN(base, value) (BME_BFI32(&XCVR_TZA_CTRL_REG(base), ((uint32_t)(value) << XCVR_TZA_CTRL_TZA_GAIN_SHIFT), XCVR_TZA_CTRL_TZA_GAIN_SHIFT, XCVR_TZA_CTRL_TZA_GAIN_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TZA_CTRL, field TZA_DCOC_ON[5] (RW)
 *
 * Not currently connected. Was intended to enable the DCOC DAC at the output of
 * the TZA
 */
/*@{*/
/*! @brief Read current value of the XCVR_TZA_CTRL_TZA_DCOC_ON field. */
#define XCVR_RD_TZA_CTRL_TZA_DCOC_ON(base) ((XCVR_TZA_CTRL_REG(base) & XCVR_TZA_CTRL_TZA_DCOC_ON_MASK) >> XCVR_TZA_CTRL_TZA_DCOC_ON_SHIFT)
#define XCVR_BRD_TZA_CTRL_TZA_DCOC_ON(base) (BME_UBFX32(&XCVR_TZA_CTRL_REG(base), XCVR_TZA_CTRL_TZA_DCOC_ON_SHIFT, XCVR_TZA_CTRL_TZA_DCOC_ON_WIDTH))

/*! @brief Set the TZA_DCOC_ON field to a new value. */
#define XCVR_WR_TZA_CTRL_TZA_DCOC_ON(base, value) (XCVR_RMW_TZA_CTRL(base, XCVR_TZA_CTRL_TZA_DCOC_ON_MASK, XCVR_TZA_CTRL_TZA_DCOC_ON(value)))
#define XCVR_BWR_TZA_CTRL_TZA_DCOC_ON(base, value) (BME_BFI32(&XCVR_TZA_CTRL_REG(base), ((uint32_t)(value) << XCVR_TZA_CTRL_TZA_DCOC_ON_SHIFT), XCVR_TZA_CTRL_TZA_DCOC_ON_SHIFT, XCVR_TZA_CTRL_TZA_DCOC_ON_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TZA_CTRL, field TZA_CUR_CNTL[7:6] (RW)
 *
 * Program the current in TZA. The TZA current is varied from 510uA to 2.1mA
 */
/*@{*/
/*! @brief Read current value of the XCVR_TZA_CTRL_TZA_CUR_CNTL field. */
#define XCVR_RD_TZA_CTRL_TZA_CUR_CNTL(base) ((XCVR_TZA_CTRL_REG(base) & XCVR_TZA_CTRL_TZA_CUR_CNTL_MASK) >> XCVR_TZA_CTRL_TZA_CUR_CNTL_SHIFT)
#define XCVR_BRD_TZA_CTRL_TZA_CUR_CNTL(base) (BME_UBFX32(&XCVR_TZA_CTRL_REG(base), XCVR_TZA_CTRL_TZA_CUR_CNTL_SHIFT, XCVR_TZA_CTRL_TZA_CUR_CNTL_WIDTH))

/*! @brief Set the TZA_CUR_CNTL field to a new value. */
#define XCVR_WR_TZA_CTRL_TZA_CUR_CNTL(base, value) (XCVR_RMW_TZA_CTRL(base, XCVR_TZA_CTRL_TZA_CUR_CNTL_MASK, XCVR_TZA_CTRL_TZA_CUR_CNTL(value)))
#define XCVR_BWR_TZA_CTRL_TZA_CUR_CNTL(base, value) (BME_BFI32(&XCVR_TZA_CTRL_REG(base), ((uint32_t)(value) << XCVR_TZA_CTRL_TZA_CUR_CNTL_SHIFT), XCVR_TZA_CTRL_TZA_CUR_CNTL_SHIFT, XCVR_TZA_CTRL_TZA_CUR_CNTL_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_TZA_CTRL, field TZA_SPARE[23:20] (RW)
 *
 * Spare Bits for future use
 */
/*@{*/
/*! @brief Read current value of the XCVR_TZA_CTRL_TZA_SPARE field. */
#define XCVR_RD_TZA_CTRL_TZA_SPARE(base) ((XCVR_TZA_CTRL_REG(base) & XCVR_TZA_CTRL_TZA_SPARE_MASK) >> XCVR_TZA_CTRL_TZA_SPARE_SHIFT)
#define XCVR_BRD_TZA_CTRL_TZA_SPARE(base) (BME_UBFX32(&XCVR_TZA_CTRL_REG(base), XCVR_TZA_CTRL_TZA_SPARE_SHIFT, XCVR_TZA_CTRL_TZA_SPARE_WIDTH))

/*! @brief Set the TZA_SPARE field to a new value. */
#define XCVR_WR_TZA_CTRL_TZA_SPARE(base, value) (XCVR_RMW_TZA_CTRL(base, XCVR_TZA_CTRL_TZA_SPARE_MASK, XCVR_TZA_CTRL_TZA_SPARE(value)))
#define XCVR_BWR_TZA_CTRL_TZA_SPARE(base, value) (BME_BFI32(&XCVR_TZA_CTRL_REG(base), ((uint32_t)(value) << XCVR_TZA_CTRL_TZA_SPARE_SHIFT), XCVR_TZA_CTRL_TZA_SPARE_SHIFT, XCVR_TZA_CTRL_TZA_SPARE_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_TX_ANA_CTRL - TX Analog Control
 ******************************************************************************/

/*!
 * @brief XCVR_TX_ANA_CTRL - TX Analog Control (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_TX_ANA_CTRL register
 */
/*@{*/
#define XCVR_RD_TX_ANA_CTRL(base) (XCVR_TX_ANA_CTRL_REG(base))
#define XCVR_WR_TX_ANA_CTRL(base, value) (XCVR_TX_ANA_CTRL_REG(base) = (value))
#define XCVR_RMW_TX_ANA_CTRL(base, mask, value) (XCVR_WR_TX_ANA_CTRL(base, (XCVR_RD_TX_ANA_CTRL(base) & ~(mask)) | (value)))
#define XCVR_SET_TX_ANA_CTRL(base, value) (BME_OR32(&XCVR_TX_ANA_CTRL_REG(base), (uint32_t)(value)))
#define XCVR_CLR_TX_ANA_CTRL(base, value) (BME_AND32(&XCVR_TX_ANA_CTRL_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_TX_ANA_CTRL(base, value) (BME_XOR32(&XCVR_TX_ANA_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_TX_ANA_CTRL bitfields
 */

/*!
 * @name Register XCVR_TX_ANA_CTRL, field HPM_CAL_ADJUST[3:0] (RW)
 *
 * Provides a (-8/+7) range of adjustment to the HPM Calibration Count
 * Difference for the HPM Calibration lookup table
 */
/*@{*/
/*! @brief Read current value of the XCVR_TX_ANA_CTRL_HPM_CAL_ADJUST field. */
#define XCVR_RD_TX_ANA_CTRL_HPM_CAL_ADJUST(base) ((XCVR_TX_ANA_CTRL_REG(base) & XCVR_TX_ANA_CTRL_HPM_CAL_ADJUST_MASK) >> XCVR_TX_ANA_CTRL_HPM_CAL_ADJUST_SHIFT)
#define XCVR_BRD_TX_ANA_CTRL_HPM_CAL_ADJUST(base) (BME_UBFX32(&XCVR_TX_ANA_CTRL_REG(base), XCVR_TX_ANA_CTRL_HPM_CAL_ADJUST_SHIFT, XCVR_TX_ANA_CTRL_HPM_CAL_ADJUST_WIDTH))

/*! @brief Set the HPM_CAL_ADJUST field to a new value. */
#define XCVR_WR_TX_ANA_CTRL_HPM_CAL_ADJUST(base, value) (XCVR_RMW_TX_ANA_CTRL(base, XCVR_TX_ANA_CTRL_HPM_CAL_ADJUST_MASK, XCVR_TX_ANA_CTRL_HPM_CAL_ADJUST(value)))
#define XCVR_BWR_TX_ANA_CTRL_HPM_CAL_ADJUST(base, value) (BME_BFI32(&XCVR_TX_ANA_CTRL_REG(base), ((uint32_t)(value) << XCVR_TX_ANA_CTRL_HPM_CAL_ADJUST_SHIFT), XCVR_TX_ANA_CTRL_HPM_CAL_ADJUST_SHIFT, XCVR_TX_ANA_CTRL_HPM_CAL_ADJUST_WIDTH))
/*@}*/

/*******************************************************************************
 * XCVR_ANA_SPARE - Analog Spare
 ******************************************************************************/

/*!
 * @brief XCVR_ANA_SPARE - Analog Spare (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire XCVR_ANA_SPARE register
 */
/*@{*/
#define XCVR_RD_ANA_SPARE(base)  (XCVR_ANA_SPARE_REG(base))
#define XCVR_WR_ANA_SPARE(base, value) (XCVR_ANA_SPARE_REG(base) = (value))
#define XCVR_RMW_ANA_SPARE(base, mask, value) (XCVR_WR_ANA_SPARE(base, (XCVR_RD_ANA_SPARE(base) & ~(mask)) | (value)))
#define XCVR_SET_ANA_SPARE(base, value) (BME_OR32(&XCVR_ANA_SPARE_REG(base), (uint32_t)(value)))
#define XCVR_CLR_ANA_SPARE(base, value) (BME_AND32(&XCVR_ANA_SPARE_REG(base), (uint32_t)(~(value))))
#define XCVR_TOG_ANA_SPARE(base, value) (BME_XOR32(&XCVR_ANA_SPARE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XCVR_ANA_SPARE bitfields
 */

/*!
 * @name Register XCVR_ANA_SPARE, field IQMC_DC_GAIN_ADJ[10:0] (RW)
 *
 * I/Q mismatch correction DC gain coefficient. This is the value by which the Q
 * channel data is multiplied during DCOC calibration if the IQMC_DC_GAIN_ADJ_EN
 * bit is set; otherwise IQMC_GAIN_ADJ is used during DCOC calibration. Format
 * is u1.10 so e.g. 11'h400 (the reset value) corresponds to a value of 1.0,
 * 11'h200 corresponds to 0.5, 11'h600 corresponds to 1.5.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ANA_SPARE_IQMC_DC_GAIN_ADJ field. */
#define XCVR_RD_ANA_SPARE_IQMC_DC_GAIN_ADJ(base) ((XCVR_ANA_SPARE_REG(base) & XCVR_ANA_SPARE_IQMC_DC_GAIN_ADJ_MASK) >> XCVR_ANA_SPARE_IQMC_DC_GAIN_ADJ_SHIFT)
#define XCVR_BRD_ANA_SPARE_IQMC_DC_GAIN_ADJ(base) (BME_UBFX32(&XCVR_ANA_SPARE_REG(base), XCVR_ANA_SPARE_IQMC_DC_GAIN_ADJ_SHIFT, XCVR_ANA_SPARE_IQMC_DC_GAIN_ADJ_WIDTH))

/*! @brief Set the IQMC_DC_GAIN_ADJ field to a new value. */
#define XCVR_WR_ANA_SPARE_IQMC_DC_GAIN_ADJ(base, value) (XCVR_RMW_ANA_SPARE(base, XCVR_ANA_SPARE_IQMC_DC_GAIN_ADJ_MASK, XCVR_ANA_SPARE_IQMC_DC_GAIN_ADJ(value)))
#define XCVR_BWR_ANA_SPARE_IQMC_DC_GAIN_ADJ(base, value) (BME_BFI32(&XCVR_ANA_SPARE_REG(base), ((uint32_t)(value) << XCVR_ANA_SPARE_IQMC_DC_GAIN_ADJ_SHIFT), XCVR_ANA_SPARE_IQMC_DC_GAIN_ADJ_SHIFT, XCVR_ANA_SPARE_IQMC_DC_GAIN_ADJ_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ANA_SPARE, field DCOC_TRK_EST_GS_CNT[13:11] (RW)
 *
 * Indicates the number of tracking update corrections after an AGC gain change
 * before the tracking estimator switches from parameters {dcoc_alpha_radius_idx,
 * dcoc_alphac_scaling_idx, dcoc_sign_scaling_idx} to the set of gearshift
 * parameters {dcoc_alpha_radius_gs_idx, dcoc_alphac_scaling_gs_idx,
 * dcoc_sign_scaling_idx}. Note that dcoc_sign_scaling_idx is used in both configurations.
 *
 * Values:
 * - 0b000 - Only use {dcoc_alpha_radius_idx, dcoc_alphac_scaling_idx,
 *     dcoc_sign_scaling_idx}
 * - 0b001 - Switch from {dcoc_alpha_radius_idx, dcoc_alphac_scaling_idx,
 *     dcoc_sign_scaling_idx} to {dcoc_alpha_radius_gs_idx, dcoc_alphac_scaling_gs_idx,
 *     dcoc_sign_scaling_idx} after the 1 update correction.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ANA_SPARE_DCOC_TRK_EST_GS_CNT field. */
#define XCVR_RD_ANA_SPARE_DCOC_TRK_EST_GS_CNT(base) ((XCVR_ANA_SPARE_REG(base) & XCVR_ANA_SPARE_DCOC_TRK_EST_GS_CNT_MASK) >> XCVR_ANA_SPARE_DCOC_TRK_EST_GS_CNT_SHIFT)
#define XCVR_BRD_ANA_SPARE_DCOC_TRK_EST_GS_CNT(base) (BME_UBFX32(&XCVR_ANA_SPARE_REG(base), XCVR_ANA_SPARE_DCOC_TRK_EST_GS_CNT_SHIFT, XCVR_ANA_SPARE_DCOC_TRK_EST_GS_CNT_WIDTH))

/*! @brief Set the DCOC_TRK_EST_GS_CNT field to a new value. */
#define XCVR_WR_ANA_SPARE_DCOC_TRK_EST_GS_CNT(base, value) (XCVR_RMW_ANA_SPARE(base, XCVR_ANA_SPARE_DCOC_TRK_EST_GS_CNT_MASK, XCVR_ANA_SPARE_DCOC_TRK_EST_GS_CNT(value)))
#define XCVR_BWR_ANA_SPARE_DCOC_TRK_EST_GS_CNT(base, value) (BME_BFI32(&XCVR_ANA_SPARE_REG(base), ((uint32_t)(value) << XCVR_ANA_SPARE_DCOC_TRK_EST_GS_CNT_SHIFT), XCVR_ANA_SPARE_DCOC_TRK_EST_GS_CNT_SHIFT, XCVR_ANA_SPARE_DCOC_TRK_EST_GS_CNT_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ANA_SPARE, field HPM_LSB_INVERT[15:14] (RW)
 *
 * Provides individual inversion settings for the two HPM LSB Array Units
 */
/*@{*/
/*! @brief Read current value of the XCVR_ANA_SPARE_HPM_LSB_INVERT field. */
#define XCVR_RD_ANA_SPARE_HPM_LSB_INVERT(base) ((XCVR_ANA_SPARE_REG(base) & XCVR_ANA_SPARE_HPM_LSB_INVERT_MASK) >> XCVR_ANA_SPARE_HPM_LSB_INVERT_SHIFT)
#define XCVR_BRD_ANA_SPARE_HPM_LSB_INVERT(base) (BME_UBFX32(&XCVR_ANA_SPARE_REG(base), XCVR_ANA_SPARE_HPM_LSB_INVERT_SHIFT, XCVR_ANA_SPARE_HPM_LSB_INVERT_WIDTH))

/*! @brief Set the HPM_LSB_INVERT field to a new value. */
#define XCVR_WR_ANA_SPARE_HPM_LSB_INVERT(base, value) (XCVR_RMW_ANA_SPARE(base, XCVR_ANA_SPARE_HPM_LSB_INVERT_MASK, XCVR_ANA_SPARE_HPM_LSB_INVERT(value)))
#define XCVR_BWR_ANA_SPARE_HPM_LSB_INVERT(base, value) (BME_BFI32(&XCVR_ANA_SPARE_REG(base), ((uint32_t)(value) << XCVR_ANA_SPARE_HPM_LSB_INVERT_SHIFT), XCVR_ANA_SPARE_HPM_LSB_INVERT_SHIFT, XCVR_ANA_SPARE_HPM_LSB_INVERT_WIDTH))
/*@}*/

/*!
 * @name Register XCVR_ANA_SPARE, field ANA_DTEST[21:16] (RO)
 *
 * Not currently implemented, reads back zero.
 */
/*@{*/
/*! @brief Read current value of the XCVR_ANA_SPARE_ANA_DTEST field. */
#define XCVR_RD_ANA_SPARE_ANA_DTEST(base) ((XCVR_ANA_SPARE_REG(base) & XCVR_ANA_SPARE_ANA_DTEST_MASK) >> XCVR_ANA_SPARE_ANA_DTEST_SHIFT)
#define XCVR_BRD_ANA_SPARE_ANA_DTEST(base) (BME_UBFX32(&XCVR_ANA_SPARE_REG(base), XCVR_ANA_SPARE_ANA_DTEST_SHIFT, XCVR_ANA_SPARE_ANA_DTEST_WIDTH))
/*@}*/

/*
 * MKW40Z4 ZLL
 *
 * Zigbee Link Layer
 *
 * Registers defined in this header file:
 * - ZLL_IRQSTS - INTERRUPT REQUEST STATUS
 * - ZLL_PHY_CTRL - PHY CONTROL
 * - ZLL_EVENT_TMR - EVENT TIMER
 * - ZLL_TIMESTAMP - TIMESTAMP
 * - ZLL_T1CMP - T1 COMPARE
 * - ZLL_T2CMP - T2 COMPARE
 * - ZLL_T2PRIMECMP - T2 PRIME COMPARE
 * - ZLL_T3CMP - T3 COMPARE
 * - ZLL_T4CMP - T4 COMPARE
 * - ZLL_PA_PWR - PA POWER
 * - ZLL_CHANNEL_NUM0 - CHANNEL NUMBER 0
 * - ZLL_LQI_AND_RSSI - LQI AND RSSI
 * - ZLL_MACSHORTADDRS0 - MAC SHORT ADDRESS 0
 * - ZLL_MACLONGADDRS0_LSB - MAC LONG ADDRESS 0 LSB
 * - ZLL_MACLONGADDRS0_MSB - MAC LONG ADDRESS 0 MSB
 * - ZLL_RX_FRAME_FILTER - RECEIVE FRAME FILTER
 * - ZLL_CCA_LQI_CTRL - CCA AND LQI CONTROL
 * - ZLL_CCA2_CTRL - CCA2 CONTROL
 * - ZLL_FAD_CTRL - FAD CONTROL
 * - ZLL_SNF_CTRL - SNF CONTROL
 * - ZLL_BSM_CTRL - BSM CONTROL
 * - ZLL_MACSHORTADDRS1 - MAC SHORT ADDRESS 1
 * - ZLL_MACLONGADDRS1_LSB - MAC LONG ADDRESS 1 LSB
 * - ZLL_MACLONGADDRS1_MSB - MAC LONG ADDRESS 1 MSB
 * - ZLL_DUAL_PAN_CTRL - DUAL PAN CONTROL
 * - ZLL_CHANNEL_NUM1 - CHANNEL NUMBER 1
 * - ZLL_SAM_CTRL - SAM CONTROL
 * - ZLL_SAM_TABLE - SOURCE ADDRESS MANAGEMENT TABLE
 * - ZLL_SAM_MATCH - SAM MATCH
 * - ZLL_SAM_FREE_IDX - SAM FREE INDEX
 * - ZLL_SEQ_CTRL_STS - SEQUENCE CONTROL AND STATUS
 * - ZLL_ACKDELAY - ACK DELAY
 * - ZLL_FILTERFAIL_CODE - FILTER FAIL CODE
 * - ZLL_RX_WTR_MARK - RECEIVE WATER MARK
 * - ZLL_SLOT_PRELOAD - SLOT PRELOAD
 * - ZLL_SEQ_STATE - ZIGBEE SEQUENCE STATE
 * - ZLL_TMR_PRESCALE - TIMER PRESCALER
 * - ZLL_LENIENCY_LSB - LENIENCY LSB
 * - ZLL_LENIENCY_MSB - LENIENCY MSB
 * - ZLL_PART_ID - PART ID
 * - ZLL_PKT_BUFFER - PACKET BUFFER
 */

#define ZLL_INSTANCE_COUNT (1U) /*!< Number of instances of the ZLL module. */
#define ZLL_IDX (0U) /*!< Instance number for ZLL. */

/*******************************************************************************
 * ZLL_IRQSTS - INTERRUPT REQUEST STATUS
 ******************************************************************************/

/*!
 * @brief ZLL_IRQSTS - INTERRUPT REQUEST STATUS (RW)
 *
 * Reset value: 0x00F00000U
 *
 * Zigbee Interrupt Request Status
 */
/*!
 * @name Constants and macros for entire ZLL_IRQSTS register
 */
/*@{*/
#define ZLL_RD_IRQSTS(base)      (ZLL_IRQSTS_REG(base))
#define ZLL_WR_IRQSTS(base, value) (ZLL_IRQSTS_REG(base) = (value))
#define ZLL_RMW_IRQSTS(base, mask, value) (ZLL_WR_IRQSTS(base, (ZLL_RD_IRQSTS(base) & ~(mask)) | (value)))
#define ZLL_SET_IRQSTS(base, value) (BME_OR32(&ZLL_IRQSTS_REG(base), (uint32_t)(value)))
#define ZLL_CLR_IRQSTS(base, value) (BME_AND32(&ZLL_IRQSTS_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_IRQSTS(base, value) (BME_XOR32(&ZLL_IRQSTS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_IRQSTS bitfields
 */

/*!
 * @name Register ZLL_IRQSTS, field SEQIRQ[0] (W1C)
 *
 * Values:
 * - 0b0 - A Sequencer Interrupt has not occurred
 * - 0b1 - A Sequencer Interrupt has occurred
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_SEQIRQ field. */
#define ZLL_RD_IRQSTS_SEQIRQ(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_SEQIRQ_MASK) >> ZLL_IRQSTS_SEQIRQ_SHIFT)
#define ZLL_BRD_IRQSTS_SEQIRQ(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_SEQIRQ_SHIFT, ZLL_IRQSTS_SEQIRQ_WIDTH))

/*! @brief Set the SEQIRQ field to a new value. */
#define ZLL_WR_IRQSTS_SEQIRQ(base, value) (ZLL_RMW_IRQSTS(base, (ZLL_IRQSTS_SEQIRQ_MASK | ZLL_IRQSTS_TXIRQ_MASK | ZLL_IRQSTS_RXIRQ_MASK | ZLL_IRQSTS_CCAIRQ_MASK | ZLL_IRQSTS_RXWTRMRKIRQ_MASK | ZLL_IRQSTS_FILTERFAIL_IRQ_MASK | ZLL_IRQSTS_PLL_UNLOCK_IRQ_MASK | ZLL_IRQSTS_PB_ERR_IRQ_MASK | ZLL_IRQSTS_TMR1IRQ_MASK | ZLL_IRQSTS_TMR2IRQ_MASK | ZLL_IRQSTS_TMR3IRQ_MASK | ZLL_IRQSTS_TMR4IRQ_MASK), ZLL_IRQSTS_SEQIRQ(value)))
#define ZLL_BWR_IRQSTS_SEQIRQ(base, value) (BME_BFI32(&ZLL_IRQSTS_REG(base), ((uint32_t)(value) << ZLL_IRQSTS_SEQIRQ_SHIFT), ZLL_IRQSTS_SEQIRQ_SHIFT, ZLL_IRQSTS_SEQIRQ_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field TXIRQ[1] (W1C)
 *
 * Values:
 * - 0b0 - A TX Interrupt has not occurred
 * - 0b1 - A TX Interrupt has occurred
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_TXIRQ field. */
#define ZLL_RD_IRQSTS_TXIRQ(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_TXIRQ_MASK) >> ZLL_IRQSTS_TXIRQ_SHIFT)
#define ZLL_BRD_IRQSTS_TXIRQ(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_TXIRQ_SHIFT, ZLL_IRQSTS_TXIRQ_WIDTH))

/*! @brief Set the TXIRQ field to a new value. */
#define ZLL_WR_IRQSTS_TXIRQ(base, value) (ZLL_RMW_IRQSTS(base, (ZLL_IRQSTS_TXIRQ_MASK | ZLL_IRQSTS_SEQIRQ_MASK | ZLL_IRQSTS_RXIRQ_MASK | ZLL_IRQSTS_CCAIRQ_MASK | ZLL_IRQSTS_RXWTRMRKIRQ_MASK | ZLL_IRQSTS_FILTERFAIL_IRQ_MASK | ZLL_IRQSTS_PLL_UNLOCK_IRQ_MASK | ZLL_IRQSTS_PB_ERR_IRQ_MASK | ZLL_IRQSTS_TMR1IRQ_MASK | ZLL_IRQSTS_TMR2IRQ_MASK | ZLL_IRQSTS_TMR3IRQ_MASK | ZLL_IRQSTS_TMR4IRQ_MASK), ZLL_IRQSTS_TXIRQ(value)))
#define ZLL_BWR_IRQSTS_TXIRQ(base, value) (BME_BFI32(&ZLL_IRQSTS_REG(base), ((uint32_t)(value) << ZLL_IRQSTS_TXIRQ_SHIFT), ZLL_IRQSTS_TXIRQ_SHIFT, ZLL_IRQSTS_TXIRQ_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field RXIRQ[2] (W1C)
 *
 * Values:
 * - 0b0 - A RX Interrupt has not occurred
 * - 0b1 - A RX Interrupt has occurred
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_RXIRQ field. */
#define ZLL_RD_IRQSTS_RXIRQ(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_RXIRQ_MASK) >> ZLL_IRQSTS_RXIRQ_SHIFT)
#define ZLL_BRD_IRQSTS_RXIRQ(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_RXIRQ_SHIFT, ZLL_IRQSTS_RXIRQ_WIDTH))

/*! @brief Set the RXIRQ field to a new value. */
#define ZLL_WR_IRQSTS_RXIRQ(base, value) (ZLL_RMW_IRQSTS(base, (ZLL_IRQSTS_RXIRQ_MASK | ZLL_IRQSTS_SEQIRQ_MASK | ZLL_IRQSTS_TXIRQ_MASK | ZLL_IRQSTS_CCAIRQ_MASK | ZLL_IRQSTS_RXWTRMRKIRQ_MASK | ZLL_IRQSTS_FILTERFAIL_IRQ_MASK | ZLL_IRQSTS_PLL_UNLOCK_IRQ_MASK | ZLL_IRQSTS_PB_ERR_IRQ_MASK | ZLL_IRQSTS_TMR1IRQ_MASK | ZLL_IRQSTS_TMR2IRQ_MASK | ZLL_IRQSTS_TMR3IRQ_MASK | ZLL_IRQSTS_TMR4IRQ_MASK), ZLL_IRQSTS_RXIRQ(value)))
#define ZLL_BWR_IRQSTS_RXIRQ(base, value) (BME_BFI32(&ZLL_IRQSTS_REG(base), ((uint32_t)(value) << ZLL_IRQSTS_RXIRQ_SHIFT), ZLL_IRQSTS_RXIRQ_SHIFT, ZLL_IRQSTS_RXIRQ_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field CCAIRQ[3] (W1C)
 *
 * Values:
 * - 0b0 - A CCA Interrupt has not occurred
 * - 0b1 - A CCA Interrupt has occurred
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_CCAIRQ field. */
#define ZLL_RD_IRQSTS_CCAIRQ(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_CCAIRQ_MASK) >> ZLL_IRQSTS_CCAIRQ_SHIFT)
#define ZLL_BRD_IRQSTS_CCAIRQ(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_CCAIRQ_SHIFT, ZLL_IRQSTS_CCAIRQ_WIDTH))

/*! @brief Set the CCAIRQ field to a new value. */
#define ZLL_WR_IRQSTS_CCAIRQ(base, value) (ZLL_RMW_IRQSTS(base, (ZLL_IRQSTS_CCAIRQ_MASK | ZLL_IRQSTS_SEQIRQ_MASK | ZLL_IRQSTS_TXIRQ_MASK | ZLL_IRQSTS_RXIRQ_MASK | ZLL_IRQSTS_RXWTRMRKIRQ_MASK | ZLL_IRQSTS_FILTERFAIL_IRQ_MASK | ZLL_IRQSTS_PLL_UNLOCK_IRQ_MASK | ZLL_IRQSTS_PB_ERR_IRQ_MASK | ZLL_IRQSTS_TMR1IRQ_MASK | ZLL_IRQSTS_TMR2IRQ_MASK | ZLL_IRQSTS_TMR3IRQ_MASK | ZLL_IRQSTS_TMR4IRQ_MASK), ZLL_IRQSTS_CCAIRQ(value)))
#define ZLL_BWR_IRQSTS_CCAIRQ(base, value) (BME_BFI32(&ZLL_IRQSTS_REG(base), ((uint32_t)(value) << ZLL_IRQSTS_CCAIRQ_SHIFT), ZLL_IRQSTS_CCAIRQ_SHIFT, ZLL_IRQSTS_CCAIRQ_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field RXWTRMRKIRQ[4] (W1C)
 *
 * Values:
 * - 0b0 - A RX Watermark Interrupt has not occurred
 * - 0b1 - A RX Watermark Interrupt has occurred
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_RXWTRMRKIRQ field. */
#define ZLL_RD_IRQSTS_RXWTRMRKIRQ(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_RXWTRMRKIRQ_MASK) >> ZLL_IRQSTS_RXWTRMRKIRQ_SHIFT)
#define ZLL_BRD_IRQSTS_RXWTRMRKIRQ(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_RXWTRMRKIRQ_SHIFT, ZLL_IRQSTS_RXWTRMRKIRQ_WIDTH))

/*! @brief Set the RXWTRMRKIRQ field to a new value. */
#define ZLL_WR_IRQSTS_RXWTRMRKIRQ(base, value) (ZLL_RMW_IRQSTS(base, (ZLL_IRQSTS_RXWTRMRKIRQ_MASK | ZLL_IRQSTS_SEQIRQ_MASK | ZLL_IRQSTS_TXIRQ_MASK | ZLL_IRQSTS_RXIRQ_MASK | ZLL_IRQSTS_CCAIRQ_MASK | ZLL_IRQSTS_FILTERFAIL_IRQ_MASK | ZLL_IRQSTS_PLL_UNLOCK_IRQ_MASK | ZLL_IRQSTS_PB_ERR_IRQ_MASK | ZLL_IRQSTS_TMR1IRQ_MASK | ZLL_IRQSTS_TMR2IRQ_MASK | ZLL_IRQSTS_TMR3IRQ_MASK | ZLL_IRQSTS_TMR4IRQ_MASK), ZLL_IRQSTS_RXWTRMRKIRQ(value)))
#define ZLL_BWR_IRQSTS_RXWTRMRKIRQ(base, value) (BME_BFI32(&ZLL_IRQSTS_REG(base), ((uint32_t)(value) << ZLL_IRQSTS_RXWTRMRKIRQ_SHIFT), ZLL_IRQSTS_RXWTRMRKIRQ_SHIFT, ZLL_IRQSTS_RXWTRMRKIRQ_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field FILTERFAIL_IRQ[5] (W1C)
 *
 * Values:
 * - 0b0 - A Filter Fail Interrupt has not occurred
 * - 0b1 - A Filter Fail Interrupt has occurred
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_FILTERFAIL_IRQ field. */
#define ZLL_RD_IRQSTS_FILTERFAIL_IRQ(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_FILTERFAIL_IRQ_MASK) >> ZLL_IRQSTS_FILTERFAIL_IRQ_SHIFT)
#define ZLL_BRD_IRQSTS_FILTERFAIL_IRQ(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_FILTERFAIL_IRQ_SHIFT, ZLL_IRQSTS_FILTERFAIL_IRQ_WIDTH))

/*! @brief Set the FILTERFAIL_IRQ field to a new value. */
#define ZLL_WR_IRQSTS_FILTERFAIL_IRQ(base, value) (ZLL_RMW_IRQSTS(base, (ZLL_IRQSTS_FILTERFAIL_IRQ_MASK | ZLL_IRQSTS_SEQIRQ_MASK | ZLL_IRQSTS_TXIRQ_MASK | ZLL_IRQSTS_RXIRQ_MASK | ZLL_IRQSTS_CCAIRQ_MASK | ZLL_IRQSTS_RXWTRMRKIRQ_MASK | ZLL_IRQSTS_PLL_UNLOCK_IRQ_MASK | ZLL_IRQSTS_PB_ERR_IRQ_MASK | ZLL_IRQSTS_TMR1IRQ_MASK | ZLL_IRQSTS_TMR2IRQ_MASK | ZLL_IRQSTS_TMR3IRQ_MASK | ZLL_IRQSTS_TMR4IRQ_MASK), ZLL_IRQSTS_FILTERFAIL_IRQ(value)))
#define ZLL_BWR_IRQSTS_FILTERFAIL_IRQ(base, value) (BME_BFI32(&ZLL_IRQSTS_REG(base), ((uint32_t)(value) << ZLL_IRQSTS_FILTERFAIL_IRQ_SHIFT), ZLL_IRQSTS_FILTERFAIL_IRQ_SHIFT, ZLL_IRQSTS_FILTERFAIL_IRQ_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field PLL_UNLOCK_IRQ[6] (W1C)
 *
 * Values:
 * - 0b0 - A PLL Unlock Interrupt has not occurred
 * - 0b1 - A PLL Unlock Interrupt has occurred
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_PLL_UNLOCK_IRQ field. */
#define ZLL_RD_IRQSTS_PLL_UNLOCK_IRQ(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_PLL_UNLOCK_IRQ_MASK) >> ZLL_IRQSTS_PLL_UNLOCK_IRQ_SHIFT)
#define ZLL_BRD_IRQSTS_PLL_UNLOCK_IRQ(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_PLL_UNLOCK_IRQ_SHIFT, ZLL_IRQSTS_PLL_UNLOCK_IRQ_WIDTH))

/*! @brief Set the PLL_UNLOCK_IRQ field to a new value. */
#define ZLL_WR_IRQSTS_PLL_UNLOCK_IRQ(base, value) (ZLL_RMW_IRQSTS(base, (ZLL_IRQSTS_PLL_UNLOCK_IRQ_MASK | ZLL_IRQSTS_SEQIRQ_MASK | ZLL_IRQSTS_TXIRQ_MASK | ZLL_IRQSTS_RXIRQ_MASK | ZLL_IRQSTS_CCAIRQ_MASK | ZLL_IRQSTS_RXWTRMRKIRQ_MASK | ZLL_IRQSTS_FILTERFAIL_IRQ_MASK | ZLL_IRQSTS_PB_ERR_IRQ_MASK | ZLL_IRQSTS_TMR1IRQ_MASK | ZLL_IRQSTS_TMR2IRQ_MASK | ZLL_IRQSTS_TMR3IRQ_MASK | ZLL_IRQSTS_TMR4IRQ_MASK), ZLL_IRQSTS_PLL_UNLOCK_IRQ(value)))
#define ZLL_BWR_IRQSTS_PLL_UNLOCK_IRQ(base, value) (BME_BFI32(&ZLL_IRQSTS_REG(base), ((uint32_t)(value) << ZLL_IRQSTS_PLL_UNLOCK_IRQ_SHIFT), ZLL_IRQSTS_PLL_UNLOCK_IRQ_SHIFT, ZLL_IRQSTS_PLL_UNLOCK_IRQ_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field RX_FRM_PEND[7] (RO)
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_RX_FRM_PEND field. */
#define ZLL_RD_IRQSTS_RX_FRM_PEND(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_RX_FRM_PEND_MASK) >> ZLL_IRQSTS_RX_FRM_PEND_SHIFT)
#define ZLL_BRD_IRQSTS_RX_FRM_PEND(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_RX_FRM_PEND_SHIFT, ZLL_IRQSTS_RX_FRM_PEND_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field PB_ERR_IRQ[9] (W1C)
 *
 * Values:
 * - 0b0 - A Packet Buffer Underrun Error Interrupt has not occurred
 * - 0b1 - A Packet Buffer Underrun Error Interrupt has occurred
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_PB_ERR_IRQ field. */
#define ZLL_RD_IRQSTS_PB_ERR_IRQ(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_PB_ERR_IRQ_MASK) >> ZLL_IRQSTS_PB_ERR_IRQ_SHIFT)
#define ZLL_BRD_IRQSTS_PB_ERR_IRQ(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_PB_ERR_IRQ_SHIFT, ZLL_IRQSTS_PB_ERR_IRQ_WIDTH))

/*! @brief Set the PB_ERR_IRQ field to a new value. */
#define ZLL_WR_IRQSTS_PB_ERR_IRQ(base, value) (ZLL_RMW_IRQSTS(base, (ZLL_IRQSTS_PB_ERR_IRQ_MASK | ZLL_IRQSTS_SEQIRQ_MASK | ZLL_IRQSTS_TXIRQ_MASK | ZLL_IRQSTS_RXIRQ_MASK | ZLL_IRQSTS_CCAIRQ_MASK | ZLL_IRQSTS_RXWTRMRKIRQ_MASK | ZLL_IRQSTS_FILTERFAIL_IRQ_MASK | ZLL_IRQSTS_PLL_UNLOCK_IRQ_MASK | ZLL_IRQSTS_TMR1IRQ_MASK | ZLL_IRQSTS_TMR2IRQ_MASK | ZLL_IRQSTS_TMR3IRQ_MASK | ZLL_IRQSTS_TMR4IRQ_MASK), ZLL_IRQSTS_PB_ERR_IRQ(value)))
#define ZLL_BWR_IRQSTS_PB_ERR_IRQ(base, value) (BME_BFI32(&ZLL_IRQSTS_REG(base), ((uint32_t)(value) << ZLL_IRQSTS_PB_ERR_IRQ_SHIFT), ZLL_IRQSTS_PB_ERR_IRQ_SHIFT, ZLL_IRQSTS_PB_ERR_IRQ_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field TMRSTATUS[11] (RO)
 *
 * Values:
 * - 0b0 - no TMRxIRQ is asserted
 * - 0b1 - At least one of the TMRxIRQ is asserted (TMR1IRQ, TMR2IRQ, TMR3IRQ,
 *     or TMR4IRQ)
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_TMRSTATUS field. */
#define ZLL_RD_IRQSTS_TMRSTATUS(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_TMRSTATUS_MASK) >> ZLL_IRQSTS_TMRSTATUS_SHIFT)
#define ZLL_BRD_IRQSTS_TMRSTATUS(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_TMRSTATUS_SHIFT, ZLL_IRQSTS_TMRSTATUS_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field PI[12] (RO)
 *
 * Values:
 * - 0b0 - the received packet was not a data request
 * - 0b1 - the received packet was a data request, regardless of whether a
 *     Source Address table match occurred, or whether Source Address Management is
 *     enabled or not
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_PI field. */
#define ZLL_RD_IRQSTS_PI(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_PI_MASK) >> ZLL_IRQSTS_PI_SHIFT)
#define ZLL_BRD_IRQSTS_PI(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_PI_SHIFT, ZLL_IRQSTS_PI_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field SRCADDR[13] (RO)
 *
 * If Source Address Management is engaged, meaning at least one of the
 * following bits is set: SAP0_EN SAA0_EN SAP1_EN SAA1_EN Then SRCADDR will be set to 1
 * if the packet just received is a poll request (PI=1), and at least one of the
 * following conditions is met: SAP0_EN and SAP0_ADDR_PRESENT SAA0_EN and
 * SAA0_ADDR_ABSENT SAP1_EN and SAP1_ADDR_PRESENT SAA1_EN and SAA1_ADDR_ABSENT If
 * SRCADDR=1, this indicates to SW that the Packet Processor has determined that an
 * auto-TxACK frame must be transmitted with the FramePending subfield of the
 * FrameControlField set to 1. HW will assemble and transmit this Ack packet. If the
 * above conditions are not met, SRCADDR will be cleared to 0.
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_SRCADDR field. */
#define ZLL_RD_IRQSTS_SRCADDR(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_SRCADDR_MASK) >> ZLL_IRQSTS_SRCADDR_SHIFT)
#define ZLL_BRD_IRQSTS_SRCADDR(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_SRCADDR_SHIFT, ZLL_IRQSTS_SRCADDR_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field CCA[14] (RO)
 *
 * Channel IDLE/BUSY indicator. This indicator is valid at CCAIRQ and also at
 * SEQIRQ. This flag is cleared at next receiver warm up.
 *
 * Values:
 * - 0b0 - IDLE
 * - 0b1 - BUSY
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_CCA field. */
#define ZLL_RD_IRQSTS_CCA(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_CCA_MASK) >> ZLL_IRQSTS_CCA_SHIFT)
#define ZLL_BRD_IRQSTS_CCA(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_CCA_SHIFT, ZLL_IRQSTS_CCA_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field CRCVALID[15] (RO)
 *
 * Code Redundancy Check Valid: This flag indicates the compare result between
 * the FCS field, in the most-recently received frame, and the internally
 * calculated CRC value. This flag is cleared at next receiver warm up.
 *
 * Values:
 * - 0b0 - Rx FCS != calculated CRC (incorrect)
 * - 0b1 - Rx FCS = calculated CRC (correct)
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_CRCVALID field. */
#define ZLL_RD_IRQSTS_CRCVALID(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_CRCVALID_MASK) >> ZLL_IRQSTS_CRCVALID_SHIFT)
#define ZLL_BRD_IRQSTS_CRCVALID(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_CRCVALID_SHIFT, ZLL_IRQSTS_CRCVALID_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field TMR1IRQ[16] (W1C)
 *
 * Timer Comparator 1 Interrupt Status bit: Indiates T1CMP comparator value
 * matched event timer counter. This is write '1' to clear bit
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_TMR1IRQ field. */
#define ZLL_RD_IRQSTS_TMR1IRQ(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_TMR1IRQ_MASK) >> ZLL_IRQSTS_TMR1IRQ_SHIFT)
#define ZLL_BRD_IRQSTS_TMR1IRQ(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_TMR1IRQ_SHIFT, ZLL_IRQSTS_TMR1IRQ_WIDTH))

/*! @brief Set the TMR1IRQ field to a new value. */
#define ZLL_WR_IRQSTS_TMR1IRQ(base, value) (ZLL_RMW_IRQSTS(base, (ZLL_IRQSTS_TMR1IRQ_MASK | ZLL_IRQSTS_SEQIRQ_MASK | ZLL_IRQSTS_TXIRQ_MASK | ZLL_IRQSTS_RXIRQ_MASK | ZLL_IRQSTS_CCAIRQ_MASK | ZLL_IRQSTS_RXWTRMRKIRQ_MASK | ZLL_IRQSTS_FILTERFAIL_IRQ_MASK | ZLL_IRQSTS_PLL_UNLOCK_IRQ_MASK | ZLL_IRQSTS_PB_ERR_IRQ_MASK | ZLL_IRQSTS_TMR2IRQ_MASK | ZLL_IRQSTS_TMR3IRQ_MASK | ZLL_IRQSTS_TMR4IRQ_MASK), ZLL_IRQSTS_TMR1IRQ(value)))
#define ZLL_BWR_IRQSTS_TMR1IRQ(base, value) (BME_BFI32(&ZLL_IRQSTS_REG(base), ((uint32_t)(value) << ZLL_IRQSTS_TMR1IRQ_SHIFT), ZLL_IRQSTS_TMR1IRQ_SHIFT, ZLL_IRQSTS_TMR1IRQ_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field TMR2IRQ[17] (W1C)
 *
 * Timer Comparator 2 Interrupt Status bit: Indiates comparator value matched
 * event timer counter. This flag is shared between the T2CMP (24-bit) and
 * T2PRIMECMP (16-bit) compare registers. This is write '1' to clear bit
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_TMR2IRQ field. */
#define ZLL_RD_IRQSTS_TMR2IRQ(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_TMR2IRQ_MASK) >> ZLL_IRQSTS_TMR2IRQ_SHIFT)
#define ZLL_BRD_IRQSTS_TMR2IRQ(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_TMR2IRQ_SHIFT, ZLL_IRQSTS_TMR2IRQ_WIDTH))

/*! @brief Set the TMR2IRQ field to a new value. */
#define ZLL_WR_IRQSTS_TMR2IRQ(base, value) (ZLL_RMW_IRQSTS(base, (ZLL_IRQSTS_TMR2IRQ_MASK | ZLL_IRQSTS_SEQIRQ_MASK | ZLL_IRQSTS_TXIRQ_MASK | ZLL_IRQSTS_RXIRQ_MASK | ZLL_IRQSTS_CCAIRQ_MASK | ZLL_IRQSTS_RXWTRMRKIRQ_MASK | ZLL_IRQSTS_FILTERFAIL_IRQ_MASK | ZLL_IRQSTS_PLL_UNLOCK_IRQ_MASK | ZLL_IRQSTS_PB_ERR_IRQ_MASK | ZLL_IRQSTS_TMR1IRQ_MASK | ZLL_IRQSTS_TMR3IRQ_MASK | ZLL_IRQSTS_TMR4IRQ_MASK), ZLL_IRQSTS_TMR2IRQ(value)))
#define ZLL_BWR_IRQSTS_TMR2IRQ(base, value) (BME_BFI32(&ZLL_IRQSTS_REG(base), ((uint32_t)(value) << ZLL_IRQSTS_TMR2IRQ_SHIFT), ZLL_IRQSTS_TMR2IRQ_SHIFT, ZLL_IRQSTS_TMR2IRQ_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field TMR3IRQ[18] (W1C)
 *
 * Timer Comparator 3 Interrupt Status bit: Indiates T3CMP comparator value
 * matched event timer counter. This is write '1' to clear bit
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_TMR3IRQ field. */
#define ZLL_RD_IRQSTS_TMR3IRQ(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_TMR3IRQ_MASK) >> ZLL_IRQSTS_TMR3IRQ_SHIFT)
#define ZLL_BRD_IRQSTS_TMR3IRQ(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_TMR3IRQ_SHIFT, ZLL_IRQSTS_TMR3IRQ_WIDTH))

/*! @brief Set the TMR3IRQ field to a new value. */
#define ZLL_WR_IRQSTS_TMR3IRQ(base, value) (ZLL_RMW_IRQSTS(base, (ZLL_IRQSTS_TMR3IRQ_MASK | ZLL_IRQSTS_SEQIRQ_MASK | ZLL_IRQSTS_TXIRQ_MASK | ZLL_IRQSTS_RXIRQ_MASK | ZLL_IRQSTS_CCAIRQ_MASK | ZLL_IRQSTS_RXWTRMRKIRQ_MASK | ZLL_IRQSTS_FILTERFAIL_IRQ_MASK | ZLL_IRQSTS_PLL_UNLOCK_IRQ_MASK | ZLL_IRQSTS_PB_ERR_IRQ_MASK | ZLL_IRQSTS_TMR1IRQ_MASK | ZLL_IRQSTS_TMR2IRQ_MASK | ZLL_IRQSTS_TMR4IRQ_MASK), ZLL_IRQSTS_TMR3IRQ(value)))
#define ZLL_BWR_IRQSTS_TMR3IRQ(base, value) (BME_BFI32(&ZLL_IRQSTS_REG(base), ((uint32_t)(value) << ZLL_IRQSTS_TMR3IRQ_SHIFT), ZLL_IRQSTS_TMR3IRQ_SHIFT, ZLL_IRQSTS_TMR3IRQ_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field TMR4IRQ[19] (W1C)
 *
 * Timer Comparator 4 Interrupt Status bit: Indiates T4CMP comparator value
 * matched event timer counter. This is write '1' to clear bit
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_TMR4IRQ field. */
#define ZLL_RD_IRQSTS_TMR4IRQ(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_TMR4IRQ_MASK) >> ZLL_IRQSTS_TMR4IRQ_SHIFT)
#define ZLL_BRD_IRQSTS_TMR4IRQ(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_TMR4IRQ_SHIFT, ZLL_IRQSTS_TMR4IRQ_WIDTH))

/*! @brief Set the TMR4IRQ field to a new value. */
#define ZLL_WR_IRQSTS_TMR4IRQ(base, value) (ZLL_RMW_IRQSTS(base, (ZLL_IRQSTS_TMR4IRQ_MASK | ZLL_IRQSTS_SEQIRQ_MASK | ZLL_IRQSTS_TXIRQ_MASK | ZLL_IRQSTS_RXIRQ_MASK | ZLL_IRQSTS_CCAIRQ_MASK | ZLL_IRQSTS_RXWTRMRKIRQ_MASK | ZLL_IRQSTS_FILTERFAIL_IRQ_MASK | ZLL_IRQSTS_PLL_UNLOCK_IRQ_MASK | ZLL_IRQSTS_PB_ERR_IRQ_MASK | ZLL_IRQSTS_TMR1IRQ_MASK | ZLL_IRQSTS_TMR2IRQ_MASK | ZLL_IRQSTS_TMR3IRQ_MASK), ZLL_IRQSTS_TMR4IRQ(value)))
#define ZLL_BWR_IRQSTS_TMR4IRQ(base, value) (BME_BFI32(&ZLL_IRQSTS_REG(base), ((uint32_t)(value) << ZLL_IRQSTS_TMR4IRQ_SHIFT), ZLL_IRQSTS_TMR4IRQ_SHIFT, ZLL_IRQSTS_TMR4IRQ_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field TMR1MSK[20] (RW)
 *
 * Values:
 * - 0b0 - allows interrupt when comparator matches event timer count
 * - 0b1 - Interrupt generation is disabled, but a TMR1IRQ flag can be set
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_TMR1MSK field. */
#define ZLL_RD_IRQSTS_TMR1MSK(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_TMR1MSK_MASK) >> ZLL_IRQSTS_TMR1MSK_SHIFT)
#define ZLL_BRD_IRQSTS_TMR1MSK(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_TMR1MSK_SHIFT, ZLL_IRQSTS_TMR1MSK_WIDTH))

/*! @brief Set the TMR1MSK field to a new value. */
#define ZLL_WR_IRQSTS_TMR1MSK(base, value) (ZLL_RMW_IRQSTS(base, (ZLL_IRQSTS_TMR1MSK_MASK | ZLL_IRQSTS_SEQIRQ_MASK | ZLL_IRQSTS_TXIRQ_MASK | ZLL_IRQSTS_RXIRQ_MASK | ZLL_IRQSTS_CCAIRQ_MASK | ZLL_IRQSTS_RXWTRMRKIRQ_MASK | ZLL_IRQSTS_FILTERFAIL_IRQ_MASK | ZLL_IRQSTS_PLL_UNLOCK_IRQ_MASK | ZLL_IRQSTS_PB_ERR_IRQ_MASK | ZLL_IRQSTS_TMR1IRQ_MASK | ZLL_IRQSTS_TMR2IRQ_MASK | ZLL_IRQSTS_TMR3IRQ_MASK | ZLL_IRQSTS_TMR4IRQ_MASK), ZLL_IRQSTS_TMR1MSK(value)))
#define ZLL_BWR_IRQSTS_TMR1MSK(base, value) (BME_BFI32(&ZLL_IRQSTS_REG(base), ((uint32_t)(value) << ZLL_IRQSTS_TMR1MSK_SHIFT), ZLL_IRQSTS_TMR1MSK_SHIFT, ZLL_IRQSTS_TMR1MSK_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field TMR2MSK[21] (RW)
 *
 * Values:
 * - 0b0 - allows interrupt when comparator matches event timer count
 * - 0b1 - Interrupt generation is disabled, but a TMR2IRQ flag can be set
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_TMR2MSK field. */
#define ZLL_RD_IRQSTS_TMR2MSK(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_TMR2MSK_MASK) >> ZLL_IRQSTS_TMR2MSK_SHIFT)
#define ZLL_BRD_IRQSTS_TMR2MSK(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_TMR2MSK_SHIFT, ZLL_IRQSTS_TMR2MSK_WIDTH))

/*! @brief Set the TMR2MSK field to a new value. */
#define ZLL_WR_IRQSTS_TMR2MSK(base, value) (ZLL_RMW_IRQSTS(base, (ZLL_IRQSTS_TMR2MSK_MASK | ZLL_IRQSTS_SEQIRQ_MASK | ZLL_IRQSTS_TXIRQ_MASK | ZLL_IRQSTS_RXIRQ_MASK | ZLL_IRQSTS_CCAIRQ_MASK | ZLL_IRQSTS_RXWTRMRKIRQ_MASK | ZLL_IRQSTS_FILTERFAIL_IRQ_MASK | ZLL_IRQSTS_PLL_UNLOCK_IRQ_MASK | ZLL_IRQSTS_PB_ERR_IRQ_MASK | ZLL_IRQSTS_TMR1IRQ_MASK | ZLL_IRQSTS_TMR2IRQ_MASK | ZLL_IRQSTS_TMR3IRQ_MASK | ZLL_IRQSTS_TMR4IRQ_MASK), ZLL_IRQSTS_TMR2MSK(value)))
#define ZLL_BWR_IRQSTS_TMR2MSK(base, value) (BME_BFI32(&ZLL_IRQSTS_REG(base), ((uint32_t)(value) << ZLL_IRQSTS_TMR2MSK_SHIFT), ZLL_IRQSTS_TMR2MSK_SHIFT, ZLL_IRQSTS_TMR2MSK_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field TMR3MSK[22] (RW)
 *
 * Values:
 * - 0b0 - allows interrupt when comparator matches event timer count
 * - 0b1 - Interrupt generation is disabled, but a TMR3IRQ flag can be set
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_TMR3MSK field. */
#define ZLL_RD_IRQSTS_TMR3MSK(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_TMR3MSK_MASK) >> ZLL_IRQSTS_TMR3MSK_SHIFT)
#define ZLL_BRD_IRQSTS_TMR3MSK(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_TMR3MSK_SHIFT, ZLL_IRQSTS_TMR3MSK_WIDTH))

/*! @brief Set the TMR3MSK field to a new value. */
#define ZLL_WR_IRQSTS_TMR3MSK(base, value) (ZLL_RMW_IRQSTS(base, (ZLL_IRQSTS_TMR3MSK_MASK | ZLL_IRQSTS_SEQIRQ_MASK | ZLL_IRQSTS_TXIRQ_MASK | ZLL_IRQSTS_RXIRQ_MASK | ZLL_IRQSTS_CCAIRQ_MASK | ZLL_IRQSTS_RXWTRMRKIRQ_MASK | ZLL_IRQSTS_FILTERFAIL_IRQ_MASK | ZLL_IRQSTS_PLL_UNLOCK_IRQ_MASK | ZLL_IRQSTS_PB_ERR_IRQ_MASK | ZLL_IRQSTS_TMR1IRQ_MASK | ZLL_IRQSTS_TMR2IRQ_MASK | ZLL_IRQSTS_TMR3IRQ_MASK | ZLL_IRQSTS_TMR4IRQ_MASK), ZLL_IRQSTS_TMR3MSK(value)))
#define ZLL_BWR_IRQSTS_TMR3MSK(base, value) (BME_BFI32(&ZLL_IRQSTS_REG(base), ((uint32_t)(value) << ZLL_IRQSTS_TMR3MSK_SHIFT), ZLL_IRQSTS_TMR3MSK_SHIFT, ZLL_IRQSTS_TMR3MSK_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field TMR4MSK[23] (RW)
 *
 * Values:
 * - 0b0 - allows interrupt when comparator matches event timer count
 * - 0b1 - Interrupt generation is disabled, but a TMR4IRQ flag can be set
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_TMR4MSK field. */
#define ZLL_RD_IRQSTS_TMR4MSK(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_TMR4MSK_MASK) >> ZLL_IRQSTS_TMR4MSK_SHIFT)
#define ZLL_BRD_IRQSTS_TMR4MSK(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_TMR4MSK_SHIFT, ZLL_IRQSTS_TMR4MSK_WIDTH))

/*! @brief Set the TMR4MSK field to a new value. */
#define ZLL_WR_IRQSTS_TMR4MSK(base, value) (ZLL_RMW_IRQSTS(base, (ZLL_IRQSTS_TMR4MSK_MASK | ZLL_IRQSTS_SEQIRQ_MASK | ZLL_IRQSTS_TXIRQ_MASK | ZLL_IRQSTS_RXIRQ_MASK | ZLL_IRQSTS_CCAIRQ_MASK | ZLL_IRQSTS_RXWTRMRKIRQ_MASK | ZLL_IRQSTS_FILTERFAIL_IRQ_MASK | ZLL_IRQSTS_PLL_UNLOCK_IRQ_MASK | ZLL_IRQSTS_PB_ERR_IRQ_MASK | ZLL_IRQSTS_TMR1IRQ_MASK | ZLL_IRQSTS_TMR2IRQ_MASK | ZLL_IRQSTS_TMR3IRQ_MASK | ZLL_IRQSTS_TMR4IRQ_MASK), ZLL_IRQSTS_TMR4MSK(value)))
#define ZLL_BWR_IRQSTS_TMR4MSK(base, value) (BME_BFI32(&ZLL_IRQSTS_REG(base), ((uint32_t)(value) << ZLL_IRQSTS_TMR4MSK_SHIFT), ZLL_IRQSTS_TMR4MSK_SHIFT, ZLL_IRQSTS_TMR4MSK_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_IRQSTS, field RX_FRAME_LENGTH[30:24] (RO)
 *
 * Contents of the PHR (PHY header), or FrameLength field, of the most recently
 * received packet. Read-only.
 */
/*@{*/
/*! @brief Read current value of the ZLL_IRQSTS_RX_FRAME_LENGTH field. */
#define ZLL_RD_IRQSTS_RX_FRAME_LENGTH(base) ((ZLL_IRQSTS_REG(base) & ZLL_IRQSTS_RX_FRAME_LENGTH_MASK) >> ZLL_IRQSTS_RX_FRAME_LENGTH_SHIFT)
#define ZLL_BRD_IRQSTS_RX_FRAME_LENGTH(base) (BME_UBFX32(&ZLL_IRQSTS_REG(base), ZLL_IRQSTS_RX_FRAME_LENGTH_SHIFT, ZLL_IRQSTS_RX_FRAME_LENGTH_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_PHY_CTRL - PHY CONTROL
 ******************************************************************************/

/*!
 * @brief ZLL_PHY_CTRL - PHY CONTROL (RW)
 *
 * Reset value: 0x0802FF00U
 *
 * PHY Control Register
 */
/*!
 * @name Constants and macros for entire ZLL_PHY_CTRL register
 */
/*@{*/
#define ZLL_RD_PHY_CTRL(base)    (ZLL_PHY_CTRL_REG(base))
#define ZLL_WR_PHY_CTRL(base, value) (ZLL_PHY_CTRL_REG(base) = (value))
#define ZLL_RMW_PHY_CTRL(base, mask, value) (ZLL_WR_PHY_CTRL(base, (ZLL_RD_PHY_CTRL(base) & ~(mask)) | (value)))
#define ZLL_SET_PHY_CTRL(base, value) (BME_OR32(&ZLL_PHY_CTRL_REG(base), (uint32_t)(value)))
#define ZLL_CLR_PHY_CTRL(base, value) (BME_AND32(&ZLL_PHY_CTRL_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_PHY_CTRL(base, value) (BME_XOR32(&ZLL_PHY_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_PHY_CTRL bitfields
 */

/*!
 * @name Register ZLL_PHY_CTRL, field XCVSEQ[2:0] (RW)
 *
 * The Transceiver Sequence Selector register selects an autosequence for the
 * sequence manager to execute. Sequence initiation can be immediate, or scheduled
 * (see TMRTRIGEN). A write of XCVSEQ=IDLE will abort any ongoing sequence. A
 * write of XCVSEQ=IDLE must always be performed after a sequence is complete, and
 * before a new sequence is programmed. Any write to XCVSEQ other than XCVSEQ=IDLE
 * during an ongoing sequence, shall be ignored. The mapping of XCVSEQ to
 * sequence types is as follows:
 *
 * Values:
 * - 0b000 - I (IDLE)
 * - 0b001 - R (RECEIVE)
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_XCVSEQ field. */
#define ZLL_RD_PHY_CTRL_XCVSEQ(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_XCVSEQ_MASK) >> ZLL_PHY_CTRL_XCVSEQ_SHIFT)
#define ZLL_BRD_PHY_CTRL_XCVSEQ(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_XCVSEQ_SHIFT, ZLL_PHY_CTRL_XCVSEQ_WIDTH))

/*! @brief Set the XCVSEQ field to a new value. */
#define ZLL_WR_PHY_CTRL_XCVSEQ(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_XCVSEQ_MASK, ZLL_PHY_CTRL_XCVSEQ(value)))
#define ZLL_BWR_PHY_CTRL_XCVSEQ(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_XCVSEQ_SHIFT), ZLL_PHY_CTRL_XCVSEQ_SHIFT, ZLL_PHY_CTRL_XCVSEQ_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field AUTOACK[3] (RW)
 *
 * Applies only to Sequence R and Sequence TR, ignored during other sequences
 *
 * Values:
 * - 0b0 - sequence manager will not follow a receive frame with a Tx Ack frame,
 *     under any conditions; the autosequence will terminate after the receive
 *     frame.
 * - 0b1 - sequence manager will follow a receive frame with an automatic
 *     hardware-generated Tx Ack frame, assuming other necessary conditions are met.
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_AUTOACK field. */
#define ZLL_RD_PHY_CTRL_AUTOACK(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_AUTOACK_MASK) >> ZLL_PHY_CTRL_AUTOACK_SHIFT)
#define ZLL_BRD_PHY_CTRL_AUTOACK(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_AUTOACK_SHIFT, ZLL_PHY_CTRL_AUTOACK_WIDTH))

/*! @brief Set the AUTOACK field to a new value. */
#define ZLL_WR_PHY_CTRL_AUTOACK(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_AUTOACK_MASK, ZLL_PHY_CTRL_AUTOACK(value)))
#define ZLL_BWR_PHY_CTRL_AUTOACK(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_AUTOACK_SHIFT), ZLL_PHY_CTRL_AUTOACK_SHIFT, ZLL_PHY_CTRL_AUTOACK_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field RXACKRQD[4] (RW)
 *
 * Applies only to Sequence TR, ignored during all other sequences.
 *
 * Values:
 * - 0b0 - An ordinary receive frame (any type of frame) follows the transmit
 *     frame.
 * - 0b1 - A receive Ack frame is expected to follow the transmit frame (non-Ack
 *     frames are rejected).
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_RXACKRQD field. */
#define ZLL_RD_PHY_CTRL_RXACKRQD(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_RXACKRQD_MASK) >> ZLL_PHY_CTRL_RXACKRQD_SHIFT)
#define ZLL_BRD_PHY_CTRL_RXACKRQD(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_RXACKRQD_SHIFT, ZLL_PHY_CTRL_RXACKRQD_WIDTH))

/*! @brief Set the RXACKRQD field to a new value. */
#define ZLL_WR_PHY_CTRL_RXACKRQD(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_RXACKRQD_MASK, ZLL_PHY_CTRL_RXACKRQD(value)))
#define ZLL_BWR_PHY_CTRL_RXACKRQD(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_RXACKRQD_SHIFT), ZLL_PHY_CTRL_RXACKRQD_SHIFT, ZLL_PHY_CTRL_RXACKRQD_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field CCABFRTX[5] (RW)
 *
 * Applies only to Sequences T and TR, ignored during all other sequences.
 *
 * Values:
 * - 0b0 - no CCA required, transmit operation begins immediately.
 * - 0b1 - at least one CCA measurement is required prior to the transmit
 *     operation (see also SLOTTED).
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_CCABFRTX field. */
#define ZLL_RD_PHY_CTRL_CCABFRTX(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_CCABFRTX_MASK) >> ZLL_PHY_CTRL_CCABFRTX_SHIFT)
#define ZLL_BRD_PHY_CTRL_CCABFRTX(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_CCABFRTX_SHIFT, ZLL_PHY_CTRL_CCABFRTX_WIDTH))

/*! @brief Set the CCABFRTX field to a new value. */
#define ZLL_WR_PHY_CTRL_CCABFRTX(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_CCABFRTX_MASK, ZLL_PHY_CTRL_CCABFRTX(value)))
#define ZLL_BWR_PHY_CTRL_CCABFRTX(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_CCABFRTX_SHIFT), ZLL_PHY_CTRL_CCABFRTX_SHIFT, ZLL_PHY_CTRL_CCABFRTX_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field SLOTTED[6] (RW)
 *
 * Slotted Mode, for beacon-enabled networks. Applies only to Sequences T, TR,
 * and R, ignored during all other sequences. Used, in concert with CCABFRTX, to
 * determine how many CCA measurements are required prior to a transmit operation.
 * Also used during R sequence to determine whether the ensuing transmit
 * acknowledge frame (if any) needs to be synchronized to a backoff slot boundary.
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_SLOTTED field. */
#define ZLL_RD_PHY_CTRL_SLOTTED(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_SLOTTED_MASK) >> ZLL_PHY_CTRL_SLOTTED_SHIFT)
#define ZLL_BRD_PHY_CTRL_SLOTTED(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_SLOTTED_SHIFT, ZLL_PHY_CTRL_SLOTTED_WIDTH))

/*! @brief Set the SLOTTED field to a new value. */
#define ZLL_WR_PHY_CTRL_SLOTTED(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_SLOTTED_MASK, ZLL_PHY_CTRL_SLOTTED(value)))
#define ZLL_BWR_PHY_CTRL_SLOTTED(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_SLOTTED_SHIFT), ZLL_PHY_CTRL_SLOTTED_SHIFT, ZLL_PHY_CTRL_SLOTTED_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field TMRTRIGEN[7] (RW)
 *
 * Values:
 * - 0b0 - programmed sequence initiates immediately upon write to XCVSEQ.
 * - 0b1 - allow timer TC2 (or TC2') to initiate a preprogrammed sequence (see
 *     XCVSEQ register).
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_TMRTRIGEN field. */
#define ZLL_RD_PHY_CTRL_TMRTRIGEN(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_TMRTRIGEN_MASK) >> ZLL_PHY_CTRL_TMRTRIGEN_SHIFT)
#define ZLL_BRD_PHY_CTRL_TMRTRIGEN(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_TMRTRIGEN_SHIFT, ZLL_PHY_CTRL_TMRTRIGEN_WIDTH))

/*! @brief Set the TMRTRIGEN field to a new value. */
#define ZLL_WR_PHY_CTRL_TMRTRIGEN(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_TMRTRIGEN_MASK, ZLL_PHY_CTRL_TMRTRIGEN(value)))
#define ZLL_BWR_PHY_CTRL_TMRTRIGEN(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_TMRTRIGEN_SHIFT), ZLL_PHY_CTRL_TMRTRIGEN_SHIFT, ZLL_PHY_CTRL_TMRTRIGEN_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field SEQMSK[8] (RW)
 *
 * Values:
 * - 0b0 - allows completion of an autosequence to generate a zigbee interrupt
 * - 0b1 - Completion of an autosequence will set the SEQIRQ status bit, but a
 *     zigbee interrupt is not generated
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_SEQMSK field. */
#define ZLL_RD_PHY_CTRL_SEQMSK(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_SEQMSK_MASK) >> ZLL_PHY_CTRL_SEQMSK_SHIFT)
#define ZLL_BRD_PHY_CTRL_SEQMSK(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_SEQMSK_SHIFT, ZLL_PHY_CTRL_SEQMSK_WIDTH))

/*! @brief Set the SEQMSK field to a new value. */
#define ZLL_WR_PHY_CTRL_SEQMSK(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_SEQMSK_MASK, ZLL_PHY_CTRL_SEQMSK(value)))
#define ZLL_BWR_PHY_CTRL_SEQMSK(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_SEQMSK_SHIFT), ZLL_PHY_CTRL_SEQMSK_SHIFT, ZLL_PHY_CTRL_SEQMSK_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field TXMSK[9] (RW)
 *
 * Values:
 * - 0b0 - allows completion of a TX operation to generate a zigbee interrupt
 * - 0b1 - Completion of a TX operation will set the TXIRQ status bit, but a
 *     zigbee interrupt is not generated
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_TXMSK field. */
#define ZLL_RD_PHY_CTRL_TXMSK(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_TXMSK_MASK) >> ZLL_PHY_CTRL_TXMSK_SHIFT)
#define ZLL_BRD_PHY_CTRL_TXMSK(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_TXMSK_SHIFT, ZLL_PHY_CTRL_TXMSK_WIDTH))

/*! @brief Set the TXMSK field to a new value. */
#define ZLL_WR_PHY_CTRL_TXMSK(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_TXMSK_MASK, ZLL_PHY_CTRL_TXMSK(value)))
#define ZLL_BWR_PHY_CTRL_TXMSK(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_TXMSK_SHIFT), ZLL_PHY_CTRL_TXMSK_SHIFT, ZLL_PHY_CTRL_TXMSK_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field RXMSK[10] (RW)
 *
 * Values:
 * - 0b0 - allows completion of a RX operation to generate a zigbee interrupt
 * - 0b1 - Completion of a RX operation will set the RXIRQ status bit, but a
 *     zigbee interrupt is not generated
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_RXMSK field. */
#define ZLL_RD_PHY_CTRL_RXMSK(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_RXMSK_MASK) >> ZLL_PHY_CTRL_RXMSK_SHIFT)
#define ZLL_BRD_PHY_CTRL_RXMSK(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_RXMSK_SHIFT, ZLL_PHY_CTRL_RXMSK_WIDTH))

/*! @brief Set the RXMSK field to a new value. */
#define ZLL_WR_PHY_CTRL_RXMSK(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_RXMSK_MASK, ZLL_PHY_CTRL_RXMSK(value)))
#define ZLL_BWR_PHY_CTRL_RXMSK(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_RXMSK_SHIFT), ZLL_PHY_CTRL_RXMSK_SHIFT, ZLL_PHY_CTRL_RXMSK_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field CCAMSK[11] (RW)
 *
 * CCA Interrupt Mask
 *
 * Values:
 * - 0b0 - allows completion of a CCA operation to generate a zigbee interrupt
 * - 0b1 - Completion of a CCA operation will set the CCAIRQ status bit, but an
 *     zigbee interrupt
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_CCAMSK field. */
#define ZLL_RD_PHY_CTRL_CCAMSK(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_CCAMSK_MASK) >> ZLL_PHY_CTRL_CCAMSK_SHIFT)
#define ZLL_BRD_PHY_CTRL_CCAMSK(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_CCAMSK_SHIFT, ZLL_PHY_CTRL_CCAMSK_WIDTH))

/*! @brief Set the CCAMSK field to a new value. */
#define ZLL_WR_PHY_CTRL_CCAMSK(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_CCAMSK_MASK, ZLL_PHY_CTRL_CCAMSK(value)))
#define ZLL_BWR_PHY_CTRL_CCAMSK(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_CCAMSK_SHIFT), ZLL_PHY_CTRL_CCAMSK_SHIFT, ZLL_PHY_CTRL_CCAMSK_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field RX_WMRK_MSK[12] (RW)
 *
 * RX Watermark Interrupt Mask
 *
 * Values:
 * - 0b0 - allows a Received Byte Count match to the RX_WTR_MARK threshold
 *     register to generate a zigbee interrupt
 * - 0b1 - A Received Byte Count match to the RX_WTR_MARK threshold register
 *     will set the RXWTRMRKIRQ status bit, but a zigbee interrupt is not generated
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_RX_WMRK_MSK field. */
#define ZLL_RD_PHY_CTRL_RX_WMRK_MSK(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_RX_WMRK_MSK_MASK) >> ZLL_PHY_CTRL_RX_WMRK_MSK_SHIFT)
#define ZLL_BRD_PHY_CTRL_RX_WMRK_MSK(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_RX_WMRK_MSK_SHIFT, ZLL_PHY_CTRL_RX_WMRK_MSK_WIDTH))

/*! @brief Set the RX_WMRK_MSK field to a new value. */
#define ZLL_WR_PHY_CTRL_RX_WMRK_MSK(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_RX_WMRK_MSK_MASK, ZLL_PHY_CTRL_RX_WMRK_MSK(value)))
#define ZLL_BWR_PHY_CTRL_RX_WMRK_MSK(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_RX_WMRK_MSK_SHIFT), ZLL_PHY_CTRL_RX_WMRK_MSK_SHIFT, ZLL_PHY_CTRL_RX_WMRK_MSK_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field FILTERFAIL_MSK[13] (RW)
 *
 * FilterFail Interrupt Mask
 *
 * Values:
 * - 0b0 - allows Packet Processor Filtering Failure to generate a zigbee
 *     interrupt
 * - 0b1 - A Packet Processor Filtering Failure will set the FILTERFAIL_IRQ
 *     status bit, but a zigbee interrupt is not generated
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_FILTERFAIL_MSK field. */
#define ZLL_RD_PHY_CTRL_FILTERFAIL_MSK(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_FILTERFAIL_MSK_MASK) >> ZLL_PHY_CTRL_FILTERFAIL_MSK_SHIFT)
#define ZLL_BRD_PHY_CTRL_FILTERFAIL_MSK(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_FILTERFAIL_MSK_SHIFT, ZLL_PHY_CTRL_FILTERFAIL_MSK_WIDTH))

/*! @brief Set the FILTERFAIL_MSK field to a new value. */
#define ZLL_WR_PHY_CTRL_FILTERFAIL_MSK(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_FILTERFAIL_MSK_MASK, ZLL_PHY_CTRL_FILTERFAIL_MSK(value)))
#define ZLL_BWR_PHY_CTRL_FILTERFAIL_MSK(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_FILTERFAIL_MSK_SHIFT), ZLL_PHY_CTRL_FILTERFAIL_MSK_SHIFT, ZLL_PHY_CTRL_FILTERFAIL_MSK_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field PLL_UNLOCK_MSK[14] (RW)
 *
 * Values:
 * - 0b0 - allows PLL unlock event to generate a zigbee interrupt
 * - 0b1 - A PLL unlock event will set the PLL_UNLOCK_IRQ status bit, but a
 *     zigbee interrupt is not generated
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_PLL_UNLOCK_MSK field. */
#define ZLL_RD_PHY_CTRL_PLL_UNLOCK_MSK(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_PLL_UNLOCK_MSK_MASK) >> ZLL_PHY_CTRL_PLL_UNLOCK_MSK_SHIFT)
#define ZLL_BRD_PHY_CTRL_PLL_UNLOCK_MSK(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_PLL_UNLOCK_MSK_SHIFT, ZLL_PHY_CTRL_PLL_UNLOCK_MSK_WIDTH))

/*! @brief Set the PLL_UNLOCK_MSK field to a new value. */
#define ZLL_WR_PHY_CTRL_PLL_UNLOCK_MSK(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_PLL_UNLOCK_MSK_MASK, ZLL_PHY_CTRL_PLL_UNLOCK_MSK(value)))
#define ZLL_BWR_PHY_CTRL_PLL_UNLOCK_MSK(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_PLL_UNLOCK_MSK_SHIFT), ZLL_PHY_CTRL_PLL_UNLOCK_MSK_SHIFT, ZLL_PHY_CTRL_PLL_UNLOCK_MSK_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field CRC_MSK[15] (RW)
 *
 * CRC Mask
 *
 * Values:
 * - 0b0 - sequence manager ignores CRCVALID and considers the receive operation
 *     complete after the last octet of the frame has been received.
 * - 0b1 - sequence manager requires CRCVALID=1 at the end of the received frame
 *     in order for the receive operation to complete successfully; if
 *     CRCVALID=0, sequence manager will return to preamble-detect mode after the last
 *     octet of the frame has been received.
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_CRC_MSK field. */
#define ZLL_RD_PHY_CTRL_CRC_MSK(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_CRC_MSK_MASK) >> ZLL_PHY_CTRL_CRC_MSK_SHIFT)
#define ZLL_BRD_PHY_CTRL_CRC_MSK(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_CRC_MSK_SHIFT, ZLL_PHY_CTRL_CRC_MSK_WIDTH))

/*! @brief Set the CRC_MSK field to a new value. */
#define ZLL_WR_PHY_CTRL_CRC_MSK(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_CRC_MSK_MASK, ZLL_PHY_CTRL_CRC_MSK(value)))
#define ZLL_BWR_PHY_CTRL_CRC_MSK(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_CRC_MSK_SHIFT), ZLL_PHY_CTRL_CRC_MSK_SHIFT, ZLL_PHY_CTRL_CRC_MSK_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field PB_ERR_MSK[17] (RW)
 *
 * Values:
 * - 0b0 - Enable Packet Buffer Error to assert a zigbee interrupt
 * - 0b1 - Mask Packet Buffer Error from generating a zigbee interrupt
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_PB_ERR_MSK field. */
#define ZLL_RD_PHY_CTRL_PB_ERR_MSK(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_PB_ERR_MSK_MASK) >> ZLL_PHY_CTRL_PB_ERR_MSK_SHIFT)
#define ZLL_BRD_PHY_CTRL_PB_ERR_MSK(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_PB_ERR_MSK_SHIFT, ZLL_PHY_CTRL_PB_ERR_MSK_WIDTH))

/*! @brief Set the PB_ERR_MSK field to a new value. */
#define ZLL_WR_PHY_CTRL_PB_ERR_MSK(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_PB_ERR_MSK_MASK, ZLL_PHY_CTRL_PB_ERR_MSK(value)))
#define ZLL_BWR_PHY_CTRL_PB_ERR_MSK(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_PB_ERR_MSK_SHIFT), ZLL_PHY_CTRL_PB_ERR_MSK_SHIFT, ZLL_PHY_CTRL_PB_ERR_MSK_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field TMR1CMP_EN[20] (RW)
 *
 * Values:
 * - 0b0 - Don't allow an Event Timer Match to T1CMP to set TMR1IRQ
 * - 0b1 - Allow an Event Timer Match to T1CMP to set TMR1IRQ
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_TMR1CMP_EN field. */
#define ZLL_RD_PHY_CTRL_TMR1CMP_EN(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_TMR1CMP_EN_MASK) >> ZLL_PHY_CTRL_TMR1CMP_EN_SHIFT)
#define ZLL_BRD_PHY_CTRL_TMR1CMP_EN(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_TMR1CMP_EN_SHIFT, ZLL_PHY_CTRL_TMR1CMP_EN_WIDTH))

/*! @brief Set the TMR1CMP_EN field to a new value. */
#define ZLL_WR_PHY_CTRL_TMR1CMP_EN(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_TMR1CMP_EN_MASK, ZLL_PHY_CTRL_TMR1CMP_EN(value)))
#define ZLL_BWR_PHY_CTRL_TMR1CMP_EN(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_TMR1CMP_EN_SHIFT), ZLL_PHY_CTRL_TMR1CMP_EN_SHIFT, ZLL_PHY_CTRL_TMR1CMP_EN_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field TMR2CMP_EN[21] (RW)
 *
 * Values:
 * - 0b0 - Don't allow an Event Timer Match to T2CMP or T2PRIMECMP to set TMR2IRQ
 * - 0b1 - Allow an Event Timer Match to T2CMP or T2PRIMECMP to set TMR2IRQ
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_TMR2CMP_EN field. */
#define ZLL_RD_PHY_CTRL_TMR2CMP_EN(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_TMR2CMP_EN_MASK) >> ZLL_PHY_CTRL_TMR2CMP_EN_SHIFT)
#define ZLL_BRD_PHY_CTRL_TMR2CMP_EN(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_TMR2CMP_EN_SHIFT, ZLL_PHY_CTRL_TMR2CMP_EN_WIDTH))

/*! @brief Set the TMR2CMP_EN field to a new value. */
#define ZLL_WR_PHY_CTRL_TMR2CMP_EN(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_TMR2CMP_EN_MASK, ZLL_PHY_CTRL_TMR2CMP_EN(value)))
#define ZLL_BWR_PHY_CTRL_TMR2CMP_EN(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_TMR2CMP_EN_SHIFT), ZLL_PHY_CTRL_TMR2CMP_EN_SHIFT, ZLL_PHY_CTRL_TMR2CMP_EN_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field TMR3CMP_EN[22] (RW)
 *
 * Values:
 * - 0b0 - Don't allow an Event Timer Match to T3CMP to set TMR3IRQ
 * - 0b1 - Allow an Event Timer Match to T3CMP to set TMR3IRQ
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_TMR3CMP_EN field. */
#define ZLL_RD_PHY_CTRL_TMR3CMP_EN(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_TMR3CMP_EN_MASK) >> ZLL_PHY_CTRL_TMR3CMP_EN_SHIFT)
#define ZLL_BRD_PHY_CTRL_TMR3CMP_EN(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_TMR3CMP_EN_SHIFT, ZLL_PHY_CTRL_TMR3CMP_EN_WIDTH))

/*! @brief Set the TMR3CMP_EN field to a new value. */
#define ZLL_WR_PHY_CTRL_TMR3CMP_EN(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_TMR3CMP_EN_MASK, ZLL_PHY_CTRL_TMR3CMP_EN(value)))
#define ZLL_BWR_PHY_CTRL_TMR3CMP_EN(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_TMR3CMP_EN_SHIFT), ZLL_PHY_CTRL_TMR3CMP_EN_SHIFT, ZLL_PHY_CTRL_TMR3CMP_EN_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field TMR4CMP_EN[23] (RW)
 *
 * Values:
 * - 0b0 - Don't allow an Event Timer Match to T4CMP to set TMR4IRQ
 * - 0b1 - Allow an Event Timer Match to T4CMP to set TMR4IRQ
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_TMR4CMP_EN field. */
#define ZLL_RD_PHY_CTRL_TMR4CMP_EN(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_TMR4CMP_EN_MASK) >> ZLL_PHY_CTRL_TMR4CMP_EN_SHIFT)
#define ZLL_BRD_PHY_CTRL_TMR4CMP_EN(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_TMR4CMP_EN_SHIFT, ZLL_PHY_CTRL_TMR4CMP_EN_WIDTH))

/*! @brief Set the TMR4CMP_EN field to a new value. */
#define ZLL_WR_PHY_CTRL_TMR4CMP_EN(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_TMR4CMP_EN_MASK, ZLL_PHY_CTRL_TMR4CMP_EN(value)))
#define ZLL_BWR_PHY_CTRL_TMR4CMP_EN(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_TMR4CMP_EN_SHIFT), ZLL_PHY_CTRL_TMR4CMP_EN_SHIFT, ZLL_PHY_CTRL_TMR4CMP_EN_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field TC2PRIME_EN[24] (RW)
 *
 * Values:
 * - 0b0 - Don't allow a match of the lower 16 bits of Event Timer to T2PRIMECMP
 *     to set TMR2IRQ
 * - 0b1 - Allow a match of the lower 16 bits of Event Timer to T2PRIMECMP to
 *     set TMR2IRQ
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_TC2PRIME_EN field. */
#define ZLL_RD_PHY_CTRL_TC2PRIME_EN(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_TC2PRIME_EN_MASK) >> ZLL_PHY_CTRL_TC2PRIME_EN_SHIFT)
#define ZLL_BRD_PHY_CTRL_TC2PRIME_EN(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_TC2PRIME_EN_SHIFT, ZLL_PHY_CTRL_TC2PRIME_EN_WIDTH))

/*! @brief Set the TC2PRIME_EN field to a new value. */
#define ZLL_WR_PHY_CTRL_TC2PRIME_EN(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_TC2PRIME_EN_MASK, ZLL_PHY_CTRL_TC2PRIME_EN(value)))
#define ZLL_BWR_PHY_CTRL_TC2PRIME_EN(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_TC2PRIME_EN_SHIFT), ZLL_PHY_CTRL_TC2PRIME_EN_SHIFT, ZLL_PHY_CTRL_TC2PRIME_EN_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field PROMISCUOUS[25] (RW)
 *
 * Bypasses most packet filtering.
 *
 * Values:
 * - 0b0 - normal mode
 * - 0b1 - all packet filtering except frame length checking (FrameLength>=5 and
 *     FrameLength<=127) is bypassed.
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_PROMISCUOUS field. */
#define ZLL_RD_PHY_CTRL_PROMISCUOUS(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_PROMISCUOUS_MASK) >> ZLL_PHY_CTRL_PROMISCUOUS_SHIFT)
#define ZLL_BRD_PHY_CTRL_PROMISCUOUS(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_PROMISCUOUS_SHIFT, ZLL_PHY_CTRL_PROMISCUOUS_WIDTH))

/*! @brief Set the PROMISCUOUS field to a new value. */
#define ZLL_WR_PHY_CTRL_PROMISCUOUS(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_PROMISCUOUS_MASK, ZLL_PHY_CTRL_PROMISCUOUS(value)))
#define ZLL_BWR_PHY_CTRL_PROMISCUOUS(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_PROMISCUOUS_SHIFT), ZLL_PHY_CTRL_PROMISCUOUS_SHIFT, ZLL_PHY_CTRL_PROMISCUOUS_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field TMRLOAD[26] (WO)
 *
 * A low to high transition of this bit causes the contents of register
 * T1CMP[23:0] to be loaded into the Event Timer.This is a self clearing bit, always
 * reads zero. Note: the TMRLOAD feature requires the Apache RF Oscillator to be
 * running; TMRLOAD should not be attempted in the Apache radio gasket-bypass mode.
 */
/*@{*/
/*! @brief Set the TMRLOAD field to a new value. */
#define ZLL_WR_PHY_CTRL_TMRLOAD(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_TMRLOAD_MASK, ZLL_PHY_CTRL_TMRLOAD(value)))
#define ZLL_BWR_PHY_CTRL_TMRLOAD(base, value) (ZLL_WR_PHY_CTRL_TMRLOAD(base, value))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field CCATYPE[28:27] (RW)
 *
 * Clear Channel Assessment Type. Selects one of four possible functions for CCA
 * or Energy Detect, per below.
 *
 * Values:
 * - 0b00 - ENERGY DETECT
 * - 0b01 - CCA MODE 1
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_CCATYPE field. */
#define ZLL_RD_PHY_CTRL_CCATYPE(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_CCATYPE_MASK) >> ZLL_PHY_CTRL_CCATYPE_SHIFT)
#define ZLL_BRD_PHY_CTRL_CCATYPE(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_CCATYPE_SHIFT, ZLL_PHY_CTRL_CCATYPE_WIDTH))

/*! @brief Set the CCATYPE field to a new value. */
#define ZLL_WR_PHY_CTRL_CCATYPE(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_CCATYPE_MASK, ZLL_PHY_CTRL_CCATYPE(value)))
#define ZLL_BWR_PHY_CTRL_CCATYPE(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_CCATYPE_SHIFT), ZLL_PHY_CTRL_CCATYPE_SHIFT, ZLL_PHY_CTRL_CCATYPE_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field PANCORDNTR0[29] (RW)
 *
 * Device is a PAN Coordinator on PAN0. Allows device to receive packets with no
 * destination address, if Source PAN ID matches.
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_PANCORDNTR0 field. */
#define ZLL_RD_PHY_CTRL_PANCORDNTR0(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_PANCORDNTR0_MASK) >> ZLL_PHY_CTRL_PANCORDNTR0_SHIFT)
#define ZLL_BRD_PHY_CTRL_PANCORDNTR0(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_PANCORDNTR0_SHIFT, ZLL_PHY_CTRL_PANCORDNTR0_WIDTH))

/*! @brief Set the PANCORDNTR0 field to a new value. */
#define ZLL_WR_PHY_CTRL_PANCORDNTR0(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_PANCORDNTR0_MASK, ZLL_PHY_CTRL_PANCORDNTR0(value)))
#define ZLL_BWR_PHY_CTRL_PANCORDNTR0(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_PANCORDNTR0_SHIFT), ZLL_PHY_CTRL_PANCORDNTR0_SHIFT, ZLL_PHY_CTRL_PANCORDNTR0_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field TC3TMOUT[30] (RW)
 *
 * TMR3 Timeout Enable
 *
 * Values:
 * - 0b0 - TMR3 is a software timer only
 * - 0b1 - Enable TMR3 to abort Rx or CCCA operations.
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_TC3TMOUT field. */
#define ZLL_RD_PHY_CTRL_TC3TMOUT(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_TC3TMOUT_MASK) >> ZLL_PHY_CTRL_TC3TMOUT_SHIFT)
#define ZLL_BRD_PHY_CTRL_TC3TMOUT(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_TC3TMOUT_SHIFT, ZLL_PHY_CTRL_TC3TMOUT_WIDTH))

/*! @brief Set the TC3TMOUT field to a new value. */
#define ZLL_WR_PHY_CTRL_TC3TMOUT(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_TC3TMOUT_MASK, ZLL_PHY_CTRL_TC3TMOUT(value)))
#define ZLL_BWR_PHY_CTRL_TC3TMOUT(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_TC3TMOUT_SHIFT), ZLL_PHY_CTRL_TC3TMOUT_SHIFT, ZLL_PHY_CTRL_TC3TMOUT_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_PHY_CTRL, field TRCV_MSK[31] (RW)
 *
 * Transceiver Global Interrupt Mask
 *
 * Values:
 * - 0b0 - Enable any unmasked interrupt source to assert zigbee interrupt
 * - 0b1 - Mask all interrupt sources from asserting zigbee interrupt
 */
/*@{*/
/*! @brief Read current value of the ZLL_PHY_CTRL_TRCV_MSK field. */
#define ZLL_RD_PHY_CTRL_TRCV_MSK(base) ((ZLL_PHY_CTRL_REG(base) & ZLL_PHY_CTRL_TRCV_MSK_MASK) >> ZLL_PHY_CTRL_TRCV_MSK_SHIFT)
#define ZLL_BRD_PHY_CTRL_TRCV_MSK(base) (BME_UBFX32(&ZLL_PHY_CTRL_REG(base), ZLL_PHY_CTRL_TRCV_MSK_SHIFT, ZLL_PHY_CTRL_TRCV_MSK_WIDTH))

/*! @brief Set the TRCV_MSK field to a new value. */
#define ZLL_WR_PHY_CTRL_TRCV_MSK(base, value) (ZLL_RMW_PHY_CTRL(base, ZLL_PHY_CTRL_TRCV_MSK_MASK, ZLL_PHY_CTRL_TRCV_MSK(value)))
#define ZLL_BWR_PHY_CTRL_TRCV_MSK(base, value) (BME_BFI32(&ZLL_PHY_CTRL_REG(base), ((uint32_t)(value) << ZLL_PHY_CTRL_TRCV_MSK_SHIFT), ZLL_PHY_CTRL_TRCV_MSK_SHIFT, ZLL_PHY_CTRL_TRCV_MSK_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_EVENT_TMR - EVENT TIMER
 ******************************************************************************/

/*!
 * @brief ZLL_EVENT_TMR - EVENT TIMER (RO)
 *
 * Reset value: 0x00000000U
 *
 * Holds the current value of the 24-bit event timer. The hardware latches the
 * upper 2 bytes of EVENT_TMR on each read of least signficant byte.
 */
/*!
 * @name Constants and macros for entire ZLL_EVENT_TMR register
 */
/*@{*/
#define ZLL_RD_EVENT_TMR(base)   (ZLL_EVENT_TMR_REG(base))
/*@}*/

/*
 * Constants & macros for individual ZLL_EVENT_TMR bitfields
 */

/*!
 * @name Register ZLL_EVENT_TMR, field EVENT_TMR[23:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ZLL_EVENT_TMR_EVENT_TMR field. */
#define ZLL_RD_EVENT_TMR_EVENT_TMR(base) ((ZLL_EVENT_TMR_REG(base) & ZLL_EVENT_TMR_EVENT_TMR_MASK) >> ZLL_EVENT_TMR_EVENT_TMR_SHIFT)
#define ZLL_BRD_EVENT_TMR_EVENT_TMR(base) (ZLL_RD_EVENT_TMR_EVENT_TMR(base))
/*@}*/

/*******************************************************************************
 * ZLL_TIMESTAMP - TIMESTAMP
 ******************************************************************************/

/*!
 * @brief ZLL_TIMESTAMP - TIMESTAMP (RO)
 *
 * Reset value: 0x00000000U
 *
 * Holds the latched value of the Event Timer current time corresponding to the
 * beginning of the just received Rx packet, at SFD detect.
 */
/*!
 * @name Constants and macros for entire ZLL_TIMESTAMP register
 */
/*@{*/
#define ZLL_RD_TIMESTAMP(base)   (ZLL_TIMESTAMP_REG(base))
/*@}*/

/*
 * Constants & macros for individual ZLL_TIMESTAMP bitfields
 */

/*!
 * @name Register ZLL_TIMESTAMP, field TIMESTAMP[23:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ZLL_TIMESTAMP_TIMESTAMP field. */
#define ZLL_RD_TIMESTAMP_TIMESTAMP(base) ((ZLL_TIMESTAMP_REG(base) & ZLL_TIMESTAMP_TIMESTAMP_MASK) >> ZLL_TIMESTAMP_TIMESTAMP_SHIFT)
#define ZLL_BRD_TIMESTAMP_TIMESTAMP(base) (ZLL_RD_TIMESTAMP_TIMESTAMP(base))
/*@}*/

/*******************************************************************************
 * ZLL_T1CMP - T1 COMPARE
 ******************************************************************************/

/*!
 * @brief ZLL_T1CMP - T1 COMPARE (RW)
 *
 * Reset value: 0x00FFFFFFU
 *
 * TMR1 compare value. If TMR1CMP_EN=1 and the Event Timer matches this value,
 * TMR1IRQ is set.
 */
/*!
 * @name Constants and macros for entire ZLL_T1CMP register
 */
/*@{*/
#define ZLL_RD_T1CMP(base)       (ZLL_T1CMP_REG(base))
#define ZLL_WR_T1CMP(base, value) (ZLL_T1CMP_REG(base) = (value))
#define ZLL_RMW_T1CMP(base, mask, value) (ZLL_WR_T1CMP(base, (ZLL_RD_T1CMP(base) & ~(mask)) | (value)))
#define ZLL_SET_T1CMP(base, value) (BME_OR32(&ZLL_T1CMP_REG(base), (uint32_t)(value)))
#define ZLL_CLR_T1CMP(base, value) (BME_AND32(&ZLL_T1CMP_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_T1CMP(base, value) (BME_XOR32(&ZLL_T1CMP_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_T1CMP bitfields
 */

/*!
 * @name Register ZLL_T1CMP, field T1CMP[23:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ZLL_T1CMP_T1CMP field. */
#define ZLL_RD_T1CMP_T1CMP(base) ((ZLL_T1CMP_REG(base) & ZLL_T1CMP_T1CMP_MASK) >> ZLL_T1CMP_T1CMP_SHIFT)
#define ZLL_BRD_T1CMP_T1CMP(base) (ZLL_RD_T1CMP_T1CMP(base))

/*! @brief Set the T1CMP field to a new value. */
#define ZLL_WR_T1CMP_T1CMP(base, value) (ZLL_RMW_T1CMP(base, ZLL_T1CMP_T1CMP_MASK, ZLL_T1CMP_T1CMP(value)))
#define ZLL_BWR_T1CMP_T1CMP(base, value) (ZLL_WR_T1CMP_T1CMP(base, value))
/*@}*/

/*******************************************************************************
 * ZLL_T2CMP - T2 COMPARE
 ******************************************************************************/

/*!
 * @brief ZLL_T2CMP - T2 COMPARE (RW)
 *
 * Reset value: 0x00FFFFFFU
 *
 * TMR2 compare value. If TMR2CMP_EN=1 and TC2PRIME_EN=0 and the Event Timer
 * matches this value, TMR2IRQ is set.
 */
/*!
 * @name Constants and macros for entire ZLL_T2CMP register
 */
/*@{*/
#define ZLL_RD_T2CMP(base)       (ZLL_T2CMP_REG(base))
#define ZLL_WR_T2CMP(base, value) (ZLL_T2CMP_REG(base) = (value))
#define ZLL_RMW_T2CMP(base, mask, value) (ZLL_WR_T2CMP(base, (ZLL_RD_T2CMP(base) & ~(mask)) | (value)))
#define ZLL_SET_T2CMP(base, value) (BME_OR32(&ZLL_T2CMP_REG(base), (uint32_t)(value)))
#define ZLL_CLR_T2CMP(base, value) (BME_AND32(&ZLL_T2CMP_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_T2CMP(base, value) (BME_XOR32(&ZLL_T2CMP_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_T2CMP bitfields
 */

/*!
 * @name Register ZLL_T2CMP, field T2CMP[23:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ZLL_T2CMP_T2CMP field. */
#define ZLL_RD_T2CMP_T2CMP(base) ((ZLL_T2CMP_REG(base) & ZLL_T2CMP_T2CMP_MASK) >> ZLL_T2CMP_T2CMP_SHIFT)
#define ZLL_BRD_T2CMP_T2CMP(base) (ZLL_RD_T2CMP_T2CMP(base))

/*! @brief Set the T2CMP field to a new value. */
#define ZLL_WR_T2CMP_T2CMP(base, value) (ZLL_RMW_T2CMP(base, ZLL_T2CMP_T2CMP_MASK, ZLL_T2CMP_T2CMP(value)))
#define ZLL_BWR_T2CMP_T2CMP(base, value) (ZLL_WR_T2CMP_T2CMP(base, value))
/*@}*/

/*******************************************************************************
 * ZLL_T2PRIMECMP - T2 PRIME COMPARE
 ******************************************************************************/

/*!
 * @brief ZLL_T2PRIMECMP - T2 PRIME COMPARE (RW)
 *
 * Reset value: 0x0000FFFFU
 *
 * TMR2 compare value. If TMR2CMP_EN=1 and TC2PRIME_EN=1 and the Event Timer
 * matches this value, TMR2IRQ is set.
 */
/*!
 * @name Constants and macros for entire ZLL_T2PRIMECMP register
 */
/*@{*/
#define ZLL_RD_T2PRIMECMP(base)  (ZLL_T2PRIMECMP_REG(base))
#define ZLL_WR_T2PRIMECMP(base, value) (ZLL_T2PRIMECMP_REG(base) = (value))
#define ZLL_RMW_T2PRIMECMP(base, mask, value) (ZLL_WR_T2PRIMECMP(base, (ZLL_RD_T2PRIMECMP(base) & ~(mask)) | (value)))
#define ZLL_SET_T2PRIMECMP(base, value) (BME_OR32(&ZLL_T2PRIMECMP_REG(base), (uint32_t)(value)))
#define ZLL_CLR_T2PRIMECMP(base, value) (BME_AND32(&ZLL_T2PRIMECMP_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_T2PRIMECMP(base, value) (BME_XOR32(&ZLL_T2PRIMECMP_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_T2PRIMECMP bitfields
 */

/*!
 * @name Register ZLL_T2PRIMECMP, field T2PRIMECMP[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ZLL_T2PRIMECMP_T2PRIMECMP field. */
#define ZLL_RD_T2PRIMECMP_T2PRIMECMP(base) ((ZLL_T2PRIMECMP_REG(base) & ZLL_T2PRIMECMP_T2PRIMECMP_MASK) >> ZLL_T2PRIMECMP_T2PRIMECMP_SHIFT)
#define ZLL_BRD_T2PRIMECMP_T2PRIMECMP(base) (BME_UBFX32(&ZLL_T2PRIMECMP_REG(base), ZLL_T2PRIMECMP_T2PRIMECMP_SHIFT, ZLL_T2PRIMECMP_T2PRIMECMP_WIDTH))

/*! @brief Set the T2PRIMECMP field to a new value. */
#define ZLL_WR_T2PRIMECMP_T2PRIMECMP(base, value) (ZLL_RMW_T2PRIMECMP(base, ZLL_T2PRIMECMP_T2PRIMECMP_MASK, ZLL_T2PRIMECMP_T2PRIMECMP(value)))
#define ZLL_BWR_T2PRIMECMP_T2PRIMECMP(base, value) (BME_BFI32(&ZLL_T2PRIMECMP_REG(base), ((uint32_t)(value) << ZLL_T2PRIMECMP_T2PRIMECMP_SHIFT), ZLL_T2PRIMECMP_T2PRIMECMP_SHIFT, ZLL_T2PRIMECMP_T2PRIMECMP_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_T3CMP - T3 COMPARE
 ******************************************************************************/

/*!
 * @brief ZLL_T3CMP - T3 COMPARE (RW)
 *
 * Reset value: 0x00FFFFFFU
 *
 * TMR3 compare value. If TMR3CMP_EN=1 and the Event Timer matches this value,
 * TMR3IRQ is set.
 */
/*!
 * @name Constants and macros for entire ZLL_T3CMP register
 */
/*@{*/
#define ZLL_RD_T3CMP(base)       (ZLL_T3CMP_REG(base))
#define ZLL_WR_T3CMP(base, value) (ZLL_T3CMP_REG(base) = (value))
#define ZLL_RMW_T3CMP(base, mask, value) (ZLL_WR_T3CMP(base, (ZLL_RD_T3CMP(base) & ~(mask)) | (value)))
#define ZLL_SET_T3CMP(base, value) (BME_OR32(&ZLL_T3CMP_REG(base), (uint32_t)(value)))
#define ZLL_CLR_T3CMP(base, value) (BME_AND32(&ZLL_T3CMP_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_T3CMP(base, value) (BME_XOR32(&ZLL_T3CMP_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_T3CMP bitfields
 */

/*!
 * @name Register ZLL_T3CMP, field T3CMP[23:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ZLL_T3CMP_T3CMP field. */
#define ZLL_RD_T3CMP_T3CMP(base) ((ZLL_T3CMP_REG(base) & ZLL_T3CMP_T3CMP_MASK) >> ZLL_T3CMP_T3CMP_SHIFT)
#define ZLL_BRD_T3CMP_T3CMP(base) (ZLL_RD_T3CMP_T3CMP(base))

/*! @brief Set the T3CMP field to a new value. */
#define ZLL_WR_T3CMP_T3CMP(base, value) (ZLL_RMW_T3CMP(base, ZLL_T3CMP_T3CMP_MASK, ZLL_T3CMP_T3CMP(value)))
#define ZLL_BWR_T3CMP_T3CMP(base, value) (ZLL_WR_T3CMP_T3CMP(base, value))
/*@}*/

/*******************************************************************************
 * ZLL_T4CMP - T4 COMPARE
 ******************************************************************************/

/*!
 * @brief ZLL_T4CMP - T4 COMPARE (RW)
 *
 * Reset value: 0x00FFFFFFU
 *
 * TMR4 compare value. If TMR4CMP_EN=1 and the Event Timer matches this value,
 * TMR4IRQ is set.
 */
/*!
 * @name Constants and macros for entire ZLL_T4CMP register
 */
/*@{*/
#define ZLL_RD_T4CMP(base)       (ZLL_T4CMP_REG(base))
#define ZLL_WR_T4CMP(base, value) (ZLL_T4CMP_REG(base) = (value))
#define ZLL_RMW_T4CMP(base, mask, value) (ZLL_WR_T4CMP(base, (ZLL_RD_T4CMP(base) & ~(mask)) | (value)))
#define ZLL_SET_T4CMP(base, value) (BME_OR32(&ZLL_T4CMP_REG(base), (uint32_t)(value)))
#define ZLL_CLR_T4CMP(base, value) (BME_AND32(&ZLL_T4CMP_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_T4CMP(base, value) (BME_XOR32(&ZLL_T4CMP_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_T4CMP bitfields
 */

/*!
 * @name Register ZLL_T4CMP, field T4CMP[23:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ZLL_T4CMP_T4CMP field. */
#define ZLL_RD_T4CMP_T4CMP(base) ((ZLL_T4CMP_REG(base) & ZLL_T4CMP_T4CMP_MASK) >> ZLL_T4CMP_T4CMP_SHIFT)
#define ZLL_BRD_T4CMP_T4CMP(base) (ZLL_RD_T4CMP_T4CMP(base))

/*! @brief Set the T4CMP field to a new value. */
#define ZLL_WR_T4CMP_T4CMP(base, value) (ZLL_RMW_T4CMP(base, ZLL_T4CMP_T4CMP_MASK, ZLL_T4CMP_T4CMP(value)))
#define ZLL_BWR_T4CMP_T4CMP(base, value) (ZLL_WR_T4CMP_T4CMP(base, value))
/*@}*/

/*******************************************************************************
 * ZLL_PA_PWR - PA POWER
 ******************************************************************************/

/*!
 * @brief ZLL_PA_PWR - PA POWER (RW)
 *
 * Reset value: 0x00000008U
 *
 * PA Target Power used to transmit Zigbee packets
 */
/*!
 * @name Constants and macros for entire ZLL_PA_PWR register
 */
/*@{*/
#define ZLL_RD_PA_PWR(base)      (ZLL_PA_PWR_REG(base))
#define ZLL_WR_PA_PWR(base, value) (ZLL_PA_PWR_REG(base) = (value))
#define ZLL_RMW_PA_PWR(base, mask, value) (ZLL_WR_PA_PWR(base, (ZLL_RD_PA_PWR(base) & ~(mask)) | (value)))
#define ZLL_SET_PA_PWR(base, value) (BME_OR32(&ZLL_PA_PWR_REG(base), (uint32_t)(value)))
#define ZLL_CLR_PA_PWR(base, value) (BME_AND32(&ZLL_PA_PWR_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_PA_PWR(base, value) (BME_XOR32(&ZLL_PA_PWR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_PA_PWR bitfields
 */

/*!
 * @name Register ZLL_PA_PWR, field PA_PWR[3:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ZLL_PA_PWR_PA_PWR field. */
#define ZLL_RD_PA_PWR_PA_PWR(base) ((ZLL_PA_PWR_REG(base) & ZLL_PA_PWR_PA_PWR_MASK) >> ZLL_PA_PWR_PA_PWR_SHIFT)
#define ZLL_BRD_PA_PWR_PA_PWR(base) (BME_UBFX32(&ZLL_PA_PWR_REG(base), ZLL_PA_PWR_PA_PWR_SHIFT, ZLL_PA_PWR_PA_PWR_WIDTH))

/*! @brief Set the PA_PWR field to a new value. */
#define ZLL_WR_PA_PWR_PA_PWR(base, value) (ZLL_RMW_PA_PWR(base, ZLL_PA_PWR_PA_PWR_MASK, ZLL_PA_PWR_PA_PWR(value)))
#define ZLL_BWR_PA_PWR_PA_PWR(base, value) (BME_BFI32(&ZLL_PA_PWR_REG(base), ((uint32_t)(value) << ZLL_PA_PWR_PA_PWR_SHIFT), ZLL_PA_PWR_PA_PWR_SHIFT, ZLL_PA_PWR_PA_PWR_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_CHANNEL_NUM0 - CHANNEL NUMBER 0
 ******************************************************************************/

/*!
 * @brief ZLL_CHANNEL_NUM0 - CHANNEL NUMBER 0 (RW)
 *
 * Reset value: 0x00000012U
 *
 * This is the mapped channel number used to transmit and receive Zigbee
 * packets. If Dual PAN is engaged, this register applies to PAN0. CHANNEL_NUM0 should
 * be in the range: 11 <= CHANNEL_NUM0 <= 26
 */
/*!
 * @name Constants and macros for entire ZLL_CHANNEL_NUM0 register
 */
/*@{*/
#define ZLL_RD_CHANNEL_NUM0(base) (ZLL_CHANNEL_NUM0_REG(base))
#define ZLL_WR_CHANNEL_NUM0(base, value) (ZLL_CHANNEL_NUM0_REG(base) = (value))
#define ZLL_RMW_CHANNEL_NUM0(base, mask, value) (ZLL_WR_CHANNEL_NUM0(base, (ZLL_RD_CHANNEL_NUM0(base) & ~(mask)) | (value)))
#define ZLL_SET_CHANNEL_NUM0(base, value) (BME_OR32(&ZLL_CHANNEL_NUM0_REG(base), (uint32_t)(value)))
#define ZLL_CLR_CHANNEL_NUM0(base, value) (BME_AND32(&ZLL_CHANNEL_NUM0_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_CHANNEL_NUM0(base, value) (BME_XOR32(&ZLL_CHANNEL_NUM0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_CHANNEL_NUM0 bitfields
 */

/*!
 * @name Register ZLL_CHANNEL_NUM0, field CHANNEL_NUM0[6:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ZLL_CHANNEL_NUM0_CHANNEL_NUM0 field. */
#define ZLL_RD_CHANNEL_NUM0_CHANNEL_NUM0(base) ((ZLL_CHANNEL_NUM0_REG(base) & ZLL_CHANNEL_NUM0_CHANNEL_NUM0_MASK) >> ZLL_CHANNEL_NUM0_CHANNEL_NUM0_SHIFT)
#define ZLL_BRD_CHANNEL_NUM0_CHANNEL_NUM0(base) (BME_UBFX32(&ZLL_CHANNEL_NUM0_REG(base), ZLL_CHANNEL_NUM0_CHANNEL_NUM0_SHIFT, ZLL_CHANNEL_NUM0_CHANNEL_NUM0_WIDTH))

/*! @brief Set the CHANNEL_NUM0 field to a new value. */
#define ZLL_WR_CHANNEL_NUM0_CHANNEL_NUM0(base, value) (ZLL_RMW_CHANNEL_NUM0(base, ZLL_CHANNEL_NUM0_CHANNEL_NUM0_MASK, ZLL_CHANNEL_NUM0_CHANNEL_NUM0(value)))
#define ZLL_BWR_CHANNEL_NUM0_CHANNEL_NUM0(base, value) (BME_BFI32(&ZLL_CHANNEL_NUM0_REG(base), ((uint32_t)(value) << ZLL_CHANNEL_NUM0_CHANNEL_NUM0_SHIFT), ZLL_CHANNEL_NUM0_CHANNEL_NUM0_SHIFT, ZLL_CHANNEL_NUM0_CHANNEL_NUM0_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_LQI_AND_RSSI - LQI AND RSSI
 ******************************************************************************/

/*!
 * @brief ZLL_LQI_AND_RSSI - LQI AND RSSI (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ZLL_LQI_AND_RSSI register
 */
/*@{*/
#define ZLL_RD_LQI_AND_RSSI(base) (ZLL_LQI_AND_RSSI_REG(base))
/*@}*/

/*
 * Constants & macros for individual ZLL_LQI_AND_RSSI bitfields
 */

/*!
 * @name Register ZLL_LQI_AND_RSSI, field LQI_VALUE[7:0] (RO)
 *
 * Link Quality Indicator for the most recently received packet. (LQI is also
 * available in the Packet Buffer, at the end of the received packet data)
 */
/*@{*/
/*! @brief Read current value of the ZLL_LQI_AND_RSSI_LQI_VALUE field. */
#define ZLL_RD_LQI_AND_RSSI_LQI_VALUE(base) ((ZLL_LQI_AND_RSSI_REG(base) & ZLL_LQI_AND_RSSI_LQI_VALUE_MASK) >> ZLL_LQI_AND_RSSI_LQI_VALUE_SHIFT)
#define ZLL_BRD_LQI_AND_RSSI_LQI_VALUE(base) (BME_UBFX32(&ZLL_LQI_AND_RSSI_REG(base), ZLL_LQI_AND_RSSI_LQI_VALUE_SHIFT, ZLL_LQI_AND_RSSI_LQI_VALUE_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_LQI_AND_RSSI, field RSSI[15:8] (RO)
 *
 * RSSI Output
 */
/*@{*/
/*! @brief Read current value of the ZLL_LQI_AND_RSSI_RSSI field. */
#define ZLL_RD_LQI_AND_RSSI_RSSI(base) ((ZLL_LQI_AND_RSSI_REG(base) & ZLL_LQI_AND_RSSI_RSSI_MASK) >> ZLL_LQI_AND_RSSI_RSSI_SHIFT)
#define ZLL_BRD_LQI_AND_RSSI_RSSI(base) (BME_UBFX32(&ZLL_LQI_AND_RSSI_REG(base), ZLL_LQI_AND_RSSI_RSSI_SHIFT, ZLL_LQI_AND_RSSI_RSSI_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_LQI_AND_RSSI, field CCA1_ED_FNL[23:16] (RO)
 *
 * Output register to show final averaged RSSI value or compensated value of the
 * same at the end of a CCA Mode1 or Energy Detect computation.
 */
/*@{*/
/*! @brief Read current value of the ZLL_LQI_AND_RSSI_CCA1_ED_FNL field. */
#define ZLL_RD_LQI_AND_RSSI_CCA1_ED_FNL(base) ((ZLL_LQI_AND_RSSI_REG(base) & ZLL_LQI_AND_RSSI_CCA1_ED_FNL_MASK) >> ZLL_LQI_AND_RSSI_CCA1_ED_FNL_SHIFT)
#define ZLL_BRD_LQI_AND_RSSI_CCA1_ED_FNL(base) (BME_UBFX32(&ZLL_LQI_AND_RSSI_REG(base), ZLL_LQI_AND_RSSI_CCA1_ED_FNL_SHIFT, ZLL_LQI_AND_RSSI_CCA1_ED_FNL_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_MACSHORTADDRS0 - MAC SHORT ADDRESS 0
 ******************************************************************************/

/*!
 * @brief ZLL_MACSHORTADDRS0 - MAC SHORT ADDRESS 0 (RW)
 *
 * Reset value: 0xFFFFFFFFU
 */
/*!
 * @name Constants and macros for entire ZLL_MACSHORTADDRS0 register
 */
/*@{*/
#define ZLL_RD_MACSHORTADDRS0(base) (ZLL_MACSHORTADDRS0_REG(base))
#define ZLL_WR_MACSHORTADDRS0(base, value) (ZLL_MACSHORTADDRS0_REG(base) = (value))
#define ZLL_RMW_MACSHORTADDRS0(base, mask, value) (ZLL_WR_MACSHORTADDRS0(base, (ZLL_RD_MACSHORTADDRS0(base) & ~(mask)) | (value)))
#define ZLL_SET_MACSHORTADDRS0(base, value) (BME_OR32(&ZLL_MACSHORTADDRS0_REG(base), (uint32_t)(value)))
#define ZLL_CLR_MACSHORTADDRS0(base, value) (BME_AND32(&ZLL_MACSHORTADDRS0_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_MACSHORTADDRS0(base, value) (BME_XOR32(&ZLL_MACSHORTADDRS0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_MACSHORTADDRS0 bitfields
 */

/*!
 * @name Register ZLL_MACSHORTADDRS0, field MACPANID0[15:0] (RW)
 *
 * MAC PAN ID for PAN0. The packet processor compares the incoming packet's
 * Destination PAN ID against the contents of this register to determine if the
 * packet is addressed to this device; or if the incoming packet is a Beacon frame,
 * the packet processor compares the incoming packet Source PAN ID against this
 * register. Also, if PANCORDNTR0=1, and the incoming packet has no Destination
 * Address field, and if the incoming packet is a Data or MAC Command frame, the
 * packet processor compares the incoming packet Source PAN ID against this register.
 */
/*@{*/
/*! @brief Read current value of the ZLL_MACSHORTADDRS0_MACPANID0 field. */
#define ZLL_RD_MACSHORTADDRS0_MACPANID0(base) ((ZLL_MACSHORTADDRS0_REG(base) & ZLL_MACSHORTADDRS0_MACPANID0_MASK) >> ZLL_MACSHORTADDRS0_MACPANID0_SHIFT)
#define ZLL_BRD_MACSHORTADDRS0_MACPANID0(base) (BME_UBFX32(&ZLL_MACSHORTADDRS0_REG(base), ZLL_MACSHORTADDRS0_MACPANID0_SHIFT, ZLL_MACSHORTADDRS0_MACPANID0_WIDTH))

/*! @brief Set the MACPANID0 field to a new value. */
#define ZLL_WR_MACSHORTADDRS0_MACPANID0(base, value) (ZLL_RMW_MACSHORTADDRS0(base, ZLL_MACSHORTADDRS0_MACPANID0_MASK, ZLL_MACSHORTADDRS0_MACPANID0(value)))
#define ZLL_BWR_MACSHORTADDRS0_MACPANID0(base, value) (BME_BFI32(&ZLL_MACSHORTADDRS0_REG(base), ((uint32_t)(value) << ZLL_MACSHORTADDRS0_MACPANID0_SHIFT), ZLL_MACSHORTADDRS0_MACPANID0_SHIFT, ZLL_MACSHORTADDRS0_MACPANID0_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_MACSHORTADDRS0, field MACSHORTADDRS0[31:16] (RW)
 *
 * MAC Short Address for PAN0, for 16-bit destination addressing mode. The
 * packet processor compares the incoming packet's Destination Address against the
 * contents of this register to determine if the packet is addressed to this device.
 */
/*@{*/
/*! @brief Read current value of the ZLL_MACSHORTADDRS0_MACSHORTADDRS0 field. */
#define ZLL_RD_MACSHORTADDRS0_MACSHORTADDRS0(base) ((ZLL_MACSHORTADDRS0_REG(base) & ZLL_MACSHORTADDRS0_MACSHORTADDRS0_MASK) >> ZLL_MACSHORTADDRS0_MACSHORTADDRS0_SHIFT)
#define ZLL_BRD_MACSHORTADDRS0_MACSHORTADDRS0(base) (BME_UBFX32(&ZLL_MACSHORTADDRS0_REG(base), ZLL_MACSHORTADDRS0_MACSHORTADDRS0_SHIFT, ZLL_MACSHORTADDRS0_MACSHORTADDRS0_WIDTH))

/*! @brief Set the MACSHORTADDRS0 field to a new value. */
#define ZLL_WR_MACSHORTADDRS0_MACSHORTADDRS0(base, value) (ZLL_RMW_MACSHORTADDRS0(base, ZLL_MACSHORTADDRS0_MACSHORTADDRS0_MASK, ZLL_MACSHORTADDRS0_MACSHORTADDRS0(value)))
#define ZLL_BWR_MACSHORTADDRS0_MACSHORTADDRS0(base, value) (BME_BFI32(&ZLL_MACSHORTADDRS0_REG(base), ((uint32_t)(value) << ZLL_MACSHORTADDRS0_MACSHORTADDRS0_SHIFT), ZLL_MACSHORTADDRS0_MACSHORTADDRS0_SHIFT, ZLL_MACSHORTADDRS0_MACSHORTADDRS0_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_MACLONGADDRS0_LSB - MAC LONG ADDRESS 0 LSB
 ******************************************************************************/

/*!
 * @brief ZLL_MACLONGADDRS0_LSB - MAC LONG ADDRESS 0 LSB (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * MAC Long Address for PAN0, for 64-bit destination addressing mode. The packet
 * processor compares the incoming packet's Destination Address against the
 * contents of this register to determine if the packet is addressed to this device.
 */
/*!
 * @name Constants and macros for entire ZLL_MACLONGADDRS0_LSB register
 */
/*@{*/
#define ZLL_RD_MACLONGADDRS0_LSB(base) (ZLL_MACLONGADDRS0_LSB_REG(base))
#define ZLL_WR_MACLONGADDRS0_LSB(base, value) (ZLL_MACLONGADDRS0_LSB_REG(base) = (value))
#define ZLL_RMW_MACLONGADDRS0_LSB(base, mask, value) (ZLL_WR_MACLONGADDRS0_LSB(base, (ZLL_RD_MACLONGADDRS0_LSB(base) & ~(mask)) | (value)))
#define ZLL_SET_MACLONGADDRS0_LSB(base, value) (BME_OR32(&ZLL_MACLONGADDRS0_LSB_REG(base), (uint32_t)(value)))
#define ZLL_CLR_MACLONGADDRS0_LSB(base, value) (BME_AND32(&ZLL_MACLONGADDRS0_LSB_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_MACLONGADDRS0_LSB(base, value) (BME_XOR32(&ZLL_MACLONGADDRS0_LSB_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * ZLL_MACLONGADDRS0_MSB - MAC LONG ADDRESS 0 MSB
 ******************************************************************************/

/*!
 * @brief ZLL_MACLONGADDRS0_MSB - MAC LONG ADDRESS 0 MSB (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * MAC Long Address for PAN0, for 64-bit destination addressing mode. The packet
 * processor compares the incoming packet's Destination Address against the
 * contents of this register to determine if the packet is addressed to this device.
 */
/*!
 * @name Constants and macros for entire ZLL_MACLONGADDRS0_MSB register
 */
/*@{*/
#define ZLL_RD_MACLONGADDRS0_MSB(base) (ZLL_MACLONGADDRS0_MSB_REG(base))
#define ZLL_WR_MACLONGADDRS0_MSB(base, value) (ZLL_MACLONGADDRS0_MSB_REG(base) = (value))
#define ZLL_RMW_MACLONGADDRS0_MSB(base, mask, value) (ZLL_WR_MACLONGADDRS0_MSB(base, (ZLL_RD_MACLONGADDRS0_MSB(base) & ~(mask)) | (value)))
#define ZLL_SET_MACLONGADDRS0_MSB(base, value) (BME_OR32(&ZLL_MACLONGADDRS0_MSB_REG(base), (uint32_t)(value)))
#define ZLL_CLR_MACLONGADDRS0_MSB(base, value) (BME_AND32(&ZLL_MACLONGADDRS0_MSB_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_MACLONGADDRS0_MSB(base, value) (BME_XOR32(&ZLL_MACLONGADDRS0_MSB_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * ZLL_RX_FRAME_FILTER - RECEIVE FRAME FILTER
 ******************************************************************************/

/*!
 * @brief ZLL_RX_FRAME_FILTER - RECEIVE FRAME FILTER (RW)
 *
 * Reset value: 0x0000000FU
 */
/*!
 * @name Constants and macros for entire ZLL_RX_FRAME_FILTER register
 */
/*@{*/
#define ZLL_RD_RX_FRAME_FILTER(base) (ZLL_RX_FRAME_FILTER_REG(base))
#define ZLL_WR_RX_FRAME_FILTER(base, value) (ZLL_RX_FRAME_FILTER_REG(base) = (value))
#define ZLL_RMW_RX_FRAME_FILTER(base, mask, value) (ZLL_WR_RX_FRAME_FILTER(base, (ZLL_RD_RX_FRAME_FILTER(base) & ~(mask)) | (value)))
#define ZLL_SET_RX_FRAME_FILTER(base, value) (BME_OR32(&ZLL_RX_FRAME_FILTER_REG(base), (uint32_t)(value)))
#define ZLL_CLR_RX_FRAME_FILTER(base, value) (BME_AND32(&ZLL_RX_FRAME_FILTER_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_RX_FRAME_FILTER(base, value) (BME_XOR32(&ZLL_RX_FRAME_FILTER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_RX_FRAME_FILTER bitfields
 */

/*!
 * @name Register ZLL_RX_FRAME_FILTER, field BEACON_FT[0] (RW)
 *
 * Values:
 * - 0b0 - reject all Beacon frames
 * - 0b1 - Beacon frame type enabled.
 */
/*@{*/
/*! @brief Read current value of the ZLL_RX_FRAME_FILTER_BEACON_FT field. */
#define ZLL_RD_RX_FRAME_FILTER_BEACON_FT(base) ((ZLL_RX_FRAME_FILTER_REG(base) & ZLL_RX_FRAME_FILTER_BEACON_FT_MASK) >> ZLL_RX_FRAME_FILTER_BEACON_FT_SHIFT)
#define ZLL_BRD_RX_FRAME_FILTER_BEACON_FT(base) (BME_UBFX32(&ZLL_RX_FRAME_FILTER_REG(base), ZLL_RX_FRAME_FILTER_BEACON_FT_SHIFT, ZLL_RX_FRAME_FILTER_BEACON_FT_WIDTH))

/*! @brief Set the BEACON_FT field to a new value. */
#define ZLL_WR_RX_FRAME_FILTER_BEACON_FT(base, value) (ZLL_RMW_RX_FRAME_FILTER(base, ZLL_RX_FRAME_FILTER_BEACON_FT_MASK, ZLL_RX_FRAME_FILTER_BEACON_FT(value)))
#define ZLL_BWR_RX_FRAME_FILTER_BEACON_FT(base, value) (BME_BFI32(&ZLL_RX_FRAME_FILTER_REG(base), ((uint32_t)(value) << ZLL_RX_FRAME_FILTER_BEACON_FT_SHIFT), ZLL_RX_FRAME_FILTER_BEACON_FT_SHIFT, ZLL_RX_FRAME_FILTER_BEACON_FT_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_RX_FRAME_FILTER, field DATA_FT[1] (RW)
 *
 * Values:
 * - 0b0 - reject all Data frames
 * - 0b1 - Data frame type enabled.
 */
/*@{*/
/*! @brief Read current value of the ZLL_RX_FRAME_FILTER_DATA_FT field. */
#define ZLL_RD_RX_FRAME_FILTER_DATA_FT(base) ((ZLL_RX_FRAME_FILTER_REG(base) & ZLL_RX_FRAME_FILTER_DATA_FT_MASK) >> ZLL_RX_FRAME_FILTER_DATA_FT_SHIFT)
#define ZLL_BRD_RX_FRAME_FILTER_DATA_FT(base) (BME_UBFX32(&ZLL_RX_FRAME_FILTER_REG(base), ZLL_RX_FRAME_FILTER_DATA_FT_SHIFT, ZLL_RX_FRAME_FILTER_DATA_FT_WIDTH))

/*! @brief Set the DATA_FT field to a new value. */
#define ZLL_WR_RX_FRAME_FILTER_DATA_FT(base, value) (ZLL_RMW_RX_FRAME_FILTER(base, ZLL_RX_FRAME_FILTER_DATA_FT_MASK, ZLL_RX_FRAME_FILTER_DATA_FT(value)))
#define ZLL_BWR_RX_FRAME_FILTER_DATA_FT(base, value) (BME_BFI32(&ZLL_RX_FRAME_FILTER_REG(base), ((uint32_t)(value) << ZLL_RX_FRAME_FILTER_DATA_FT_SHIFT), ZLL_RX_FRAME_FILTER_DATA_FT_SHIFT, ZLL_RX_FRAME_FILTER_DATA_FT_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_RX_FRAME_FILTER, field ACK_FT[2] (RW)
 *
 * Values:
 * - 0b0 - reject all Acknowledge frames
 * - 0b1 - Acknowledge frame type enabled.
 */
/*@{*/
/*! @brief Read current value of the ZLL_RX_FRAME_FILTER_ACK_FT field. */
#define ZLL_RD_RX_FRAME_FILTER_ACK_FT(base) ((ZLL_RX_FRAME_FILTER_REG(base) & ZLL_RX_FRAME_FILTER_ACK_FT_MASK) >> ZLL_RX_FRAME_FILTER_ACK_FT_SHIFT)
#define ZLL_BRD_RX_FRAME_FILTER_ACK_FT(base) (BME_UBFX32(&ZLL_RX_FRAME_FILTER_REG(base), ZLL_RX_FRAME_FILTER_ACK_FT_SHIFT, ZLL_RX_FRAME_FILTER_ACK_FT_WIDTH))

/*! @brief Set the ACK_FT field to a new value. */
#define ZLL_WR_RX_FRAME_FILTER_ACK_FT(base, value) (ZLL_RMW_RX_FRAME_FILTER(base, ZLL_RX_FRAME_FILTER_ACK_FT_MASK, ZLL_RX_FRAME_FILTER_ACK_FT(value)))
#define ZLL_BWR_RX_FRAME_FILTER_ACK_FT(base, value) (BME_BFI32(&ZLL_RX_FRAME_FILTER_REG(base), ((uint32_t)(value) << ZLL_RX_FRAME_FILTER_ACK_FT_SHIFT), ZLL_RX_FRAME_FILTER_ACK_FT_SHIFT, ZLL_RX_FRAME_FILTER_ACK_FT_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_RX_FRAME_FILTER, field CMD_FT[3] (RW)
 *
 * Values:
 * - 0b0 - reject all MAC Command frames
 * - 0b1 - MAC Command frame type enabled.
 */
/*@{*/
/*! @brief Read current value of the ZLL_RX_FRAME_FILTER_CMD_FT field. */
#define ZLL_RD_RX_FRAME_FILTER_CMD_FT(base) ((ZLL_RX_FRAME_FILTER_REG(base) & ZLL_RX_FRAME_FILTER_CMD_FT_MASK) >> ZLL_RX_FRAME_FILTER_CMD_FT_SHIFT)
#define ZLL_BRD_RX_FRAME_FILTER_CMD_FT(base) (BME_UBFX32(&ZLL_RX_FRAME_FILTER_REG(base), ZLL_RX_FRAME_FILTER_CMD_FT_SHIFT, ZLL_RX_FRAME_FILTER_CMD_FT_WIDTH))

/*! @brief Set the CMD_FT field to a new value. */
#define ZLL_WR_RX_FRAME_FILTER_CMD_FT(base, value) (ZLL_RMW_RX_FRAME_FILTER(base, ZLL_RX_FRAME_FILTER_CMD_FT_MASK, ZLL_RX_FRAME_FILTER_CMD_FT(value)))
#define ZLL_BWR_RX_FRAME_FILTER_CMD_FT(base, value) (BME_BFI32(&ZLL_RX_FRAME_FILTER_REG(base), ((uint32_t)(value) << ZLL_RX_FRAME_FILTER_CMD_FT_SHIFT), ZLL_RX_FRAME_FILTER_CMD_FT_SHIFT, ZLL_RX_FRAME_FILTER_CMD_FT_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_RX_FRAME_FILTER, field NS_FT[4] (RW)
 *
 * Values:
 * - 0b0 - reject all reserved frame types
 * - 0b1 - Not-specified (reserved) frame type enabled. No packet filtering is
 *     performed, except for frame length checking (FrameLength>=5 and
 *     FrameLength<=127).
 */
/*@{*/
/*! @brief Read current value of the ZLL_RX_FRAME_FILTER_NS_FT field. */
#define ZLL_RD_RX_FRAME_FILTER_NS_FT(base) ((ZLL_RX_FRAME_FILTER_REG(base) & ZLL_RX_FRAME_FILTER_NS_FT_MASK) >> ZLL_RX_FRAME_FILTER_NS_FT_SHIFT)
#define ZLL_BRD_RX_FRAME_FILTER_NS_FT(base) (BME_UBFX32(&ZLL_RX_FRAME_FILTER_REG(base), ZLL_RX_FRAME_FILTER_NS_FT_SHIFT, ZLL_RX_FRAME_FILTER_NS_FT_WIDTH))

/*! @brief Set the NS_FT field to a new value. */
#define ZLL_WR_RX_FRAME_FILTER_NS_FT(base, value) (ZLL_RMW_RX_FRAME_FILTER(base, ZLL_RX_FRAME_FILTER_NS_FT_MASK, ZLL_RX_FRAME_FILTER_NS_FT(value)))
#define ZLL_BWR_RX_FRAME_FILTER_NS_FT(base, value) (BME_BFI32(&ZLL_RX_FRAME_FILTER_REG(base), ((uint32_t)(value) << ZLL_RX_FRAME_FILTER_NS_FT_SHIFT), ZLL_RX_FRAME_FILTER_NS_FT_SHIFT, ZLL_RX_FRAME_FILTER_NS_FT_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_RX_FRAME_FILTER, field ACTIVE_PROMISCUOUS[5] (RW)
 *
 * Values:
 * - 0b0 - normal operation
 * - 0b1 - Provide Data Indication on all received packets under the same rules
 *     which apply in PROMISCUOUS mode, however acknowledge those packets under
 *     rules which apply in non-PROMISCUOUS mode
 */
/*@{*/
/*! @brief Read current value of the ZLL_RX_FRAME_FILTER_ACTIVE_PROMISCUOUS field. */
#define ZLL_RD_RX_FRAME_FILTER_ACTIVE_PROMISCUOUS(base) ((ZLL_RX_FRAME_FILTER_REG(base) & ZLL_RX_FRAME_FILTER_ACTIVE_PROMISCUOUS_MASK) >> ZLL_RX_FRAME_FILTER_ACTIVE_PROMISCUOUS_SHIFT)
#define ZLL_BRD_RX_FRAME_FILTER_ACTIVE_PROMISCUOUS(base) (BME_UBFX32(&ZLL_RX_FRAME_FILTER_REG(base), ZLL_RX_FRAME_FILTER_ACTIVE_PROMISCUOUS_SHIFT, ZLL_RX_FRAME_FILTER_ACTIVE_PROMISCUOUS_WIDTH))

/*! @brief Set the ACTIVE_PROMISCUOUS field to a new value. */
#define ZLL_WR_RX_FRAME_FILTER_ACTIVE_PROMISCUOUS(base, value) (ZLL_RMW_RX_FRAME_FILTER(base, ZLL_RX_FRAME_FILTER_ACTIVE_PROMISCUOUS_MASK, ZLL_RX_FRAME_FILTER_ACTIVE_PROMISCUOUS(value)))
#define ZLL_BWR_RX_FRAME_FILTER_ACTIVE_PROMISCUOUS(base, value) (BME_BFI32(&ZLL_RX_FRAME_FILTER_REG(base), ((uint32_t)(value) << ZLL_RX_FRAME_FILTER_ACTIVE_PROMISCUOUS_SHIFT), ZLL_RX_FRAME_FILTER_ACTIVE_PROMISCUOUS_SHIFT, ZLL_RX_FRAME_FILTER_ACTIVE_PROMISCUOUS_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_RX_FRAME_FILTER, field FRM_VER[7:6] (RW)
 *
 * Frame Version selector. The incoming packet's Frame Control Field is parsed
 * to obtain the FrameVersion subfield, and that value is compared against this
 * register, in accordance with the following: 00: Any FrameVersion accepted (0,1,2
 * or 3) 01: Only accept FrameVersion 0 packets (2003 compliant) 10: Only accept
 * FrameVersion 1 packets (2006 compliant) 11: Accept FrameVersion 0 and 1
 * packets, reject all others Frames received with FrameVersion 2 or 3 will be treated
 * identically to FrameVersion 1, with respect to parsing of the Auxiliary
 * Security Header. Other than this Header, all 4 frame versions will be treated
 * identically
 */
/*@{*/
/*! @brief Read current value of the ZLL_RX_FRAME_FILTER_FRM_VER field. */
#define ZLL_RD_RX_FRAME_FILTER_FRM_VER(base) ((ZLL_RX_FRAME_FILTER_REG(base) & ZLL_RX_FRAME_FILTER_FRM_VER_MASK) >> ZLL_RX_FRAME_FILTER_FRM_VER_SHIFT)
#define ZLL_BRD_RX_FRAME_FILTER_FRM_VER(base) (BME_UBFX32(&ZLL_RX_FRAME_FILTER_REG(base), ZLL_RX_FRAME_FILTER_FRM_VER_SHIFT, ZLL_RX_FRAME_FILTER_FRM_VER_WIDTH))

/*! @brief Set the FRM_VER field to a new value. */
#define ZLL_WR_RX_FRAME_FILTER_FRM_VER(base, value) (ZLL_RMW_RX_FRAME_FILTER(base, ZLL_RX_FRAME_FILTER_FRM_VER_MASK, ZLL_RX_FRAME_FILTER_FRM_VER(value)))
#define ZLL_BWR_RX_FRAME_FILTER_FRM_VER(base, value) (BME_BFI32(&ZLL_RX_FRAME_FILTER_REG(base), ((uint32_t)(value) << ZLL_RX_FRAME_FILTER_FRM_VER_SHIFT), ZLL_RX_FRAME_FILTER_FRM_VER_SHIFT, ZLL_RX_FRAME_FILTER_FRM_VER_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_CCA_LQI_CTRL - CCA AND LQI CONTROL
 ******************************************************************************/

/*!
 * @brief ZLL_CCA_LQI_CTRL - CCA AND LQI CONTROL (RW)
 *
 * Reset value: 0x0866004BU
 */
/*!
 * @name Constants and macros for entire ZLL_CCA_LQI_CTRL register
 */
/*@{*/
#define ZLL_RD_CCA_LQI_CTRL(base) (ZLL_CCA_LQI_CTRL_REG(base))
#define ZLL_WR_CCA_LQI_CTRL(base, value) (ZLL_CCA_LQI_CTRL_REG(base) = (value))
#define ZLL_RMW_CCA_LQI_CTRL(base, mask, value) (ZLL_WR_CCA_LQI_CTRL(base, (ZLL_RD_CCA_LQI_CTRL(base) & ~(mask)) | (value)))
#define ZLL_SET_CCA_LQI_CTRL(base, value) (BME_OR32(&ZLL_CCA_LQI_CTRL_REG(base), (uint32_t)(value)))
#define ZLL_CLR_CCA_LQI_CTRL(base, value) (BME_AND32(&ZLL_CCA_LQI_CTRL_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_CCA_LQI_CTRL(base, value) (BME_XOR32(&ZLL_CCA_LQI_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_CCA_LQI_CTRL bitfields
 */

/*!
 * @name Register ZLL_CCA_LQI_CTRL, field CCA1_THRESH[7:0] (RW)
 *
 * Programmable energy threshold register for CCA mode 1.
 */
/*@{*/
/*! @brief Read current value of the ZLL_CCA_LQI_CTRL_CCA1_THRESH field. */
#define ZLL_RD_CCA_LQI_CTRL_CCA1_THRESH(base) ((ZLL_CCA_LQI_CTRL_REG(base) & ZLL_CCA_LQI_CTRL_CCA1_THRESH_MASK) >> ZLL_CCA_LQI_CTRL_CCA1_THRESH_SHIFT)
#define ZLL_BRD_CCA_LQI_CTRL_CCA1_THRESH(base) (BME_UBFX32(&ZLL_CCA_LQI_CTRL_REG(base), ZLL_CCA_LQI_CTRL_CCA1_THRESH_SHIFT, ZLL_CCA_LQI_CTRL_CCA1_THRESH_WIDTH))

/*! @brief Set the CCA1_THRESH field to a new value. */
#define ZLL_WR_CCA_LQI_CTRL_CCA1_THRESH(base, value) (ZLL_RMW_CCA_LQI_CTRL(base, ZLL_CCA_LQI_CTRL_CCA1_THRESH_MASK, ZLL_CCA_LQI_CTRL_CCA1_THRESH(value)))
#define ZLL_BWR_CCA_LQI_CTRL_CCA1_THRESH(base, value) (BME_BFI32(&ZLL_CCA_LQI_CTRL_REG(base), ((uint32_t)(value) << ZLL_CCA_LQI_CTRL_CCA1_THRESH_SHIFT), ZLL_CCA_LQI_CTRL_CCA1_THRESH_SHIFT, ZLL_CCA_LQI_CTRL_CCA1_THRESH_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_CCA_LQI_CTRL, field LQI_OFFSET_COMP[23:16] (RW)
 *
 * Programmable amount to offset RSSI based LQI value
 */
/*@{*/
/*! @brief Read current value of the ZLL_CCA_LQI_CTRL_LQI_OFFSET_COMP field. */
#define ZLL_RD_CCA_LQI_CTRL_LQI_OFFSET_COMP(base) ((ZLL_CCA_LQI_CTRL_REG(base) & ZLL_CCA_LQI_CTRL_LQI_OFFSET_COMP_MASK) >> ZLL_CCA_LQI_CTRL_LQI_OFFSET_COMP_SHIFT)
#define ZLL_BRD_CCA_LQI_CTRL_LQI_OFFSET_COMP(base) (BME_UBFX32(&ZLL_CCA_LQI_CTRL_REG(base), ZLL_CCA_LQI_CTRL_LQI_OFFSET_COMP_SHIFT, ZLL_CCA_LQI_CTRL_LQI_OFFSET_COMP_WIDTH))

/*! @brief Set the LQI_OFFSET_COMP field to a new value. */
#define ZLL_WR_CCA_LQI_CTRL_LQI_OFFSET_COMP(base, value) (ZLL_RMW_CCA_LQI_CTRL(base, ZLL_CCA_LQI_CTRL_LQI_OFFSET_COMP_MASK, ZLL_CCA_LQI_CTRL_LQI_OFFSET_COMP(value)))
#define ZLL_BWR_CCA_LQI_CTRL_LQI_OFFSET_COMP(base, value) (BME_BFI32(&ZLL_CCA_LQI_CTRL_REG(base), ((uint32_t)(value) << ZLL_CCA_LQI_CTRL_LQI_OFFSET_COMP_SHIFT), ZLL_CCA_LQI_CTRL_LQI_OFFSET_COMP_SHIFT, ZLL_CCA_LQI_CTRL_LQI_OFFSET_COMP_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_CCA_LQI_CTRL, field CCA3_AND_NOT_OR[27] (RW)
 *
 * Determines the way CCA3 is required to be detected
 *
 * Values:
 * - 0b0 - CCA1 or CCA2
 * - 0b1 - CCA1 and CCA2
 */
/*@{*/
/*! @brief Read current value of the ZLL_CCA_LQI_CTRL_CCA3_AND_NOT_OR field. */
#define ZLL_RD_CCA_LQI_CTRL_CCA3_AND_NOT_OR(base) ((ZLL_CCA_LQI_CTRL_REG(base) & ZLL_CCA_LQI_CTRL_CCA3_AND_NOT_OR_MASK) >> ZLL_CCA_LQI_CTRL_CCA3_AND_NOT_OR_SHIFT)
#define ZLL_BRD_CCA_LQI_CTRL_CCA3_AND_NOT_OR(base) (BME_UBFX32(&ZLL_CCA_LQI_CTRL_REG(base), ZLL_CCA_LQI_CTRL_CCA3_AND_NOT_OR_SHIFT, ZLL_CCA_LQI_CTRL_CCA3_AND_NOT_OR_WIDTH))

/*! @brief Set the CCA3_AND_NOT_OR field to a new value. */
#define ZLL_WR_CCA_LQI_CTRL_CCA3_AND_NOT_OR(base, value) (ZLL_RMW_CCA_LQI_CTRL(base, ZLL_CCA_LQI_CTRL_CCA3_AND_NOT_OR_MASK, ZLL_CCA_LQI_CTRL_CCA3_AND_NOT_OR(value)))
#define ZLL_BWR_CCA_LQI_CTRL_CCA3_AND_NOT_OR(base, value) (BME_BFI32(&ZLL_CCA_LQI_CTRL_REG(base), ((uint32_t)(value) << ZLL_CCA_LQI_CTRL_CCA3_AND_NOT_OR_SHIFT), ZLL_CCA_LQI_CTRL_CCA3_AND_NOT_OR_SHIFT, ZLL_CCA_LQI_CTRL_CCA3_AND_NOT_OR_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_CCA2_CTRL - CCA2 CONTROL
 ******************************************************************************/

/*!
 * @brief ZLL_CCA2_CTRL - CCA2 CONTROL (RW)
 *
 * Reset value: 0x00008230U
 *
 * CCA Mode 2 Control Register
 */
/*!
 * @name Constants and macros for entire ZLL_CCA2_CTRL register
 */
/*@{*/
#define ZLL_RD_CCA2_CTRL(base)   (ZLL_CCA2_CTRL_REG(base))
#define ZLL_WR_CCA2_CTRL(base, value) (ZLL_CCA2_CTRL_REG(base) = (value))
#define ZLL_RMW_CCA2_CTRL(base, mask, value) (ZLL_WR_CCA2_CTRL(base, (ZLL_RD_CCA2_CTRL(base) & ~(mask)) | (value)))
#define ZLL_SET_CCA2_CTRL(base, value) (BME_OR32(&ZLL_CCA2_CTRL_REG(base), (uint32_t)(value)))
#define ZLL_CLR_CCA2_CTRL(base, value) (BME_AND32(&ZLL_CCA2_CTRL_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_CCA2_CTRL(base, value) (BME_XOR32(&ZLL_CCA2_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_CCA2_CTRL bitfields
 */

/*!
 * @name Register ZLL_CCA2_CTRL, field CCA2_NUM_CORR_PEAKS[3:0] (RO)
 *
 * Counts of number of peaks that crossed cca2_corr_thresh in CCA Mode 2
 * operation
 */
/*@{*/
/*! @brief Read current value of the ZLL_CCA2_CTRL_CCA2_NUM_CORR_PEAKS field. */
#define ZLL_RD_CCA2_CTRL_CCA2_NUM_CORR_PEAKS(base) ((ZLL_CCA2_CTRL_REG(base) & ZLL_CCA2_CTRL_CCA2_NUM_CORR_PEAKS_MASK) >> ZLL_CCA2_CTRL_CCA2_NUM_CORR_PEAKS_SHIFT)
#define ZLL_BRD_CCA2_CTRL_CCA2_NUM_CORR_PEAKS(base) (BME_UBFX32(&ZLL_CCA2_CTRL_REG(base), ZLL_CCA2_CTRL_CCA2_NUM_CORR_PEAKS_SHIFT, ZLL_CCA2_CTRL_CCA2_NUM_CORR_PEAKS_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_CCA2_CTRL, field CCA2_MIN_NUM_CORR_TH[6:4] (RW)
 *
 * Programmable threshold to be compared against number of correlation peaks
 * that exceeded cca2_corr_thresh for detecting CCA mode 2. Number of peaks detected
 * = cca2_min_num_corr_th + 1; Example: If it is programmed to 3, CCA2 logic
 * looks for at least 4 correlation peaks that crossed the threshold, to indicate
 * channel is idle or busy.
 */
/*@{*/
/*! @brief Read current value of the ZLL_CCA2_CTRL_CCA2_MIN_NUM_CORR_TH field. */
#define ZLL_RD_CCA2_CTRL_CCA2_MIN_NUM_CORR_TH(base) ((ZLL_CCA2_CTRL_REG(base) & ZLL_CCA2_CTRL_CCA2_MIN_NUM_CORR_TH_MASK) >> ZLL_CCA2_CTRL_CCA2_MIN_NUM_CORR_TH_SHIFT)
#define ZLL_BRD_CCA2_CTRL_CCA2_MIN_NUM_CORR_TH(base) (BME_UBFX32(&ZLL_CCA2_CTRL_REG(base), ZLL_CCA2_CTRL_CCA2_MIN_NUM_CORR_TH_SHIFT, ZLL_CCA2_CTRL_CCA2_MIN_NUM_CORR_TH_WIDTH))

/*! @brief Set the CCA2_MIN_NUM_CORR_TH field to a new value. */
#define ZLL_WR_CCA2_CTRL_CCA2_MIN_NUM_CORR_TH(base, value) (ZLL_RMW_CCA2_CTRL(base, ZLL_CCA2_CTRL_CCA2_MIN_NUM_CORR_TH_MASK, ZLL_CCA2_CTRL_CCA2_MIN_NUM_CORR_TH(value)))
#define ZLL_BWR_CCA2_CTRL_CCA2_MIN_NUM_CORR_TH(base, value) (BME_BFI32(&ZLL_CCA2_CTRL_REG(base), ((uint32_t)(value) << ZLL_CCA2_CTRL_CCA2_MIN_NUM_CORR_TH_SHIFT), ZLL_CCA2_CTRL_CCA2_MIN_NUM_CORR_TH_SHIFT, ZLL_CCA2_CTRL_CCA2_MIN_NUM_CORR_TH_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_CCA2_CTRL, field CCA2_CORR_THRESH[15:8] (RW)
 *
 * Programmable threshold to be compared against number of correlation peaks
 * that exceeded cca2_corr_thresh for detecting CCA mode 2. Number of peaks detected
 * = cca2_min_num_corr_th + 1; Example: If it is programmed to 3, CCA2 logic
 * looks for at least 4 correlation peaks that crossed the threshold, to indicate
 * channel is idle or busy.
 */
/*@{*/
/*! @brief Read current value of the ZLL_CCA2_CTRL_CCA2_CORR_THRESH field. */
#define ZLL_RD_CCA2_CTRL_CCA2_CORR_THRESH(base) ((ZLL_CCA2_CTRL_REG(base) & ZLL_CCA2_CTRL_CCA2_CORR_THRESH_MASK) >> ZLL_CCA2_CTRL_CCA2_CORR_THRESH_SHIFT)
#define ZLL_BRD_CCA2_CTRL_CCA2_CORR_THRESH(base) (BME_UBFX32(&ZLL_CCA2_CTRL_REG(base), ZLL_CCA2_CTRL_CCA2_CORR_THRESH_SHIFT, ZLL_CCA2_CTRL_CCA2_CORR_THRESH_WIDTH))

/*! @brief Set the CCA2_CORR_THRESH field to a new value. */
#define ZLL_WR_CCA2_CTRL_CCA2_CORR_THRESH(base, value) (ZLL_RMW_CCA2_CTRL(base, ZLL_CCA2_CTRL_CCA2_CORR_THRESH_MASK, ZLL_CCA2_CTRL_CCA2_CORR_THRESH(value)))
#define ZLL_BWR_CCA2_CTRL_CCA2_CORR_THRESH(base, value) (BME_BFI32(&ZLL_CCA2_CTRL_REG(base), ((uint32_t)(value) << ZLL_CCA2_CTRL_CCA2_CORR_THRESH_SHIFT), ZLL_CCA2_CTRL_CCA2_CORR_THRESH_SHIFT, ZLL_CCA2_CTRL_CCA2_CORR_THRESH_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_FAD_CTRL - FAD CONTROL
 ******************************************************************************/

/*!
 * @brief ZLL_FAD_CTRL - FAD CONTROL (RW)
 *
 * Reset value: 0x00000804U
 *
 * Fast Antenna Diversity Control Register
 */
/*!
 * @name Constants and macros for entire ZLL_FAD_CTRL register
 */
/*@{*/
#define ZLL_RD_FAD_CTRL(base)    (ZLL_FAD_CTRL_REG(base))
#define ZLL_WR_FAD_CTRL(base, value) (ZLL_FAD_CTRL_REG(base) = (value))
#define ZLL_RMW_FAD_CTRL(base, mask, value) (ZLL_WR_FAD_CTRL(base, (ZLL_RD_FAD_CTRL(base) & ~(mask)) | (value)))
#define ZLL_SET_FAD_CTRL(base, value) (BME_OR32(&ZLL_FAD_CTRL_REG(base), (uint32_t)(value)))
#define ZLL_CLR_FAD_CTRL(base, value) (BME_AND32(&ZLL_FAD_CTRL_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_FAD_CTRL(base, value) (BME_XOR32(&ZLL_FAD_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_FAD_CTRL bitfields
 */

/*!
 * @name Register ZLL_FAD_CTRL, field FAD_EN[0] (RW)
 *
 * Enable Fast Antenna Diversity for Zigbee
 */
/*@{*/
/*! @brief Read current value of the ZLL_FAD_CTRL_FAD_EN field. */
#define ZLL_RD_FAD_CTRL_FAD_EN(base) ((ZLL_FAD_CTRL_REG(base) & ZLL_FAD_CTRL_FAD_EN_MASK) >> ZLL_FAD_CTRL_FAD_EN_SHIFT)
#define ZLL_BRD_FAD_CTRL_FAD_EN(base) (BME_UBFX32(&ZLL_FAD_CTRL_REG(base), ZLL_FAD_CTRL_FAD_EN_SHIFT, ZLL_FAD_CTRL_FAD_EN_WIDTH))

/*! @brief Set the FAD_EN field to a new value. */
#define ZLL_WR_FAD_CTRL_FAD_EN(base, value) (ZLL_RMW_FAD_CTRL(base, ZLL_FAD_CTRL_FAD_EN_MASK, ZLL_FAD_CTRL_FAD_EN(value)))
#define ZLL_BWR_FAD_CTRL_FAD_EN(base, value) (BME_BFI32(&ZLL_FAD_CTRL_REG(base), ((uint32_t)(value) << ZLL_FAD_CTRL_FAD_EN_SHIFT), ZLL_FAD_CTRL_FAD_EN_SHIFT, ZLL_FAD_CTRL_FAD_EN_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_FAD_CTRL, field ANTX[1] (RW)
 *
 * If FAD_EN=0, the ANTX bit is used to take manual (software) control of the
 * antenna selection, overriding the FAD state machine; in this case, the readback
 * value of ANTX is whatever was last written by the host. If FAD_EN=1, the FAD
 * state machine controls antenna selection, and the readback value of ANTX
 * reflects the machine-selected antenna.
 */
/*@{*/
/*! @brief Read current value of the ZLL_FAD_CTRL_ANTX field. */
#define ZLL_RD_FAD_CTRL_ANTX(base) ((ZLL_FAD_CTRL_REG(base) & ZLL_FAD_CTRL_ANTX_MASK) >> ZLL_FAD_CTRL_ANTX_SHIFT)
#define ZLL_BRD_FAD_CTRL_ANTX(base) (BME_UBFX32(&ZLL_FAD_CTRL_REG(base), ZLL_FAD_CTRL_ANTX_SHIFT, ZLL_FAD_CTRL_ANTX_WIDTH))

/*! @brief Set the ANTX field to a new value. */
#define ZLL_WR_FAD_CTRL_ANTX(base, value) (ZLL_RMW_FAD_CTRL(base, ZLL_FAD_CTRL_ANTX_MASK, ZLL_FAD_CTRL_ANTX(value)))
#define ZLL_BWR_FAD_CTRL_ANTX(base, value) (BME_BFI32(&ZLL_FAD_CTRL_REG(base), ((uint32_t)(value) << ZLL_FAD_CTRL_ANTX_SHIFT), ZLL_FAD_CTRL_ANTX_SHIFT, ZLL_FAD_CTRL_ANTX_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_FAD_CTRL, field FAD_NOT_GPIO[2] (RW)
 *
 * This bit FAD_NOT_GPIO determines whether the 4 FAD-related pads function in
 * FAD mode or in TSM/GPIO mode. The 4 FAD-related pads are: ANT_A, ANT_B,
 * TX_SWITCH, and RX_SWITCH. If FAD_NOT_GPIO=1, these pads assume their Zigbee FAD
 * functionality If FAD_NOT_GPIO=0, these pads are assigned as TSM GPIO outputs, as
 * shown: ANT_A -> GPIO0_TRIG_EN ANT_B -> GPIO1_TRIG_EN TX_SWITCH -> GPIO2_TRIG_EN
 * RX_SWITCH -> GPIO3_TRIG_EN To use these pads in TSM GPIO mode, the TSM timing
 * registers associated with GPIO0-3 should be programmed with the desired
 * timings.
 */
/*@{*/
/*! @brief Read current value of the ZLL_FAD_CTRL_FAD_NOT_GPIO field. */
#define ZLL_RD_FAD_CTRL_FAD_NOT_GPIO(base) ((ZLL_FAD_CTRL_REG(base) & ZLL_FAD_CTRL_FAD_NOT_GPIO_MASK) >> ZLL_FAD_CTRL_FAD_NOT_GPIO_SHIFT)
#define ZLL_BRD_FAD_CTRL_FAD_NOT_GPIO(base) (BME_UBFX32(&ZLL_FAD_CTRL_REG(base), ZLL_FAD_CTRL_FAD_NOT_GPIO_SHIFT, ZLL_FAD_CTRL_FAD_NOT_GPIO_WIDTH))

/*! @brief Set the FAD_NOT_GPIO field to a new value. */
#define ZLL_WR_FAD_CTRL_FAD_NOT_GPIO(base, value) (ZLL_RMW_FAD_CTRL(base, ZLL_FAD_CTRL_FAD_NOT_GPIO_MASK, ZLL_FAD_CTRL_FAD_NOT_GPIO(value)))
#define ZLL_BWR_FAD_CTRL_FAD_NOT_GPIO(base, value) (BME_BFI32(&ZLL_FAD_CTRL_REG(base), ((uint32_t)(value) << ZLL_FAD_CTRL_FAD_NOT_GPIO_SHIFT), ZLL_FAD_CTRL_FAD_NOT_GPIO_SHIFT, ZLL_FAD_CTRL_FAD_NOT_GPIO_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_FAD_CTRL, field ANTX_EN[9:8] (RW)
 *
 * When FAD_NOT_GPIO=1, ANTX_EN[1:0] determines which pairs of FAD related
 * outputs are enabled:
 *
 * Values:
 * - 0b00 - all disabled (held low)
 * - 0b01 - only RX/TX_SWITCH enabled
 * - 0b10 - only ANT_A/B enabled
 * - 0b11 - all enabled
 */
/*@{*/
/*! @brief Read current value of the ZLL_FAD_CTRL_ANTX_EN field. */
#define ZLL_RD_FAD_CTRL_ANTX_EN(base) ((ZLL_FAD_CTRL_REG(base) & ZLL_FAD_CTRL_ANTX_EN_MASK) >> ZLL_FAD_CTRL_ANTX_EN_SHIFT)
#define ZLL_BRD_FAD_CTRL_ANTX_EN(base) (BME_UBFX32(&ZLL_FAD_CTRL_REG(base), ZLL_FAD_CTRL_ANTX_EN_SHIFT, ZLL_FAD_CTRL_ANTX_EN_WIDTH))

/*! @brief Set the ANTX_EN field to a new value. */
#define ZLL_WR_FAD_CTRL_ANTX_EN(base, value) (ZLL_RMW_FAD_CTRL(base, ZLL_FAD_CTRL_ANTX_EN_MASK, ZLL_FAD_CTRL_ANTX_EN(value)))
#define ZLL_BWR_FAD_CTRL_ANTX_EN(base, value) (BME_BFI32(&ZLL_FAD_CTRL_REG(base), ((uint32_t)(value) << ZLL_FAD_CTRL_ANTX_EN_SHIFT), ZLL_FAD_CTRL_ANTX_EN_SHIFT, ZLL_FAD_CTRL_ANTX_EN_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_FAD_CTRL, field ANTX_HZ[10] (RW)
 *
 * Values:
 * - 0b0 - ANT_A, ANT_B, RX_SWITCH and TX_SWITCH are actively driven outputs.
 * - 0b1 - Antenna controls high impedance- Set ANT_A, ANT_B, RX_SWITCH and
 *     TX_SWITCH in high impedance.
 */
/*@{*/
/*! @brief Read current value of the ZLL_FAD_CTRL_ANTX_HZ field. */
#define ZLL_RD_FAD_CTRL_ANTX_HZ(base) ((ZLL_FAD_CTRL_REG(base) & ZLL_FAD_CTRL_ANTX_HZ_MASK) >> ZLL_FAD_CTRL_ANTX_HZ_SHIFT)
#define ZLL_BRD_FAD_CTRL_ANTX_HZ(base) (BME_UBFX32(&ZLL_FAD_CTRL_REG(base), ZLL_FAD_CTRL_ANTX_HZ_SHIFT, ZLL_FAD_CTRL_ANTX_HZ_WIDTH))

/*! @brief Set the ANTX_HZ field to a new value. */
#define ZLL_WR_FAD_CTRL_ANTX_HZ(base, value) (ZLL_RMW_FAD_CTRL(base, ZLL_FAD_CTRL_ANTX_HZ_MASK, ZLL_FAD_CTRL_ANTX_HZ(value)))
#define ZLL_BWR_FAD_CTRL_ANTX_HZ(base, value) (BME_BFI32(&ZLL_FAD_CTRL_REG(base), ((uint32_t)(value) << ZLL_FAD_CTRL_ANTX_HZ_SHIFT), ZLL_FAD_CTRL_ANTX_HZ_SHIFT, ZLL_FAD_CTRL_ANTX_HZ_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_FAD_CTRL, field ANTX_CTRLMODE[11] (RW)
 *
 * When ANTX_CTRLMODE=1 (dual mode): ANT_A=NOT(ANTX) AND (GPIO3_TRIG_EN OR
 * GPIO2_TRIG_EN) ANT_B=ANTX AND (GPIO3_TRIG_EN OR GPIO2_TRIG_EN)
 * TX_SWITCH=GPIO2_TRIG_EN RX_SWITCH=GPIO3_TRIG_EN When ANTX_CTRLMODE=0 (single mode):
 * ANT_A=NOT(ANTX) AND (GPIO3_TRIG_EN OR GPIO2_TRIG_EN) ANT_B=ANTX AND (GPIO3_TRIG_EN OR
 * GPIO2_TRIG_EN) TX_SWITCH=GPIO2_TRIG_EN RX_SWITCH=(GPIO3_TRIG_EN OR GPIO2_TRIG_EN)
 * GPIO2_TRIG_EN and GPIO3_TRIG_EN are outputs of the Transceiver Sequence Manager
 * (TSM). The TSM timing registers associated with GPIO2_TRIG_EN and
 * GPIO3_TRIG_EN should be programmed with the desired TX_SWITCH and RX_SWITCH timing, before
 * enabling Fast Antenna Diversity.
 */
/*@{*/
/*! @brief Read current value of the ZLL_FAD_CTRL_ANTX_CTRLMODE field. */
#define ZLL_RD_FAD_CTRL_ANTX_CTRLMODE(base) ((ZLL_FAD_CTRL_REG(base) & ZLL_FAD_CTRL_ANTX_CTRLMODE_MASK) >> ZLL_FAD_CTRL_ANTX_CTRLMODE_SHIFT)
#define ZLL_BRD_FAD_CTRL_ANTX_CTRLMODE(base) (BME_UBFX32(&ZLL_FAD_CTRL_REG(base), ZLL_FAD_CTRL_ANTX_CTRLMODE_SHIFT, ZLL_FAD_CTRL_ANTX_CTRLMODE_WIDTH))

/*! @brief Set the ANTX_CTRLMODE field to a new value. */
#define ZLL_WR_FAD_CTRL_ANTX_CTRLMODE(base, value) (ZLL_RMW_FAD_CTRL(base, ZLL_FAD_CTRL_ANTX_CTRLMODE_MASK, ZLL_FAD_CTRL_ANTX_CTRLMODE(value)))
#define ZLL_BWR_FAD_CTRL_ANTX_CTRLMODE(base, value) (BME_BFI32(&ZLL_FAD_CTRL_REG(base), ((uint32_t)(value) << ZLL_FAD_CTRL_ANTX_CTRLMODE_SHIFT), ZLL_FAD_CTRL_ANTX_CTRLMODE_SHIFT, ZLL_FAD_CTRL_ANTX_CTRLMODE_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_FAD_CTRL, field ANTX_POL[15:12] (RW)
 *
 * Control the polarity of the Antenna or Switch control pins: ANTX_POL[0]=0 :
 * don't invert the ANT_A output ANTX_POL[1]=0 : don't invert the ANT_B output
 * ANTX_POL[2]=0 : don't invert the TX_SWITCH output ANTX_POL[3]=0 : don't invert
 * the RX_SWITCH output ANTX_POL[0]=1 : invert the ANT_A output ANTX_POL[1]=1 :
 * invert the ANT_B output ANTX_POL[2]=1 : invert the TX_SWITCH output ANTX_POL[3]=1
 * : invert the RX_SWITCH output
 */
/*@{*/
/*! @brief Read current value of the ZLL_FAD_CTRL_ANTX_POL field. */
#define ZLL_RD_FAD_CTRL_ANTX_POL(base) ((ZLL_FAD_CTRL_REG(base) & ZLL_FAD_CTRL_ANTX_POL_MASK) >> ZLL_FAD_CTRL_ANTX_POL_SHIFT)
#define ZLL_BRD_FAD_CTRL_ANTX_POL(base) (BME_UBFX32(&ZLL_FAD_CTRL_REG(base), ZLL_FAD_CTRL_ANTX_POL_SHIFT, ZLL_FAD_CTRL_ANTX_POL_WIDTH))

/*! @brief Set the ANTX_POL field to a new value. */
#define ZLL_WR_FAD_CTRL_ANTX_POL(base, value) (ZLL_RMW_FAD_CTRL(base, ZLL_FAD_CTRL_ANTX_POL_MASK, ZLL_FAD_CTRL_ANTX_POL(value)))
#define ZLL_BWR_FAD_CTRL_ANTX_POL(base, value) (BME_BFI32(&ZLL_FAD_CTRL_REG(base), ((uint32_t)(value) << ZLL_FAD_CTRL_ANTX_POL_SHIFT), ZLL_FAD_CTRL_ANTX_POL_SHIFT, ZLL_FAD_CTRL_ANTX_POL_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_SNF_CTRL - SNF CONTROL
 ******************************************************************************/

/*!
 * @brief ZLL_SNF_CTRL - SNF CONTROL (RW)
 *
 * Reset value: 0x00000000U
 *
 * SNIFF Mode Control Register
 */
/*!
 * @name Constants and macros for entire ZLL_SNF_CTRL register
 */
/*@{*/
#define ZLL_RD_SNF_CTRL(base)    (ZLL_SNF_CTRL_REG(base))
#define ZLL_WR_SNF_CTRL(base, value) (ZLL_SNF_CTRL_REG(base) = (value))
#define ZLL_RMW_SNF_CTRL(base, mask, value) (ZLL_WR_SNF_CTRL(base, (ZLL_RD_SNF_CTRL(base) & ~(mask)) | (value)))
#define ZLL_SET_SNF_CTRL(base, value) (BME_OR32(&ZLL_SNF_CTRL_REG(base), (uint32_t)(value)))
#define ZLL_CLR_SNF_CTRL(base, value) (BME_AND32(&ZLL_SNF_CTRL_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_SNF_CTRL(base, value) (BME_XOR32(&ZLL_SNF_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_SNF_CTRL bitfields
 */

/*!
 * @name Register ZLL_SNF_CTRL, field SNF_EN[0] (RW)
 *
 * SNIFF Mode Enable. Note: SNIFF Mode not currently supported. SNF_EN has no
 * effect
 */
/*@{*/
/*! @brief Read current value of the ZLL_SNF_CTRL_SNF_EN field. */
#define ZLL_RD_SNF_CTRL_SNF_EN(base) ((ZLL_SNF_CTRL_REG(base) & ZLL_SNF_CTRL_SNF_EN_MASK) >> ZLL_SNF_CTRL_SNF_EN_SHIFT)
#define ZLL_BRD_SNF_CTRL_SNF_EN(base) (BME_UBFX32(&ZLL_SNF_CTRL_REG(base), ZLL_SNF_CTRL_SNF_EN_SHIFT, ZLL_SNF_CTRL_SNF_EN_WIDTH))

/*! @brief Set the SNF_EN field to a new value. */
#define ZLL_WR_SNF_CTRL_SNF_EN(base, value) (ZLL_RMW_SNF_CTRL(base, ZLL_SNF_CTRL_SNF_EN_MASK, ZLL_SNF_CTRL_SNF_EN(value)))
#define ZLL_BWR_SNF_CTRL_SNF_EN(base, value) (BME_BFI32(&ZLL_SNF_CTRL_REG(base), ((uint32_t)(value) << ZLL_SNF_CTRL_SNF_EN_SHIFT), ZLL_SNF_CTRL_SNF_EN_SHIFT, ZLL_SNF_CTRL_SNF_EN_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_BSM_CTRL - BSM CONTROL
 ******************************************************************************/

/*!
 * @brief ZLL_BSM_CTRL - BSM CONTROL (RW)
 *
 * Reset value: 0x00000000U
 *
 * Bit Streaming Mode Control Register
 */
/*!
 * @name Constants and macros for entire ZLL_BSM_CTRL register
 */
/*@{*/
#define ZLL_RD_BSM_CTRL(base)    (ZLL_BSM_CTRL_REG(base))
#define ZLL_WR_BSM_CTRL(base, value) (ZLL_BSM_CTRL_REG(base) = (value))
#define ZLL_RMW_BSM_CTRL(base, mask, value) (ZLL_WR_BSM_CTRL(base, (ZLL_RD_BSM_CTRL(base) & ~(mask)) | (value)))
#define ZLL_SET_BSM_CTRL(base, value) (BME_OR32(&ZLL_BSM_CTRL_REG(base), (uint32_t)(value)))
#define ZLL_CLR_BSM_CTRL(base, value) (BME_AND32(&ZLL_BSM_CTRL_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_BSM_CTRL(base, value) (BME_XOR32(&ZLL_BSM_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_BSM_CTRL bitfields
 */

/*!
 * @name Register ZLL_BSM_CTRL, field BSM_EN[0] (RW)
 *
 * Values:
 * - 0b0 - Zigbee Bit Streaming Mode Disabled
 * - 0b1 - Zigbee Bit Streaming Mode Enabled
 */
/*@{*/
/*! @brief Read current value of the ZLL_BSM_CTRL_BSM_EN field. */
#define ZLL_RD_BSM_CTRL_BSM_EN(base) ((ZLL_BSM_CTRL_REG(base) & ZLL_BSM_CTRL_BSM_EN_MASK) >> ZLL_BSM_CTRL_BSM_EN_SHIFT)
#define ZLL_BRD_BSM_CTRL_BSM_EN(base) (BME_UBFX32(&ZLL_BSM_CTRL_REG(base), ZLL_BSM_CTRL_BSM_EN_SHIFT, ZLL_BSM_CTRL_BSM_EN_WIDTH))

/*! @brief Set the BSM_EN field to a new value. */
#define ZLL_WR_BSM_CTRL_BSM_EN(base, value) (ZLL_RMW_BSM_CTRL(base, ZLL_BSM_CTRL_BSM_EN_MASK, ZLL_BSM_CTRL_BSM_EN(value)))
#define ZLL_BWR_BSM_CTRL_BSM_EN(base, value) (BME_BFI32(&ZLL_BSM_CTRL_REG(base), ((uint32_t)(value) << ZLL_BSM_CTRL_BSM_EN_SHIFT), ZLL_BSM_CTRL_BSM_EN_SHIFT, ZLL_BSM_CTRL_BSM_EN_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_MACSHORTADDRS1 - MAC SHORT ADDRESS 1
 ******************************************************************************/

/*!
 * @brief ZLL_MACSHORTADDRS1 - MAC SHORT ADDRESS 1 (RW)
 *
 * Reset value: 0xFFFFFFFFU
 */
/*!
 * @name Constants and macros for entire ZLL_MACSHORTADDRS1 register
 */
/*@{*/
#define ZLL_RD_MACSHORTADDRS1(base) (ZLL_MACSHORTADDRS1_REG(base))
#define ZLL_WR_MACSHORTADDRS1(base, value) (ZLL_MACSHORTADDRS1_REG(base) = (value))
#define ZLL_RMW_MACSHORTADDRS1(base, mask, value) (ZLL_WR_MACSHORTADDRS1(base, (ZLL_RD_MACSHORTADDRS1(base) & ~(mask)) | (value)))
#define ZLL_SET_MACSHORTADDRS1(base, value) (BME_OR32(&ZLL_MACSHORTADDRS1_REG(base), (uint32_t)(value)))
#define ZLL_CLR_MACSHORTADDRS1(base, value) (BME_AND32(&ZLL_MACSHORTADDRS1_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_MACSHORTADDRS1(base, value) (BME_XOR32(&ZLL_MACSHORTADDRS1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_MACSHORTADDRS1 bitfields
 */

/*!
 * @name Register ZLL_MACSHORTADDRS1, field MACPANID1[15:0] (RW)
 *
 * MAC PAN ID for PAN1. The packet processor compares the incoming packet's
 * Destination PAN ID against the contents of this register to determine if the
 * packet is addressed to this device; or if the incoming packet is a Beacon frame,
 * the packet processor compares the incoming packet Source PAN ID against this
 * register. Also, if PANCORDNTR1=1, and the incoming packet has no Destination
 * Address field, and if the incoming packet is a Data or MAC Command frame, the
 * packet processor compares the incoming packet Source PAN ID against this register.
 */
/*@{*/
/*! @brief Read current value of the ZLL_MACSHORTADDRS1_MACPANID1 field. */
#define ZLL_RD_MACSHORTADDRS1_MACPANID1(base) ((ZLL_MACSHORTADDRS1_REG(base) & ZLL_MACSHORTADDRS1_MACPANID1_MASK) >> ZLL_MACSHORTADDRS1_MACPANID1_SHIFT)
#define ZLL_BRD_MACSHORTADDRS1_MACPANID1(base) (BME_UBFX32(&ZLL_MACSHORTADDRS1_REG(base), ZLL_MACSHORTADDRS1_MACPANID1_SHIFT, ZLL_MACSHORTADDRS1_MACPANID1_WIDTH))

/*! @brief Set the MACPANID1 field to a new value. */
#define ZLL_WR_MACSHORTADDRS1_MACPANID1(base, value) (ZLL_RMW_MACSHORTADDRS1(base, ZLL_MACSHORTADDRS1_MACPANID1_MASK, ZLL_MACSHORTADDRS1_MACPANID1(value)))
#define ZLL_BWR_MACSHORTADDRS1_MACPANID1(base, value) (BME_BFI32(&ZLL_MACSHORTADDRS1_REG(base), ((uint32_t)(value) << ZLL_MACSHORTADDRS1_MACPANID1_SHIFT), ZLL_MACSHORTADDRS1_MACPANID1_SHIFT, ZLL_MACSHORTADDRS1_MACPANID1_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_MACSHORTADDRS1, field MACSHORTADDRS1[31:16] (RW)
 *
 * MAC Short Address for PAN1, for 16-bit destination addressing mode. The
 * packet processor compares the incoming packet's Destination Address against the
 * contents of this register to determine if the packet is addressed to this device.
 */
/*@{*/
/*! @brief Read current value of the ZLL_MACSHORTADDRS1_MACSHORTADDRS1 field. */
#define ZLL_RD_MACSHORTADDRS1_MACSHORTADDRS1(base) ((ZLL_MACSHORTADDRS1_REG(base) & ZLL_MACSHORTADDRS1_MACSHORTADDRS1_MASK) >> ZLL_MACSHORTADDRS1_MACSHORTADDRS1_SHIFT)
#define ZLL_BRD_MACSHORTADDRS1_MACSHORTADDRS1(base) (BME_UBFX32(&ZLL_MACSHORTADDRS1_REG(base), ZLL_MACSHORTADDRS1_MACSHORTADDRS1_SHIFT, ZLL_MACSHORTADDRS1_MACSHORTADDRS1_WIDTH))

/*! @brief Set the MACSHORTADDRS1 field to a new value. */
#define ZLL_WR_MACSHORTADDRS1_MACSHORTADDRS1(base, value) (ZLL_RMW_MACSHORTADDRS1(base, ZLL_MACSHORTADDRS1_MACSHORTADDRS1_MASK, ZLL_MACSHORTADDRS1_MACSHORTADDRS1(value)))
#define ZLL_BWR_MACSHORTADDRS1_MACSHORTADDRS1(base, value) (BME_BFI32(&ZLL_MACSHORTADDRS1_REG(base), ((uint32_t)(value) << ZLL_MACSHORTADDRS1_MACSHORTADDRS1_SHIFT), ZLL_MACSHORTADDRS1_MACSHORTADDRS1_SHIFT, ZLL_MACSHORTADDRS1_MACSHORTADDRS1_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_MACLONGADDRS1_LSB - MAC LONG ADDRESS 1 LSB
 ******************************************************************************/

/*!
 * @brief ZLL_MACLONGADDRS1_LSB - MAC LONG ADDRESS 1 LSB (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * MAC Long Address for PAN1, for 64-bit destination addressing mode. The packet
 * processor compares the incoming packet's Destination Address against the
 * contents of this register to determine if the packet is addressed to this device.
 */
/*!
 * @name Constants and macros for entire ZLL_MACLONGADDRS1_LSB register
 */
/*@{*/
#define ZLL_RD_MACLONGADDRS1_LSB(base) (ZLL_MACLONGADDRS1_LSB_REG(base))
#define ZLL_WR_MACLONGADDRS1_LSB(base, value) (ZLL_MACLONGADDRS1_LSB_REG(base) = (value))
#define ZLL_RMW_MACLONGADDRS1_LSB(base, mask, value) (ZLL_WR_MACLONGADDRS1_LSB(base, (ZLL_RD_MACLONGADDRS1_LSB(base) & ~(mask)) | (value)))
#define ZLL_SET_MACLONGADDRS1_LSB(base, value) (BME_OR32(&ZLL_MACLONGADDRS1_LSB_REG(base), (uint32_t)(value)))
#define ZLL_CLR_MACLONGADDRS1_LSB(base, value) (BME_AND32(&ZLL_MACLONGADDRS1_LSB_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_MACLONGADDRS1_LSB(base, value) (BME_XOR32(&ZLL_MACLONGADDRS1_LSB_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * ZLL_MACLONGADDRS1_MSB - MAC LONG ADDRESS 1 MSB
 ******************************************************************************/

/*!
 * @brief ZLL_MACLONGADDRS1_MSB - MAC LONG ADDRESS 1 MSB (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * MAC Long Address for PAN1, for 64-bit destination addressing mode. The packet
 * processor compares the incoming packet's Destination Address against the
 * contents of this register to determine if the packet is addressed to this device.
 */
/*!
 * @name Constants and macros for entire ZLL_MACLONGADDRS1_MSB register
 */
/*@{*/
#define ZLL_RD_MACLONGADDRS1_MSB(base) (ZLL_MACLONGADDRS1_MSB_REG(base))
#define ZLL_WR_MACLONGADDRS1_MSB(base, value) (ZLL_MACLONGADDRS1_MSB_REG(base) = (value))
#define ZLL_RMW_MACLONGADDRS1_MSB(base, mask, value) (ZLL_WR_MACLONGADDRS1_MSB(base, (ZLL_RD_MACLONGADDRS1_MSB(base) & ~(mask)) | (value)))
#define ZLL_SET_MACLONGADDRS1_MSB(base, value) (BME_OR32(&ZLL_MACLONGADDRS1_MSB_REG(base), (uint32_t)(value)))
#define ZLL_CLR_MACLONGADDRS1_MSB(base, value) (BME_AND32(&ZLL_MACLONGADDRS1_MSB_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_MACLONGADDRS1_MSB(base, value) (BME_XOR32(&ZLL_MACLONGADDRS1_MSB_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * ZLL_DUAL_PAN_CTRL - DUAL PAN CONTROL
 ******************************************************************************/

/*!
 * @brief ZLL_DUAL_PAN_CTRL - DUAL PAN CONTROL (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ZLL_DUAL_PAN_CTRL register
 */
/*@{*/
#define ZLL_RD_DUAL_PAN_CTRL(base) (ZLL_DUAL_PAN_CTRL_REG(base))
#define ZLL_WR_DUAL_PAN_CTRL(base, value) (ZLL_DUAL_PAN_CTRL_REG(base) = (value))
#define ZLL_RMW_DUAL_PAN_CTRL(base, mask, value) (ZLL_WR_DUAL_PAN_CTRL(base, (ZLL_RD_DUAL_PAN_CTRL(base) & ~(mask)) | (value)))
#define ZLL_SET_DUAL_PAN_CTRL(base, value) (BME_OR32(&ZLL_DUAL_PAN_CTRL_REG(base), (uint32_t)(value)))
#define ZLL_CLR_DUAL_PAN_CTRL(base, value) (BME_AND32(&ZLL_DUAL_PAN_CTRL_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_DUAL_PAN_CTRL(base, value) (BME_XOR32(&ZLL_DUAL_PAN_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_DUAL_PAN_CTRL bitfields
 */

/*!
 * @name Register ZLL_DUAL_PAN_CTRL, field ACTIVE_NETWORK[0] (RW)
 *
 * Selects the PAN on which to transceive, by activating a PAN parameter set
 * (PAN0 or PAN1). In Manual Dual PAN mode (or Single PAN mode), this bit selects
 * the active PAN parameter set (channel and addressing parameters) which governs
 * all autosequences. In Auto Dual PAN mode, this bit selects the PAN on which to
 * begin transceiving, latched at the point at which DUAL_PAN_DWELL register is
 * written.
 *
 * Values:
 * - 0b0 - Select PAN0
 * - 0b1 - Select PAN1
 */
/*@{*/
/*! @brief Read current value of the ZLL_DUAL_PAN_CTRL_ACTIVE_NETWORK field. */
#define ZLL_RD_DUAL_PAN_CTRL_ACTIVE_NETWORK(base) ((ZLL_DUAL_PAN_CTRL_REG(base) & ZLL_DUAL_PAN_CTRL_ACTIVE_NETWORK_MASK) >> ZLL_DUAL_PAN_CTRL_ACTIVE_NETWORK_SHIFT)
#define ZLL_BRD_DUAL_PAN_CTRL_ACTIVE_NETWORK(base) (BME_UBFX32(&ZLL_DUAL_PAN_CTRL_REG(base), ZLL_DUAL_PAN_CTRL_ACTIVE_NETWORK_SHIFT, ZLL_DUAL_PAN_CTRL_ACTIVE_NETWORK_WIDTH))

/*! @brief Set the ACTIVE_NETWORK field to a new value. */
#define ZLL_WR_DUAL_PAN_CTRL_ACTIVE_NETWORK(base, value) (ZLL_RMW_DUAL_PAN_CTRL(base, ZLL_DUAL_PAN_CTRL_ACTIVE_NETWORK_MASK, ZLL_DUAL_PAN_CTRL_ACTIVE_NETWORK(value)))
#define ZLL_BWR_DUAL_PAN_CTRL_ACTIVE_NETWORK(base, value) (BME_BFI32(&ZLL_DUAL_PAN_CTRL_REG(base), ((uint32_t)(value) << ZLL_DUAL_PAN_CTRL_ACTIVE_NETWORK_SHIFT), ZLL_DUAL_PAN_CTRL_ACTIVE_NETWORK_SHIFT, ZLL_DUAL_PAN_CTRL_ACTIVE_NETWORK_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_DUAL_PAN_CTRL, field DUAL_PAN_AUTO[1] (RW)
 *
 * Activates automatic Dual PAN operating mode. In this mode, PAN-switching is
 * controlled by hardware at a pre-programmed rate, determined by DUAL_PAN_DWELL.
 * 0: Manual Dual PAN mode (or Single PAN mode). 1: Auto Dual PAN Mode Whenever
 * DUAL_PAN_AUTO=0, CURRENT_NETWORK=ACTIVE_NETWORK at all times. In other words,
 * software directly controls which PAN is selected. Whenever DUAL_PAN_AUTO=1,
 * CURRENT_NETWORK is controlled by hardware.
 */
/*@{*/
/*! @brief Read current value of the ZLL_DUAL_PAN_CTRL_DUAL_PAN_AUTO field. */
#define ZLL_RD_DUAL_PAN_CTRL_DUAL_PAN_AUTO(base) ((ZLL_DUAL_PAN_CTRL_REG(base) & ZLL_DUAL_PAN_CTRL_DUAL_PAN_AUTO_MASK) >> ZLL_DUAL_PAN_CTRL_DUAL_PAN_AUTO_SHIFT)
#define ZLL_BRD_DUAL_PAN_CTRL_DUAL_PAN_AUTO(base) (BME_UBFX32(&ZLL_DUAL_PAN_CTRL_REG(base), ZLL_DUAL_PAN_CTRL_DUAL_PAN_AUTO_SHIFT, ZLL_DUAL_PAN_CTRL_DUAL_PAN_AUTO_WIDTH))

/*! @brief Set the DUAL_PAN_AUTO field to a new value. */
#define ZLL_WR_DUAL_PAN_CTRL_DUAL_PAN_AUTO(base, value) (ZLL_RMW_DUAL_PAN_CTRL(base, ZLL_DUAL_PAN_CTRL_DUAL_PAN_AUTO_MASK, ZLL_DUAL_PAN_CTRL_DUAL_PAN_AUTO(value)))
#define ZLL_BWR_DUAL_PAN_CTRL_DUAL_PAN_AUTO(base, value) (BME_BFI32(&ZLL_DUAL_PAN_CTRL_REG(base), ((uint32_t)(value) << ZLL_DUAL_PAN_CTRL_DUAL_PAN_AUTO_SHIFT), ZLL_DUAL_PAN_CTRL_DUAL_PAN_AUTO_SHIFT, ZLL_DUAL_PAN_CTRL_DUAL_PAN_AUTO_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_DUAL_PAN_CTRL, field PANCORDNTR1[2] (RW)
 *
 * Device is a PAN Coordinator on PAN1. Allows device to receive packets with no
 * destination address, if Source PAN ID matches.
 */
/*@{*/
/*! @brief Read current value of the ZLL_DUAL_PAN_CTRL_PANCORDNTR1 field. */
#define ZLL_RD_DUAL_PAN_CTRL_PANCORDNTR1(base) ((ZLL_DUAL_PAN_CTRL_REG(base) & ZLL_DUAL_PAN_CTRL_PANCORDNTR1_MASK) >> ZLL_DUAL_PAN_CTRL_PANCORDNTR1_SHIFT)
#define ZLL_BRD_DUAL_PAN_CTRL_PANCORDNTR1(base) (BME_UBFX32(&ZLL_DUAL_PAN_CTRL_REG(base), ZLL_DUAL_PAN_CTRL_PANCORDNTR1_SHIFT, ZLL_DUAL_PAN_CTRL_PANCORDNTR1_WIDTH))

/*! @brief Set the PANCORDNTR1 field to a new value. */
#define ZLL_WR_DUAL_PAN_CTRL_PANCORDNTR1(base, value) (ZLL_RMW_DUAL_PAN_CTRL(base, ZLL_DUAL_PAN_CTRL_PANCORDNTR1_MASK, ZLL_DUAL_PAN_CTRL_PANCORDNTR1(value)))
#define ZLL_BWR_DUAL_PAN_CTRL_PANCORDNTR1(base, value) (BME_BFI32(&ZLL_DUAL_PAN_CTRL_REG(base), ((uint32_t)(value) << ZLL_DUAL_PAN_CTRL_PANCORDNTR1_SHIFT), ZLL_DUAL_PAN_CTRL_PANCORDNTR1_SHIFT, ZLL_DUAL_PAN_CTRL_PANCORDNTR1_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_DUAL_PAN_CTRL, field CURRENT_NETWORK[3] (RO)
 *
 * This read-only bit indicates which PAN is currently selected by hardware in
 * automatic Dual PAN mode
 *
 * Values:
 * - 0b0 - PAN0 is selected
 * - 0b1 - PAN1 is selected
 */
/*@{*/
/*! @brief Read current value of the ZLL_DUAL_PAN_CTRL_CURRENT_NETWORK field. */
#define ZLL_RD_DUAL_PAN_CTRL_CURRENT_NETWORK(base) ((ZLL_DUAL_PAN_CTRL_REG(base) & ZLL_DUAL_PAN_CTRL_CURRENT_NETWORK_MASK) >> ZLL_DUAL_PAN_CTRL_CURRENT_NETWORK_SHIFT)
#define ZLL_BRD_DUAL_PAN_CTRL_CURRENT_NETWORK(base) (BME_UBFX32(&ZLL_DUAL_PAN_CTRL_REG(base), ZLL_DUAL_PAN_CTRL_CURRENT_NETWORK_SHIFT, ZLL_DUAL_PAN_CTRL_CURRENT_NETWORK_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_DUAL_PAN_CTRL, field ZB_DP_CHAN_OVRD_EN[4] (RW)
 *
 * In Dual PAN mode, in case there is a need to generate a frequency which may
 * be offset from the 16 prescribed 5MHz-spaced channels, to, for example, avoid
 * interference on one of the Dual PAN channels, a method has been provided to do
 * that on Apache, by designating one of the two PAN channels to use the Apache
 * transceiver's set of direct frequency-programming registers, instead of
 * CHANNEL_NUMx. Programming the direct frequency-programming registers -- integer,
 * numerator, and denominator, allows an RF frequency to be selected with much more
 * precision than the 5MHz granularity of the Zigbee mapped-channel registers,
 * CHANNEL_NUM0 and CHANNEL_NUM1. Two bits have been provided in Zigbee space to
 * realize this feature: ZB_DP_CHAN_OVRD_SEL and ZB_DP_CHAN_OVRD_EN. When
 * ZB_DP_CHAN_OVRD_EN=1, this enables one of the Dual PAN channels to use the direct
 * frequency programming. The ZB_DP_CHAN_OVRD_SEL bit determines which channel uses the
 * direct programming, according to the following table: ZB_DP_CHAN_OVRD_EN
 * ZB_DP_CHAN_OVRD_SEL PAN0 Frequency Determined by  PAN1 Frequency Determined by
 *  0 X CHANNEL_NUM0[6:0] CHANNEL_NUM1[6:0] 1 0 DIRECT FREQUENCY PROGRAMMING
 * CHANNEL_NUM1[6:0] 1 1 CHANNEL_NUM0[6:0] DIRECT FREQUENCY PROGRAMMING Direct
 * Frequency Programming is accomplished by setting the PLL's Integer, Numerator,
 * and Denominator registers to the appropriate values for the desired RF frequency.
 */
/*@{*/
/*! @brief Read current value of the ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_EN field. */
#define ZLL_RD_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_EN(base) ((ZLL_DUAL_PAN_CTRL_REG(base) & ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_EN_MASK) >> ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_EN_SHIFT)
#define ZLL_BRD_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_EN(base) (BME_UBFX32(&ZLL_DUAL_PAN_CTRL_REG(base), ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_EN_SHIFT, ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_EN_WIDTH))

/*! @brief Set the ZB_DP_CHAN_OVRD_EN field to a new value. */
#define ZLL_WR_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_EN(base, value) (ZLL_RMW_DUAL_PAN_CTRL(base, ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_EN_MASK, ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_EN(value)))
#define ZLL_BWR_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_EN(base, value) (BME_BFI32(&ZLL_DUAL_PAN_CTRL_REG(base), ((uint32_t)(value) << ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_EN_SHIFT), ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_EN_SHIFT, ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_DUAL_PAN_CTRL, field ZB_DP_CHAN_OVRD_SEL[5] (RW)
 *
 * This bit works with ZB_DP_CHAN_OVRD_EN to allow one of the two Dual PAN
 * channels to use Direct Frequency programming. See description for
 * ZB_DP_CHAN_OVRD_EN.
 */
/*@{*/
/*! @brief Read current value of the ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_SEL field. */
#define ZLL_RD_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_SEL(base) ((ZLL_DUAL_PAN_CTRL_REG(base) & ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_SEL_MASK) >> ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_SEL_SHIFT)
#define ZLL_BRD_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_SEL(base) (BME_UBFX32(&ZLL_DUAL_PAN_CTRL_REG(base), ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_SEL_SHIFT, ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_SEL_WIDTH))

/*! @brief Set the ZB_DP_CHAN_OVRD_SEL field to a new value. */
#define ZLL_WR_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_SEL(base, value) (ZLL_RMW_DUAL_PAN_CTRL(base, ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_SEL_MASK, ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_SEL(value)))
#define ZLL_BWR_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_SEL(base, value) (BME_BFI32(&ZLL_DUAL_PAN_CTRL_REG(base), ((uint32_t)(value) << ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_SEL_SHIFT), ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_SEL_SHIFT, ZLL_DUAL_PAN_CTRL_ZB_DP_CHAN_OVRD_SEL_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_DUAL_PAN_CTRL, field DUAL_PAN_DWELL[15:8] (RW)
 *
 * Channel Frequency Dwell Time. In Auto Dual PAN mode, hardware will toggle the
 * PAN, after dwelling on the current PAN for the interval described below
 * (assuming Preamble/SFD not detected). A write to DUAL_PAN_DWELL, always
 * re-initilizes the DWELL TIMER to the programmed value. If a write to DUAL_PAN_DWELL
 * occurs during an autosequence, the DWELL TIMER will begin counting down
 * immediately. If a write to DUAL_PAN_DWELL occurs when there is no autosequence underway,
 * the DWELL TIMER will not begin counting until the next autosequence begins; it
 * will begin counting at the start of the sequence warmup. PRESCALER (bits
 * [1:0]) TIMEBASE (bits [7:2]) RANGE (min) - (max) 00 0.5ms 0.5 - 32ms 01 2.5ms 2.5
 * - 160ms 10 10ms 10 - 640ms 11 50ms 50ms - 3.2seconds A write to DUAL_PAN_DWELL
 * also causes the value of ACTIVE_NETWORK to get latched into the hardware.
 * This latched value will be the starting point for the automatic dual-pan mode
 * (i.e., start on PAN0 or on PAN1). The starting value takes effect immediately (if
 * sequence is underway and DUAL_PAN_AUTO=1), or is otherwise delayed until
 * sequence starts and DUAL_PAN_AUTO=1.
 */
/*@{*/
/*! @brief Read current value of the ZLL_DUAL_PAN_CTRL_DUAL_PAN_DWELL field. */
#define ZLL_RD_DUAL_PAN_CTRL_DUAL_PAN_DWELL(base) ((ZLL_DUAL_PAN_CTRL_REG(base) & ZLL_DUAL_PAN_CTRL_DUAL_PAN_DWELL_MASK) >> ZLL_DUAL_PAN_CTRL_DUAL_PAN_DWELL_SHIFT)
#define ZLL_BRD_DUAL_PAN_CTRL_DUAL_PAN_DWELL(base) (BME_UBFX32(&ZLL_DUAL_PAN_CTRL_REG(base), ZLL_DUAL_PAN_CTRL_DUAL_PAN_DWELL_SHIFT, ZLL_DUAL_PAN_CTRL_DUAL_PAN_DWELL_WIDTH))

/*! @brief Set the DUAL_PAN_DWELL field to a new value. */
#define ZLL_WR_DUAL_PAN_CTRL_DUAL_PAN_DWELL(base, value) (ZLL_RMW_DUAL_PAN_CTRL(base, ZLL_DUAL_PAN_CTRL_DUAL_PAN_DWELL_MASK, ZLL_DUAL_PAN_CTRL_DUAL_PAN_DWELL(value)))
#define ZLL_BWR_DUAL_PAN_CTRL_DUAL_PAN_DWELL(base, value) (BME_BFI32(&ZLL_DUAL_PAN_CTRL_REG(base), ((uint32_t)(value) << ZLL_DUAL_PAN_CTRL_DUAL_PAN_DWELL_SHIFT), ZLL_DUAL_PAN_CTRL_DUAL_PAN_DWELL_SHIFT, ZLL_DUAL_PAN_CTRL_DUAL_PAN_DWELL_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_DUAL_PAN_CTRL, field DUAL_PAN_REMAIN[21:16] (RO)
 *
 * This read-only register indicates time remaining before next PAN switch in
 * auto Dual PAN mode. The units for this register, depend on the PRESCALER setting
 * (bits [1:0]) in the DUAL_PAN_DWELL register, according to the following
 * table: DUAL_PAN_DWELL PRESCALER DUAL_PAN_REMAIN UNITS 00 0.5ms 01 2.5ms 10 10ms 11
 * 50ms The readback value indicates that between N-1 and N timebase units remain
 * until the next PAN switch. For example, a DUAL_PAN_REMAIN readback value of
 * 3, with a DUAL_PAN_DWELL PRESCALER setting of 2 (10ms), indicates that between
 * 20ms (2*10ms) and 30ms (3*10ms), remain until the next automatic PAN switch.
 */
/*@{*/
/*! @brief Read current value of the ZLL_DUAL_PAN_CTRL_DUAL_PAN_REMAIN field. */
#define ZLL_RD_DUAL_PAN_CTRL_DUAL_PAN_REMAIN(base) ((ZLL_DUAL_PAN_CTRL_REG(base) & ZLL_DUAL_PAN_CTRL_DUAL_PAN_REMAIN_MASK) >> ZLL_DUAL_PAN_CTRL_DUAL_PAN_REMAIN_SHIFT)
#define ZLL_BRD_DUAL_PAN_CTRL_DUAL_PAN_REMAIN(base) (BME_UBFX32(&ZLL_DUAL_PAN_CTRL_REG(base), ZLL_DUAL_PAN_CTRL_DUAL_PAN_REMAIN_SHIFT, ZLL_DUAL_PAN_CTRL_DUAL_PAN_REMAIN_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_DUAL_PAN_CTRL, field RECD_ON_PAN0[22] (RO)
 *
 * Indicates the packet which was just received, was received on PAN0. In Dual
 * PAN mode operating on 2 different channels, RECD_ON_PAN0 will be set if
 * CURRENT_NETWORK=0 when the packet was received, regardless of FILTERFAIL status. In
 * DUAL PAN mode operating with same channel on both networks, CURRENT_NETWORK
 * will be ignored and RECD_ON_PAN0 will be set only if a valid packet was received
 * on PAN0 (PAN0's FILTERFAIL_FLAG is deasserted). RECD_ON_PAN0 remains valid
 * until the start of the next autoseqeuence.
 */
/*@{*/
/*! @brief Read current value of the ZLL_DUAL_PAN_CTRL_RECD_ON_PAN0 field. */
#define ZLL_RD_DUAL_PAN_CTRL_RECD_ON_PAN0(base) ((ZLL_DUAL_PAN_CTRL_REG(base) & ZLL_DUAL_PAN_CTRL_RECD_ON_PAN0_MASK) >> ZLL_DUAL_PAN_CTRL_RECD_ON_PAN0_SHIFT)
#define ZLL_BRD_DUAL_PAN_CTRL_RECD_ON_PAN0(base) (BME_UBFX32(&ZLL_DUAL_PAN_CTRL_REG(base), ZLL_DUAL_PAN_CTRL_RECD_ON_PAN0_SHIFT, ZLL_DUAL_PAN_CTRL_RECD_ON_PAN0_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_DUAL_PAN_CTRL, field RECD_ON_PAN1[23] (RO)
 *
 * Indicates the packet which was just received, was received on PAN1. In Dual
 * PAN mode operating on 2 different channels, RECD_ON_PAN1 will be set if
 * CURRENT_NETWORK=1 when the packet was received, regardless of FILTERFAIL status. In
 * DUAL PAN mode operating with same channel on both networks, CURRENT_NETWORK
 * will be ignored and RECD_ON_PAN1 will be set only if a valid packet was received
 * on PAN1 (PAN1's FILTERFAIL_FLAG is deasserted). RECD_ON_PAN1 remains valid
 * until the start of the next autoseqeuence.
 */
/*@{*/
/*! @brief Read current value of the ZLL_DUAL_PAN_CTRL_RECD_ON_PAN1 field. */
#define ZLL_RD_DUAL_PAN_CTRL_RECD_ON_PAN1(base) ((ZLL_DUAL_PAN_CTRL_REG(base) & ZLL_DUAL_PAN_CTRL_RECD_ON_PAN1_MASK) >> ZLL_DUAL_PAN_CTRL_RECD_ON_PAN1_SHIFT)
#define ZLL_BRD_DUAL_PAN_CTRL_RECD_ON_PAN1(base) (BME_UBFX32(&ZLL_DUAL_PAN_CTRL_REG(base), ZLL_DUAL_PAN_CTRL_RECD_ON_PAN1_SHIFT, ZLL_DUAL_PAN_CTRL_RECD_ON_PAN1_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_CHANNEL_NUM1 - CHANNEL NUMBER 1
 ******************************************************************************/

/*!
 * @brief ZLL_CHANNEL_NUM1 - CHANNEL NUMBER 1 (RW)
 *
 * Reset value: 0x0000007FU
 *
 * This is the mapped channel number used to transmit and receive Zigbee
 * packets. This register applies to PAN1 only. CHANNEL_NUM1 should be in the range: 11
 * <= CHANNEL_NUM1 <= 26 Note: This register should not be programmed, and left
 * in its default state, if Dual PAN mode is not in use.
 */
/*!
 * @name Constants and macros for entire ZLL_CHANNEL_NUM1 register
 */
/*@{*/
#define ZLL_RD_CHANNEL_NUM1(base) (ZLL_CHANNEL_NUM1_REG(base))
#define ZLL_WR_CHANNEL_NUM1(base, value) (ZLL_CHANNEL_NUM1_REG(base) = (value))
#define ZLL_RMW_CHANNEL_NUM1(base, mask, value) (ZLL_WR_CHANNEL_NUM1(base, (ZLL_RD_CHANNEL_NUM1(base) & ~(mask)) | (value)))
#define ZLL_SET_CHANNEL_NUM1(base, value) (BME_OR32(&ZLL_CHANNEL_NUM1_REG(base), (uint32_t)(value)))
#define ZLL_CLR_CHANNEL_NUM1(base, value) (BME_AND32(&ZLL_CHANNEL_NUM1_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_CHANNEL_NUM1(base, value) (BME_XOR32(&ZLL_CHANNEL_NUM1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_CHANNEL_NUM1 bitfields
 */

/*!
 * @name Register ZLL_CHANNEL_NUM1, field CHANNEL_NUM1[6:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ZLL_CHANNEL_NUM1_CHANNEL_NUM1 field. */
#define ZLL_RD_CHANNEL_NUM1_CHANNEL_NUM1(base) ((ZLL_CHANNEL_NUM1_REG(base) & ZLL_CHANNEL_NUM1_CHANNEL_NUM1_MASK) >> ZLL_CHANNEL_NUM1_CHANNEL_NUM1_SHIFT)
#define ZLL_BRD_CHANNEL_NUM1_CHANNEL_NUM1(base) (BME_UBFX32(&ZLL_CHANNEL_NUM1_REG(base), ZLL_CHANNEL_NUM1_CHANNEL_NUM1_SHIFT, ZLL_CHANNEL_NUM1_CHANNEL_NUM1_WIDTH))

/*! @brief Set the CHANNEL_NUM1 field to a new value. */
#define ZLL_WR_CHANNEL_NUM1_CHANNEL_NUM1(base, value) (ZLL_RMW_CHANNEL_NUM1(base, ZLL_CHANNEL_NUM1_CHANNEL_NUM1_MASK, ZLL_CHANNEL_NUM1_CHANNEL_NUM1(value)))
#define ZLL_BWR_CHANNEL_NUM1_CHANNEL_NUM1(base, value) (BME_BFI32(&ZLL_CHANNEL_NUM1_REG(base), ((uint32_t)(value) << ZLL_CHANNEL_NUM1_CHANNEL_NUM1_SHIFT), ZLL_CHANNEL_NUM1_CHANNEL_NUM1_SHIFT, ZLL_CHANNEL_NUM1_CHANNEL_NUM1_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_SAM_CTRL - SAM CONTROL
 ******************************************************************************/

/*!
 * @brief ZLL_SAM_CTRL - SAM CONTROL (RW)
 *
 * Reset value: 0x80804000U
 *
 * Source Address Management Control Register
 */
/*!
 * @name Constants and macros for entire ZLL_SAM_CTRL register
 */
/*@{*/
#define ZLL_RD_SAM_CTRL(base)    (ZLL_SAM_CTRL_REG(base))
#define ZLL_WR_SAM_CTRL(base, value) (ZLL_SAM_CTRL_REG(base) = (value))
#define ZLL_RMW_SAM_CTRL(base, mask, value) (ZLL_WR_SAM_CTRL(base, (ZLL_RD_SAM_CTRL(base) & ~(mask)) | (value)))
#define ZLL_SET_SAM_CTRL(base, value) (BME_OR32(&ZLL_SAM_CTRL_REG(base), (uint32_t)(value)))
#define ZLL_CLR_SAM_CTRL(base, value) (BME_AND32(&ZLL_SAM_CTRL_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_SAM_CTRL(base, value) (BME_XOR32(&ZLL_SAM_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_SAM_CTRL bitfields
 */

/*!
 * @name Register ZLL_SAM_CTRL, field SAP0_EN[0] (RW)
 *
 * Values:
 * - 0b0 - Disables SAP0 Partition
 * - 0b1 - Enables SAP0 Partition
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_CTRL_SAP0_EN field. */
#define ZLL_RD_SAM_CTRL_SAP0_EN(base) ((ZLL_SAM_CTRL_REG(base) & ZLL_SAM_CTRL_SAP0_EN_MASK) >> ZLL_SAM_CTRL_SAP0_EN_SHIFT)
#define ZLL_BRD_SAM_CTRL_SAP0_EN(base) (BME_UBFX32(&ZLL_SAM_CTRL_REG(base), ZLL_SAM_CTRL_SAP0_EN_SHIFT, ZLL_SAM_CTRL_SAP0_EN_WIDTH))

/*! @brief Set the SAP0_EN field to a new value. */
#define ZLL_WR_SAM_CTRL_SAP0_EN(base, value) (ZLL_RMW_SAM_CTRL(base, ZLL_SAM_CTRL_SAP0_EN_MASK, ZLL_SAM_CTRL_SAP0_EN(value)))
#define ZLL_BWR_SAM_CTRL_SAP0_EN(base, value) (BME_BFI32(&ZLL_SAM_CTRL_REG(base), ((uint32_t)(value) << ZLL_SAM_CTRL_SAP0_EN_SHIFT), ZLL_SAM_CTRL_SAP0_EN_SHIFT, ZLL_SAM_CTRL_SAP0_EN_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_CTRL, field SAA0_EN[1] (RW)
 *
 * Values:
 * - 0b0 - Disables SAA0 Partition
 * - 0b1 - Enables SAA0 Partition
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_CTRL_SAA0_EN field. */
#define ZLL_RD_SAM_CTRL_SAA0_EN(base) ((ZLL_SAM_CTRL_REG(base) & ZLL_SAM_CTRL_SAA0_EN_MASK) >> ZLL_SAM_CTRL_SAA0_EN_SHIFT)
#define ZLL_BRD_SAM_CTRL_SAA0_EN(base) (BME_UBFX32(&ZLL_SAM_CTRL_REG(base), ZLL_SAM_CTRL_SAA0_EN_SHIFT, ZLL_SAM_CTRL_SAA0_EN_WIDTH))

/*! @brief Set the SAA0_EN field to a new value. */
#define ZLL_WR_SAM_CTRL_SAA0_EN(base, value) (ZLL_RMW_SAM_CTRL(base, ZLL_SAM_CTRL_SAA0_EN_MASK, ZLL_SAM_CTRL_SAA0_EN(value)))
#define ZLL_BWR_SAM_CTRL_SAA0_EN(base, value) (BME_BFI32(&ZLL_SAM_CTRL_REG(base), ((uint32_t)(value) << ZLL_SAM_CTRL_SAA0_EN_SHIFT), ZLL_SAM_CTRL_SAA0_EN_SHIFT, ZLL_SAM_CTRL_SAA0_EN_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_CTRL, field SAP1_EN[2] (RW)
 *
 * Values:
 * - 0b0 - Disables SAP1 Partition
 * - 0b1 - Enables SAP1 Partition
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_CTRL_SAP1_EN field. */
#define ZLL_RD_SAM_CTRL_SAP1_EN(base) ((ZLL_SAM_CTRL_REG(base) & ZLL_SAM_CTRL_SAP1_EN_MASK) >> ZLL_SAM_CTRL_SAP1_EN_SHIFT)
#define ZLL_BRD_SAM_CTRL_SAP1_EN(base) (BME_UBFX32(&ZLL_SAM_CTRL_REG(base), ZLL_SAM_CTRL_SAP1_EN_SHIFT, ZLL_SAM_CTRL_SAP1_EN_WIDTH))

/*! @brief Set the SAP1_EN field to a new value. */
#define ZLL_WR_SAM_CTRL_SAP1_EN(base, value) (ZLL_RMW_SAM_CTRL(base, ZLL_SAM_CTRL_SAP1_EN_MASK, ZLL_SAM_CTRL_SAP1_EN(value)))
#define ZLL_BWR_SAM_CTRL_SAP1_EN(base, value) (BME_BFI32(&ZLL_SAM_CTRL_REG(base), ((uint32_t)(value) << ZLL_SAM_CTRL_SAP1_EN_SHIFT), ZLL_SAM_CTRL_SAP1_EN_SHIFT, ZLL_SAM_CTRL_SAP1_EN_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_CTRL, field SAA1_EN[3] (RW)
 *
 * Values:
 * - 0b0 - Disables SAA1 Partition
 * - 0b1 - Enables SAA1 Partition
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_CTRL_SAA1_EN field. */
#define ZLL_RD_SAM_CTRL_SAA1_EN(base) ((ZLL_SAM_CTRL_REG(base) & ZLL_SAM_CTRL_SAA1_EN_MASK) >> ZLL_SAM_CTRL_SAA1_EN_SHIFT)
#define ZLL_BRD_SAM_CTRL_SAA1_EN(base) (BME_UBFX32(&ZLL_SAM_CTRL_REG(base), ZLL_SAM_CTRL_SAA1_EN_SHIFT, ZLL_SAM_CTRL_SAA1_EN_WIDTH))

/*! @brief Set the SAA1_EN field to a new value. */
#define ZLL_WR_SAM_CTRL_SAA1_EN(base, value) (ZLL_RMW_SAM_CTRL(base, ZLL_SAM_CTRL_SAA1_EN_MASK, ZLL_SAM_CTRL_SAA1_EN(value)))
#define ZLL_BWR_SAM_CTRL_SAA1_EN(base, value) (BME_BFI32(&ZLL_SAM_CTRL_REG(base), ((uint32_t)(value) << ZLL_SAM_CTRL_SAA1_EN_SHIFT), ZLL_SAM_CTRL_SAA1_EN_SHIFT, ZLL_SAM_CTRL_SAA1_EN_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_CTRL, field SAA0_START[15:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_CTRL_SAA0_START field. */
#define ZLL_RD_SAM_CTRL_SAA0_START(base) ((ZLL_SAM_CTRL_REG(base) & ZLL_SAM_CTRL_SAA0_START_MASK) >> ZLL_SAM_CTRL_SAA0_START_SHIFT)
#define ZLL_BRD_SAM_CTRL_SAA0_START(base) (BME_UBFX32(&ZLL_SAM_CTRL_REG(base), ZLL_SAM_CTRL_SAA0_START_SHIFT, ZLL_SAM_CTRL_SAA0_START_WIDTH))

/*! @brief Set the SAA0_START field to a new value. */
#define ZLL_WR_SAM_CTRL_SAA0_START(base, value) (ZLL_RMW_SAM_CTRL(base, ZLL_SAM_CTRL_SAA0_START_MASK, ZLL_SAM_CTRL_SAA0_START(value)))
#define ZLL_BWR_SAM_CTRL_SAA0_START(base, value) (BME_BFI32(&ZLL_SAM_CTRL_REG(base), ((uint32_t)(value) << ZLL_SAM_CTRL_SAA0_START_SHIFT), ZLL_SAM_CTRL_SAA0_START_SHIFT, ZLL_SAM_CTRL_SAA0_START_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_CTRL, field SAP1_START[23:16] (RW)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_CTRL_SAP1_START field. */
#define ZLL_RD_SAM_CTRL_SAP1_START(base) ((ZLL_SAM_CTRL_REG(base) & ZLL_SAM_CTRL_SAP1_START_MASK) >> ZLL_SAM_CTRL_SAP1_START_SHIFT)
#define ZLL_BRD_SAM_CTRL_SAP1_START(base) (BME_UBFX32(&ZLL_SAM_CTRL_REG(base), ZLL_SAM_CTRL_SAP1_START_SHIFT, ZLL_SAM_CTRL_SAP1_START_WIDTH))

/*! @brief Set the SAP1_START field to a new value. */
#define ZLL_WR_SAM_CTRL_SAP1_START(base, value) (ZLL_RMW_SAM_CTRL(base, ZLL_SAM_CTRL_SAP1_START_MASK, ZLL_SAM_CTRL_SAP1_START(value)))
#define ZLL_BWR_SAM_CTRL_SAP1_START(base, value) (BME_BFI32(&ZLL_SAM_CTRL_REG(base), ((uint32_t)(value) << ZLL_SAM_CTRL_SAP1_START_SHIFT), ZLL_SAM_CTRL_SAP1_START_SHIFT, ZLL_SAM_CTRL_SAP1_START_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_CTRL, field SAA1_START[31:24] (RW)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_CTRL_SAA1_START field. */
#define ZLL_RD_SAM_CTRL_SAA1_START(base) ((ZLL_SAM_CTRL_REG(base) & ZLL_SAM_CTRL_SAA1_START_MASK) >> ZLL_SAM_CTRL_SAA1_START_SHIFT)
#define ZLL_BRD_SAM_CTRL_SAA1_START(base) (BME_UBFX32(&ZLL_SAM_CTRL_REG(base), ZLL_SAM_CTRL_SAA1_START_SHIFT, ZLL_SAM_CTRL_SAA1_START_WIDTH))

/*! @brief Set the SAA1_START field to a new value. */
#define ZLL_WR_SAM_CTRL_SAA1_START(base, value) (ZLL_RMW_SAM_CTRL(base, ZLL_SAM_CTRL_SAA1_START_MASK, ZLL_SAM_CTRL_SAA1_START(value)))
#define ZLL_BWR_SAM_CTRL_SAA1_START(base, value) (BME_BFI32(&ZLL_SAM_CTRL_REG(base), ((uint32_t)(value) << ZLL_SAM_CTRL_SAA1_START_SHIFT), ZLL_SAM_CTRL_SAA1_START_SHIFT, ZLL_SAM_CTRL_SAA1_START_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_SAM_TABLE - SOURCE ADDRESS MANAGEMENT TABLE
 ******************************************************************************/

/*!
 * @brief ZLL_SAM_TABLE - SOURCE ADDRESS MANAGEMENT TABLE (RW)
 *
 * Reset value: 0x00000000U
 *
 * Source Address Management Table
 */
/*!
 * @name Constants and macros for entire ZLL_SAM_TABLE register
 */
/*@{*/
#define ZLL_RD_SAM_TABLE(base)   (ZLL_SAM_TABLE_REG(base))
#define ZLL_WR_SAM_TABLE(base, value) (ZLL_SAM_TABLE_REG(base) = (value))
#define ZLL_RMW_SAM_TABLE(base, mask, value) (ZLL_WR_SAM_TABLE(base, (ZLL_RD_SAM_TABLE(base) & ~(mask)) | (value)))
#define ZLL_SET_SAM_TABLE(base, value) (BME_OR32(&ZLL_SAM_TABLE_REG(base), (uint32_t)(value)))
#define ZLL_CLR_SAM_TABLE(base, value) (BME_AND32(&ZLL_SAM_TABLE_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_SAM_TABLE(base, value) (BME_XOR32(&ZLL_SAM_TABLE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_SAM_TABLE bitfields
 */

/*!
 * @name Register ZLL_SAM_TABLE, field SAM_INDEX[6:0] (RW)
 *
 * Contains the table index to be enabled or invalidated. Software must ensure
 * that the index is within the range of the desired partition.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_TABLE_SAM_INDEX field. */
#define ZLL_RD_SAM_TABLE_SAM_INDEX(base) ((ZLL_SAM_TABLE_REG(base) & ZLL_SAM_TABLE_SAM_INDEX_MASK) >> ZLL_SAM_TABLE_SAM_INDEX_SHIFT)
#define ZLL_BRD_SAM_TABLE_SAM_INDEX(base) (BME_UBFX32(&ZLL_SAM_TABLE_REG(base), ZLL_SAM_TABLE_SAM_INDEX_SHIFT, ZLL_SAM_TABLE_SAM_INDEX_WIDTH))

/*! @brief Set the SAM_INDEX field to a new value. */
#define ZLL_WR_SAM_TABLE_SAM_INDEX(base, value) (ZLL_RMW_SAM_TABLE(base, ZLL_SAM_TABLE_SAM_INDEX_MASK, ZLL_SAM_TABLE_SAM_INDEX(value)))
#define ZLL_BWR_SAM_TABLE_SAM_INDEX(base, value) (BME_BFI32(&ZLL_SAM_TABLE_REG(base), ((uint32_t)(value) << ZLL_SAM_TABLE_SAM_INDEX_SHIFT), ZLL_SAM_TABLE_SAM_INDEX_SHIFT, ZLL_SAM_TABLE_SAM_INDEX_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_TABLE, field SAM_INDEX_WR[7] (WO)
 *
 * For 32-bit writes, SAM_INDEX_WR must be set to indicate that the table entry
 * specified by SAM_INDEX[6:0] is to be written; if SAM_INDEX_WR=0, the table
 * entry is not written, but the SAM_INDEX[6:0] register is updated. For 8-bit
 * writes, this bit is ignored.
 */
/*@{*/
/*! @brief Set the SAM_INDEX_WR field to a new value. */
#define ZLL_WR_SAM_TABLE_SAM_INDEX_WR(base, value) (ZLL_RMW_SAM_TABLE(base, ZLL_SAM_TABLE_SAM_INDEX_WR_MASK, ZLL_SAM_TABLE_SAM_INDEX_WR(value)))
#define ZLL_BWR_SAM_TABLE_SAM_INDEX_WR(base, value) (ZLL_WR_SAM_TABLE_SAM_INDEX_WR(base, value))
/*@}*/

/*!
 * @name Register ZLL_SAM_TABLE, field SAM_CHECKSUM[23:8] (RW)
 *
 * Software-computed source address checksum, to be installed into a table
 * index. The value on SAM_CHECKSUM[15:0] can be installed into the table with a
 * single, atomic 32-bit write; in that case, the write data would contain the desired
 * SAM_INDEX[6:0] and SAM_CHECKSUM[15:0], and SAM_INDEX_WR=1.If SAM_INDEX_WR=0,
 * then the SAM_INDEX[6:0] register is written, but the checksum is not written
 * to the table.The readback value of SAM_CHECKSUM[15:0] is the contents of the
 * SAM Table at the location pointed to by SAM_INDEX[6:0]. To readback from a
 * specific table index, software should first write the desired index to
 * SAM_INDEX[6:0], and then read back the checksum from the table on SAM_CHECKSUM[15:0].
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_TABLE_SAM_CHECKSUM field. */
#define ZLL_RD_SAM_TABLE_SAM_CHECKSUM(base) ((ZLL_SAM_TABLE_REG(base) & ZLL_SAM_TABLE_SAM_CHECKSUM_MASK) >> ZLL_SAM_TABLE_SAM_CHECKSUM_SHIFT)
#define ZLL_BRD_SAM_TABLE_SAM_CHECKSUM(base) (BME_UBFX32(&ZLL_SAM_TABLE_REG(base), ZLL_SAM_TABLE_SAM_CHECKSUM_SHIFT, ZLL_SAM_TABLE_SAM_CHECKSUM_WIDTH))

/*! @brief Set the SAM_CHECKSUM field to a new value. */
#define ZLL_WR_SAM_TABLE_SAM_CHECKSUM(base, value) (ZLL_RMW_SAM_TABLE(base, ZLL_SAM_TABLE_SAM_CHECKSUM_MASK, ZLL_SAM_TABLE_SAM_CHECKSUM(value)))
#define ZLL_BWR_SAM_TABLE_SAM_CHECKSUM(base, value) (BME_BFI32(&ZLL_SAM_TABLE_REG(base), ((uint32_t)(value) << ZLL_SAM_TABLE_SAM_CHECKSUM_SHIFT), ZLL_SAM_TABLE_SAM_CHECKSUM_SHIFT, ZLL_SAM_TABLE_SAM_CHECKSUM_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_TABLE, field SAM_INDEX_INV[24] (WO)
 */
/*@{*/
/*! @brief Set the SAM_INDEX_INV field to a new value. */
#define ZLL_WR_SAM_TABLE_SAM_INDEX_INV(base, value) (ZLL_RMW_SAM_TABLE(base, ZLL_SAM_TABLE_SAM_INDEX_INV_MASK, ZLL_SAM_TABLE_SAM_INDEX_INV(value)))
#define ZLL_BWR_SAM_TABLE_SAM_INDEX_INV(base, value) (ZLL_WR_SAM_TABLE_SAM_INDEX_INV(base, value))
/*@}*/

/*!
 * @name Register ZLL_SAM_TABLE, field SAM_INDEX_EN[25] (WO)
 */
/*@{*/
/*! @brief Set the SAM_INDEX_EN field to a new value. */
#define ZLL_WR_SAM_TABLE_SAM_INDEX_EN(base, value) (ZLL_RMW_SAM_TABLE(base, ZLL_SAM_TABLE_SAM_INDEX_EN_MASK, ZLL_SAM_TABLE_SAM_INDEX_EN(value)))
#define ZLL_BWR_SAM_TABLE_SAM_INDEX_EN(base, value) (ZLL_WR_SAM_TABLE_SAM_INDEX_EN(base, value))
/*@}*/

/*!
 * @name Register ZLL_SAM_TABLE, field ACK_FRM_PND[26] (RW)
 *
 * Software can take manual control of the FramePending field of the Frame
 * Control Field of the next automatic TX acknowledge packet, by setting
 * ACK_FRM_PND_CTRL=1; in that case FramePending will track the state of this bit. The
 * FramePending field also tracks this bit if Source Address Management is comletely
 * disabled, i.e., SAP0_EN=SAA0_EN=SAP1_EN=SAA1_EN=0 Otherwise, the FramePending
 * field is determined by Source Address Management (SAM) hardware.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_TABLE_ACK_FRM_PND field. */
#define ZLL_RD_SAM_TABLE_ACK_FRM_PND(base) ((ZLL_SAM_TABLE_REG(base) & ZLL_SAM_TABLE_ACK_FRM_PND_MASK) >> ZLL_SAM_TABLE_ACK_FRM_PND_SHIFT)
#define ZLL_BRD_SAM_TABLE_ACK_FRM_PND(base) (BME_UBFX32(&ZLL_SAM_TABLE_REG(base), ZLL_SAM_TABLE_ACK_FRM_PND_SHIFT, ZLL_SAM_TABLE_ACK_FRM_PND_WIDTH))

/*! @brief Set the ACK_FRM_PND field to a new value. */
#define ZLL_WR_SAM_TABLE_ACK_FRM_PND(base, value) (ZLL_RMW_SAM_TABLE(base, ZLL_SAM_TABLE_ACK_FRM_PND_MASK, ZLL_SAM_TABLE_ACK_FRM_PND(value)))
#define ZLL_BWR_SAM_TABLE_ACK_FRM_PND(base, value) (BME_BFI32(&ZLL_SAM_TABLE_REG(base), ((uint32_t)(value) << ZLL_SAM_TABLE_ACK_FRM_PND_SHIFT), ZLL_SAM_TABLE_ACK_FRM_PND_SHIFT, ZLL_SAM_TABLE_ACK_FRM_PND_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_TABLE, field ACK_FRM_PND_CTRL[27] (RW)
 *
 * Values:
 * - 0b0 - the FramePending field of the Frame Control Field of the next
 *     automatic TX acknowledge packet is determined by hardware
 * - 0b1 - the FramePending field of the Frame Control Field of the next
 *     automatic TX acknowledge packet tracks ACK_FRM_PEND
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_TABLE_ACK_FRM_PND_CTRL field. */
#define ZLL_RD_SAM_TABLE_ACK_FRM_PND_CTRL(base) ((ZLL_SAM_TABLE_REG(base) & ZLL_SAM_TABLE_ACK_FRM_PND_CTRL_MASK) >> ZLL_SAM_TABLE_ACK_FRM_PND_CTRL_SHIFT)
#define ZLL_BRD_SAM_TABLE_ACK_FRM_PND_CTRL(base) (BME_UBFX32(&ZLL_SAM_TABLE_REG(base), ZLL_SAM_TABLE_ACK_FRM_PND_CTRL_SHIFT, ZLL_SAM_TABLE_ACK_FRM_PND_CTRL_WIDTH))

/*! @brief Set the ACK_FRM_PND_CTRL field to a new value. */
#define ZLL_WR_SAM_TABLE_ACK_FRM_PND_CTRL(base, value) (ZLL_RMW_SAM_TABLE(base, ZLL_SAM_TABLE_ACK_FRM_PND_CTRL_MASK, ZLL_SAM_TABLE_ACK_FRM_PND_CTRL(value)))
#define ZLL_BWR_SAM_TABLE_ACK_FRM_PND_CTRL(base, value) (BME_BFI32(&ZLL_SAM_TABLE_REG(base), ((uint32_t)(value) << ZLL_SAM_TABLE_ACK_FRM_PND_CTRL_SHIFT), ZLL_SAM_TABLE_ACK_FRM_PND_CTRL_SHIFT, ZLL_SAM_TABLE_ACK_FRM_PND_CTRL_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_TABLE, field FIND_FREE_IDX[28] (WO)
 *
 * After modifying Valid bits (enabling or invalidating), write this bit to 1 to
 * force hardware to update the "First Free Index" registers to account for the
 * changed Valid bits. This hardware update process takes 4us. Software can poll
 * SAM_BUSY to determine when the table update is complete. Write-only bit.
 * Writing 0 to this bit has no effect. Readback value is indeterminate.
 */
/*@{*/
/*! @brief Set the FIND_FREE_IDX field to a new value. */
#define ZLL_WR_SAM_TABLE_FIND_FREE_IDX(base, value) (ZLL_RMW_SAM_TABLE(base, ZLL_SAM_TABLE_FIND_FREE_IDX_MASK, ZLL_SAM_TABLE_FIND_FREE_IDX(value)))
#define ZLL_BWR_SAM_TABLE_FIND_FREE_IDX(base, value) (ZLL_WR_SAM_TABLE_FIND_FREE_IDX(base, value))
/*@}*/

/*!
 * @name Register ZLL_SAM_TABLE, field INVALIDATE_ALL[29] (WO)
 *
 * Writing a 1 to this bit clears all 128 Valid bits. Invalidates the entire
 * table. Write-only bit. Writing 0 to this bit has no effect. Readback value is
 * indeterminate.
 */
/*@{*/
/*! @brief Set the INVALIDATE_ALL field to a new value. */
#define ZLL_WR_SAM_TABLE_INVALIDATE_ALL(base, value) (ZLL_RMW_SAM_TABLE(base, ZLL_SAM_TABLE_INVALIDATE_ALL_MASK, ZLL_SAM_TABLE_INVALIDATE_ALL(value)))
#define ZLL_BWR_SAM_TABLE_INVALIDATE_ALL(base, value) (ZLL_WR_SAM_TABLE_INVALIDATE_ALL(base, value))
/*@}*/

/*!
 * @name Register ZLL_SAM_TABLE, field SAM_BUSY[31] (RO)
 *
 * Hardware is in the process of updating the Source Address table, either in
 * response to a poll indication from the packet processor, or due to software
 * setting FIND_FREE_IDX=1. In the latter case, software should poll SAM_BUSY until
 * low before accessing the "First Free Index" registers. Read-only bit.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_TABLE_SAM_BUSY field. */
#define ZLL_RD_SAM_TABLE_SAM_BUSY(base) ((ZLL_SAM_TABLE_REG(base) & ZLL_SAM_TABLE_SAM_BUSY_MASK) >> ZLL_SAM_TABLE_SAM_BUSY_SHIFT)
#define ZLL_BRD_SAM_TABLE_SAM_BUSY(base) (BME_UBFX32(&ZLL_SAM_TABLE_REG(base), ZLL_SAM_TABLE_SAM_BUSY_SHIFT, ZLL_SAM_TABLE_SAM_BUSY_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_SAM_MATCH - SAM MATCH
 ******************************************************************************/

/*!
 * @brief ZLL_SAM_MATCH - SAM MATCH (RO)
 *
 * Reset value: 0x00000000U
 *
 * Source Address Management Match Register
 */
/*!
 * @name Constants and macros for entire ZLL_SAM_MATCH register
 */
/*@{*/
#define ZLL_RD_SAM_MATCH(base)   (ZLL_SAM_MATCH_REG(base))
/*@}*/

/*
 * Constants & macros for individual ZLL_SAM_MATCH bitfields
 */

/*!
 * @name Register ZLL_SAM_MATCH, field SAP0_MATCH[6:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_MATCH_SAP0_MATCH field. */
#define ZLL_RD_SAM_MATCH_SAP0_MATCH(base) ((ZLL_SAM_MATCH_REG(base) & ZLL_SAM_MATCH_SAP0_MATCH_MASK) >> ZLL_SAM_MATCH_SAP0_MATCH_SHIFT)
#define ZLL_BRD_SAM_MATCH_SAP0_MATCH(base) (BME_UBFX32(&ZLL_SAM_MATCH_REG(base), ZLL_SAM_MATCH_SAP0_MATCH_SHIFT, ZLL_SAM_MATCH_SAP0_MATCH_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_MATCH, field SAP0_ADDR_PRESENT[7] (RO)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_MATCH_SAP0_ADDR_PRESENT field. */
#define ZLL_RD_SAM_MATCH_SAP0_ADDR_PRESENT(base) ((ZLL_SAM_MATCH_REG(base) & ZLL_SAM_MATCH_SAP0_ADDR_PRESENT_MASK) >> ZLL_SAM_MATCH_SAP0_ADDR_PRESENT_SHIFT)
#define ZLL_BRD_SAM_MATCH_SAP0_ADDR_PRESENT(base) (BME_UBFX32(&ZLL_SAM_MATCH_REG(base), ZLL_SAM_MATCH_SAP0_ADDR_PRESENT_SHIFT, ZLL_SAM_MATCH_SAP0_ADDR_PRESENT_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_MATCH, field SAA0_MATCH[14:8] (RO)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_MATCH_SAA0_MATCH field. */
#define ZLL_RD_SAM_MATCH_SAA0_MATCH(base) ((ZLL_SAM_MATCH_REG(base) & ZLL_SAM_MATCH_SAA0_MATCH_MASK) >> ZLL_SAM_MATCH_SAA0_MATCH_SHIFT)
#define ZLL_BRD_SAM_MATCH_SAA0_MATCH(base) (BME_UBFX32(&ZLL_SAM_MATCH_REG(base), ZLL_SAM_MATCH_SAA0_MATCH_SHIFT, ZLL_SAM_MATCH_SAA0_MATCH_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_MATCH, field SAA0_ADDR_ABSENT[15] (RO)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_MATCH_SAA0_ADDR_ABSENT field. */
#define ZLL_RD_SAM_MATCH_SAA0_ADDR_ABSENT(base) ((ZLL_SAM_MATCH_REG(base) & ZLL_SAM_MATCH_SAA0_ADDR_ABSENT_MASK) >> ZLL_SAM_MATCH_SAA0_ADDR_ABSENT_SHIFT)
#define ZLL_BRD_SAM_MATCH_SAA0_ADDR_ABSENT(base) (BME_UBFX32(&ZLL_SAM_MATCH_REG(base), ZLL_SAM_MATCH_SAA0_ADDR_ABSENT_SHIFT, ZLL_SAM_MATCH_SAA0_ADDR_ABSENT_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_MATCH, field SAP1_MATCH[22:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_MATCH_SAP1_MATCH field. */
#define ZLL_RD_SAM_MATCH_SAP1_MATCH(base) ((ZLL_SAM_MATCH_REG(base) & ZLL_SAM_MATCH_SAP1_MATCH_MASK) >> ZLL_SAM_MATCH_SAP1_MATCH_SHIFT)
#define ZLL_BRD_SAM_MATCH_SAP1_MATCH(base) (BME_UBFX32(&ZLL_SAM_MATCH_REG(base), ZLL_SAM_MATCH_SAP1_MATCH_SHIFT, ZLL_SAM_MATCH_SAP1_MATCH_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_MATCH, field SAP1_ADDR_PRESENT[23] (RO)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_MATCH_SAP1_ADDR_PRESENT field. */
#define ZLL_RD_SAM_MATCH_SAP1_ADDR_PRESENT(base) ((ZLL_SAM_MATCH_REG(base) & ZLL_SAM_MATCH_SAP1_ADDR_PRESENT_MASK) >> ZLL_SAM_MATCH_SAP1_ADDR_PRESENT_SHIFT)
#define ZLL_BRD_SAM_MATCH_SAP1_ADDR_PRESENT(base) (BME_UBFX32(&ZLL_SAM_MATCH_REG(base), ZLL_SAM_MATCH_SAP1_ADDR_PRESENT_SHIFT, ZLL_SAM_MATCH_SAP1_ADDR_PRESENT_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_MATCH, field SAA1_MATCH[30:24] (RO)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_MATCH_SAA1_MATCH field. */
#define ZLL_RD_SAM_MATCH_SAA1_MATCH(base) ((ZLL_SAM_MATCH_REG(base) & ZLL_SAM_MATCH_SAA1_MATCH_MASK) >> ZLL_SAM_MATCH_SAA1_MATCH_SHIFT)
#define ZLL_BRD_SAM_MATCH_SAA1_MATCH(base) (BME_UBFX32(&ZLL_SAM_MATCH_REG(base), ZLL_SAM_MATCH_SAA1_MATCH_SHIFT, ZLL_SAM_MATCH_SAA1_MATCH_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_MATCH, field SAA1_ADDR_ABSENT[31] (RO)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_MATCH_SAA1_ADDR_ABSENT field. */
#define ZLL_RD_SAM_MATCH_SAA1_ADDR_ABSENT(base) ((ZLL_SAM_MATCH_REG(base) & ZLL_SAM_MATCH_SAA1_ADDR_ABSENT_MASK) >> ZLL_SAM_MATCH_SAA1_ADDR_ABSENT_SHIFT)
#define ZLL_BRD_SAM_MATCH_SAA1_ADDR_ABSENT(base) (BME_UBFX32(&ZLL_SAM_MATCH_REG(base), ZLL_SAM_MATCH_SAA1_ADDR_ABSENT_SHIFT, ZLL_SAM_MATCH_SAA1_ADDR_ABSENT_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_SAM_FREE_IDX - SAM FREE INDEX
 ******************************************************************************/

/*!
 * @brief ZLL_SAM_FREE_IDX - SAM FREE INDEX (RO)
 *
 * Reset value: 0x00000000U
 *
 * Source Address Management Free Index Register
 */
/*!
 * @name Constants and macros for entire ZLL_SAM_FREE_IDX register
 */
/*@{*/
#define ZLL_RD_SAM_FREE_IDX(base) (ZLL_SAM_FREE_IDX_REG(base))
/*@}*/

/*
 * Constants & macros for individual ZLL_SAM_FREE_IDX bitfields
 */

/*!
 * @name Register ZLL_SAM_FREE_IDX, field SAP0_1ST_FREE_IDX[7:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_FREE_IDX_SAP0_1ST_FREE_IDX field. */
#define ZLL_RD_SAM_FREE_IDX_SAP0_1ST_FREE_IDX(base) ((ZLL_SAM_FREE_IDX_REG(base) & ZLL_SAM_FREE_IDX_SAP0_1ST_FREE_IDX_MASK) >> ZLL_SAM_FREE_IDX_SAP0_1ST_FREE_IDX_SHIFT)
#define ZLL_BRD_SAM_FREE_IDX_SAP0_1ST_FREE_IDX(base) (BME_UBFX32(&ZLL_SAM_FREE_IDX_REG(base), ZLL_SAM_FREE_IDX_SAP0_1ST_FREE_IDX_SHIFT, ZLL_SAM_FREE_IDX_SAP0_1ST_FREE_IDX_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_FREE_IDX, field SAA0_1ST_FREE_IDX[15:8] (RO)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_FREE_IDX_SAA0_1ST_FREE_IDX field. */
#define ZLL_RD_SAM_FREE_IDX_SAA0_1ST_FREE_IDX(base) ((ZLL_SAM_FREE_IDX_REG(base) & ZLL_SAM_FREE_IDX_SAA0_1ST_FREE_IDX_MASK) >> ZLL_SAM_FREE_IDX_SAA0_1ST_FREE_IDX_SHIFT)
#define ZLL_BRD_SAM_FREE_IDX_SAA0_1ST_FREE_IDX(base) (BME_UBFX32(&ZLL_SAM_FREE_IDX_REG(base), ZLL_SAM_FREE_IDX_SAA0_1ST_FREE_IDX_SHIFT, ZLL_SAM_FREE_IDX_SAA0_1ST_FREE_IDX_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_FREE_IDX, field SAP1_1ST_FREE_IDX[23:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_FREE_IDX_SAP1_1ST_FREE_IDX field. */
#define ZLL_RD_SAM_FREE_IDX_SAP1_1ST_FREE_IDX(base) ((ZLL_SAM_FREE_IDX_REG(base) & ZLL_SAM_FREE_IDX_SAP1_1ST_FREE_IDX_MASK) >> ZLL_SAM_FREE_IDX_SAP1_1ST_FREE_IDX_SHIFT)
#define ZLL_BRD_SAM_FREE_IDX_SAP1_1ST_FREE_IDX(base) (BME_UBFX32(&ZLL_SAM_FREE_IDX_REG(base), ZLL_SAM_FREE_IDX_SAP1_1ST_FREE_IDX_SHIFT, ZLL_SAM_FREE_IDX_SAP1_1ST_FREE_IDX_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SAM_FREE_IDX, field SAA1_1ST_FREE_IDX[31:24] (RO)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SAM_FREE_IDX_SAA1_1ST_FREE_IDX field. */
#define ZLL_RD_SAM_FREE_IDX_SAA1_1ST_FREE_IDX(base) ((ZLL_SAM_FREE_IDX_REG(base) & ZLL_SAM_FREE_IDX_SAA1_1ST_FREE_IDX_MASK) >> ZLL_SAM_FREE_IDX_SAA1_1ST_FREE_IDX_SHIFT)
#define ZLL_BRD_SAM_FREE_IDX_SAA1_1ST_FREE_IDX(base) (BME_UBFX32(&ZLL_SAM_FREE_IDX_REG(base), ZLL_SAM_FREE_IDX_SAA1_1ST_FREE_IDX_SHIFT, ZLL_SAM_FREE_IDX_SAA1_1ST_FREE_IDX_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_SEQ_CTRL_STS - SEQUENCE CONTROL AND STATUS
 ******************************************************************************/

/*!
 * @brief ZLL_SEQ_CTRL_STS - SEQUENCE CONTROL AND STATUS (RW)
 *
 * Reset value: 0x00000008U
 */
/*!
 * @name Constants and macros for entire ZLL_SEQ_CTRL_STS register
 */
/*@{*/
#define ZLL_RD_SEQ_CTRL_STS(base) (ZLL_SEQ_CTRL_STS_REG(base))
#define ZLL_WR_SEQ_CTRL_STS(base, value) (ZLL_SEQ_CTRL_STS_REG(base) = (value))
#define ZLL_RMW_SEQ_CTRL_STS(base, mask, value) (ZLL_WR_SEQ_CTRL_STS(base, (ZLL_RD_SEQ_CTRL_STS(base) & ~(mask)) | (value)))
#define ZLL_SET_SEQ_CTRL_STS(base, value) (BME_OR32(&ZLL_SEQ_CTRL_STS_REG(base), (uint32_t)(value)))
#define ZLL_CLR_SEQ_CTRL_STS(base, value) (BME_AND32(&ZLL_SEQ_CTRL_STS_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_SEQ_CTRL_STS(base, value) (BME_XOR32(&ZLL_SEQ_CTRL_STS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_SEQ_CTRL_STS bitfields
 */

/*!
 * @name Register ZLL_SEQ_CTRL_STS, field CLR_NEW_SEQ_INHIBIT[2] (RW)
 *
 * when asserted, overrides the automatic hardware locking of the programmed
 * XCVSEQ while an autosequence is underway. Asserting this feature will allow
 * software to change the programmed autosequence "on-the-fly", without aborting and
 * returning to idle between sequences. Overriding the hardware lockout of XCVSEQ
 * should be used with caution, since the Sequence Manager is not designed (or
 * verified) for manual state transitions between one type of autosequence and
 * other (i.e., Sequence T -> Sequence R).
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_CTRL_STS_CLR_NEW_SEQ_INHIBIT field. */
#define ZLL_RD_SEQ_CTRL_STS_CLR_NEW_SEQ_INHIBIT(base) ((ZLL_SEQ_CTRL_STS_REG(base) & ZLL_SEQ_CTRL_STS_CLR_NEW_SEQ_INHIBIT_MASK) >> ZLL_SEQ_CTRL_STS_CLR_NEW_SEQ_INHIBIT_SHIFT)
#define ZLL_BRD_SEQ_CTRL_STS_CLR_NEW_SEQ_INHIBIT(base) (BME_UBFX32(&ZLL_SEQ_CTRL_STS_REG(base), ZLL_SEQ_CTRL_STS_CLR_NEW_SEQ_INHIBIT_SHIFT, ZLL_SEQ_CTRL_STS_CLR_NEW_SEQ_INHIBIT_WIDTH))

/*! @brief Set the CLR_NEW_SEQ_INHIBIT field to a new value. */
#define ZLL_WR_SEQ_CTRL_STS_CLR_NEW_SEQ_INHIBIT(base, value) (ZLL_RMW_SEQ_CTRL_STS(base, ZLL_SEQ_CTRL_STS_CLR_NEW_SEQ_INHIBIT_MASK, ZLL_SEQ_CTRL_STS_CLR_NEW_SEQ_INHIBIT(value)))
#define ZLL_BWR_SEQ_CTRL_STS_CLR_NEW_SEQ_INHIBIT(base, value) (BME_BFI32(&ZLL_SEQ_CTRL_STS_REG(base), ((uint32_t)(value) << ZLL_SEQ_CTRL_STS_CLR_NEW_SEQ_INHIBIT_SHIFT), ZLL_SEQ_CTRL_STS_CLR_NEW_SEQ_INHIBIT_SHIFT, ZLL_SEQ_CTRL_STS_CLR_NEW_SEQ_INHIBIT_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_CTRL_STS, field EVENT_TMR_DO_NOT_LATCH[3] (RW)
 *
 * when asserted, overrides the automatic hardware latching of the Event Timer
 * that prevents the timer from updating while software reads the 3 Event Timer
 * bytes. This allows the Event Timer LS byte to continue to update without reading
 * the upper 2 bytes. Overriding the automatic latching of the Event Timer
 * should be used with caution, as it can allow the Event Timer lower bytes to get
 * out-of-sync with the upper bytes. However, it can be useful when polling the
 * Event Timer LS byte for a value that is just a few counts in the future.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_CTRL_STS_EVENT_TMR_DO_NOT_LATCH field. */
#define ZLL_RD_SEQ_CTRL_STS_EVENT_TMR_DO_NOT_LATCH(base) ((ZLL_SEQ_CTRL_STS_REG(base) & ZLL_SEQ_CTRL_STS_EVENT_TMR_DO_NOT_LATCH_MASK) >> ZLL_SEQ_CTRL_STS_EVENT_TMR_DO_NOT_LATCH_SHIFT)
#define ZLL_BRD_SEQ_CTRL_STS_EVENT_TMR_DO_NOT_LATCH(base) (BME_UBFX32(&ZLL_SEQ_CTRL_STS_REG(base), ZLL_SEQ_CTRL_STS_EVENT_TMR_DO_NOT_LATCH_SHIFT, ZLL_SEQ_CTRL_STS_EVENT_TMR_DO_NOT_LATCH_WIDTH))

/*! @brief Set the EVENT_TMR_DO_NOT_LATCH field to a new value. */
#define ZLL_WR_SEQ_CTRL_STS_EVENT_TMR_DO_NOT_LATCH(base, value) (ZLL_RMW_SEQ_CTRL_STS(base, ZLL_SEQ_CTRL_STS_EVENT_TMR_DO_NOT_LATCH_MASK, ZLL_SEQ_CTRL_STS_EVENT_TMR_DO_NOT_LATCH(value)))
#define ZLL_BWR_SEQ_CTRL_STS_EVENT_TMR_DO_NOT_LATCH(base, value) (BME_BFI32(&ZLL_SEQ_CTRL_STS_REG(base), ((uint32_t)(value) << ZLL_SEQ_CTRL_STS_EVENT_TMR_DO_NOT_LATCH_SHIFT), ZLL_SEQ_CTRL_STS_EVENT_TMR_DO_NOT_LATCH_SHIFT, ZLL_SEQ_CTRL_STS_EVENT_TMR_DO_NOT_LATCH_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_CTRL_STS, field LATCH_PREAMBLE[4] (RW)
 *
 * Values:
 * - 0b0 - Don't make PREAMBLE_DET and SFD_DET bits of PHY_STS (SEQ_STATE)
 *     Register "sticky", i.e, these status bits reflect the realtime, dynamic state
 *     of preamble_detect and sfd_detect
 * - 0b1 - Make PREAMBLE_DET and SFD_DET bits of PHY_STS (SEQ_STATE) Register
 *     "sticky", i.e.,occurrences of preamble and SFD detection are latched and
 *     held until the start of the next autosequence
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_CTRL_STS_LATCH_PREAMBLE field. */
#define ZLL_RD_SEQ_CTRL_STS_LATCH_PREAMBLE(base) ((ZLL_SEQ_CTRL_STS_REG(base) & ZLL_SEQ_CTRL_STS_LATCH_PREAMBLE_MASK) >> ZLL_SEQ_CTRL_STS_LATCH_PREAMBLE_SHIFT)
#define ZLL_BRD_SEQ_CTRL_STS_LATCH_PREAMBLE(base) (BME_UBFX32(&ZLL_SEQ_CTRL_STS_REG(base), ZLL_SEQ_CTRL_STS_LATCH_PREAMBLE_SHIFT, ZLL_SEQ_CTRL_STS_LATCH_PREAMBLE_WIDTH))

/*! @brief Set the LATCH_PREAMBLE field to a new value. */
#define ZLL_WR_SEQ_CTRL_STS_LATCH_PREAMBLE(base, value) (ZLL_RMW_SEQ_CTRL_STS(base, ZLL_SEQ_CTRL_STS_LATCH_PREAMBLE_MASK, ZLL_SEQ_CTRL_STS_LATCH_PREAMBLE(value)))
#define ZLL_BWR_SEQ_CTRL_STS_LATCH_PREAMBLE(base, value) (BME_BFI32(&ZLL_SEQ_CTRL_STS_REG(base), ((uint32_t)(value) << ZLL_SEQ_CTRL_STS_LATCH_PREAMBLE_SHIFT), ZLL_SEQ_CTRL_STS_LATCH_PREAMBLE_SHIFT, ZLL_SEQ_CTRL_STS_LATCH_PREAMBLE_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_CTRL_STS, field NO_RX_RECYCLE[5] (RW)
 *
 * when asserted, prevents the Zigbee Sequence Manager (ZSM) from automatically
 * re-starting (recycling) the receiver when a packet is received which results
 * in a FilterFail or CRC failure. Normally, on a RX recycle, the ZSM returns to
 * the RX_WU (warmup) state, and then resumes from there with a new,
 * foreshortened, Rx warmup, in search of a new preamble. When this bit is set, the Sequence
 * Manager will instead return to idle state, and issue a SEQIRQ, after a
 * FilterFail or CRC failure.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_CTRL_STS_NO_RX_RECYCLE field. */
#define ZLL_RD_SEQ_CTRL_STS_NO_RX_RECYCLE(base) ((ZLL_SEQ_CTRL_STS_REG(base) & ZLL_SEQ_CTRL_STS_NO_RX_RECYCLE_MASK) >> ZLL_SEQ_CTRL_STS_NO_RX_RECYCLE_SHIFT)
#define ZLL_BRD_SEQ_CTRL_STS_NO_RX_RECYCLE(base) (BME_UBFX32(&ZLL_SEQ_CTRL_STS_REG(base), ZLL_SEQ_CTRL_STS_NO_RX_RECYCLE_SHIFT, ZLL_SEQ_CTRL_STS_NO_RX_RECYCLE_WIDTH))

/*! @brief Set the NO_RX_RECYCLE field to a new value. */
#define ZLL_WR_SEQ_CTRL_STS_NO_RX_RECYCLE(base, value) (ZLL_RMW_SEQ_CTRL_STS(base, ZLL_SEQ_CTRL_STS_NO_RX_RECYCLE_MASK, ZLL_SEQ_CTRL_STS_NO_RX_RECYCLE(value)))
#define ZLL_BWR_SEQ_CTRL_STS_NO_RX_RECYCLE(base, value) (BME_BFI32(&ZLL_SEQ_CTRL_STS_REG(base), ((uint32_t)(value) << ZLL_SEQ_CTRL_STS_NO_RX_RECYCLE_SHIFT), ZLL_SEQ_CTRL_STS_NO_RX_RECYCLE_SHIFT, ZLL_SEQ_CTRL_STS_NO_RX_RECYCLE_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_CTRL_STS, field FORCE_CRC_ERROR[6] (RW)
 *
 * Values:
 * - 0b0 - normal operation
 * - 0b1 - Force the next transmitted packet to have a CRC error
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_CTRL_STS_FORCE_CRC_ERROR field. */
#define ZLL_RD_SEQ_CTRL_STS_FORCE_CRC_ERROR(base) ((ZLL_SEQ_CTRL_STS_REG(base) & ZLL_SEQ_CTRL_STS_FORCE_CRC_ERROR_MASK) >> ZLL_SEQ_CTRL_STS_FORCE_CRC_ERROR_SHIFT)
#define ZLL_BRD_SEQ_CTRL_STS_FORCE_CRC_ERROR(base) (BME_UBFX32(&ZLL_SEQ_CTRL_STS_REG(base), ZLL_SEQ_CTRL_STS_FORCE_CRC_ERROR_SHIFT, ZLL_SEQ_CTRL_STS_FORCE_CRC_ERROR_WIDTH))

/*! @brief Set the FORCE_CRC_ERROR field to a new value. */
#define ZLL_WR_SEQ_CTRL_STS_FORCE_CRC_ERROR(base, value) (ZLL_RMW_SEQ_CTRL_STS(base, ZLL_SEQ_CTRL_STS_FORCE_CRC_ERROR_MASK, ZLL_SEQ_CTRL_STS_FORCE_CRC_ERROR(value)))
#define ZLL_BWR_SEQ_CTRL_STS_FORCE_CRC_ERROR(base, value) (BME_BFI32(&ZLL_SEQ_CTRL_STS_REG(base), ((uint32_t)(value) << ZLL_SEQ_CTRL_STS_FORCE_CRC_ERROR_SHIFT), ZLL_SEQ_CTRL_STS_FORCE_CRC_ERROR_SHIFT, ZLL_SEQ_CTRL_STS_FORCE_CRC_ERROR_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_CTRL_STS, field CONTINUOUS_EN[7] (RW)
 *
 * Continuous Mode Enable (Continuous TX or RX). Note: Dual PAN mode should not
 * be engaged in Continuous TX or RX modes.
 *
 * Values:
 * - 0b0 - normal operation
 * - 0b1 - Continuous TX or RX mode is enabled (depending on XCVSEQ setting).
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_CTRL_STS_CONTINUOUS_EN field. */
#define ZLL_RD_SEQ_CTRL_STS_CONTINUOUS_EN(base) ((ZLL_SEQ_CTRL_STS_REG(base) & ZLL_SEQ_CTRL_STS_CONTINUOUS_EN_MASK) >> ZLL_SEQ_CTRL_STS_CONTINUOUS_EN_SHIFT)
#define ZLL_BRD_SEQ_CTRL_STS_CONTINUOUS_EN(base) (BME_UBFX32(&ZLL_SEQ_CTRL_STS_REG(base), ZLL_SEQ_CTRL_STS_CONTINUOUS_EN_SHIFT, ZLL_SEQ_CTRL_STS_CONTINUOUS_EN_WIDTH))

/*! @brief Set the CONTINUOUS_EN field to a new value. */
#define ZLL_WR_SEQ_CTRL_STS_CONTINUOUS_EN(base, value) (ZLL_RMW_SEQ_CTRL_STS(base, ZLL_SEQ_CTRL_STS_CONTINUOUS_EN_MASK, ZLL_SEQ_CTRL_STS_CONTINUOUS_EN(value)))
#define ZLL_BWR_SEQ_CTRL_STS_CONTINUOUS_EN(base, value) (BME_BFI32(&ZLL_SEQ_CTRL_STS_REG(base), ((uint32_t)(value) << ZLL_SEQ_CTRL_STS_CONTINUOUS_EN_SHIFT), ZLL_SEQ_CTRL_STS_CONTINUOUS_EN_SHIFT, ZLL_SEQ_CTRL_STS_CONTINUOUS_EN_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_CTRL_STS, field XCVSEQ_ACTUAL[10:8] (RO)
 *
 * Reflects the programmed sequence that has been recognized by the Zigbee
 * Sequence Manager. Takes into account the fact that sequence-change commands from
 * software are ignored while a sequence is underway (see NEW_SEQ_INHIBIT).
 * Read-only bits.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_CTRL_STS_XCVSEQ_ACTUAL field. */
#define ZLL_RD_SEQ_CTRL_STS_XCVSEQ_ACTUAL(base) ((ZLL_SEQ_CTRL_STS_REG(base) & ZLL_SEQ_CTRL_STS_XCVSEQ_ACTUAL_MASK) >> ZLL_SEQ_CTRL_STS_XCVSEQ_ACTUAL_SHIFT)
#define ZLL_BRD_SEQ_CTRL_STS_XCVSEQ_ACTUAL(base) (BME_UBFX32(&ZLL_SEQ_CTRL_STS_REG(base), ZLL_SEQ_CTRL_STS_XCVSEQ_ACTUAL_SHIFT, ZLL_SEQ_CTRL_STS_XCVSEQ_ACTUAL_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_CTRL_STS, field SEQ_IDLE[11] (RO)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_CTRL_STS_SEQ_IDLE field. */
#define ZLL_RD_SEQ_CTRL_STS_SEQ_IDLE(base) ((ZLL_SEQ_CTRL_STS_REG(base) & ZLL_SEQ_CTRL_STS_SEQ_IDLE_MASK) >> ZLL_SEQ_CTRL_STS_SEQ_IDLE_SHIFT)
#define ZLL_BRD_SEQ_CTRL_STS_SEQ_IDLE(base) (BME_UBFX32(&ZLL_SEQ_CTRL_STS_REG(base), ZLL_SEQ_CTRL_STS_SEQ_IDLE_SHIFT, ZLL_SEQ_CTRL_STS_SEQ_IDLE_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_CTRL_STS, field NEW_SEQ_INHIBIT[12] (RO)
 *
 * When asserted, indicates that a new programmed autosequence has commenced
 * (TMR2 match has occurred if TMRTRIGEN=1). Once this bit is asserted, software is
 * blocked from commanding any "new" autosequences (other than Sequence I to
 * abort the current sequence), until the current sequence completes. Hardware will
 * ignore a sequence-change command from software while this bit is asserted.
 * Hardware will automatically deassert this bit once the sequence completes.
 * Read-only bit.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_CTRL_STS_NEW_SEQ_INHIBIT field. */
#define ZLL_RD_SEQ_CTRL_STS_NEW_SEQ_INHIBIT(base) ((ZLL_SEQ_CTRL_STS_REG(base) & ZLL_SEQ_CTRL_STS_NEW_SEQ_INHIBIT_MASK) >> ZLL_SEQ_CTRL_STS_NEW_SEQ_INHIBIT_SHIFT)
#define ZLL_BRD_SEQ_CTRL_STS_NEW_SEQ_INHIBIT(base) (BME_UBFX32(&ZLL_SEQ_CTRL_STS_REG(base), ZLL_SEQ_CTRL_STS_NEW_SEQ_INHIBIT_SHIFT, ZLL_SEQ_CTRL_STS_NEW_SEQ_INHIBIT_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_CTRL_STS, field RX_TIMEOUT_PENDING[13] (RO)
 *
 * when asserted, indicates that a TMR3 timeout (RX timeout) flag has been set
 * by Hardware, but the Sequence Manager has not yet aborted because an RX
 * operation is not currently underway. This would be the case, for example, during a
 * Sequence TR, if a TMR3 timeout were to occur during the transmit operation of
 * this sequence; the sequence would not be aborted by Hardware until the receive
 * operation begins. This bit will always be 0 if TC3TMOUT=0. Read-only bit.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_CTRL_STS_RX_TIMEOUT_PENDING field. */
#define ZLL_RD_SEQ_CTRL_STS_RX_TIMEOUT_PENDING(base) ((ZLL_SEQ_CTRL_STS_REG(base) & ZLL_SEQ_CTRL_STS_RX_TIMEOUT_PENDING_MASK) >> ZLL_SEQ_CTRL_STS_RX_TIMEOUT_PENDING_SHIFT)
#define ZLL_BRD_SEQ_CTRL_STS_RX_TIMEOUT_PENDING(base) (BME_UBFX32(&ZLL_SEQ_CTRL_STS_REG(base), ZLL_SEQ_CTRL_STS_RX_TIMEOUT_PENDING_SHIFT, ZLL_SEQ_CTRL_STS_RX_TIMEOUT_PENDING_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_CTRL_STS, field RX_MODE[14] (RO)
 *
 * when asserted, this Sequence Manager Output indicates that an RX operation is
 * in progress. An RX operation can be part of a complex transmit autosequence
 * such as a Sequence TR. CCA and ED operations are considered RX operations,
 * during which rx_mode is asserted. Read-only bit.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_CTRL_STS_RX_MODE field. */
#define ZLL_RD_SEQ_CTRL_STS_RX_MODE(base) ((ZLL_SEQ_CTRL_STS_REG(base) & ZLL_SEQ_CTRL_STS_RX_MODE_MASK) >> ZLL_SEQ_CTRL_STS_RX_MODE_SHIFT)
#define ZLL_BRD_SEQ_CTRL_STS_RX_MODE(base) (BME_UBFX32(&ZLL_SEQ_CTRL_STS_REG(base), ZLL_SEQ_CTRL_STS_RX_MODE_SHIFT, ZLL_SEQ_CTRL_STS_RX_MODE_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_CTRL_STS, field TMR2_SEQ_TRIG_ARMED[15] (RO)
 *
 * when asserted, indicates that TMR2 has been programmed and is "armed" to
 * trigger a new autosequence, when Zigbee Sequence Manager timer-triggering mode is
 * selected (i.e., TMRTRIGEN=1). When timer-triggering mode is selected, TMR2
 * must be re-programmed (using either T2CMP or T2PRIMECMP), in advance of each new
 * sequence. Once TMR2 is programmed, this bit will be asserted, and will remain
 * asserted until the new sequence commences (at TMR2 match). Hardware will
 * deassert this bit when the new sequence starts. When TMRTRIGEN=0, this bit should
 * be ignored. Read-only bit.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_CTRL_STS_TMR2_SEQ_TRIG_ARMED field. */
#define ZLL_RD_SEQ_CTRL_STS_TMR2_SEQ_TRIG_ARMED(base) ((ZLL_SEQ_CTRL_STS_REG(base) & ZLL_SEQ_CTRL_STS_TMR2_SEQ_TRIG_ARMED_MASK) >> ZLL_SEQ_CTRL_STS_TMR2_SEQ_TRIG_ARMED_SHIFT)
#define ZLL_BRD_SEQ_CTRL_STS_TMR2_SEQ_TRIG_ARMED(base) (BME_UBFX32(&ZLL_SEQ_CTRL_STS_REG(base), ZLL_SEQ_CTRL_STS_TMR2_SEQ_TRIG_ARMED_SHIFT, ZLL_SEQ_CTRL_STS_TMR2_SEQ_TRIG_ARMED_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_CTRL_STS, field SEQ_T_STATUS[21:16] (RO)
 *
 * Status of the just-completed (or ongoing) Sequence T or Sequence TR
 * autosequence. This register is valid at all times during, and after, the Sequence T or
 * Sequence TR. Not valid for other types of autosequences. This is a read-only
 * register. The bits of this register map to status, according to the following
 * table: [0] 1st CCA complete (CCABFRTX=1) [1] 2nd CCA complete (SLOTTED=1) [2]
 * Tx operation complete [3] Rx Rec ycle occurred (Sequence TR only) [4] Rx
 * operation complete (Sequence TR only) [5] TxAck operation complete(Sequence TR only)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_CTRL_STS_SEQ_T_STATUS field. */
#define ZLL_RD_SEQ_CTRL_STS_SEQ_T_STATUS(base) ((ZLL_SEQ_CTRL_STS_REG(base) & ZLL_SEQ_CTRL_STS_SEQ_T_STATUS_MASK) >> ZLL_SEQ_CTRL_STS_SEQ_T_STATUS_SHIFT)
#define ZLL_BRD_SEQ_CTRL_STS_SEQ_T_STATUS(base) (BME_UBFX32(&ZLL_SEQ_CTRL_STS_REG(base), ZLL_SEQ_CTRL_STS_SEQ_T_STATUS_SHIFT, ZLL_SEQ_CTRL_STS_SEQ_T_STATUS_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_CTRL_STS, field SW_ABORTED[24] (RO)
 *
 * when asserted, indicates that the autosequence has terminated due to an
 * Software abort. Software can abort any programmed autosequence by writing Sequence
 * I to XCVSEQ. This bit is valid at the SEQIRQ interrupt. Hardware will maintain
 * this bit asserted until the next autosequence commences. Read-only bit.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_CTRL_STS_SW_ABORTED field. */
#define ZLL_RD_SEQ_CTRL_STS_SW_ABORTED(base) ((ZLL_SEQ_CTRL_STS_REG(base) & ZLL_SEQ_CTRL_STS_SW_ABORTED_MASK) >> ZLL_SEQ_CTRL_STS_SW_ABORTED_SHIFT)
#define ZLL_BRD_SEQ_CTRL_STS_SW_ABORTED(base) (BME_UBFX32(&ZLL_SEQ_CTRL_STS_REG(base), ZLL_SEQ_CTRL_STS_SW_ABORTED_SHIFT, ZLL_SEQ_CTRL_STS_SW_ABORTED_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_CTRL_STS, field TC3_ABORTED[25] (RO)
 *
 * when asserted, indicates that the autosequence has terminated due to an TC3
 * (TMR3) timeout during a receive operation. This bit is valid at the SEQIRQ
 * interrupt. Hardware will maintain this bit asserted until the next autosequence
 * commences. Read-only bit.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_CTRL_STS_TC3_ABORTED field. */
#define ZLL_RD_SEQ_CTRL_STS_TC3_ABORTED(base) ((ZLL_SEQ_CTRL_STS_REG(base) & ZLL_SEQ_CTRL_STS_TC3_ABORTED_MASK) >> ZLL_SEQ_CTRL_STS_TC3_ABORTED_SHIFT)
#define ZLL_BRD_SEQ_CTRL_STS_TC3_ABORTED(base) (BME_UBFX32(&ZLL_SEQ_CTRL_STS_REG(base), ZLL_SEQ_CTRL_STS_TC3_ABORTED_SHIFT, ZLL_SEQ_CTRL_STS_TC3_ABORTED_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_CTRL_STS, field PLL_ABORTED[26] (RO)
 *
 * when asserted, indicates that the autosequence has terminated due to an PLL
 * unlock event. This bit is valid at the SEQIRQ interrupt. Hardware will maintain
 * this bit asserted until the next autosequence commences. Read-only bit.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_CTRL_STS_PLL_ABORTED field. */
#define ZLL_RD_SEQ_CTRL_STS_PLL_ABORTED(base) ((ZLL_SEQ_CTRL_STS_REG(base) & ZLL_SEQ_CTRL_STS_PLL_ABORTED_MASK) >> ZLL_SEQ_CTRL_STS_PLL_ABORTED_SHIFT)
#define ZLL_BRD_SEQ_CTRL_STS_PLL_ABORTED(base) (BME_UBFX32(&ZLL_SEQ_CTRL_STS_REG(base), ZLL_SEQ_CTRL_STS_PLL_ABORTED_SHIFT, ZLL_SEQ_CTRL_STS_PLL_ABORTED_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_ACKDELAY - ACK DELAY
 ******************************************************************************/

/*!
 * @brief ZLL_ACKDELAY - ACK DELAY (RW)
 *
 * Reset value: 0x00000007U
 */
/*!
 * @name Constants and macros for entire ZLL_ACKDELAY register
 */
/*@{*/
#define ZLL_RD_ACKDELAY(base)    (ZLL_ACKDELAY_REG(base))
#define ZLL_WR_ACKDELAY(base, value) (ZLL_ACKDELAY_REG(base) = (value))
#define ZLL_RMW_ACKDELAY(base, mask, value) (ZLL_WR_ACKDELAY(base, (ZLL_RD_ACKDELAY(base) & ~(mask)) | (value)))
#define ZLL_SET_ACKDELAY(base, value) (BME_OR32(&ZLL_ACKDELAY_REG(base), (uint32_t)(value)))
#define ZLL_CLR_ACKDELAY(base, value) (BME_AND32(&ZLL_ACKDELAY_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_ACKDELAY(base, value) (BME_XOR32(&ZLL_ACKDELAY_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_ACKDELAY bitfields
 */

/*!
 * @name Register ZLL_ACKDELAY, field ACKDELAY[5:0] (RW)
 *
 * Provides a fine-tune adjustment of the time delay between Rx warmdown and the
 * beginning of Tx warmup for an Tx Acknowledge packet. ACKDELAY register will
 * apply to both SLOTTED and UNSLOTTED TxAck, but only to TxAck (not T sequences).
 * This is a two's complement value. The minimum permissible value is -19
 * (0x2D). Values less than -19 will lead to unexpected results. Resolution = 2us.
 * Range = +/- 62us. Max ACKDELAY = 0x1F.Min ACKDELAY = 0x2D.
 */
/*@{*/
/*! @brief Read current value of the ZLL_ACKDELAY_ACKDELAY field. */
#define ZLL_RD_ACKDELAY_ACKDELAY(base) ((ZLL_ACKDELAY_REG(base) & ZLL_ACKDELAY_ACKDELAY_MASK) >> ZLL_ACKDELAY_ACKDELAY_SHIFT)
#define ZLL_BRD_ACKDELAY_ACKDELAY(base) (BME_UBFX32(&ZLL_ACKDELAY_REG(base), ZLL_ACKDELAY_ACKDELAY_SHIFT, ZLL_ACKDELAY_ACKDELAY_WIDTH))

/*! @brief Set the ACKDELAY field to a new value. */
#define ZLL_WR_ACKDELAY_ACKDELAY(base, value) (ZLL_RMW_ACKDELAY(base, ZLL_ACKDELAY_ACKDELAY_MASK, ZLL_ACKDELAY_ACKDELAY(value)))
#define ZLL_BWR_ACKDELAY_ACKDELAY(base, value) (BME_BFI32(&ZLL_ACKDELAY_REG(base), ((uint32_t)(value) << ZLL_ACKDELAY_ACKDELAY_SHIFT), ZLL_ACKDELAY_ACKDELAY_SHIFT, ZLL_ACKDELAY_ACKDELAY_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_ACKDELAY, field TXDELAY[13:8] (RW)
 *
 * Provides a fine-tune adjustment of the time delay between post-CCA Rx
 * warm-down and the beginning of Tx warm-up for an Tx (non-Ack) packet. TXDELAY
 * register will apply in both SLOTTED and UNSLOTTED modes, but only to T sequences
 * (e.g., T, TR, and T(R) ), not TxAck operations. This is a two's complement value.
 * The minimum permissible value is -19 (0x2D). Values less than -19 will lead to
 * unexpected results. Resolution = 2us. Range = +/- 62us. Max TXDELAY =
 * 0x1F.Min TXDELAY = 0x2D.
 */
/*@{*/
/*! @brief Read current value of the ZLL_ACKDELAY_TXDELAY field. */
#define ZLL_RD_ACKDELAY_TXDELAY(base) ((ZLL_ACKDELAY_REG(base) & ZLL_ACKDELAY_TXDELAY_MASK) >> ZLL_ACKDELAY_TXDELAY_SHIFT)
#define ZLL_BRD_ACKDELAY_TXDELAY(base) (BME_UBFX32(&ZLL_ACKDELAY_REG(base), ZLL_ACKDELAY_TXDELAY_SHIFT, ZLL_ACKDELAY_TXDELAY_WIDTH))

/*! @brief Set the TXDELAY field to a new value. */
#define ZLL_WR_ACKDELAY_TXDELAY(base, value) (ZLL_RMW_ACKDELAY(base, ZLL_ACKDELAY_TXDELAY_MASK, ZLL_ACKDELAY_TXDELAY(value)))
#define ZLL_BWR_ACKDELAY_TXDELAY(base, value) (BME_BFI32(&ZLL_ACKDELAY_REG(base), ((uint32_t)(value) << ZLL_ACKDELAY_TXDELAY_SHIFT), ZLL_ACKDELAY_TXDELAY_SHIFT, ZLL_ACKDELAY_TXDELAY_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_FILTERFAIL_CODE - FILTER FAIL CODE
 ******************************************************************************/

/*!
 * @brief ZLL_FILTERFAIL_CODE - FILTER FAIL CODE (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ZLL_FILTERFAIL_CODE register
 */
/*@{*/
#define ZLL_RD_FILTERFAIL_CODE(base) (ZLL_FILTERFAIL_CODE_REG(base))
#define ZLL_WR_FILTERFAIL_CODE(base, value) (ZLL_FILTERFAIL_CODE_REG(base) = (value))
#define ZLL_RMW_FILTERFAIL_CODE(base, mask, value) (ZLL_WR_FILTERFAIL_CODE(base, (ZLL_RD_FILTERFAIL_CODE(base) & ~(mask)) | (value)))
#define ZLL_SET_FILTERFAIL_CODE(base, value) (BME_OR32(&ZLL_FILTERFAIL_CODE_REG(base), (uint32_t)(value)))
#define ZLL_CLR_FILTERFAIL_CODE(base, value) (BME_AND32(&ZLL_FILTERFAIL_CODE_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_FILTERFAIL_CODE(base, value) (BME_XOR32(&ZLL_FILTERFAIL_CODE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_FILTERFAIL_CODE bitfields
 */

/*!
 * @name Register ZLL_FILTERFAIL_CODE, field FILTERFAIL_CODE[9:0] (RO)
 *
 * Code inidicating what condition, or conditions, caused the Packet Processor
 * to reject the just-received packet. The bits of FILTERFAIL_CODE indicate the
 * reason for packet rejection according to the table below: FILTERFAIL CODE BIT
 * REASON FOR FILTERFAIL [0] Fails Stage 1 Frame Length Checking (FL < 5 or FL >
 * MAXFRAMELENGTH) Note: FL < 3 will not generate an SFD, so this bit will not be
 * set [1] Fails Stage 1 Section 7.2.1.1.6 or Section 7.2.1.1.8 Checking
 * (DST_ADDR_MODE or SRC_ADDR_MODE = 1) [2] Fails Stage 1 Section 7.2.1.1.5 Checking
 * (Illegal PAN_ID_COMPRESSION Usage) [3] Fails Stage 1 Frame Version Checking [4]
 * Fails Stage 2 Auto-RxAck Checking (Illegal Ack Frame Format in Sequence TR) [5]
 * Fails Stage 2 Frame Type Checking (Incorrect Frame Filter Bit setting) [6]
 * Fails Stage 2 Frame Length Checking (Illegal Beacon, Data, or Cmd FL) [7] Fails
 * Stage 2 Addressing Mode Checking (Illegal Addressing Mode for Beacon, Data, OR
 * Cmd) [8] Fails Stage 2 Sequence Number Matching (Sequence TR Only) [9] Fails
 * Stage 2 PAN ID or Address Checking (Beacon, Data, or Cmd)
 */
/*@{*/
/*! @brief Read current value of the ZLL_FILTERFAIL_CODE_FILTERFAIL_CODE field. */
#define ZLL_RD_FILTERFAIL_CODE_FILTERFAIL_CODE(base) ((ZLL_FILTERFAIL_CODE_REG(base) & ZLL_FILTERFAIL_CODE_FILTERFAIL_CODE_MASK) >> ZLL_FILTERFAIL_CODE_FILTERFAIL_CODE_SHIFT)
#define ZLL_BRD_FILTERFAIL_CODE_FILTERFAIL_CODE(base) (BME_UBFX32(&ZLL_FILTERFAIL_CODE_REG(base), ZLL_FILTERFAIL_CODE_FILTERFAIL_CODE_SHIFT, ZLL_FILTERFAIL_CODE_FILTERFAIL_CODE_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_FILTERFAIL_CODE, field FILTERFAIL_PAN_SEL[15] (RW)
 *
 * Values:
 * - 0b0 - FILTERFAIL_CODE[9:0] will report the FILTERFAIL status of PAN0
 * - 0b1 - FILTERFAIL_CODE[9:0] will report the FILTERFAIL status of PAN1
 */
/*@{*/
/*! @brief Read current value of the ZLL_FILTERFAIL_CODE_FILTERFAIL_PAN_SEL field. */
#define ZLL_RD_FILTERFAIL_CODE_FILTERFAIL_PAN_SEL(base) ((ZLL_FILTERFAIL_CODE_REG(base) & ZLL_FILTERFAIL_CODE_FILTERFAIL_PAN_SEL_MASK) >> ZLL_FILTERFAIL_CODE_FILTERFAIL_PAN_SEL_SHIFT)
#define ZLL_BRD_FILTERFAIL_CODE_FILTERFAIL_PAN_SEL(base) (BME_UBFX32(&ZLL_FILTERFAIL_CODE_REG(base), ZLL_FILTERFAIL_CODE_FILTERFAIL_PAN_SEL_SHIFT, ZLL_FILTERFAIL_CODE_FILTERFAIL_PAN_SEL_WIDTH))

/*! @brief Set the FILTERFAIL_PAN_SEL field to a new value. */
#define ZLL_WR_FILTERFAIL_CODE_FILTERFAIL_PAN_SEL(base, value) (ZLL_RMW_FILTERFAIL_CODE(base, ZLL_FILTERFAIL_CODE_FILTERFAIL_PAN_SEL_MASK, ZLL_FILTERFAIL_CODE_FILTERFAIL_PAN_SEL(value)))
#define ZLL_BWR_FILTERFAIL_CODE_FILTERFAIL_PAN_SEL(base, value) (BME_BFI32(&ZLL_FILTERFAIL_CODE_REG(base), ((uint32_t)(value) << ZLL_FILTERFAIL_CODE_FILTERFAIL_PAN_SEL_SHIFT), ZLL_FILTERFAIL_CODE_FILTERFAIL_PAN_SEL_SHIFT, ZLL_FILTERFAIL_CODE_FILTERFAIL_PAN_SEL_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_RX_WTR_MARK - RECEIVE WATER MARK
 ******************************************************************************/

/*!
 * @brief ZLL_RX_WTR_MARK - RECEIVE WATER MARK (RW)
 *
 * Reset value: 0x000000FFU
 *
 * Receive byte count (octets) needed to trigger a RXWTRMRKIRQ interrupt . A
 * setting of 0 generates an interrupt at end of the Frame Length field (first byte
 * after SFD). A setting of 1 generates an interrupt after the first byte of
 * Frame Control Field, etc.
 */
/*!
 * @name Constants and macros for entire ZLL_RX_WTR_MARK register
 */
/*@{*/
#define ZLL_RD_RX_WTR_MARK(base) (ZLL_RX_WTR_MARK_REG(base))
#define ZLL_WR_RX_WTR_MARK(base, value) (ZLL_RX_WTR_MARK_REG(base) = (value))
#define ZLL_RMW_RX_WTR_MARK(base, mask, value) (ZLL_WR_RX_WTR_MARK(base, (ZLL_RD_RX_WTR_MARK(base) & ~(mask)) | (value)))
#define ZLL_SET_RX_WTR_MARK(base, value) (BME_OR32(&ZLL_RX_WTR_MARK_REG(base), (uint32_t)(value)))
#define ZLL_CLR_RX_WTR_MARK(base, value) (BME_AND32(&ZLL_RX_WTR_MARK_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_RX_WTR_MARK(base, value) (BME_XOR32(&ZLL_RX_WTR_MARK_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_RX_WTR_MARK bitfields
 */

/*!
 * @name Register ZLL_RX_WTR_MARK, field RX_WTR_MARK[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ZLL_RX_WTR_MARK_RX_WTR_MARK field. */
#define ZLL_RD_RX_WTR_MARK_RX_WTR_MARK(base) ((ZLL_RX_WTR_MARK_REG(base) & ZLL_RX_WTR_MARK_RX_WTR_MARK_MASK) >> ZLL_RX_WTR_MARK_RX_WTR_MARK_SHIFT)
#define ZLL_BRD_RX_WTR_MARK_RX_WTR_MARK(base) (BME_UBFX32(&ZLL_RX_WTR_MARK_REG(base), ZLL_RX_WTR_MARK_RX_WTR_MARK_SHIFT, ZLL_RX_WTR_MARK_RX_WTR_MARK_WIDTH))

/*! @brief Set the RX_WTR_MARK field to a new value. */
#define ZLL_WR_RX_WTR_MARK_RX_WTR_MARK(base, value) (ZLL_RMW_RX_WTR_MARK(base, ZLL_RX_WTR_MARK_RX_WTR_MARK_MASK, ZLL_RX_WTR_MARK_RX_WTR_MARK(value)))
#define ZLL_BWR_RX_WTR_MARK_RX_WTR_MARK(base, value) (BME_BFI32(&ZLL_RX_WTR_MARK_REG(base), ((uint32_t)(value) << ZLL_RX_WTR_MARK_RX_WTR_MARK_SHIFT), ZLL_RX_WTR_MARK_RX_WTR_MARK_SHIFT, ZLL_RX_WTR_MARK_RX_WTR_MARK_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_SLOT_PRELOAD - SLOT PRELOAD
 ******************************************************************************/

/*!
 * @brief ZLL_SLOT_PRELOAD - SLOT PRELOAD (RW)
 *
 * Reset value: 0x00000074U
 *
 * This register represents the number that gets loaded into the slot_timer at
 * SFD detect, which ultimately determines when the next slot boundary will occur.
 * Due to processing delays within the analog front-end and digital modem, the
 * point at which SFD is detected by the modem, is delayed relative to
 * over-the-air timing. Since this timing may not be known for coconino until actual
 * silicon, and since this is such a critical timing parameter for slotted operations,
 * it has been made programmable. This timing parameter is critical for the
 * Sequence R autosequence in slotted mode, when an automatic TxAck is required.
 */
/*!
 * @name Constants and macros for entire ZLL_SLOT_PRELOAD register
 */
/*@{*/
#define ZLL_RD_SLOT_PRELOAD(base) (ZLL_SLOT_PRELOAD_REG(base))
#define ZLL_WR_SLOT_PRELOAD(base, value) (ZLL_SLOT_PRELOAD_REG(base) = (value))
#define ZLL_RMW_SLOT_PRELOAD(base, mask, value) (ZLL_WR_SLOT_PRELOAD(base, (ZLL_RD_SLOT_PRELOAD(base) & ~(mask)) | (value)))
#define ZLL_SET_SLOT_PRELOAD(base, value) (BME_OR32(&ZLL_SLOT_PRELOAD_REG(base), (uint32_t)(value)))
#define ZLL_CLR_SLOT_PRELOAD(base, value) (BME_AND32(&ZLL_SLOT_PRELOAD_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_SLOT_PRELOAD(base, value) (BME_XOR32(&ZLL_SLOT_PRELOAD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_SLOT_PRELOAD bitfields
 */

/*!
 * @name Register ZLL_SLOT_PRELOAD, field SLOT_PRELOAD[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SLOT_PRELOAD_SLOT_PRELOAD field. */
#define ZLL_RD_SLOT_PRELOAD_SLOT_PRELOAD(base) ((ZLL_SLOT_PRELOAD_REG(base) & ZLL_SLOT_PRELOAD_SLOT_PRELOAD_MASK) >> ZLL_SLOT_PRELOAD_SLOT_PRELOAD_SHIFT)
#define ZLL_BRD_SLOT_PRELOAD_SLOT_PRELOAD(base) (BME_UBFX32(&ZLL_SLOT_PRELOAD_REG(base), ZLL_SLOT_PRELOAD_SLOT_PRELOAD_SHIFT, ZLL_SLOT_PRELOAD_SLOT_PRELOAD_WIDTH))

/*! @brief Set the SLOT_PRELOAD field to a new value. */
#define ZLL_WR_SLOT_PRELOAD_SLOT_PRELOAD(base, value) (ZLL_RMW_SLOT_PRELOAD(base, ZLL_SLOT_PRELOAD_SLOT_PRELOAD_MASK, ZLL_SLOT_PRELOAD_SLOT_PRELOAD(value)))
#define ZLL_BWR_SLOT_PRELOAD_SLOT_PRELOAD(base, value) (BME_BFI32(&ZLL_SLOT_PRELOAD_REG(base), ((uint32_t)(value) << ZLL_SLOT_PRELOAD_SLOT_PRELOAD_SHIFT), ZLL_SLOT_PRELOAD_SLOT_PRELOAD_SHIFT, ZLL_SLOT_PRELOAD_SLOT_PRELOAD_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_SEQ_STATE - ZIGBEE SEQUENCE STATE
 ******************************************************************************/

/*!
 * @brief ZLL_SEQ_STATE - ZIGBEE SEQUENCE STATE (RO)
 *
 * Reset value: 0x00000000U
 *
 * Zigbee Sequence State Register
 */
/*!
 * @name Constants and macros for entire ZLL_SEQ_STATE register
 */
/*@{*/
#define ZLL_RD_SEQ_STATE(base)   (ZLL_SEQ_STATE_REG(base))
/*@}*/

/*
 * Constants & macros for individual ZLL_SEQ_STATE bitfields
 */

/*!
 * @name Register ZLL_SEQ_STATE, field SEQ_STATE[4:0] (RO)
 *
 * This read-only register reflects the instantaneous state of the Zigbee
 * Sequence Manager
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_STATE_SEQ_STATE field. */
#define ZLL_RD_SEQ_STATE_SEQ_STATE(base) ((ZLL_SEQ_STATE_REG(base) & ZLL_SEQ_STATE_SEQ_STATE_MASK) >> ZLL_SEQ_STATE_SEQ_STATE_SHIFT)
#define ZLL_BRD_SEQ_STATE_SEQ_STATE(base) (BME_UBFX32(&ZLL_SEQ_STATE_REG(base), ZLL_SEQ_STATE_SEQ_STATE_SHIFT, ZLL_SEQ_STATE_SEQ_STATE_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_STATE, field PREAMBLE_DET[8] (RO)
 *
 * 0: an 802.15.4 preamble has not been detected. 1: An 802.15.4 preamble has
 * been detected. The function of this read-only bit depends on the setting of the
 * LATCH_PREAMBLE bit of the SEQ_MGR_CTRL register. If LATCH_PREAMBLE=1, any
 * preamble detection during a Sequence R (even false detections), will set this bit,
 * and it will remain set (sticky) until the start of the next autosequence. If
 * LATCH_PREAMBLE=0, this bit is not sticky, and reflects the instantaneous state
 * of the preamble-detection circuit; for false preambles, the bit will clear
 * when the false nature of the preamble is recognized. When LATCH_PREAMBLE=0,
 * PREAMBLE_DET should be considered valid only while an autosequence is underway.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_STATE_PREAMBLE_DET field. */
#define ZLL_RD_SEQ_STATE_PREAMBLE_DET(base) ((ZLL_SEQ_STATE_REG(base) & ZLL_SEQ_STATE_PREAMBLE_DET_MASK) >> ZLL_SEQ_STATE_PREAMBLE_DET_SHIFT)
#define ZLL_BRD_SEQ_STATE_PREAMBLE_DET(base) (BME_UBFX32(&ZLL_SEQ_STATE_REG(base), ZLL_SEQ_STATE_PREAMBLE_DET_SHIFT, ZLL_SEQ_STATE_PREAMBLE_DET_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_STATE, field SFD_DET[9] (RO)
 *
 * 0: an 802.15.4 preamble-and-SFD have not been detected. 1: An 802.15.4
 * preamble-and-SFD have been detected. The function of this read-only bit depends on
 * the setting of the LATCH_PREAMBLE bit of the SEQ_MGR_CTRL register. If
 * LATCH_PREAMBLE=1, any preamble-and-SFD detection during a Sequence R (even false
 * detections), will set this bit, and it will remain set (sticky) until the start of
 * the next autosequence. If LATCH_PREAMBLE=0, this bit is not sticky, and
 * reflects the instantaneous state of the SFD-detection circuit; for false SFD, the
 * bit will clear when the false nature of the SFD is recognized (i.e., an RX
 * recycle). When LATCH_PREAMBLE=0, SFD_DET should be considered valid only while an
 * autosequence is underway.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_STATE_SFD_DET field. */
#define ZLL_RD_SEQ_STATE_SFD_DET(base) ((ZLL_SEQ_STATE_REG(base) & ZLL_SEQ_STATE_SFD_DET_MASK) >> ZLL_SEQ_STATE_SFD_DET_SHIFT)
#define ZLL_BRD_SEQ_STATE_SFD_DET(base) (BME_UBFX32(&ZLL_SEQ_STATE_REG(base), ZLL_SEQ_STATE_SFD_DET_SHIFT, ZLL_SEQ_STATE_SFD_DET_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_STATE, field FILTERFAIL_FLAG_SEL[10] (RO)
 *
 * 0: The incoming, or just-received packet, passed packet filtering rules. 1:
 * The incoming, or just-received packet, failed packet filtering rules When
 * FILTERFAIL_FLAG_SEL=1, a non-zero FILTERFAIL_CODE is present (see FILTERFAIL_CODE
 * registers). In Dual PAN mode, FILTERFAIL_FLAG_SEL applies to either or both
 * networks, as follows: A: If PAN0 and PAN1 occupy different channels and
 * CURRENT_NETWORK=0, FILTERFAIL_FLAG_SEL applies to PAN0. B: If PAN0 and PAN1 occupy
 * different channels and CURRENT_NETWORK=1, FILTERFAIL_FLAG_SEL applies to PAN1. C:
 * If PAN0 and PAN1 occupy the same channel, FILTERFAIL_FLAG_SEL is the logical
 * 'AND' of the individual PANs' FILTERFAIL_FLAG bits.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_STATE_FILTERFAIL_FLAG_SEL field. */
#define ZLL_RD_SEQ_STATE_FILTERFAIL_FLAG_SEL(base) ((ZLL_SEQ_STATE_REG(base) & ZLL_SEQ_STATE_FILTERFAIL_FLAG_SEL_MASK) >> ZLL_SEQ_STATE_FILTERFAIL_FLAG_SEL_SHIFT)
#define ZLL_BRD_SEQ_STATE_FILTERFAIL_FLAG_SEL(base) (BME_UBFX32(&ZLL_SEQ_STATE_REG(base), ZLL_SEQ_STATE_FILTERFAIL_FLAG_SEL_SHIFT, ZLL_SEQ_STATE_FILTERFAIL_FLAG_SEL_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_STATE, field CRCVALID[11] (RO)
 *
 * Code Redundancy Check Valid: This flag indicates the compare result between
 * the FCS field, in the most-recently received frame, and the internally
 * calculated CRC value. This flag is cleared at next receiver warm up.
 *
 * Values:
 * - 0b0 - Rx FCS != calculated CRC (incorrect)
 * - 0b1 - Rx FCS = calculated CRC (correct)
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_STATE_CRCVALID field. */
#define ZLL_RD_SEQ_STATE_CRCVALID(base) ((ZLL_SEQ_STATE_REG(base) & ZLL_SEQ_STATE_CRCVALID_MASK) >> ZLL_SEQ_STATE_CRCVALID_SHIFT)
#define ZLL_BRD_SEQ_STATE_CRCVALID(base) (BME_UBFX32(&ZLL_SEQ_STATE_REG(base), ZLL_SEQ_STATE_CRCVALID_SHIFT, ZLL_SEQ_STATE_CRCVALID_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_STATE, field PLL_ABORT[12] (RO)
 *
 * This bit reflects the instantaneous, consolidated status of the PLL unlock
 * detection circuits; if asserted high, indicates that at least one of the three
 * PLL unlock detect mechanisms is currently reporting an unlocked condition.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_STATE_PLL_ABORT field. */
#define ZLL_RD_SEQ_STATE_PLL_ABORT(base) ((ZLL_SEQ_STATE_REG(base) & ZLL_SEQ_STATE_PLL_ABORT_MASK) >> ZLL_SEQ_STATE_PLL_ABORT_SHIFT)
#define ZLL_BRD_SEQ_STATE_PLL_ABORT(base) (BME_UBFX32(&ZLL_SEQ_STATE_REG(base), ZLL_SEQ_STATE_PLL_ABORT_SHIFT, ZLL_SEQ_STATE_PLL_ABORT_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_STATE, field PLL_ABORTED[13] (RO)
 *
 * when asserted, indicates that the autosequence has terminated due to an PLL
 * unlock event. This bit is valid at the SEQIRQ interrupt. Hardware will maintain
 * this bit asserted until the next autosequence commences. This bit is a
 * read-only mirror of the register bit of the same name in the ABORT_STS
 * (SEQ_CTRL_STS) register.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_STATE_PLL_ABORTED field. */
#define ZLL_RD_SEQ_STATE_PLL_ABORTED(base) ((ZLL_SEQ_STATE_REG(base) & ZLL_SEQ_STATE_PLL_ABORTED_MASK) >> ZLL_SEQ_STATE_PLL_ABORTED_SHIFT)
#define ZLL_BRD_SEQ_STATE_PLL_ABORTED(base) (BME_UBFX32(&ZLL_SEQ_STATE_REG(base), ZLL_SEQ_STATE_PLL_ABORTED_SHIFT, ZLL_SEQ_STATE_PLL_ABORTED_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_STATE, field RX_BYTE_COUNT[23:16] (RO)
 *
 * During packet reception, this read-only register is a real-time indicator of
 * the number of bytes that have been received. This register will read 0 until
 * SFD and PHR have been received. It will read 1 after the first byte of Frame
 * Control Field has been received, etc.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_STATE_RX_BYTE_COUNT field. */
#define ZLL_RD_SEQ_STATE_RX_BYTE_COUNT(base) ((ZLL_SEQ_STATE_REG(base) & ZLL_SEQ_STATE_RX_BYTE_COUNT_MASK) >> ZLL_SEQ_STATE_RX_BYTE_COUNT_SHIFT)
#define ZLL_BRD_SEQ_STATE_RX_BYTE_COUNT(base) (BME_UBFX32(&ZLL_SEQ_STATE_REG(base), ZLL_SEQ_STATE_RX_BYTE_COUNT_SHIFT, ZLL_SEQ_STATE_RX_BYTE_COUNT_WIDTH))
/*@}*/

/*!
 * @name Register ZLL_SEQ_STATE, field CCCA_BUSY_CNT[29:24] (RO)
 *
 * For Sequence CCCA mode only, this register indicates the number of "busy" CCA
 * attempts which occurred during the autosequence, before the channel was
 * detected to be idle. This register can also be read in real-time (during the
 * autosequence) to determine how many busy CCA attempts have occurred to that point.
 * The register saturates at 63 (i.e, if there are more than 63 busy attempts, the
 * register will continue to read 63). This register is automatically cleared to
 * zero by hardware when the next autosequence commences. Read-only register.
 */
/*@{*/
/*! @brief Read current value of the ZLL_SEQ_STATE_CCCA_BUSY_CNT field. */
#define ZLL_RD_SEQ_STATE_CCCA_BUSY_CNT(base) ((ZLL_SEQ_STATE_REG(base) & ZLL_SEQ_STATE_CCCA_BUSY_CNT_MASK) >> ZLL_SEQ_STATE_CCCA_BUSY_CNT_SHIFT)
#define ZLL_BRD_SEQ_STATE_CCCA_BUSY_CNT(base) (BME_UBFX32(&ZLL_SEQ_STATE_REG(base), ZLL_SEQ_STATE_CCCA_BUSY_CNT_SHIFT, ZLL_SEQ_STATE_CCCA_BUSY_CNT_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_TMR_PRESCALE - TIMER PRESCALER
 ******************************************************************************/

/*!
 * @brief ZLL_TMR_PRESCALE - TIMER PRESCALER (RW)
 *
 * Reset value: 0x00000003U
 *
 * Timer Prescaler
 */
/*!
 * @name Constants and macros for entire ZLL_TMR_PRESCALE register
 */
/*@{*/
#define ZLL_RD_TMR_PRESCALE(base) (ZLL_TMR_PRESCALE_REG(base))
#define ZLL_WR_TMR_PRESCALE(base, value) (ZLL_TMR_PRESCALE_REG(base) = (value))
#define ZLL_RMW_TMR_PRESCALE(base, mask, value) (ZLL_WR_TMR_PRESCALE(base, (ZLL_RD_TMR_PRESCALE(base) & ~(mask)) | (value)))
#define ZLL_SET_TMR_PRESCALE(base, value) (BME_OR32(&ZLL_TMR_PRESCALE_REG(base), (uint32_t)(value)))
#define ZLL_CLR_TMR_PRESCALE(base, value) (BME_AND32(&ZLL_TMR_PRESCALE_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_TMR_PRESCALE(base, value) (BME_XOR32(&ZLL_TMR_PRESCALE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_TMR_PRESCALE bitfields
 */

/*!
 * @name Register ZLL_TMR_PRESCALE, field TMR_PRESCALE[2:0] (RW)
 *
 * Timer Prescaler. Establishes the Event Timer clock rate, (maximum timer
 * duration)
 *
 * Values:
 * - 0b000 - Reserved
 * - 0b001 - Reserved
 * - 0b010 - 500kHz (33.55 S)
 * - 0b011 - 250kHz (67.11 S) -- default
 * - 0b100 - 125kHz (134.22 S)
 * - 0b101 - 62.5kHz (268.44 S)
 * - 0b110 - 31.25kHz (536.87 S)
 * - 0b111 - 15.625kHz (1073.74 S)
 */
/*@{*/
/*! @brief Read current value of the ZLL_TMR_PRESCALE_TMR_PRESCALE field. */
#define ZLL_RD_TMR_PRESCALE_TMR_PRESCALE(base) ((ZLL_TMR_PRESCALE_REG(base) & ZLL_TMR_PRESCALE_TMR_PRESCALE_MASK) >> ZLL_TMR_PRESCALE_TMR_PRESCALE_SHIFT)
#define ZLL_BRD_TMR_PRESCALE_TMR_PRESCALE(base) (BME_UBFX32(&ZLL_TMR_PRESCALE_REG(base), ZLL_TMR_PRESCALE_TMR_PRESCALE_SHIFT, ZLL_TMR_PRESCALE_TMR_PRESCALE_WIDTH))

/*! @brief Set the TMR_PRESCALE field to a new value. */
#define ZLL_WR_TMR_PRESCALE_TMR_PRESCALE(base, value) (ZLL_RMW_TMR_PRESCALE(base, ZLL_TMR_PRESCALE_TMR_PRESCALE_MASK, ZLL_TMR_PRESCALE_TMR_PRESCALE(value)))
#define ZLL_BWR_TMR_PRESCALE_TMR_PRESCALE(base, value) (BME_BFI32(&ZLL_TMR_PRESCALE_REG(base), ((uint32_t)(value) << ZLL_TMR_PRESCALE_TMR_PRESCALE_SHIFT), ZLL_TMR_PRESCALE_TMR_PRESCALE_SHIFT, ZLL_TMR_PRESCALE_TMR_PRESCALE_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_LENIENCY_LSB - LENIENCY LSB
 ******************************************************************************/

/*!
 * @brief ZLL_LENIENCY_LSB - LENIENCY LSB (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Packet Processor performs filtering on all received packets, in order to
 * determine whether the packet is intended for the device. The packet filtering
 * is based on rules. In case any of the packet filtering rules need to be
 * overriden, a 40-bit "leniency register" has been provided. When the leniency
 * register is programmed to its default value (0), all hardware packet filtering rules
 * are in effect, and if an incoming packet violates any rule, a "Filter Fail"
 * will occur (packet will be rejected). When a given leniency register bit is
 * asserted, the packet filtering rule assigned to that bit will not be in effect,
 * and if any incoming packet violates that rule (but no other rules), then a
 * "Filter Fail" will not occur, the packet will not be rejected, the packet will be
 * treated as "intended for the device", and software will be notified of the
 * incoming packet. The table below shows the assignment of leniency bits to packet
 * filtering rules.
 */
/*!
 * @name Constants and macros for entire ZLL_LENIENCY_LSB register
 */
/*@{*/
#define ZLL_RD_LENIENCY_LSB(base) (ZLL_LENIENCY_LSB_REG(base))
#define ZLL_WR_LENIENCY_LSB(base, value) (ZLL_LENIENCY_LSB_REG(base) = (value))
#define ZLL_RMW_LENIENCY_LSB(base, mask, value) (ZLL_WR_LENIENCY_LSB(base, (ZLL_RD_LENIENCY_LSB(base) & ~(mask)) | (value)))
#define ZLL_SET_LENIENCY_LSB(base, value) (BME_OR32(&ZLL_LENIENCY_LSB_REG(base), (uint32_t)(value)))
#define ZLL_CLR_LENIENCY_LSB(base, value) (BME_AND32(&ZLL_LENIENCY_LSB_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_LENIENCY_LSB(base, value) (BME_XOR32(&ZLL_LENIENCY_LSB_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * ZLL_LENIENCY_MSB - LENIENCY MSB
 ******************************************************************************/

/*!
 * @brief ZLL_LENIENCY_MSB - LENIENCY MSB (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Packet Processor performs filtering on all received packets, in order to
 * determine whether the packet is intended for the device. The packet filtering
 * is based on rules. In case any of the packet filtering rules need to be
 * overriden, a 40-bit "leniency register" has been provided. When the leniency
 * register is programmed to its default value (0), all hardware packet filtering rules
 * are in effect, and if an incoming packet violates any rule, a "Filter Fail"
 * will occur (packet will be rejected). When a given leniency register bit is
 * asserted, the packet filtering rule assigned to that bit will not be in effect,
 * and if any incoming packet violates that rule (but no other rules), then a
 * "Filter Fail" will not occur, the packet will not be rejected, the packet will be
 * treated as "intended for the device", and software will be notified of the
 * incoming packet. The table below shows the assignment of leniency bits to packet
 * filtering rules.
 */
/*!
 * @name Constants and macros for entire ZLL_LENIENCY_MSB register
 */
/*@{*/
#define ZLL_RD_LENIENCY_MSB(base) (ZLL_LENIENCY_MSB_REG(base))
#define ZLL_WR_LENIENCY_MSB(base, value) (ZLL_LENIENCY_MSB_REG(base) = (value))
#define ZLL_RMW_LENIENCY_MSB(base, mask, value) (ZLL_WR_LENIENCY_MSB(base, (ZLL_RD_LENIENCY_MSB(base) & ~(mask)) | (value)))
#define ZLL_SET_LENIENCY_MSB(base, value) (BME_OR32(&ZLL_LENIENCY_MSB_REG(base), (uint32_t)(value)))
#define ZLL_CLR_LENIENCY_MSB(base, value) (BME_AND32(&ZLL_LENIENCY_MSB_REG(base), (uint32_t)(~(value))))
#define ZLL_TOG_LENIENCY_MSB(base, value) (BME_XOR32(&ZLL_LENIENCY_MSB_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ZLL_LENIENCY_MSB bitfields
 */

/*!
 * @name Register ZLL_LENIENCY_MSB, field LENIENCY_REGISTER[7:0] (RW)
 *
 * LENIENCY BIT PACKET FILTERING RULE OVERRIDDEN leniency[32] Override Stage 2
 * Short Addr Filter for
 * DST_ADDR_MODE_SHORT/SRC_ADDR_MODE_LONG/NO_PAN_ID_COMPRESSION (Data and MAC Command Only) leniency[33] Override Stage 2 PAN ID Filter
 * for DST_ADDR_MODE_LONG/SRC_ADDR_MODE_SHORT/NO_PAN_ID_COMPRESSION (Beacon Only)
 * leniency[34] Override Stage 2 PAN ID Filter for
 * DST_ADDR_MODE_LONG/SRC_ADDR_MODE_SHORT/NO_PAN_ID_COMPRESSI ON (Data and MAC Command Only) leniency[35]
 * Override Stage 2 Long Addr Filter for
 * DST_ADDR_MODE_LONG/SRC_ADDR_MODE_SHORT/NO_PAN_ID_COMPRESSION (Data and MAC Command Only) leniency[36] Override Stage 2 PAN
 * ID Filter for DST_ADDR_MODE_LONG/SRC_ADDR_MODE_LONG (Beacon Only) leniency[37]
 * Override Stage 2 PAN ID Filter for DST_ADDR_MODE_LONG/SRC_ADDR_MODE_LONG (Data
 * and MAC Command Only) leniency[38] Override Stage 2 Long Addr Filter for
 * DST_ADDR_MODE_LONG/SRC_ADDR_MODE_LONG (Data and MAC Command Only) leniency[39]
 * Allow an auto-TxAck frame to be sent, after a receive frame which has all of the
 * following parameters: 1. Destination PAN ID = Broadcast (0xFFFF) 2.
 * Destination Address = !Broadcast (not 0xFFFF) 3. Destination Address Mode = Short
 * Nominally, the SEQ_MGR inhibits auto-TxAck on such frames.
 */
/*@{*/
/*! @brief Read current value of the ZLL_LENIENCY_MSB_LENIENCY_REGISTER field. */
#define ZLL_RD_LENIENCY_MSB_LENIENCY_REGISTER(base) ((ZLL_LENIENCY_MSB_REG(base) & ZLL_LENIENCY_MSB_LENIENCY_REGISTER_MASK) >> ZLL_LENIENCY_MSB_LENIENCY_REGISTER_SHIFT)
#define ZLL_BRD_LENIENCY_MSB_LENIENCY_REGISTER(base) (BME_UBFX32(&ZLL_LENIENCY_MSB_REG(base), ZLL_LENIENCY_MSB_LENIENCY_REGISTER_SHIFT, ZLL_LENIENCY_MSB_LENIENCY_REGISTER_WIDTH))

/*! @brief Set the LENIENCY_REGISTER field to a new value. */
#define ZLL_WR_LENIENCY_MSB_LENIENCY_REGISTER(base, value) (ZLL_RMW_LENIENCY_MSB(base, ZLL_LENIENCY_MSB_LENIENCY_REGISTER_MASK, ZLL_LENIENCY_MSB_LENIENCY_REGISTER(value)))
#define ZLL_BWR_LENIENCY_MSB_LENIENCY_REGISTER(base, value) (BME_BFI32(&ZLL_LENIENCY_MSB_REG(base), ((uint32_t)(value) << ZLL_LENIENCY_MSB_LENIENCY_REGISTER_SHIFT), ZLL_LENIENCY_MSB_LENIENCY_REGISTER_SHIFT, ZLL_LENIENCY_MSB_LENIENCY_REGISTER_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_PART_ID - PART ID
 ******************************************************************************/

/*!
 * @brief ZLL_PART_ID - PART ID (RO)
 *
 * Reset value: 0x00000000U
 *
 * Zigbee Part ID
 */
/*!
 * @name Constants and macros for entire ZLL_PART_ID register
 */
/*@{*/
#define ZLL_RD_PART_ID(base)     (ZLL_PART_ID_REG(base))
/*@}*/

/*
 * Constants & macros for individual ZLL_PART_ID bitfields
 */

/*!
 * @name Register ZLL_PART_ID, field PART_ID[7:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ZLL_PART_ID_PART_ID field. */
#define ZLL_RD_PART_ID_PART_ID(base) ((ZLL_PART_ID_REG(base) & ZLL_PART_ID_PART_ID_MASK) >> ZLL_PART_ID_PART_ID_SHIFT)
#define ZLL_BRD_PART_ID_PART_ID(base) (BME_UBFX32(&ZLL_PART_ID_REG(base), ZLL_PART_ID_PART_ID_SHIFT, ZLL_PART_ID_PART_ID_WIDTH))
/*@}*/

/*******************************************************************************
 * ZLL_PKT_BUFFER - PACKET BUFFER
 ******************************************************************************/

/*!
 * @brief ZLL_PKT_BUFFER - PACKET BUFFER (RW)
 *
 * Reset value: 0x00000000U
 *
 * Packet Buffer
 */
/*!
 * @name Constants and macros for entire ZLL_PKT_BUFFER register
 */
/*@{*/
#define ZLL_RD_PKT_BUFFER(base, index) (ZLL_PKT_BUFFER_REG(base, index))
#define ZLL_WR_PKT_BUFFER(base, index, value) (ZLL_PKT_BUFFER_REG(base, index) = (value))
#define ZLL_RMW_PKT_BUFFER(base, index, mask, value) (ZLL_WR_PKT_BUFFER(base, index, (ZLL_RD_PKT_BUFFER(base, index) & ~(mask)) | (value)))
#define ZLL_SET_PKT_BUFFER(base, index, value) (BME_OR32(&ZLL_PKT_BUFFER_REG(base, index), (uint32_t)(value)))
#define ZLL_CLR_PKT_BUFFER(base, index, value) (BME_AND32(&ZLL_PKT_BUFFER_REG(base, index), (uint32_t)(~(value))))
#define ZLL_TOG_PKT_BUFFER(base, index, value) (BME_XOR32(&ZLL_PKT_BUFFER_REG(base, index), (uint32_t)(value)))
/*@}*/

/* Instance numbers for core modules */
#define JTAG_IDX (0) /*!< Instance number for JTAG. */
#define TPIU_IDX (0) /*!< Instance number for TPIU. */
#define SCB_IDX (0) /*!< Instance number for SCB. */
#define SWD_IDX (0) /*!< Instance number for SWD. */
#define RADIO_IDX (0) /*!< Instance number for RADIO. */
#define ZigBee_IDX (0) /*!< Instance number for ZigBee. */
#define CoreDebug_IDX (0) /*!< Instance number for CoreDebug. */

#if defined(__IAR_SYSTEMS_ICC__)
  /* Restore checking of "Error[Pm008]: sections of code should not be 'commented out' (MISRA C 2004 rule 2.4)" */
  #pragma diag_default=pm008
#endif

#endif /* __MKW40Z4_EXTENSION_H__ */
/* EOF */
